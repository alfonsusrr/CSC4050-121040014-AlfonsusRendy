{"dataset": [{"lang": "java", "bug_type": "condition error", "buggy_code": "\nclass Solution {\n    public void nextPermutation(int[] n) {\n        //breakpoint\n       if(  n==null || n.length<=1)return;\n\t\t\n\t\tint i = n.length-2;\n\n\t\twhile(i>=0 && n[i]>=n[i+1])i--;\n\t\t\n\t\tint j=n.length-1;\n\t\t\n\t\tif(i>=0) {\n\t\t\twhile(n[j]>=n[i])j--;\n\t\t\tswap(n,i,j);\n\t\t}\n\t\t\n\t\treverse(n,i+1,n.length-1);\n\t\t\n\t\tfor(int p=0;p<n.length;p++) {\n\t\t\tSystem.out.println(n[p]);\n\t\t}\n\t\t\n\t}\n\tpublic static void swap(int n[],int i,int j) {\n\t\tint temp=n[i];\n\t\tn[i]=n[j];\n\t\tn[j]=temp;\n\t}\n\tpublic static void reverse(int n[],int i,int j) {\n\t\twhile(i<j) {\n\t\t\tswap(n,i,j);\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n}\n", "reasoning": "\nThe condition inside the second while in nextPermutation method should be n[j]<=n[i] not n[j]>=n[i]\n"}, {"lang": "cpp", "bug_type": "condition error", "buggy_code": "\nclass Solution {\npublic:\n    int largest1BorderedSquare(vector<vector<int>>& grid) {\n        int r = grid.size();\n        int c = grid[0].size();\n        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));\n        \n        int mx = 0;\n\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                if(grid[i][j]!=0){\n                    \n                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;\n                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;\n                    \n                    int sz = min(dp[i][j].first, dp[i][j].second);\n                    while(sz>mx){\n                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);\n                        if(p>=sz)\n                            mx = max(mx,sz);\n                        sz++;\n                    }\n                }\n            }\n        }\n            \n        return mx*mx;\n    }\n};    \n", "reasoning": "\nInstead of decreasing inside while in \"sz--\" its increasing by \"sz++\" causing an infinite loop.\n"}, {"lang": "java", "bug_type": "condition error", "buggy_code": "\n/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public void dfs(Node node, HashMap<Node, Node> dict)\n    {\n        for (Node nd : node.neighbors) {\n            if (!dict.containsKey(nd))\n                dict.put(nd, new Node(nd.val));\n            dict.get(node).neighbors.add(dict.get(nd));\n        }\n        for (Node nd : node.neighbors)\n        {\n            if (dict.get(nd).neighbors.size() == 1)\n                dfs(nd, dict);\n        }\n    }\n    public Node cloneGraph(Node node) {\n        HashMap<Node, Node> dict = new HashMap<>();\n        if (node != null) {\n            dict.put(node, new Node(node.val));\n            dfs(node, dict);\n            return dict.get(node);\n        }\n        return null;\n    }\n}\n", "reasoning": "\nThe bug is in the dfs method, it checks if size is 1 instead of 0.\n"}, {"lang": "java", "bug_type": "condition error", "buggy_code": "\nclass Solution {\n    public int[][] matrixBlockSum(int[][] mat, int k) {\n        int[][] answer = new int[mat.length][mat[0].length];\n\n        for(int i = 0; i < mat.length; i++) {\n            for(int j = 0; j < mat[0].length; j++) {\n                int rowStart = i-k;\n                int rowEnd = i+k;\n                int colStart = j-k;\n                int colEnd = j+k;\n\n                if(rowStart < 0) {\n                    rowStart = 0;\n                }\n\n                if(rowEnd >= mat.length) {\n                    rowEnd = mat.length - 1;\n                }\n\n                if(colStart < 0) {\n                    colStart = 0;\n                }\n\n                if(colEnd >= mat[0].length) {\n                    colEnd = mat[0].length - 1;\n                }\n\n                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);\n            }\n        }\n\n        return answer;\n    }\n\n    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {\n        int sum = 0;\n\n        for(int i = rowStart; i <= rowEnd; i++) {\n            for(int j = colStart; j < colEnd; j++) {\n                sum += mat[i][j];\n            }\n        }\n        return sum;\n    }\n}\n", "reasoning": "\nWith 'j < colEnd' instead of 'j <= colEnd', the last column in block wouldn't be summed.\n"}, {"lang": "python3", "bug_type": "condition error", "buggy_code": "\nclass Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        if len(dist) >= hour - 1  : return -1\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\n        while left<right:\n            mid=(left+right)//2\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n                right=mid\n            else:\n                left=mid+1\n        return left\n", "reasoning": "\nComparison condition in if statement is wrong. Should be \"if len(dist) > hour\", not \"if len(dist) >= hour - 1\".\n"}, {"lang": "python3", "bug_type": "condition error", "buggy_code": "\nclass Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return False\n        return True\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right\n", "reasoning": "\nSwapped boolean return values in satisfiesTrip causing function to return incorrect results.\n"}, {"lang": "cpp", "bug_type": "condition error", "buggy_code": "\nclass Solution {\n    const int M = 1000000007;\n    int mul(long long x, long long y) {\n        return x * y % M;\n    }\n    \n    int add(int x, int y) {\n        if ((x += y) >= M) {\n            x -= M;\n        }\n        return x; \n    }\n\npublic:\n    int sumOfPower(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        const int n = nums.size();\n        int r = mul(mul(nums[0], nums[0]), nums[0]);\n        for (int i = 0, last = 0; i < n; ++i) {\n            last = add(nums[i - 1], add(last, last));\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\n        }\n        \n        return r;\n    }\n};\n", "reasoning": "\nStart index should be 1 in for loop, but it is 0 causing an array index out-of-bound error.\n"}, {"lang": "python3", "bug_type": "condition error", "buggy_code": "\nclass Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1] > sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True\n", "reasoning": "\nThe bug occurs as the program inappropriately pop st and sr when st[-1] is greater than sr[-1].\n"}, {"lang": "cpp", "bug_type": "condition error", "buggy_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums){\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};\n", "reasoning": "\nThe condition to check if the number is even is removed, possibly returning an odd number.\n"}, {"lang": "cpp", "bug_type": "condition error", "buggy_code": "\nclass Solution {\npublic:\n    string addBinary(string a, string b) {\n        int c=0;\n        string s=\"\";\n        int i=0;\n        while(i<a.length() || i<b.length() || c!=0){\n            int x=0;\n            if(i<a.length() && a[i]=='1')\n                x=1;\n            int y=0;\n            if(i<b.length() && b[i]=='1')\n                y=1;\n            s=to_string((x+y+c)%2)+s;\n            c=(x+y+c)/2;\n            i++;\n        }\n        return s;\n    }\n};\n", "reasoning": "\nBy iterating over the binary strings from start instead of reverse, improper binary addition is happening.\n"}], "heuristic": "<heuristic> To accurately locate defective lines akin to the described bugs, follow a meticulously curated step-wise heuristic. Initially, scrutinize the code for logical conditions that appear erroneous or counter-intuitive, often spotted in loop conditions or if-else statements, pivotal to the bugs mentioned. Next, closely inspect arithmetic and algorithmic computations, paying special attention to increment/decrement operations within loops, boundary conditions in array or string manipulations, and method return values that influence the program flow inversely. Furthermore, assess array or string index accesses for potential out-of-bound errors or incorrect starting points that could lead to faulty iterations. Delve into method calls or recursive functions to ensure they're employed correctly, particularly verifying the parameters passed and return value logic. Finally, validate the handling of special cases or edge conditions explicitly, ensuring the code logic aligns with expectations across all conceivable inputs. This holistic approach aims to identify discrepancies in logical operations, loop constructs, algorithmic implementations, and special case handling, thereby enabling precise pinpointing of defective code lines. </heuristic>"}