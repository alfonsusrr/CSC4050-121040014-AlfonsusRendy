{"dataset": [{"pid": "Compress", "bid": 16, "method_path": "./dataset/Compress/16/ArchiveStreamFactory.java", "method": ["public ArchiveInputStream createArchiveInputStream(final InputStream in)\n", "throws ArchiveException {\n", "if (in == null) {\n", "throw new IllegalArgumentException(\"Stream must not be null.\");\n", "}\n", "\n", "if (!in.markSupported()) {\n", "throw new IllegalArgumentException(\"Mark is not supported.\");\n", "}\n", "\n", "final byte[] signature = new byte[12];\n", "in.mark(signature.length);\n", "try {\n", "int signatureLength = in.read(signature);\n", "in.reset();\n", "if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n", "return new ZipArchiveInputStream(in);\n", "} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n", "return new JarArchiveInputStream(in);\n", "} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n", "return new ArArchiveInputStream(in);\n", "} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n", "return new CpioArchiveInputStream(in);\n", "}\n", "\n", "// Dump needs a bigger buffer to check the signature;\n", "final byte[] dumpsig = new byte[32];\n", "in.mark(dumpsig.length);\n", "signatureLength = in.read(dumpsig);\n", "in.reset();\n", "if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n", "return new DumpArchiveInputStream(in);\n", "}\n", "\n", "// Tar needs an even bigger buffer to check the signature; read the first block\n", "final byte[] tarheader = new byte[512];\n", "in.mark(tarheader.length);\n", "signatureLength = in.read(tarheader);\n", "in.reset();\n", "if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n", "return new TarArchiveInputStream(in);\n", "}\n", "// COMPRESS-117 - improve auto-recognition\n", "if (signatureLength >= 512) {\n", "try {\n", "TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n", "// COMPRESS-191 - verify the header checksum\n", "tais.getNextEntry();\n", "return new TarArchiveInputStream(in);\n", "} catch (Exception e) { // NOPMD\n", "// can generate IllegalArgumentException as well\n", "// as IOException\n", "// autodetection, simply not a TAR\n", "// ignored\n", "}\n", "}\n", "} catch (IOException e) {\n", "throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n", "}\n", "\n", "throw new ArchiveException(\"No Archiver found for the stream signature\");\n", "}\n"], "faulty_lines": [48, 50], "cluster": 6}, {"pid": "Codec", "bid": 1, "method_path": "./dataset/Codec/1/Caverphone.java", "method": ["public String caverphone(String txt) {\n", "// NOTE: Version 1.0 of Caverphone is easily derivable from this code\n", "// by commenting out the 2.0 lines and adding in the 1.0 lines\n", "\n", "if( txt == null || txt.length() == 0 ) {\n", "return \"1111111111\";\n", "}\n", "\n", "// 1. Convert to lowercase\n", "txt = txt.toLowerCase();\n", "\n", "// 2. Remove anything not A-Z\n", "txt = txt.replaceAll(\"[^a-z]\", \"\");\n", "\n", "// 2.5. Remove final e\n", "txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n", "\n", "// 3. Handle various start options\n", "txt = txt.replaceAll(\"^cough\", \"cou2f\");\n", "txt = txt.replaceAll(\"^rough\", \"rou2f\");\n", "txt = txt.replaceAll(\"^tough\", \"tou2f\");\n", "txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n", "txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n", "txt = txt.replaceAll(\"^gn\", \"2n\");\n", "txt = txt.replaceAll(\"^mb\", \"m2\");\n", "\n", "// 4. Handle replacements\n", "txt = txt.replaceAll(\"cq\", \"2q\");\n", "txt = txt.replaceAll(\"ci\", \"si\");\n", "txt = txt.replaceAll(\"ce\", \"se\");\n", "txt = txt.replaceAll(\"cy\", \"sy\");\n", "txt = txt.replaceAll(\"tch\", \"2ch\");\n", "txt = txt.replaceAll(\"c\", \"k\");\n", "txt = txt.replaceAll(\"q\", \"k\");\n", "txt = txt.replaceAll(\"x\", \"k\");\n", "txt = txt.replaceAll(\"v\", \"f\");\n", "txt = txt.replaceAll(\"dg\", \"2g\");\n", "txt = txt.replaceAll(\"tio\", \"sio\");\n", "txt = txt.replaceAll(\"tia\", \"sia\");\n", "txt = txt.replaceAll(\"d\", \"t\");\n", "txt = txt.replaceAll(\"ph\", \"fh\");\n", "txt = txt.replaceAll(\"b\", \"p\");\n", "txt = txt.replaceAll(\"sh\", \"s2\");\n", "txt = txt.replaceAll(\"z\", \"s\");\n", "txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n", "txt = txt.replaceAll(\"[aeiou]\", \"3\");\n", "txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n", "txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n", "txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n", "txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n", "txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n", "txt = txt.replaceAll(\"gh\", \"22\");\n", "txt = txt.replaceAll(\"g\", \"k\");\n", "txt = txt.replaceAll(\"s+\", \"S\");\n", "txt = txt.replaceAll(\"t+\", \"T\");\n", "txt = txt.replaceAll(\"p+\", \"P\");\n", "txt = txt.replaceAll(\"k+\", \"K\");\n", "txt = txt.replaceAll(\"f+\", \"F\");\n", "txt = txt.replaceAll(\"m+\", \"M\");\n", "txt = txt.replaceAll(\"n+\", \"N\");\n", "txt = txt.replaceAll(\"w3\", \"W3\");\n", "//txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n", "txt = txt.replaceAll(\"wh3\", \"Wh3\");\n", "txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n", "//txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n", "txt = txt.replaceAll(\"w\", \"2\");\n", "txt = txt.replaceAll(\"^h\", \"A\");\n", "txt = txt.replaceAll(\"h\", \"2\");\n", "txt = txt.replaceAll(\"r3\", \"R3\");\n", "txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n", "//txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n", "txt = txt.replaceAll(\"r\", \"2\");\n", "txt = txt.replaceAll(\"l3\", \"L3\");\n", "txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n", "//txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n", "txt = txt.replaceAll(\"l\", \"2\");\n", "//txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n", "//txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n", "//txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n", "\n", "// 5. Handle removals\n", "txt = txt.replaceAll(\"2\", \"\");\n", "txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n", "txt = txt.replaceAll(\"3\", \"\");\n", "\n", "// 6. put ten 1s on the end\n", "txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n", "\n", "// 7. take the first six characters as the code\n", "return txt.substring(0, 10);          // 1.0 truncates to 6\n", "}\n"], "faulty_lines": [10], "cluster": 6}, {"pid": "Jsoup", "bid": 76, "method_path": "./dataset/Jsoup/76/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case Character: {\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "// todo confirm that check\n", "tb.error(this);\n", "return false;\n", "} else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "tb.framesetOk(false);\n", "}\n", "break;\n", "}\n", "case Comment: {\n", "tb.insert(t.asComment());\n", "break;\n", "}\n", "case Doctype: {\n", "tb.error(this);\n", "return false;\n", "}\n", "case StartTag:\n", "Token.StartTag startTag = t.asStartTag();\n", "// todo - refactor to a switch statement\n", "String name = startTag.normalName();\n", "if (name.equals(\"a\")) {\n", "if (tb.getActiveFormattingElement(\"a\") != null) {\n", "tb.error(this);\n", "tb.processEndTag(\"a\");\n", "\n", "// still on stack?\n", "Element remainingA = tb.getFromStack(\"a\");\n", "if (remainingA != null) {\n", "tb.removeFromActiveFormattingElements(remainingA);\n", "tb.removeFromStack(remainingA);\n", "}\n", "}\n", "tb.reconstructFormattingElements();\n", "Element a = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(a);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n", "tb.reconstructFormattingElements();\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"span\")) {\n", "// same as final else, but short circuits lots of checks\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (name.equals(\"li\")) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (el.nodeName().equals(\"li\")) {\n", "tb.processEndTag(\"li\");\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"html\")) {\n", "tb.error(this);\n", "// merge attributes onto real html\n", "Element html = tb.getStack().get(0);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!html.hasAttr(attribute.getKey()))\n", "html.attributes().put(attribute);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n", "return tb.process(t, InHead);\n", "} else if (name.equals(\"body\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else {\n", "tb.framesetOk(false);\n", "Element body = stack.get(1);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!body.hasAttr(attribute.getKey()))\n", "body.attributes().put(attribute);\n", "}\n", "}\n", "} else if (name.equals(\"frameset\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else if (!tb.framesetOk()) {\n", "return false; // ignore frameset\n", "} else {\n", "Element second = stack.get(1);\n", "if (second.parent() != null)\n", "second.remove();\n", "// pop up to html element\n", "while (stack.size() > 1)\n", "stack.remove(stack.size()-1);\n", "tb.insert(startTag);\n", "tb.transition(InFrameset);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n", "tb.error(this);\n", "tb.pop();\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"form\")) {\n", "if (tb.getFormElement() != null) {\n", "tb.error(this);\n", "return false;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertForm(startTag, true);\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n", "tb.processEndTag(el.nodeName());\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"plaintext\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n", "} else if (name.equals(\"button\")) {\n", "if (tb.inButtonScope(\"button\")) {\n", "// close and reprocess\n", "tb.error(this);\n", "tb.processEndTag(\"button\");\n", "tb.process(startTag);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Formatters)) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (name.equals(\"nobr\")) {\n", "tb.reconstructFormattingElements();\n", "if (tb.inScope(\"nobr\")) {\n", "tb.error(this);\n", "tb.processEndTag(\"nobr\");\n", "tb.reconstructFormattingElements();\n", "}\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.insertMarkerToFormattingElements();\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"table\")) {\n", "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "tb.transition(InTable);\n", "} else if (name.equals(\"input\")) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insertEmpty(startTag);\n", "if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n", "tb.insertEmpty(startTag);\n", "} else if (name.equals(\"hr\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"image\")) {\n", "if (tb.getFromStack(\"svg\") == null)\n", "return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n", "else\n", "tb.insert(startTag);\n", "} else if (name.equals(\"isindex\")) {\n", "// how much do we care about the early 90s?\n", "tb.error(this);\n", "if (tb.getFormElement() != null)\n", "return false;\n", "\n", "tb.processStartTag(\"form\");\n", "if (startTag.attributes.hasKey(\"action\")) {\n", "Element form = tb.getFormElement();\n", "form.attr(\"action\", startTag.attributes.get(\"action\"));\n", "}\n", "tb.processStartTag(\"hr\");\n", "tb.processStartTag(\"label\");\n", "// hope you like english.\n", "String prompt = startTag.attributes.hasKey(\"prompt\") ?\n", "startTag.attributes.get(\"prompt\") :\n", "\"This is a searchable index. Enter search keywords: \";\n", "\n", "tb.process(new Token.Character().data(prompt));\n", "\n", "// input\n", "Attributes inputAttribs = new Attributes();\n", "for (Attribute attr : startTag.attributes) {\n", "if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n", "inputAttribs.put(attr);\n", "}\n", "inputAttribs.put(\"name\", \"isindex\");\n", "tb.processStartTag(\"input\", inputAttribs);\n", "tb.processEndTag(\"label\");\n", "tb.processStartTag(\"hr\");\n", "tb.processEndTag(\"form\");\n", "} else if (name.equals(\"textarea\")) {\n", "tb.insert(startTag);\n", "// todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n", "tb.tokeniser.transition(TokeniserState.Rcdata);\n", "tb.markInsertionMode();\n", "tb.framesetOk(false);\n", "tb.transition(Text);\n", "} else if (name.equals(\"xmp\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.reconstructFormattingElements();\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"iframe\")) {\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"noembed\")) {\n", "// also handle noscript if script enabled\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"select\")) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "\n", "HtmlTreeBuilderState state = tb.state();\n", "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n", "tb.transition(InSelectInTable);\n", "else\n", "tb.transition(InSelect);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n", "if (tb.inScope(\"ruby\")) {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n", "tb.error(this);\n", "tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n", "}\n", "tb.insert(startTag);\n", "}\n", "} else if (name.equals(\"math\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n", "tb.insert(startTag);\n", "} else if (name.equals(\"svg\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "}\n", "break;\n", "\n", "case EndTag:\n", "Token.EndTag endTag = t.asEndTag();\n", "name = endTag.normalName();\n", "if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n", "// Adoption Agency Algorithm.\n", "for (int i = 0; i < 8; i++) {\n", "Element formatEl = tb.getActiveFormattingElement(name);\n", "if (formatEl == null)\n", "return anyOtherEndTag(t, tb);\n", "else if (!tb.onStack(formatEl)) {\n", "tb.error(this);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "} else if (!tb.inScope(formatEl.nodeName())) {\n", "tb.error(this);\n", "return false;\n", "} else if (tb.currentElement() != formatEl)\n", "tb.error(this);\n", "\n", "Element furthestBlock = null;\n", "Element commonAncestor = null;\n", "boolean seenFormattingElement = false;\n", "ArrayList<Element> stack = tb.getStack();\n", "// the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n", "// run-aways\n", "final int stackSize = stack.size();\n", "for (int si = 0; si < stackSize && si < 64; si++) {\n", "Element el = stack.get(si);\n", "if (el == formatEl) {\n", "commonAncestor = stack.get(si - 1);\n", "seenFormattingElement = true;\n", "} else if (seenFormattingElement && tb.isSpecial(el)) {\n", "furthestBlock = el;\n", "break;\n", "}\n", "}\n", "if (furthestBlock == null) {\n", "tb.popStackToClose(formatEl.nodeName());\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "}\n", "\n", "// todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n", "// does that mean: int pos of format el in list?\n", "Element node = furthestBlock;\n", "Element lastNode = furthestBlock;\n", "for (int j = 0; j < 3; j++) {\n", "if (tb.onStack(node))\n", "node = tb.aboveOnStack(node);\n", "if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n", "tb.removeFromStack(node);\n", "continue;\n", "} else if (node == formatEl)\n", "break;\n", "\n", "Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n", "// case will follow the original node (so honours ParseSettings)\n", "tb.replaceActiveFormattingElement(node, replacement);\n", "tb.replaceOnStack(node, replacement);\n", "node = replacement;\n", "\n", "if (lastNode == furthestBlock) {\n", "// todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n", "// not getting how this bookmark both straddles the element above, but is inbetween here...\n", "}\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "node.appendChild(lastNode);\n", "\n", "lastNode = node;\n", "}\n", "\n", "if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "tb.insertInFosterParent(lastNode);\n", "} else {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "commonAncestor.appendChild(lastNode);\n", "}\n", "\n", "Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n", "adopter.attributes().addAll(formatEl.attributes());\n", "Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n", "for (Node childNode : childNodes) {\n", "adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n", "}\n", "furthestBlock.appendChild(adopter);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "// todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n", "tb.removeFromStack(formatEl);\n", "tb.insertOnStackAfter(furthestBlock, adopter);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n", "if (!tb.inScope(name)) {\n", "// nothing to close\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"span\")) {\n", "// same as final fall through, but saves short circuit\n", "return anyOtherEndTag(t, tb);\n", "} else if (name.equals(\"li\")) {\n", "if (!tb.inListItemScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"body\")) {\n", "if (!tb.inScope(\"body\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "// todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n", "tb.transition(AfterBody);\n", "}\n", "} else if (name.equals(\"html\")) {\n", "boolean notIgnored = tb.processEndTag(\"body\");\n", "if (notIgnored)\n", "return tb.process(endTag);\n", "} else if (name.equals(\"form\")) {\n", "Element currentForm = tb.getFormElement();\n", "tb.setFormElement(null);\n", "if (currentForm == null || !tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "// remove currentForm from stack. will shift anything under up.\n", "tb.removeFromStack(currentForm);\n", "}\n", "} else if (name.equals(\"p\")) {\n", "if (!tb.inButtonScope(name)) {\n", "tb.error(this);\n", "tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n", "return tb.process(endTag);\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (!tb.inScope(Constants.Headings)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(Constants.Headings);\n", "}\n", "} else if (name.equals(\"sarcasm\")) {\n", "// *sigh*\n", "return anyOtherEndTag(t, tb);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "if (!tb.inScope(\"name\")) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "tb.clearFormattingElementsToLastMarker();\n", "}\n", "} else if (name.equals(\"br\")) {\n", "tb.error(this);\n", "tb.processStartTag(\"br\");\n", "return false;\n", "} else {\n", "return anyOtherEndTag(t, tb);\n", "}\n", "\n", "break;\n", "case EOF:\n", "// todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n", "// stop parsing\n", "break;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [131], "cluster": 6}], "heuristic": "The defect lines identified across the given code snippets highlight a range of common issues that developers may encounter. Each issue reflects a unique pattern of mistakes that can occur during coding. By examining these defect lines and extracting patterns, we can develop heuristics to identify similar issues in the future. Here are the patterns extracted from the specified defect lines:\n\n1. **Exception Handling and Flow Control (Defect Lines: 48, 50 in the first code snippet):** The code incorrectly handles exceptions by not properly managing resources (like streams) or failing to correctly manage program flow post an exception. This could lead to resource leaks or unexpected program behavior.\n\n    - **Heuristic:** Ensure that exceptions are caught and handled appropriately, with resources being correctly managed (e.g., using try-with-resources in Java). Also, verify that the program flow remains predictable and logical even when exceptions are thrown.\n\n2. **Incorrect String Operations (Defect Line: 10 in the second code snippet):** The misuse or misunderstanding of string operations, such as transforming strings in ways that do not meet the application\u2019s requirements.\n\n    - **Heuristic:** Verify that string operations achieve the intended transformations and outcomes. This includes ensuring regular expressions are correctly applied and that string operation sequences produce the correct result.\n\n3. **Conditional Logic Error (Defect Line: 131 in the third code snippet):** The condition might not correctly cover the intended logic, or the branching does not execute as expected, leading to incorrect program behavior.\n\n    - **Heuristic:** Thoroughly review conditional statements to ensure they logically cover all intended scenarios. Test with a wide range of inputs to confirm that the branching behaves as expected.\n\n4. **Null Safety and Equality Checks (Defect Line: not explicitly listed but inferred):** Writing code that fails to account for null values, potentially leading to NullPointerExceptions or similar issues. For instance, using `.equals` method on an object that might be null.\n\n    - **Heuristic:** Always check for null before dereferencing an object. Consider using null-safe operations or utilities (e.g., `Objects.equals()` in Java) to prevent NullPointerException.\n\n5. **Incorrect Use or Handling of API Calls (Related to the InputStream operations in the first code snippet):** Mismanaging external or internal API calls, for instance, not correctly handling stream operations or missing out on necessary API usage that ensures correct program operation.\n\n    - **Heuristic:** Ensure understanding and correct use of APIs. Pay special attention to resource management, side effects, and exceptions related to API calls. Follow official documentation and best practices for using given APIs.\n\nBy identifying and understanding these patterns, developers can apply these heuristics in code reviews, debugging sessions, or even during initial development to prevent these common issues from arising. It\u2019s also beneficial to incorporate automated static analysis tools, code linters, and adhere to coding standards and best practices relevant to the technology stack being used."}