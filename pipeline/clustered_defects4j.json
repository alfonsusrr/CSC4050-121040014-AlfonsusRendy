[{"pid": "Chart", "bid": 1, "method_path": "./dataset/Chart/1/AbstractCategoryItemRenderer.java", "method": ["public LegendItemCollection getLegendItems() {\n", "LegendItemCollection result = new LegendItemCollection();\n", "if (this.plot == null) {\n", "return result;\n", "}\n", "int index = this.plot.getIndexOf(this);\n", "CategoryDataset dataset = this.plot.getDataset(index);\n", "if (dataset != null) {\n", "return result;\n", "}\n", "int seriesCount = dataset.getRowCount();\n", "if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n", "for (int i = 0; i < seriesCount; i++) {\n", "if (isSeriesVisibleInLegend(i)) {\n", "LegendItem item = getLegendItem(index, i);\n", "if (item != null) {\n", "result.add(item);\n", "}\n", "}\n", "}\n", "}\n", "else {\n", "for (int i = seriesCount - 1; i >= 0; i--) {\n", "if (isSeriesVisibleInLegend(i)) {\n", "LegendItem item = getLegendItem(index, i);\n", "if (item != null) {\n", "result.add(item);\n", "}\n", "}\n", "}\n", "}\n", "return result;\n", "}\n"], "faulty_lines": [8], "cluster": 8}, {"pid": "Chart", "bid": 2, "method_path": "./dataset/Chart/2/DatasetUtilities.java", "method": ["boolean includeInterval) {\n", "if (dataset == null) {\n", "throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n", "}\n", "double minimum = Double.POSITIVE_INFINITY;\n", "double maximum = Double.NEGATIVE_INFINITY;\n", "int seriesCount = dataset.getSeriesCount();\n", "double lvalue;\n", "double uvalue;\n", "if (includeInterval && dataset instanceof IntervalXYDataset) {\n", "IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;\n", "for (int series = 0; series < seriesCount; series++) {\n", "int itemCount = dataset.getItemCount(series);\n", "for (int item = 0; item < itemCount; item++) {\n", "lvalue = intervalXYData.getStartXValue(series, item);\n", "uvalue = intervalXYData.getEndXValue(series, item);\n", "if (!Double.isNaN(lvalue)) {\n", "minimum = Math.min(minimum, lvalue);\n", "}\n", "if (!Double.isNaN(uvalue)) {\n", "maximum = Math.max(maximum, uvalue);\n", "}\n", "}\n", "}\n", "}\n", "else {\n", "for (int series = 0; series < seriesCount; series++) {\n", "int itemCount = dataset.getItemCount(series);\n", "for (int item = 0; item < itemCount; item++) {\n", "lvalue = dataset.getXValue(series, item);\n", "uvalue = lvalue;\n", "if (!Double.isNaN(lvalue)) {\n", "minimum = Math.min(minimum, lvalue);\n", "maximum = Math.max(maximum, uvalue);\n", "}\n", "}\n", "}\n", "}\n", "if (minimum > maximum) {\n", "return null;\n", "}\n", "else {\n", "return new Range(minimum, maximum);\n", "}\n", "}\n"], "faulty_lines": [15, 17, 19, 21], "cluster": 5}, {"pid": "Chart", "bid": 2, "method_path": "./dataset/Chart/2/DatasetUtilities.java", "method": ["boolean includeInterval) {\n", "double minimum = Double.POSITIVE_INFINITY;\n", "double maximum = Double.NEGATIVE_INFINITY;\n", "int seriesCount = dataset.getSeriesCount();\n", "\n", "// handle three cases by dataset type\n", "if (includeInterval && dataset instanceof IntervalXYDataset) {\n", "// handle special case of IntervalXYDataset\n", "IntervalXYDataset ixyd = (IntervalXYDataset) dataset;\n", "for (int series = 0; series < seriesCount; series++) {\n", "int itemCount = dataset.getItemCount(series);\n", "for (int item = 0; item < itemCount; item++) {\n", "double lvalue = ixyd.getStartYValue(series, item);\n", "double uvalue = ixyd.getEndYValue(series, item);\n", "if (!Double.isNaN(lvalue)) {\n", "minimum = Math.min(minimum, lvalue);\n", "}\n", "if (!Double.isNaN(uvalue)) {\n", "maximum = Math.max(maximum, uvalue);\n", "}\n", "}\n", "}\n", "}\n", "else if (includeInterval && dataset instanceof OHLCDataset) {\n", "// handle special case of OHLCDataset\n", "OHLCDataset ohlc = (OHLCDataset) dataset;\n", "for (int series = 0; series < seriesCount; series++) {\n", "int itemCount = dataset.getItemCount(series);\n", "for (int item = 0; item < itemCount; item++) {\n", "double lvalue = ohlc.getLowValue(series, item);\n", "double uvalue = ohlc.getHighValue(series, item);\n", "if (!Double.isNaN(lvalue)) {\n", "minimum = Math.min(minimum, lvalue);\n", "}\n", "if (!Double.isNaN(uvalue)) {\n", "maximum = Math.max(maximum, uvalue);\n", "}\n", "}\n", "}\n", "}\n", "else {\n", "// standard case - plain XYDataset\n", "for (int series = 0; series < seriesCount; series++) {\n", "int itemCount = dataset.getItemCount(series);\n", "for (int item = 0; item < itemCount; item++) {\n", "double value = dataset.getYValue(series, item);\n", "if (!Double.isNaN(value)) {\n", "minimum = Math.min(minimum, value);\n", "maximum = Math.max(maximum, value);\n", "}\n", "}\n", "}\n", "}\n", "if (minimum == Double.POSITIVE_INFINITY) {\n", "return null;\n", "}\n", "else {\n", "return new Range(minimum, maximum);\n", "}\n", "}\n"], "faulty_lines": [13, 15, 17, 19], "cluster": 3}, {"pid": "Chart", "bid": 3, "method_path": "./dataset/Chart/3/TimeSeries.java", "method": ["public TimeSeries createCopy(int start, int end)\n", "throws CloneNotSupportedException {\n", "if (start < 0) {\n", "throw new IllegalArgumentException(\"Requires start >= 0.\");\n", "}\n", "if (end < start) {\n", "throw new IllegalArgumentException(\"Requires start <= end.\");\n", "}\n", "TimeSeries copy = (TimeSeries) super.clone();\n", "copy.data = new java.util.ArrayList();\n", "if (this.data.size() > 0) {\n", "for (int index = start; index <= end; index++) {\n", "TimeSeriesDataItem item\n", "= (TimeSeriesDataItem) this.data.get(index);\n", "TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n", "try {\n", "copy.add(clone);\n", "}\n", "catch (SeriesException e) {\n", "e.printStackTrace();\n", "}\n", "}\n", "}\n", "return copy;\n", "}\n"], "faulty_lines": [10], "cluster": 2}, {"pid": "Chart", "bid": 5, "method_path": "./dataset/Chart/5/XYSeries.java", "method": ["public XYDataItem addOrUpdate(Number x, Number y) {\n", "if (x == null) {\n", "throw new IllegalArgumentException(\"Null 'x' argument.\");\n", "}\n", "\n", "// if we get to here, we know that duplicate X values are not permitted\n", "XYDataItem overwritten = null;\n", "int index = indexOf(x);\n", "if (index >= 0 && !this.allowDuplicateXValues) {\n", "XYDataItem existing = (XYDataItem) this.data.get(index);\n", "try {\n", "overwritten = (XYDataItem) existing.clone();\n", "}\n", "catch (CloneNotSupportedException e) {\n", "throw new SeriesException(\"Couldn't clone XYDataItem!\");\n", "}\n", "existing.setY(y);\n", "}\n", "else {\n", "// if the series is sorted, the negative index is a result from\n", "// Collections.binarySearch() and tells us where to insert the\n", "// new item...otherwise it will be just -1 and we should just\n", "// append the value to the list...\n", "if (this.autoSort) {\n", "this.data.add(-index - 1, new XYDataItem(x, y));\n", "}\n", "else {\n", "this.data.add(new XYDataItem(x, y));\n", "}\n", "// check if this addition will exceed the maximum item count...\n", "if (getItemCount() > this.maximumItemCount) {\n", "this.data.remove(0);\n", "}\n", "}\n", "fireSeriesChanged();\n", "return overwritten;\n", "}\n"], "faulty_lines": [5, 9], "cluster": 1}, {"pid": "Chart", "bid": 6, "method_path": "./dataset/Chart/6/ShapeList.java", "method": ["public boolean equals(Object obj) {\n", "\n", "if (obj == this) {\n", "return true;\n", "}\n", "if (!(obj instanceof ShapeList)) {\n", "return false;\n", "}\n", "return super.equals(obj);\n", "\n", "}\n"], "faulty_lines": [9], "cluster": 0}, {"pid": "Chart", "bid": 8, "method_path": "./dataset/Chart/8/Week.java", "method": ["public Week(Date time, TimeZone zone) {\n", "// defer argument checking...\n", "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Chart", "bid": 10, "method_path": "./dataset/Chart/10/StandardToolTipTagFragmentGenerator.java", "method": ["public String generateToolTipFragment(String toolTipText) {\n", "return \" title=\\\"\" + toolTipText\n", "+ \"\\\" alt=\\\"\\\"\";\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Chart", "bid": 11, "method_path": "./dataset/Chart/11/ShapeUtilities.java", "method": ["public static boolean equal(GeneralPath p1, GeneralPath p2) {\n", "if (p1 == null) {\n", "return (p2 == null);\n", "}\n", "if (p2 == null) {\n", "return false;\n", "}\n", "if (p1.getWindingRule() != p2.getWindingRule()) {\n", "return false;\n", "}\n", "PathIterator iterator1 = p1.getPathIterator(null);\n", "PathIterator iterator2 = p1.getPathIterator(null);\n", "double[] d1 = new double[6];\n", "double[] d2 = new double[6];\n", "boolean done = iterator1.isDone() && iterator2.isDone();\n", "while (!done) {\n", "if (iterator1.isDone() != iterator2.isDone()) {\n", "return false;\n", "}\n", "int seg1 = iterator1.currentSegment(d1);\n", "int seg2 = iterator2.currentSegment(d2);\n", "if (seg1 != seg2) {\n", "return false;\n", "}\n", "if (!Arrays.equals(d1, d2)) {\n", "return false;\n", "}\n", "iterator1.next();\n", "iterator2.next();\n", "done = iterator1.isDone() && iterator2.isDone();\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [12], "cluster": 8}, {"pid": "Chart", "bid": 12, "method_path": "./dataset/Chart/12/MultiplePiePlot.java", "method": ["public MultiplePiePlot(CategoryDataset dataset) {\n", "super();\n", "this.dataset = dataset;\n", "PiePlot piePlot = new PiePlot(null);\n", "this.pieChart = new JFreeChart(piePlot);\n", "this.pieChart.removeLegend();\n", "this.dataExtractOrder = TableOrder.BY_COLUMN;\n", "this.pieChart.setBackgroundPaint(null);\n", "TextTitle seriesTitle = new TextTitle(\"Series Title\",\n", "new Font(\"SansSerif\", Font.BOLD, 12));\n", "seriesTitle.setPosition(RectangleEdge.BOTTOM);\n", "this.pieChart.setTitle(seriesTitle);\n", "this.aggregatedItemsKey = \"Other\";\n", "this.aggregatedItemsPaint = Color.lightGray;\n", "this.sectionPaints = new HashMap();\n", "}\n"], "faulty_lines": [3], "cluster": 2}, {"pid": "Chart", "bid": 13, "method_path": "./dataset/Chart/13/BorderArrangement.java", "method": ["protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n", "RectangleConstraint constraint) {\n", "double[] w = new double[5];\n", "double[] h = new double[5];\n", "w[0] = constraint.getWidth();\n", "if (this.topBlock != null) {\n", "RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n", "LengthConstraintType.FIXED, 0.0,\n", "new Range(0.0, constraint.getHeight()),\n", "LengthConstraintType.RANGE);\n", "Size2D size = this.topBlock.arrange(g2, c1);\n", "h[0] = size.height;\n", "}\n", "w[1] = w[0];\n", "if (this.bottomBlock != null) {\n", "RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n", "LengthConstraintType.FIXED, 0.0, new Range(0.0,\n", "constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n", "Size2D size = this.bottomBlock.arrange(g2, c2);\n", "h[1] = size.height;\n", "}\n", "h[2] = constraint.getHeight() - h[1] - h[0];\n", "if (this.leftBlock != null) {\n", "RectangleConstraint c3 = new RectangleConstraint(0.0,\n", "new Range(0.0, constraint.getWidth()),\n", "LengthConstraintType.RANGE, h[2], null,\n", "LengthConstraintType.FIXED);\n", "Size2D size = this.leftBlock.arrange(g2, c3);\n", "w[2] = size.width;\n", "}\n", "h[3] = h[2];\n", "if (this.rightBlock != null) {\n", "RectangleConstraint c4 = new RectangleConstraint(0.0,\n", "new Range(0.0, constraint.getWidth() - w[2]),\n", "LengthConstraintType.RANGE, h[2], null,\n", "LengthConstraintType.FIXED);\n", "Size2D size = this.rightBlock.arrange(g2, c4);\n", "w[3] = size.width;\n", "}\n", "h[4] = h[2];\n", "w[4] = constraint.getWidth() - w[3] - w[2];\n", "RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n", "if (this.centerBlock != null) {\n", "this.centerBlock.arrange(g2, c5);\n", "}\n", "\n", "if (this.topBlock != null) {\n", "this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n", "h[0]));\n", "}\n", "if (this.bottomBlock != null) {\n", "this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n", "w[1], h[1]));\n", "}\n", "if (this.leftBlock != null) {\n", "this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n", "h[2]));\n", "}\n", "if (this.rightBlock != null) {\n", "this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n", "w[3], h[3]));\n", "}\n", "if (this.centerBlock != null) {\n", "this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n", "h[4]));\n", "}\n", "return new Size2D(constraint.getWidth(), constraint.getHeight());\n", "}\n"], "faulty_lines": [34], "cluster": 3}, {"pid": "Chart", "bid": 14, "method_path": "./dataset/Chart/14/CategoryPlot.java", "method": ["boolean notify) {\n", "ArrayList markers;\n", "if (layer == Layer.FOREGROUND) {\n", "markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n", "index));\n", "}\n", "else {\n", "markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n", "index));\n", "}\n", "boolean removed = markers.remove(marker);\n", "if (removed && notify) {\n", "fireChangeEvent();\n", "}\n", "return removed;\n", "}\n"], "faulty_lines": [11], "cluster": 4}, {"pid": "Chart", "bid": 14, "method_path": "./dataset/Chart/14/CategoryPlot.java", "method": ["boolean notify) {\n", "if (marker == null) {\n", "throw new IllegalArgumentException(\"Null 'marker' argument.\");\n", "}\n", "ArrayList markers;\n", "if (layer == Layer.FOREGROUND) {\n", "markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n", "index));\n", "}\n", "else {\n", "markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n", "index));\n", "}\n", "boolean removed = markers.remove(marker);\n", "if (removed && notify) {\n", "fireChangeEvent();\n", "}\n", "return removed;\n", "}\n"], "faulty_lines": [14], "cluster": 4}, {"pid": "Chart", "bid": 14, "method_path": "./dataset/Chart/14/XYPlot.java", "method": ["boolean notify) {\n", "ArrayList markers;\n", "if (layer == Layer.FOREGROUND) {\n", "markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n", "index));\n", "}\n", "else {\n", "markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n", "index));\n", "}\n", "boolean removed = markers.remove(marker);\n", "if (removed && notify) {\n", "fireChangeEvent();\n", "}\n", "return removed;\n", "}\n"], "faulty_lines": [11], "cluster": 4}, {"pid": "Chart", "bid": 14, "method_path": "./dataset/Chart/14/XYPlot.java", "method": ["boolean notify) {\n", "if (marker == null) {\n", "throw new IllegalArgumentException(\"Null 'marker' argument.\");\n", "}\n", "ArrayList markers;\n", "if (layer == Layer.FOREGROUND) {\n", "markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer(\n", "index));\n", "}\n", "else {\n", "markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer(\n", "index));\n", "}\n", "boolean removed = markers.remove(marker);\n", "if (removed && notify) {\n", "fireChangeEvent();\n", "}\n", "return removed;\n", "}\n"], "faulty_lines": [14], "cluster": 4}, {"pid": "Chart", "bid": 15, "method_path": "./dataset/Chart/15/PiePlot.java", "method": ["public double getMaximumExplodePercent() {\n", "double result = 0.0;\n", "Iterator iterator = this.dataset.getKeys().iterator();\n", "while (iterator.hasNext()) {\n", "Comparable key = (Comparable) iterator.next();\n", "Number explode = (Number) this.explodePercentages.get(key);\n", "if (explode != null) {\n", "result = Math.max(result, explode.doubleValue());\n", "}\n", "}\n", "return result;\n", "}\n"], "faulty_lines": [2], "cluster": 4}, {"pid": "Chart", "bid": 15, "method_path": "./dataset/Chart/15/PiePlot.java", "method": ["public PiePlotState initialise(Graphics2D g2, Rectangle2D plotArea,\n", "PiePlot plot, Integer index, PlotRenderingInfo info) {\n", "\n", "PiePlotState state = new PiePlotState(info);\n", "state.setPassesRequired(2);\n", "state.setTotal(DatasetUtilities.calculatePieDatasetTotal(\n", "plot.getDataset()));\n", "state.setLatestAngle(plot.getStartAngle());\n", "return state;\n", "\n", "}\n"], "faulty_lines": [6, 8], "cluster": 4}, {"pid": "Chart", "bid": 16, "method_path": "./dataset/Chart/16/DefaultIntervalCategoryDataset.java", "method": ["public DefaultIntervalCategoryDataset(Comparable[] seriesKeys,\n", "Comparable[] categoryKeys,\n", "Number[][] starts,\n", "Number[][] ends) {\n", "\n", "this.startData = starts;\n", "this.endData = ends;\n", "\n", "if (starts != null && ends != null) {\n", "\n", "String baseName = \"org.jfree.data.resources.DataPackageResources\";\n", "ResourceBundle resources = ResourceBundle.getBundle(baseName);\n", "\n", "int seriesCount = starts.length;\n", "if (seriesCount != ends.length) {\n", "String errMsg = \"DefaultIntervalCategoryDataset: the number \"\n", "+ \"of series in the start value dataset does \"\n", "+ \"not match the number of series in the end \"\n", "+ \"value dataset.\";\n", "throw new IllegalArgumentException(errMsg);\n", "}\n", "if (seriesCount > 0) {\n", "\n", "// set up the series names...\n", "if (seriesKeys != null) {\n", "\n", "if (seriesKeys.length != seriesCount) {\n", "throw new IllegalArgumentException(\n", "\"The number of series keys does not \"\n", "+ \"match the number of series in the data.\");\n", "}\n", "\n", "this.seriesKeys = seriesKeys;\n", "}\n", "else {\n", "String prefix = resources.getString(\n", "\"series.default-prefix\") + \" \";\n", "this.seriesKeys = generateKeys(seriesCount, prefix);\n", "}\n", "\n", "// set up the category names...\n", "int categoryCount = starts[0].length;\n", "if (categoryCount != ends[0].length) {\n", "String errMsg = \"DefaultIntervalCategoryDataset: the \"\n", "+ \"number of categories in the start value \"\n", "+ \"dataset does not match the number of \"\n", "+ \"categories in the end value dataset.\";\n", "throw new IllegalArgumentException(errMsg);\n", "}\n", "if (categoryKeys != null) {\n", "if (categoryKeys.length != categoryCount) {\n", "throw new IllegalArgumentException(\n", "\"The number of category keys does not match \"\n", "+ \"the number of categories in the data.\");\n", "}\n", "this.categoryKeys = categoryKeys;\n", "}\n", "else {\n", "String prefix = resources.getString(\n", "\"categories.default-prefix\") + \" \";\n", "this.categoryKeys = generateKeys(categoryCount, prefix);\n", "}\n", "\n", "}\n", "else {\n", "this.seriesKeys = null;\n", "this.categoryKeys = null;\n", "}\n", "}\n", "\n", "}\n"], "faulty_lines": [66, 67], "cluster": 3}, {"pid": "Chart", "bid": 16, "method_path": "./dataset/Chart/16/DefaultIntervalCategoryDataset.java", "method": ["public void setCategoryKeys(Comparable[] categoryKeys) {\n", "if (categoryKeys == null) {\n", "throw new IllegalArgumentException(\"Null 'categoryKeys' argument.\");\n", "}\n", "if (categoryKeys.length != this.startData[0].length) {\n", "throw new IllegalArgumentException(\n", "\"The number of categories does not match the data.\");\n", "}\n", "for (int i = 0; i < categoryKeys.length; i++) {\n", "if (categoryKeys[i] == null) {\n", "throw new IllegalArgumentException(\n", "\"DefaultIntervalCategoryDataset.setCategoryKeys(): \"\n", "+ \"null category not permitted.\");\n", "}\n", "}\n", "this.categoryKeys = categoryKeys;\n", "fireDatasetChanged();\n", "}\n"], "faulty_lines": [5], "cluster": 2}, {"pid": "Chart", "bid": 17, "method_path": "./dataset/Chart/17/TimeSeries.java", "method": ["public Object clone() throws CloneNotSupportedException {\n", "Object clone = createCopy(0, getItemCount() - 1);\n", "return clone;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Chart", "bid": 18, "method_path": "./dataset/Chart/18/DefaultKeyedValues.java", "method": ["public void removeValue(int index) {\n", "this.keys.remove(index);\n", "this.values.remove(index);\n", "if (index < this.keys.size()) {\n", "rebuildIndex();\n", "}\n", "}\n"], "faulty_lines": [4, 6], "cluster": 0}, {"pid": "Chart", "bid": 18, "method_path": "./dataset/Chart/18/DefaultKeyedValues.java", "method": ["public void removeValue(Comparable key) {\n", "int index = getIndex(key);\n", "if (index < 0) {\n", "return;\n", "}\n", "removeValue(index);\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Chart", "bid": 18, "method_path": "./dataset/Chart/18/DefaultKeyedValues2D.java", "method": ["public void removeColumn(Comparable columnKey) {\n", "Iterator iterator = this.rows.iterator();\n", "while (iterator.hasNext()) {\n", "DefaultKeyedValues rowData = (DefaultKeyedValues) iterator.next();\n", "rowData.removeValue(columnKey);\n", "}\n", "this.columnKeys.remove(columnKey);\n", "}\n"], "faulty_lines": [2, 5, 6], "cluster": 4}, {"pid": "Chart", "bid": 19, "method_path": "./dataset/Chart/19/CategoryPlot.java", "method": ["public int getDomainAxisIndex(CategoryAxis axis) {\n", "return this.domainAxes.indexOf(axis);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Chart", "bid": 19, "method_path": "./dataset/Chart/19/CategoryPlot.java", "method": ["public int getRangeAxisIndex(ValueAxis axis) {\n", "int result = this.rangeAxes.indexOf(axis);\n", "if (result < 0) { // try the parent plot\n", "Plot parent = getParent();\n", "if (parent instanceof CategoryPlot) {\n", "CategoryPlot p = (CategoryPlot) parent;\n", "result = p.getRangeAxisIndex(axis);\n", "}\n", "}\n", "return result;\n", "}\n"], "faulty_lines": [2], "cluster": 4}, {"pid": "Chart", "bid": 20, "method_path": "./dataset/Chart/20/ValueMarker.java", "method": ["public ValueMarker(double value, Paint paint, Stroke stroke,\n", "Paint outlinePaint, Stroke outlineStroke, float alpha) {\n", "super(paint, stroke, paint, stroke, alpha);\n", "this.value = value;\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Chart", "bid": 21, "method_path": "./dataset/Chart/21/DefaultBoxAndWhiskerCategoryDataset.java", "method": ["public void add(BoxAndWhiskerItem item, Comparable rowKey,\n", "Comparable columnKey) {\n", "\n", "this.data.addObject(item, rowKey, columnKey);\n", "\n", "// update cached min and max values\n", "int r = this.data.getRowIndex(rowKey);\n", "int c = this.data.getColumnIndex(columnKey);\n", "if ((this.maximumRangeValueRow == r && this.maximumRangeValueColumn\n", "== c) || (this.minimumRangeValueRow == r\n", "&& this.minimumRangeValueColumn == c))  {\n", "updateBounds();\n", "}\n", "\n", "double minval = Double.NaN;\n", "if (item.getMinOutlier() != null) {\n", "minval = item.getMinOutlier().doubleValue();\n", "}\n", "double maxval = Double.NaN;\n", "if (item.getMaxOutlier() != null) {\n", "maxval = item.getMaxOutlier().doubleValue();\n", "}\n", "\n", "if (Double.isNaN(this.maximumRangeValue)) {\n", "this.maximumRangeValue = maxval;\n", "this.maximumRangeValueRow = r;\n", "this.maximumRangeValueColumn = c;\n", "}\n", "else if (maxval > this.maximumRangeValue) {\n", "this.maximumRangeValue = maxval;\n", "this.maximumRangeValueRow = r;\n", "this.maximumRangeValueColumn = c;\n", "}\n", "\n", "if (Double.isNaN(this.minimumRangeValue)) {\n", "this.minimumRangeValue = minval;\n", "this.minimumRangeValueRow = r;\n", "this.minimumRangeValueColumn = c;\n", "}\n", "else if (minval < this.minimumRangeValue) {\n", "this.minimumRangeValue = minval;\n", "this.minimumRangeValueRow = r;\n", "this.minimumRangeValueColumn = c;\n", "}\n", "\n", "this.rangeBounds = new Range(this.minimumRangeValue,\n", "this.maximumRangeValue);\n", "fireDatasetChanged();\n", "\n", "}\n"], "faulty_lines": [14], "cluster": 5}, {"pid": "Chart", "bid": 21, "method_path": "./dataset/Chart/21/DefaultBoxAndWhiskerCategoryDataset.java", "method": ["public void add(BoxAndWhiskerItem item, Comparable rowKey,\n", "Comparable columnKey) {\n", "\n", "this.data.addObject(item, rowKey, columnKey);\n", "\n", "// update cached min and max values\n", "int r = this.data.getRowIndex(rowKey);\n", "int c = this.data.getColumnIndex(columnKey);\n", "if ((this.maximumRangeValueRow == r && this.maximumRangeValueColumn\n", "== c) || (this.minimumRangeValueRow == r\n", "&& this.minimumRangeValueColumn == c))  {\n", "updateBounds();\n", "}\n", "\n", "double minval = Double.NaN;\n", "if (item.getMinOutlier() != null) {\n", "minval = item.getMinOutlier().doubleValue();\n", "}\n", "double maxval = Double.NaN;\n", "if (item.getMaxOutlier() != null) {\n", "maxval = item.getMaxOutlier().doubleValue();\n", "}\n", "\n", "if (Double.isNaN(this.maximumRangeValue)) {\n", "this.maximumRangeValue = maxval;\n", "this.maximumRangeValueRow = r;\n", "this.maximumRangeValueColumn = c;\n", "}\n", "else if (maxval > this.maximumRangeValue) {\n", "this.maximumRangeValue = maxval;\n", "this.maximumRangeValueRow = r;\n", "this.maximumRangeValueColumn = c;\n", "}\n", "\n", "if (Double.isNaN(this.minimumRangeValue)) {\n", "this.minimumRangeValue = minval;\n", "this.minimumRangeValueRow = r;\n", "this.minimumRangeValueColumn = c;\n", "}\n", "else if (minval < this.minimumRangeValue) {\n", "this.minimumRangeValue = minval;\n", "this.minimumRangeValueRow = r;\n", "this.minimumRangeValueColumn = c;\n", "}\n", "\n", "this.rangeBounds = new Range(this.minimumRangeValue,\n", "this.maximumRangeValue);\n", "fireDatasetChanged();\n", "\n", "}\n"], "faulty_lines": [45], "cluster": 5}, {"pid": "Chart", "bid": 21, "method_path": "./dataset/Chart/21/DefaultBoxAndWhiskerCategoryDataset.java", "method": ["private void updateBounds() {\n", "this.minimumRangeValue = Double.NaN;\n", "this.maximumRangeValue = Double.NaN;\n", "}\n"], "faulty_lines": [3, 4], "cluster": 0}, {"pid": "Chart", "bid": 22, "method_path": "./dataset/Chart/22/KeyedObjects2D.java", "method": ["public Object getObject(Comparable rowKey, Comparable columnKey) {\n", "if (rowKey == null) {\n", "throw new IllegalArgumentException(\"Null 'rowKey' argument.\");\n", "}\n", "if (columnKey == null) {\n", "throw new IllegalArgumentException(\"Null 'columnKey' argument.\");\n", "}\n", "int row = this.rowKeys.indexOf(rowKey);\n", "if (row < 0) {\n", "throw new UnknownKeyException(\"Row key (\" + rowKey\n", "+ \") not recognised.\");\n", "}\n", "int column = this.columnKeys.indexOf(columnKey);\n", "if (column < 0) {\n", "throw new UnknownKeyException(\"Column key (\" + columnKey\n", "+ \") not recognised.\");\n", "}\n", "if (row >= 0) {\n", "KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\n", "return rowData.getObject(columnKey);\n", "}\n", "else {\n", "return null;\n", "}\n", "}\n"], "faulty_lines": [18, 20], "cluster": 2}, {"pid": "Chart", "bid": 22, "method_path": "./dataset/Chart/22/KeyedObjects2D.java", "method": ["public void removeRow(Comparable rowKey) {\n", "int index = getRowIndex(rowKey);\n", "removeRow(index);\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Chart", "bid": 22, "method_path": "./dataset/Chart/22/KeyedObjects2D.java", "method": ["public void removeColumn(Comparable columnKey) {\n", "int index = getColumnIndex(columnKey);\n", "if (index < 0) {\n", "throw new UnknownKeyException(\"Column key (\" + columnKey\n", "+ \") not recognised.\");\n", "}\n", "Iterator iterator = this.rows.iterator();\n", "while (iterator.hasNext()) {\n", "KeyedObjects rowData = (KeyedObjects) iterator.next();\n", "rowData.removeValue(columnKey);\n", "}\n", "this.columnKeys.remove(columnKey);\n", "}\n"], "faulty_lines": [10], "cluster": 4}, {"pid": "Chart", "bid": 24, "method_path": "./dataset/Chart/24/GrayPaintScale.java", "method": ["public Paint getPaint(double value) {\n", "double v = Math.max(value, this.lowerBound);\n", "v = Math.min(v, this.upperBound);\n", "int g = (int) ((value - this.lowerBound) / (this.upperBound\n", "- this.lowerBound) * 255.0);\n", "return new Color(g, g, g);\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Chart", "bid": 25, "method_path": "./dataset/Chart/25/StatisticalBarRenderer.java", "method": ["protected void drawHorizontalItem(Graphics2D g2,\n", "CategoryItemRendererState state,\n", "Rectangle2D dataArea,\n", "CategoryPlot plot,\n", "CategoryAxis domainAxis,\n", "ValueAxis rangeAxis,\n", "StatisticalCategoryDataset dataset,\n", "int row,\n", "int column) {\n", "\n", "RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n", "\n", "// BAR Y\n", "double rectY = domainAxis.getCategoryStart(column, getColumnCount(),\n", "dataArea, xAxisLocation);\n", "\n", "int seriesCount = getRowCount();\n", "int categoryCount = getColumnCount();\n", "if (seriesCount > 1) {\n", "double seriesGap = dataArea.getHeight() * getItemMargin()\n", "/ (categoryCount * (seriesCount - 1));\n", "rectY = rectY + row * (state.getBarWidth() + seriesGap);\n", "}\n", "else {\n", "rectY = rectY + row * state.getBarWidth();\n", "}\n", "\n", "// BAR X\n", "Number meanValue = dataset.getMeanValue(row, column);\n", "\n", "double value = meanValue.doubleValue();\n", "double base = 0.0;\n", "double lclip = getLowerClip();\n", "double uclip = getUpperClip();\n", "\n", "if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n", "if (value >= uclip) {\n", "return; // bar is not visible\n", "}\n", "base = uclip;\n", "if (value <= lclip) {\n", "value = lclip;\n", "}\n", "}\n", "else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n", "if (value >= uclip) {\n", "value = uclip;\n", "}\n", "else {\n", "if (value <= lclip) {\n", "value = lclip;\n", "}\n", "}\n", "}\n", "else { // cases 9, 10, 11 and 12\n", "if (value <= lclip) {\n", "return; // bar is not visible\n", "}\n", "base = getLowerClip();\n", "if (value >= uclip) {\n", "value = uclip;\n", "}\n", "}\n", "\n", "RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n", "double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n", "double transY2 = rangeAxis.valueToJava2D(value, dataArea,\n", "yAxisLocation);\n", "double rectX = Math.min(transY2, transY1);\n", "\n", "double rectHeight = state.getBarWidth();\n", "double rectWidth = Math.abs(transY2 - transY1);\n", "\n", "Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth,\n", "rectHeight);\n", "Paint seriesPaint = getItemPaint(row, column);\n", "g2.setPaint(seriesPaint);\n", "g2.fill(bar);\n", "if (isDrawBarOutline() && state.getBarWidth() > 3) {\n", "g2.setStroke(getItemStroke(row, column));\n", "g2.setPaint(getItemOutlinePaint(row, column));\n", "g2.draw(bar);\n", "}\n", "\n", "// standard deviation lines\n", "double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n", "double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n", "+ valueDelta, dataArea, yAxisLocation);\n", "double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n", "- valueDelta, dataArea, yAxisLocation);\n", "\n", "if (this.errorIndicatorStroke != null) {\n", "g2.setStroke(this.errorIndicatorStroke);\n", "}\n", "else {\n", "g2.setStroke(getItemOutlineStroke(row, column));\n", "}\n", "if (this.errorIndicatorPaint != null) {\n", "g2.setPaint(this.errorIndicatorPaint);\n", "}\n", "else {\n", "g2.setPaint(getItemOutlinePaint(row, column));\n", "}\n", "\n", "Line2D line = null;\n", "line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d,\n", "highVal, rectY + rectHeight / 2.0d);\n", "g2.draw(line);\n", "line = new Line2D.Double(highVal, rectY + rectHeight * 0.25,\n", "highVal, rectY + rectHeight * 0.75);\n", "g2.draw(line);\n", "line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25,\n", "lowVal, rectY + rectHeight * 0.75);\n", "g2.draw(line);\n", "\n", "CategoryItemLabelGenerator generator = getItemLabelGenerator(row,\n", "column);\n", "if (generator != null && isItemLabelVisible(row, column)) {\n", "drawItemLabel(g2, dataset, row, column, plot, generator, bar,\n", "(value < 0.0));\n", "}\n", "\n", "// add an item entity, if this information is being collected\n", "EntityCollection entities = state.getEntityCollection();\n", "if (entities != null) {\n", "addItemEntity(entities, dataset, row, column, bar);\n", "}\n", "\n", "}\n"], "faulty_lines": [30], "cluster": 3}, {"pid": "Chart", "bid": 25, "method_path": "./dataset/Chart/25/StatisticalBarRenderer.java", "method": ["protected void drawHorizontalItem(Graphics2D g2,\n", "CategoryItemRendererState state,\n", "Rectangle2D dataArea,\n", "CategoryPlot plot,\n", "CategoryAxis domainAxis,\n", "ValueAxis rangeAxis,\n", "StatisticalCategoryDataset dataset,\n", "int row,\n", "int column) {\n", "\n", "RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n", "\n", "// BAR Y\n", "double rectY = domainAxis.getCategoryStart(column, getColumnCount(),\n", "dataArea, xAxisLocation);\n", "\n", "int seriesCount = getRowCount();\n", "int categoryCount = getColumnCount();\n", "if (seriesCount > 1) {\n", "double seriesGap = dataArea.getHeight() * getItemMargin()\n", "/ (categoryCount * (seriesCount - 1));\n", "rectY = rectY + row * (state.getBarWidth() + seriesGap);\n", "}\n", "else {\n", "rectY = rectY + row * state.getBarWidth();\n", "}\n", "\n", "// BAR X\n", "Number meanValue = dataset.getMeanValue(row, column);\n", "\n", "double value = meanValue.doubleValue();\n", "double base = 0.0;\n", "double lclip = getLowerClip();\n", "double uclip = getUpperClip();\n", "\n", "if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n", "if (value >= uclip) {\n", "return; // bar is not visible\n", "}\n", "base = uclip;\n", "if (value <= lclip) {\n", "value = lclip;\n", "}\n", "}\n", "else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n", "if (value >= uclip) {\n", "value = uclip;\n", "}\n", "else {\n", "if (value <= lclip) {\n", "value = lclip;\n", "}\n", "}\n", "}\n", "else { // cases 9, 10, 11 and 12\n", "if (value <= lclip) {\n", "return; // bar is not visible\n", "}\n", "base = getLowerClip();\n", "if (value >= uclip) {\n", "value = uclip;\n", "}\n", "}\n", "\n", "RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n", "double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n", "double transY2 = rangeAxis.valueToJava2D(value, dataArea,\n", "yAxisLocation);\n", "double rectX = Math.min(transY2, transY1);\n", "\n", "double rectHeight = state.getBarWidth();\n", "double rectWidth = Math.abs(transY2 - transY1);\n", "\n", "Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth,\n", "rectHeight);\n", "Paint seriesPaint = getItemPaint(row, column);\n", "g2.setPaint(seriesPaint);\n", "g2.fill(bar);\n", "if (isDrawBarOutline() && state.getBarWidth() > 3) {\n", "g2.setStroke(getItemStroke(row, column));\n", "g2.setPaint(getItemOutlinePaint(row, column));\n", "g2.draw(bar);\n", "}\n", "\n", "// standard deviation lines\n", "double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n", "double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n", "+ valueDelta, dataArea, yAxisLocation);\n", "double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n", "- valueDelta, dataArea, yAxisLocation);\n", "\n", "if (this.errorIndicatorStroke != null) {\n", "g2.setStroke(this.errorIndicatorStroke);\n", "}\n", "else {\n", "g2.setStroke(getItemOutlineStroke(row, column));\n", "}\n", "if (this.errorIndicatorPaint != null) {\n", "g2.setPaint(this.errorIndicatorPaint);\n", "}\n", "else {\n", "g2.setPaint(getItemOutlinePaint(row, column));\n", "}\n", "\n", "Line2D line = null;\n", "line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d,\n", "highVal, rectY + rectHeight / 2.0d);\n", "g2.draw(line);\n", "line = new Line2D.Double(highVal, rectY + rectHeight * 0.25,\n", "highVal, rectY + rectHeight * 0.75);\n", "g2.draw(line);\n", "line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25,\n", "lowVal, rectY + rectHeight * 0.75);\n", "g2.draw(line);\n", "\n", "CategoryItemLabelGenerator generator = getItemLabelGenerator(row,\n", "column);\n", "if (generator != null && isItemLabelVisible(row, column)) {\n", "drawItemLabel(g2, dataset, row, column, plot, generator, bar,\n", "(value < 0.0));\n", "}\n", "\n", "// add an item entity, if this information is being collected\n", "EntityCollection entities = state.getEntityCollection();\n", "if (entities != null) {\n", "addItemEntity(entities, dataset, row, column, bar);\n", "}\n", "\n", "}\n"], "faulty_lines": [86], "cluster": 3}, {"pid": "Chart", "bid": 25, "method_path": "./dataset/Chart/25/StatisticalBarRenderer.java", "method": ["protected void drawHorizontalItem(Graphics2D g2,\n", "CategoryItemRendererState state,\n", "Rectangle2D dataArea,\n", "CategoryPlot plot,\n", "CategoryAxis domainAxis,\n", "ValueAxis rangeAxis,\n", "StatisticalCategoryDataset dataset,\n", "int row,\n", "int column) {\n", "\n", "RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n", "\n", "// BAR Y\n", "double rectY = domainAxis.getCategoryStart(column, getColumnCount(),\n", "dataArea, xAxisLocation);\n", "\n", "int seriesCount = getRowCount();\n", "int categoryCount = getColumnCount();\n", "if (seriesCount > 1) {\n", "double seriesGap = dataArea.getHeight() * getItemMargin()\n", "/ (categoryCount * (seriesCount - 1));\n", "rectY = rectY + row * (state.getBarWidth() + seriesGap);\n", "}\n", "else {\n", "rectY = rectY + row * state.getBarWidth();\n", "}\n", "\n", "// BAR X\n", "Number meanValue = dataset.getMeanValue(row, column);\n", "\n", "double value = meanValue.doubleValue();\n", "double base = 0.0;\n", "double lclip = getLowerClip();\n", "double uclip = getUpperClip();\n", "\n", "if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n", "if (value >= uclip) {\n", "return; // bar is not visible\n", "}\n", "base = uclip;\n", "if (value <= lclip) {\n", "value = lclip;\n", "}\n", "}\n", "else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n", "if (value >= uclip) {\n", "value = uclip;\n", "}\n", "else {\n", "if (value <= lclip) {\n", "value = lclip;\n", "}\n", "}\n", "}\n", "else { // cases 9, 10, 11 and 12\n", "if (value <= lclip) {\n", "return; // bar is not visible\n", "}\n", "base = getLowerClip();\n", "if (value >= uclip) {\n", "value = uclip;\n", "}\n", "}\n", "\n", "RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n", "double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n", "double transY2 = rangeAxis.valueToJava2D(value, dataArea,\n", "yAxisLocation);\n", "double rectX = Math.min(transY2, transY1);\n", "\n", "double rectHeight = state.getBarWidth();\n", "double rectWidth = Math.abs(transY2 - transY1);\n", "\n", "Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth,\n", "rectHeight);\n", "Paint seriesPaint = getItemPaint(row, column);\n", "g2.setPaint(seriesPaint);\n", "g2.fill(bar);\n", "if (isDrawBarOutline() && state.getBarWidth() > 3) {\n", "g2.setStroke(getItemStroke(row, column));\n", "g2.setPaint(getItemOutlinePaint(row, column));\n", "g2.draw(bar);\n", "}\n", "\n", "// standard deviation lines\n", "double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n", "double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n", "+ valueDelta, dataArea, yAxisLocation);\n", "double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n", "- valueDelta, dataArea, yAxisLocation);\n", "\n", "if (this.errorIndicatorStroke != null) {\n", "g2.setStroke(this.errorIndicatorStroke);\n", "}\n", "else {\n", "g2.setStroke(getItemOutlineStroke(row, column));\n", "}\n", "if (this.errorIndicatorPaint != null) {\n", "g2.setPaint(this.errorIndicatorPaint);\n", "}\n", "else {\n", "g2.setPaint(getItemOutlinePaint(row, column));\n", "}\n", "\n", "Line2D line = null;\n", "line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d,\n", "highVal, rectY + rectHeight / 2.0d);\n", "g2.draw(line);\n", "line = new Line2D.Double(highVal, rectY + rectHeight * 0.25,\n", "highVal, rectY + rectHeight * 0.75);\n", "g2.draw(line);\n", "line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25,\n", "lowVal, rectY + rectHeight * 0.75);\n", "g2.draw(line);\n", "\n", "CategoryItemLabelGenerator generator = getItemLabelGenerator(row,\n", "column);\n", "if (generator != null && isItemLabelVisible(row, column)) {\n", "drawItemLabel(g2, dataset, row, column, plot, generator, bar,\n", "(value < 0.0));\n", "}\n", "\n", "// add an item entity, if this information is being collected\n", "EntityCollection entities = state.getEntityCollection();\n", "if (entities != null) {\n", "addItemEntity(entities, dataset, row, column, bar);\n", "}\n", "\n", "}\n"], "faulty_lines": [115], "cluster": 3}, {"pid": "Chart", "bid": 25, "method_path": "./dataset/Chart/25/StatisticalBarRenderer.java", "method": ["protected void drawVerticalItem(Graphics2D g2,\n", "CategoryItemRendererState state,\n", "Rectangle2D dataArea,\n", "CategoryPlot plot,\n", "CategoryAxis domainAxis,\n", "ValueAxis rangeAxis,\n", "StatisticalCategoryDataset dataset,\n", "int row,\n", "int column) {\n", "\n", "RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n", "\n", "// BAR X\n", "double rectX = domainAxis.getCategoryStart(\n", "column, getColumnCount(), dataArea, xAxisLocation\n", ");\n", "\n", "int seriesCount = getRowCount();\n", "int categoryCount = getColumnCount();\n", "if (seriesCount > 1) {\n", "double seriesGap = dataArea.getWidth() * getItemMargin()\n", "/ (categoryCount * (seriesCount - 1));\n", "rectX = rectX + row * (state.getBarWidth() + seriesGap);\n", "}\n", "else {\n", "rectX = rectX + row * state.getBarWidth();\n", "}\n", "\n", "// BAR Y\n", "Number meanValue = dataset.getMeanValue(row, column);\n", "\n", "double value = meanValue.doubleValue();\n", "double base = 0.0;\n", "double lclip = getLowerClip();\n", "double uclip = getUpperClip();\n", "\n", "if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n", "if (value >= uclip) {\n", "return; // bar is not visible\n", "}\n", "base = uclip;\n", "if (value <= lclip) {\n", "value = lclip;\n", "}\n", "}\n", "else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n", "if (value >= uclip) {\n", "value = uclip;\n", "}\n", "else {\n", "if (value <= lclip) {\n", "value = lclip;\n", "}\n", "}\n", "}\n", "else { // cases 9, 10, 11 and 12\n", "if (value <= lclip) {\n", "return; // bar is not visible\n", "}\n", "base = getLowerClip();\n", "if (value >= uclip) {\n", "value = uclip;\n", "}\n", "}\n", "\n", "RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n", "double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n", "double transY2 = rangeAxis.valueToJava2D(value, dataArea,\n", "yAxisLocation);\n", "double rectY = Math.min(transY2, transY1);\n", "\n", "double rectWidth = state.getBarWidth();\n", "double rectHeight = Math.abs(transY2 - transY1);\n", "\n", "Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth,\n", "rectHeight);\n", "Paint seriesPaint = getItemPaint(row, column);\n", "g2.setPaint(seriesPaint);\n", "g2.fill(bar);\n", "if (isDrawBarOutline() && state.getBarWidth() > 3) {\n", "g2.setStroke(getItemStroke(row, column));\n", "g2.setPaint(getItemOutlinePaint(row, column));\n", "g2.draw(bar);\n", "}\n", "\n", "// standard deviation lines\n", "double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n", "double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n", "+ valueDelta, dataArea, yAxisLocation);\n", "double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n", "- valueDelta, dataArea, yAxisLocation);\n", "\n", "if (this.errorIndicatorStroke != null) {\n", "g2.setStroke(this.errorIndicatorStroke);\n", "}\n", "else {\n", "g2.setStroke(getItemOutlineStroke(row, column));\n", "}\n", "if (this.errorIndicatorPaint != null) {\n", "g2.setPaint(this.errorIndicatorPaint);\n", "}\n", "else {\n", "g2.setPaint(getItemOutlinePaint(row, column));\n", "}\n", "Line2D line = null;\n", "line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,\n", "rectX + rectWidth / 2.0d, highVal);\n", "g2.draw(line);\n", "line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,\n", "rectX + rectWidth / 2.0d + 5.0d, highVal);\n", "g2.draw(line);\n", "line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\n", "rectX + rectWidth / 2.0d + 5.0d, lowVal);\n", "g2.draw(line);\n", "\n", "CategoryItemLabelGenerator generator = getItemLabelGenerator(row,\n", "column);\n", "if (generator != null && isItemLabelVisible(row, column)) {\n", "drawItemLabel(g2, dataset, row, column, plot, generator, bar,\n", "(value < 0.0));\n", "}\n", "\n", "// add an item entity, if this information is being collected\n", "EntityCollection entities = state.getEntityCollection();\n", "if (entities != null) {\n", "addItemEntity(entities, dataset, row, column, bar);\n", "}\n", "}\n"], "faulty_lines": [31], "cluster": 3}, {"pid": "Chart", "bid": 25, "method_path": "./dataset/Chart/25/StatisticalBarRenderer.java", "method": ["protected void drawVerticalItem(Graphics2D g2,\n", "CategoryItemRendererState state,\n", "Rectangle2D dataArea,\n", "CategoryPlot plot,\n", "CategoryAxis domainAxis,\n", "ValueAxis rangeAxis,\n", "StatisticalCategoryDataset dataset,\n", "int row,\n", "int column) {\n", "\n", "RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n", "\n", "// BAR X\n", "double rectX = domainAxis.getCategoryStart(\n", "column, getColumnCount(), dataArea, xAxisLocation\n", ");\n", "\n", "int seriesCount = getRowCount();\n", "int categoryCount = getColumnCount();\n", "if (seriesCount > 1) {\n", "double seriesGap = dataArea.getWidth() * getItemMargin()\n", "/ (categoryCount * (seriesCount - 1));\n", "rectX = rectX + row * (state.getBarWidth() + seriesGap);\n", "}\n", "else {\n", "rectX = rectX + row * state.getBarWidth();\n", "}\n", "\n", "// BAR Y\n", "Number meanValue = dataset.getMeanValue(row, column);\n", "\n", "double value = meanValue.doubleValue();\n", "double base = 0.0;\n", "double lclip = getLowerClip();\n", "double uclip = getUpperClip();\n", "\n", "if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n", "if (value >= uclip) {\n", "return; // bar is not visible\n", "}\n", "base = uclip;\n", "if (value <= lclip) {\n", "value = lclip;\n", "}\n", "}\n", "else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n", "if (value >= uclip) {\n", "value = uclip;\n", "}\n", "else {\n", "if (value <= lclip) {\n", "value = lclip;\n", "}\n", "}\n", "}\n", "else { // cases 9, 10, 11 and 12\n", "if (value <= lclip) {\n", "return; // bar is not visible\n", "}\n", "base = getLowerClip();\n", "if (value >= uclip) {\n", "value = uclip;\n", "}\n", "}\n", "\n", "RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n", "double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n", "double transY2 = rangeAxis.valueToJava2D(value, dataArea,\n", "yAxisLocation);\n", "double rectY = Math.min(transY2, transY1);\n", "\n", "double rectWidth = state.getBarWidth();\n", "double rectHeight = Math.abs(transY2 - transY1);\n", "\n", "Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth,\n", "rectHeight);\n", "Paint seriesPaint = getItemPaint(row, column);\n", "g2.setPaint(seriesPaint);\n", "g2.fill(bar);\n", "if (isDrawBarOutline() && state.getBarWidth() > 3) {\n", "g2.setStroke(getItemStroke(row, column));\n", "g2.setPaint(getItemOutlinePaint(row, column));\n", "g2.draw(bar);\n", "}\n", "\n", "// standard deviation lines\n", "double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n", "double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n", "+ valueDelta, dataArea, yAxisLocation);\n", "double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n", "- valueDelta, dataArea, yAxisLocation);\n", "\n", "if (this.errorIndicatorStroke != null) {\n", "g2.setStroke(this.errorIndicatorStroke);\n", "}\n", "else {\n", "g2.setStroke(getItemOutlineStroke(row, column));\n", "}\n", "if (this.errorIndicatorPaint != null) {\n", "g2.setPaint(this.errorIndicatorPaint);\n", "}\n", "else {\n", "g2.setPaint(getItemOutlinePaint(row, column));\n", "}\n", "Line2D line = null;\n", "line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,\n", "rectX + rectWidth / 2.0d, highVal);\n", "g2.draw(line);\n", "line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,\n", "rectX + rectWidth / 2.0d + 5.0d, highVal);\n", "g2.draw(line);\n", "line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\n", "rectX + rectWidth / 2.0d + 5.0d, lowVal);\n", "g2.draw(line);\n", "\n", "CategoryItemLabelGenerator generator = getItemLabelGenerator(row,\n", "column);\n", "if (generator != null && isItemLabelVisible(row, column)) {\n", "drawItemLabel(g2, dataset, row, column, plot, generator, bar,\n", "(value < 0.0));\n", "}\n", "\n", "// add an item entity, if this information is being collected\n", "EntityCollection entities = state.getEntityCollection();\n", "if (entities != null) {\n", "addItemEntity(entities, dataset, row, column, bar);\n", "}\n", "}\n"], "faulty_lines": [87], "cluster": 3}, {"pid": "Chart", "bid": 25, "method_path": "./dataset/Chart/25/StatisticalBarRenderer.java", "method": ["protected void drawVerticalItem(Graphics2D g2,\n", "CategoryItemRendererState state,\n", "Rectangle2D dataArea,\n", "CategoryPlot plot,\n", "CategoryAxis domainAxis,\n", "ValueAxis rangeAxis,\n", "StatisticalCategoryDataset dataset,\n", "int row,\n", "int column) {\n", "\n", "RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n", "\n", "// BAR X\n", "double rectX = domainAxis.getCategoryStart(\n", "column, getColumnCount(), dataArea, xAxisLocation\n", ");\n", "\n", "int seriesCount = getRowCount();\n", "int categoryCount = getColumnCount();\n", "if (seriesCount > 1) {\n", "double seriesGap = dataArea.getWidth() * getItemMargin()\n", "/ (categoryCount * (seriesCount - 1));\n", "rectX = rectX + row * (state.getBarWidth() + seriesGap);\n", "}\n", "else {\n", "rectX = rectX + row * state.getBarWidth();\n", "}\n", "\n", "// BAR Y\n", "Number meanValue = dataset.getMeanValue(row, column);\n", "\n", "double value = meanValue.doubleValue();\n", "double base = 0.0;\n", "double lclip = getLowerClip();\n", "double uclip = getUpperClip();\n", "\n", "if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n", "if (value >= uclip) {\n", "return; // bar is not visible\n", "}\n", "base = uclip;\n", "if (value <= lclip) {\n", "value = lclip;\n", "}\n", "}\n", "else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n", "if (value >= uclip) {\n", "value = uclip;\n", "}\n", "else {\n", "if (value <= lclip) {\n", "value = lclip;\n", "}\n", "}\n", "}\n", "else { // cases 9, 10, 11 and 12\n", "if (value <= lclip) {\n", "return; // bar is not visible\n", "}\n", "base = getLowerClip();\n", "if (value >= uclip) {\n", "value = uclip;\n", "}\n", "}\n", "\n", "RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n", "double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n", "double transY2 = rangeAxis.valueToJava2D(value, dataArea,\n", "yAxisLocation);\n", "double rectY = Math.min(transY2, transY1);\n", "\n", "double rectWidth = state.getBarWidth();\n", "double rectHeight = Math.abs(transY2 - transY1);\n", "\n", "Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth,\n", "rectHeight);\n", "Paint seriesPaint = getItemPaint(row, column);\n", "g2.setPaint(seriesPaint);\n", "g2.fill(bar);\n", "if (isDrawBarOutline() && state.getBarWidth() > 3) {\n", "g2.setStroke(getItemStroke(row, column));\n", "g2.setPaint(getItemOutlinePaint(row, column));\n", "g2.draw(bar);\n", "}\n", "\n", "// standard deviation lines\n", "double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n", "double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n", "+ valueDelta, dataArea, yAxisLocation);\n", "double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue()\n", "- valueDelta, dataArea, yAxisLocation);\n", "\n", "if (this.errorIndicatorStroke != null) {\n", "g2.setStroke(this.errorIndicatorStroke);\n", "}\n", "else {\n", "g2.setStroke(getItemOutlineStroke(row, column));\n", "}\n", "if (this.errorIndicatorPaint != null) {\n", "g2.setPaint(this.errorIndicatorPaint);\n", "}\n", "else {\n", "g2.setPaint(getItemOutlinePaint(row, column));\n", "}\n", "Line2D line = null;\n", "line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,\n", "rectX + rectWidth / 2.0d, highVal);\n", "g2.draw(line);\n", "line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,\n", "rectX + rectWidth / 2.0d + 5.0d, highVal);\n", "g2.draw(line);\n", "line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\n", "rectX + rectWidth / 2.0d + 5.0d, lowVal);\n", "g2.draw(line);\n", "\n", "CategoryItemLabelGenerator generator = getItemLabelGenerator(row,\n", "column);\n", "if (generator != null && isItemLabelVisible(row, column)) {\n", "drawItemLabel(g2, dataset, row, column, plot, generator, bar,\n", "(value < 0.0));\n", "}\n", "\n", "// add an item entity, if this information is being collected\n", "EntityCollection entities = state.getEntityCollection();\n", "if (entities != null) {\n", "addItemEntity(entities, dataset, row, column, bar);\n", "}\n", "}\n"], "faulty_lines": [115], "cluster": 3}, {"pid": "Chart", "bid": 26, "method_path": "./dataset/Chart/26/Axis.java", "method": ["protected AxisState drawLabel(String label, Graphics2D g2,\n", "Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,\n", "AxisState state, PlotRenderingInfo plotState) {\n", "\n", "// it is unlikely that 'state' will be null, but check anyway...\n", "if (state == null) {\n", "throw new IllegalArgumentException(\"Null 'state' argument.\");\n", "}\n", "\n", "if ((label == null) || (label.equals(\"\"))) {\n", "return state;\n", "}\n", "\n", "Font font = getLabelFont();\n", "RectangleInsets insets = getLabelInsets();\n", "g2.setFont(font);\n", "g2.setPaint(getLabelPaint());\n", "FontMetrics fm = g2.getFontMetrics();\n", "Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n", "Shape hotspot = null;\n", "\n", "if (edge == RectangleEdge.TOP) {\n", "AffineTransform t = AffineTransform.getRotateInstance(\n", "getLabelAngle(), labelBounds.getCenterX(),\n", "labelBounds.getCenterY());\n", "Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n", "labelBounds = rotatedLabelBounds.getBounds2D();\n", "float w = (float) labelBounds.getWidth();\n", "float h = (float) labelBounds.getHeight();\n", "float labelx = (float) dataArea.getCenterX();\n", "float labely = (float) (state.getCursor() - insets.getBottom()\n", "- h / 2.0);\n", "TextUtilities.drawRotatedString(label, g2, labelx, labely,\n", "TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n", "hotspot = new Rectangle2D.Float(labelx - w / 2.0f,\n", "labely - h / 2.0f, w, h);\n", "state.cursorUp(insets.getTop() + labelBounds.getHeight()\n", "+ insets.getBottom());\n", "}\n", "else if (edge == RectangleEdge.BOTTOM) {\n", "AffineTransform t = AffineTransform.getRotateInstance(\n", "getLabelAngle(), labelBounds.getCenterX(),\n", "labelBounds.getCenterY());\n", "Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n", "labelBounds = rotatedLabelBounds.getBounds2D();\n", "float w = (float) labelBounds.getWidth();\n", "float h = (float) labelBounds.getHeight();\n", "float labelx = (float) dataArea.getCenterX();\n", "float labely = (float) (state.getCursor() + insets.getTop()\n", "+ h / 2.0);\n", "TextUtilities.drawRotatedString(label, g2, labelx, labely,\n", "TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n", "hotspot = new Rectangle2D.Float(labelx - w / 2.0f,\n", "labely - h / 2.0f, w, h);\n", "state.cursorDown(insets.getTop() + labelBounds.getHeight()\n", "+ insets.getBottom());\n", "}\n", "else if (edge == RectangleEdge.LEFT) {\n", "AffineTransform t = AffineTransform.getRotateInstance(\n", "getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(),\n", "labelBounds.getCenterY());\n", "Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n", "labelBounds = rotatedLabelBounds.getBounds2D();\n", "float w = (float) labelBounds.getWidth();\n", "float h = (float) labelBounds.getHeight();\n", "float labelx = (float) (state.getCursor() - insets.getRight()\n", "- w / 2.0);\n", "float labely = (float) dataArea.getCenterY();\n", "TextUtilities.drawRotatedString(label, g2, labelx, labely,\n", "TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0,\n", "TextAnchor.CENTER);\n", "hotspot = new Rectangle2D.Float(labelx - w / 2.0f,\n", "labely - h / 2.0f, w, h);\n", "state.cursorLeft(insets.getLeft() + labelBounds.getWidth()\n", "+ insets.getRight());\n", "}\n", "else if (edge == RectangleEdge.RIGHT) {\n", "\n", "AffineTransform t = AffineTransform.getRotateInstance(\n", "getLabelAngle() + Math.PI / 2.0,\n", "labelBounds.getCenterX(), labelBounds.getCenterY());\n", "Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n", "labelBounds = rotatedLabelBounds.getBounds2D();\n", "float w = (float) labelBounds.getWidth();\n", "float h = (float) labelBounds.getHeight();\n", "float labelx = (float) (state.getCursor()\n", "+ insets.getLeft() + w / 2.0);\n", "float labely = (float) (dataArea.getY() + dataArea.getHeight()\n", "/ 2.0);\n", "TextUtilities.drawRotatedString(label, g2, labelx, labely,\n", "TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0,\n", "TextAnchor.CENTER);\n", "hotspot = new Rectangle2D.Float(labelx - w / 2.0f,\n", "labely - h / 2.0f, w, h);\n", "state.cursorRight(insets.getLeft() + labelBounds.getWidth()\n", "+ insets.getRight());\n", "\n", "}\n", "if (plotState != null && hotspot != null) {\n", "ChartRenderingInfo owner = plotState.getOwner();\n", "EntityCollection entities = owner.getEntityCollection();\n", "if (entities != null) {\n", "entities.add(new AxisLabelEntity(this, hotspot,\n", "this.labelToolTip, this.labelURL));\n", "}\n", "}\n", "return state;\n", "\n", "}\n"], "faulty_lines": [101, 106], "cluster": 3}, {"pid": "JxPath", "bid": 2, "method_path": "./dataset/JxPath/2/Expression.java", "method": ["public Iterator iterate(EvalContext context) {\n", "Object result = compute(context);\n", "if (result instanceof EvalContext) {\n", "return new ValueIterator((EvalContext) result);\n", "}\n", "return ValueUtils.iterate(result);\n", "}\n"], "faulty_lines": [6], "cluster": 0}, {"pid": "JxPath", "bid": 2, "method_path": "./dataset/JxPath/2/Expression.java", "method": ["public Iterator iteratePointers(EvalContext context) {\n", "Object result = compute(context);\n", "if (result == null) {\n", "return Collections.EMPTY_LIST.iterator();\n", "}\n", "if (result instanceof EvalContext) {\n", "return (EvalContext) result;\n", "}\n", "return new PointerIterator(ValueUtils.iterate(result),\n", "new QName(null, \"value\"),\n", "context.getRootContext().getCurrentNodePointer().getLocale());\n", "}\n"], "faulty_lines": [9], "cluster": 4}, {"pid": "JxPath", "bid": 3, "method_path": "./dataset/JxPath/3/NullPropertyPointer.java", "method": ["public NodePointer createPath(JXPathContext context) {\n", "NodePointer newParent = parent.createPath(context);\n", "if (isAttribute()) {\n", "return newParent.createAttribute(context, getName());\n", "}\n", "else {\n", "// Consider these two use cases:\n", "// 1. The parent pointer of NullPropertyPointer is\n", "//    a PropertyOwnerPointer other than NullPointer. When we call\n", "//    createPath on it, it most likely returns itself. We then\n", "//    take a PropertyPointer from it and get the PropertyPointer\n", "//    to expand the collection for the corresponding property.\n", "//\n", "// 2. The parent pointer of NullPropertyPointer is a NullPointer.\n", "//    When we call createPath, it may return a PropertyOwnerPointer\n", "//    or it may return anything else, like a DOMNodePointer.\n", "//    In the former case we need to do exactly what we did in use\n", "//    case 1.  In the latter case, we simply request that the\n", "//    non-property pointer expand the collection by itself.\n", "if (newParent instanceof PropertyOwnerPointer) {\n", "PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n", "newParent = pop.getPropertyPointer();\n", "}\n", "return newParent.createChild(context, getName(), getIndex());\n", "}\n", "}\n"], "faulty_lines": [7], "cluster": 1}, {"pid": "JxPath", "bid": 3, "method_path": "./dataset/JxPath/3/NullPropertyPointer.java", "method": ["public NodePointer createPath(JXPathContext context, Object value) {\n", "NodePointer newParent = parent.createPath(context);\n", "if (isAttribute()) {\n", "NodePointer pointer = newParent.createAttribute(context, getName());\n", "pointer.setValue(value);\n", "return pointer;\n", "}\n", "else {\n", "if (newParent instanceof PropertyOwnerPointer) {\n", "PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent;\n", "newParent = pop.getPropertyPointer();\n", "}\n", "return newParent.createChild(context, getName(), index, value);\n", "}\n", "}\n"], "faulty_lines": [9], "cluster": 2}, {"pid": "JxPath", "bid": 4, "method_path": "./dataset/JxPath/4/JDOMNodePointer.java", "method": ["public Object getValue() {\n", "if (node instanceof Element) {\n", "return ((Element) node).getTextTrim();\n", "}\n", "if (node instanceof Comment) {\n", "String text = ((Comment) node).getText();\n", "if (text != null) {\n", "text = text.trim();\n", "}\n", "return text;\n", "}\n", "if (node instanceof Text) {\n", "return ((Text) node).getTextTrim();\n", "}\n", "if (node instanceof CDATA) {\n", "return ((CDATA) node).getTextTrim();\n", "}\n", "if (node instanceof ProcessingInstruction) {\n", "String text = ((ProcessingInstruction) node).getData();\n", "if (text != null) {\n", "text = text.trim();\n", "}\n", "return text;\n", "}\n", "return null;\n", "}\n"], "faulty_lines": [3], "cluster": 2}, {"pid": "JxPath", "bid": 4, "method_path": "./dataset/JxPath/4/JDOMNodePointer.java", "method": ["public Object getValue() {\n", "if (node instanceof Element) {\n", "return ((Element) node).getTextTrim();\n", "}\n", "if (node instanceof Comment) {\n", "String text = ((Comment) node).getText();\n", "if (text != null) {\n", "text = text.trim();\n", "}\n", "return text;\n", "}\n", "if (node instanceof Text) {\n", "return ((Text) node).getTextTrim();\n", "}\n", "if (node instanceof CDATA) {\n", "return ((CDATA) node).getTextTrim();\n", "}\n", "if (node instanceof ProcessingInstruction) {\n", "String text = ((ProcessingInstruction) node).getData();\n", "if (text != null) {\n", "text = text.trim();\n", "}\n", "return text;\n", "}\n", "return null;\n", "}\n"], "faulty_lines": [12, 13, 14, 15, 16, 19, 20, 21, 22, 23, 25], "cluster": 2}, {"pid": "JxPath", "bid": 4, "method_path": "./dataset/JxPath/4/JDOMNodePointer.java", "method": ["protected String getLanguage() {\n", "Object n = node;\n", "while (n != null) {\n", "if (n instanceof Element) {\n", "Element e = (Element) n;\n", "String attr =\n", "e.getAttributeValue(\"lang\", Namespace.XML_NAMESPACE);\n", "if (attr != null && !attr.equals(\"\")) {\n", "return attr;\n", "}\n", "}\n", "n = nodeParent(n);\n", "}\n", "return null;\n", "}\n"], "faulty_lines": [2, 6, 7], "cluster": 4}, {"pid": "JxPath", "bid": 5, "method_path": "./dataset/JxPath/5/NodePointer.java", "method": ["private int compareNodePointers(\n", "NodePointer p1,\n", "int depth1,\n", "NodePointer p2,\n", "int depth2)\n", "{\n", "if (depth1 < depth2) {\n", "int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n", "return r == 0 ? -1 : r;\n", "}\n", "if (depth1 > depth2) {\n", "int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n", "return r == 0 ? 1 : r;\n", "}\n", "if (p1 == null && p2 == null) {\n", "return 0;\n", "}\n", "\n", "if (p1 != null && p1.equals(p2)) {\n", "return 0;\n", "}\n", "\n", "if (depth1 == 1) {\n", "throw new JXPathException(\n", "\"Cannot compare pointers that do not belong to the same tree: '\"\n", "+ p1 + \"' and '\" + p2 + \"'\");\n", "}\n", "int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n", "if (r != 0) {\n", "return r;\n", "}\n", "\n", "return p1.parent.compareChildNodePointers(p1, p2);\n", "}\n"], "faulty_lines": [24, 25, 26], "cluster": 8}, {"pid": "JxPath", "bid": 6, "method_path": "./dataset/JxPath/6/CoreOperationCompare.java", "method": ["protected boolean equal(\n", "EvalContext context,\n", "Expression left,\n", "Expression right)\n", "{\n", "Object l = left.compute(context);\n", "Object r = right.compute(context);\n", "\n", "//        System.err.println(\"COMPARING: \" +\n", "//            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n", "//            (r == null ? \"null\" : r.getClass().getName()));\n", "\n", "if (l instanceof InitialContext || l instanceof SelfContext) {\n", "l = ((EvalContext) l).getSingleNodePointer();\n", "}\n", "\n", "if (r instanceof InitialContext || r instanceof SelfContext) {\n", "r = ((EvalContext) r).getSingleNodePointer();\n", "}\n", "\n", "if (l instanceof Collection) {\n", "l = ((Collection) l).iterator();\n", "}\n", "\n", "if (r instanceof Collection) {\n", "r = ((Collection) r).iterator();\n", "}\n", "\n", "if ((l instanceof Iterator) && !(r instanceof Iterator)) {\n", "return contains((Iterator) l, r);\n", "}\n", "if (!(l instanceof Iterator) && (r instanceof Iterator)) {\n", "return contains((Iterator) r, l);\n", "}\n", "if (l instanceof Iterator && r instanceof Iterator) {\n", "return findMatch((Iterator) l, (Iterator) r);\n", "}\n", "return equal(l, r);\n", "}\n"], "faulty_lines": [13, 17], "cluster": 1}, {"pid": "JxPath", "bid": 8, "method_path": "./dataset/JxPath/8/CoreOperationRelationalExpression.java", "method": ["private boolean compute(Object left, Object right) {\n", "left = reduce(left);\n", "right = reduce(right);\n", "\n", "if (left instanceof InitialContext) {\n", "((InitialContext) left).reset();\n", "}\n", "if (right instanceof InitialContext) {\n", "((InitialContext) right).reset();\n", "}\n", "if (left instanceof Iterator && right instanceof Iterator) {\n", "return findMatch((Iterator) left, (Iterator) right);\n", "}\n", "if (left instanceof Iterator) {\n", "return containsMatch((Iterator) left, right);\n", "}\n", "if (right instanceof Iterator) {\n", "return containsMatch((Iterator) right, left);\n", "}\n", "double ld = InfoSetUtil.doubleValue(left);\n", "double rd = InfoSetUtil.doubleValue(right);\n", "return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n", "}\n"], "faulty_lines": [21, 22], "cluster": 2}, {"pid": "JxPath", "bid": 9, "method_path": "./dataset/JxPath/9/CoreOperationCompare.java", "method": ["public abstract class CoreOperationCompare extends CoreOperation {\n", "\n", "public CoreOperationCompare(Expression arg1, Expression arg2) {\n", "\n", "super(new Expression[] { arg1, arg2 });\n", "}\n", "\n", "\n", "protected int getPrecedence() {\n", "return 2;\n", "}\n", "\n", "protected boolean isSymmetric() {\n", "return true;\n", "}\n", "\n", "/**\n", "* Compares two values\n", "*/\n", "protected boolean equal(\n", "EvalContext context,\n", "Expression left,\n", "Expression right)\n", "{\n", "Object l = left.compute(context);\n", "Object r = right.compute(context);\n", "\n", "if (l instanceof InitialContext) {\n", "((EvalContext) l).reset();\n", "}\n", "\n", "if (l instanceof SelfContext) {\n", "l = ((EvalContext) l).getSingleNodePointer();\n", "}\n", "\n", "if (r instanceof InitialContext) {\n", "((EvalContext) r).reset();\n", "}\n", "\n", "if (r instanceof SelfContext) {\n", "r = ((EvalContext) r).getSingleNodePointer();\n", "}\n", "\n", "if (l instanceof Collection) {\n", "l = ((Collection) l).iterator();\n", "}\n", "\n", "if (r instanceof Collection) {\n", "r = ((Collection) r).iterator();\n", "}\n", "\n", "if (l instanceof Iterator && r instanceof Iterator) {\n", "return findMatch((Iterator) l, (Iterator) r);\n", "}\n", "if (l instanceof Iterator) {\n", "return contains((Iterator) l, r);\n", "}\n", "if (r instanceof Iterator) {\n", "return contains((Iterator) r, l);\n", "}\n", "return equal(l, r);\n", "}\n", "\n", "protected boolean contains(Iterator it, Object value) {\n", "while (it.hasNext()) {\n", "Object element = it.next();\n", "if (equal(element, value)) {\n", "return true;\n", "}\n", "}\n", "return false;\n", "}\n", "\n", "protected boolean findMatch(Iterator lit, Iterator rit) {\n", "HashSet left = new HashSet();\n", "while (lit.hasNext()) {\n", "left.add(lit.next());\n", "}\n", "while (rit.hasNext()) {\n", "if (contains(left.iterator(), rit.next())) {\n", "return true;\n", "}\n", "}\n", "return false;\n", "}\n", "\n", "protected boolean equal(Object l, Object r) {\n", "if (l instanceof Pointer && r instanceof Pointer) {\n", "if (l.equals(r)) {\n", "return true;\n", "}\n", "}\n", "if (l instanceof Pointer) {\n", "l = ((Pointer) l).getValue();\n", "}\n", "\n", "if (r instanceof Pointer) {\n", "r = ((Pointer) r).getValue();\n", "}\n", "\n", "if (l == r) {\n", "return true;\n", "}\n", "if (l instanceof Boolean || r instanceof Boolean) {\n", "return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n", "}\n", "//if either side is NaN, no comparison returns true:\n", "if (l instanceof Number || r instanceof Number) {\n", "return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n", "}\n", "if (l instanceof String || r instanceof String) {\n", "return (\n", "InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n", "}\n", "return l != null && l.equals(r);\n", "}\n", "\n", "}\n"], "faulty_lines": [2, 4, 5, 6, 8], "cluster": 3}, {"pid": "JxPath", "bid": 9, "method_path": "./dataset/JxPath/9/CoreOperationCompare.java", "method": ["protected boolean equal(Object l, Object r) {\n", "if (l instanceof Pointer && r instanceof Pointer) {\n", "if (l.equals(r)) {\n", "return true;\n", "}\n", "}\n", "if (l instanceof Pointer) {\n", "l = ((Pointer) l).getValue();\n", "}\n", "\n", "if (r instanceof Pointer) {\n", "r = ((Pointer) r).getValue();\n", "}\n", "\n", "if (l == r) {\n", "return true;\n", "}\n", "if (l instanceof Boolean || r instanceof Boolean) {\n", "return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n", "}\n", "//if either side is NaN, no comparison returns true:\n", "if (l instanceof Number || r instanceof Number) {\n", "return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n", "}\n", "if (l instanceof String || r instanceof String) {\n", "return (\n", "InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n", "}\n", "return l != null && l.equals(r);\n", "}\n"], "faulty_lines": [2, 3, 4, 5, 6], "cluster": 8}, {"pid": "JxPath", "bid": 9, "method_path": "./dataset/JxPath/9/CoreOperationCompare.java", "method": ["protected boolean equal(Object l, Object r) {\n", "if (l instanceof Pointer && r instanceof Pointer) {\n", "if (l.equals(r)) {\n", "return true;\n", "}\n", "}\n", "if (l instanceof Pointer) {\n", "l = ((Pointer) l).getValue();\n", "}\n", "\n", "if (r instanceof Pointer) {\n", "r = ((Pointer) r).getValue();\n", "}\n", "\n", "if (l == r) {\n", "return true;\n", "}\n", "if (l instanceof Boolean || r instanceof Boolean) {\n", "return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r));\n", "}\n", "//if either side is NaN, no comparison returns true:\n", "if (l instanceof Number || r instanceof Number) {\n", "return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r));\n", "}\n", "if (l instanceof String || r instanceof String) {\n", "return (\n", "InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r)));\n", "}\n", "return l != null && l.equals(r);\n", "}\n"], "faulty_lines": [15, 16, 17, 19, 21, 22, 23, 25, 26, 27, 29], "cluster": 8}, {"pid": "JxPath", "bid": 10, "method_path": "./dataset/JxPath/10/CoreOperationRelationalExpression.java", "method": ["public final Object computeValue(EvalContext context) {\n", "return compute(args[0].computeValue(context), args[1].computeValue(context))\n", "? Boolean.TRUE : Boolean.FALSE;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "JxPath", "bid": 11, "method_path": "./dataset/JxPath/11/DOMAttributeIterator.java", "method": ["private Attr getAttribute(Element element, QName name) {\n", "String testPrefix = name.getPrefix();\n", "String testNS = null;\n", "\n", "if (testPrefix != null) {\n", "testNS = parent.getNamespaceURI(testPrefix);\n", "}\n", "\n", "if (testNS != null) {\n", "Attr attr = element.getAttributeNodeNS(testNS, name.getName());\n", "if (attr != null) {\n", "return attr;\n", "}\n", "\n", "// This may mean that the parser does not support NS for\n", "// attributes, example - the version of Crimson bundled\n", "// with JDK 1.4.0\n", "NamedNodeMap nnm = element.getAttributes();\n", "for (int i = 0; i < nnm.getLength(); i++) {\n", "attr = (Attr) nnm.item(i);\n", "if (testAttr(attr, name)) {\n", "return attr;\n", "}\n", "}\n", "return null;\n", "}\n", "return element.getAttributeNode(name.getName());\n", "}\n"], "faulty_lines": [6], "cluster": 8}, {"pid": "JxPath", "bid": 11, "method_path": "./dataset/JxPath/11/JDOMAttributeIterator.java", "method": ["public JDOMAttributeIterator(NodePointer parent, QName name) {\n", "this.parent = parent;\n", "if (parent.getNode() instanceof Element) {\n", "Element element = (Element) parent.getNode();\n", "String prefix = name.getPrefix();\n", "Namespace ns = null;\n", "if (prefix != null) {\n", "if (prefix.equals(\"xml\")) {\n", "ns = Namespace.XML_NAMESPACE;\n", "}\n", "else {\n", "ns = element.getNamespace(prefix);\n", "if (ns == null) {\n", "// TBD: no attributes\n", "attributes = Collections.EMPTY_LIST;\n", "return;\n", "}\n", "}\n", "}\n", "else {\n", "ns = Namespace.NO_NAMESPACE;\n", "}\n", "\n", "String lname = name.getName();\n", "if (!lname.equals(\"*\")) {\n", "attributes = new ArrayList();\n", "if (ns != null) {\n", "Attribute attr = element.getAttribute(lname, ns);\n", "if (attr != null) {\n", "attributes.add(attr);\n", "}\n", "}\n", "}\n", "else {\n", "attributes = new ArrayList();\n", "List allAttributes = element.getAttributes();\n", "for (int i = 0; i < allAttributes.size(); i++) {\n", "Attribute attr = (Attribute) allAttributes.get(i);\n", "if (attr.getNamespace().equals(ns)) {\n", "attributes.add(attr);\n", "}\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [12, 18], "cluster": 1}, {"pid": "JxPath", "bid": 13, "method_path": "./dataset/JxPath/13/NamespaceResolver.java", "method": ["public synchronized String getNamespaceURI(String prefix) {\n", "\n", "/**\n", "* Given a prefix, returns an externally registered namespace URI.\n", "*\n", "* @param prefix The namespace prefix to look up\n", "* @return namespace URI or null if the prefix is undefined.\n", "* @since JXPath 1.3\n", "*/\n", "String uri = (String) namespaceMap.get(prefix);\n", "if (uri == null && pointer != null) {\n", "uri = pointer.getNamespaceURI(prefix);\n", "}\n", "if (uri == null && parent != null) {\n", "return parent.getNamespaceURI(prefix);\n", "}\n", "return uri;\n", "}\n"], "faulty_lines": [2], "cluster": 2}, {"pid": "JxPath", "bid": 13, "method_path": "./dataset/JxPath/13/NamespaceResolver.java", "method": ["public synchronized String getNamespaceURI(String prefix) {\n", "\n", "/**\n", "* Given a prefix, returns an externally registered namespace URI.\n", "*\n", "* @param prefix The namespace prefix to look up\n", "* @return namespace URI or null if the prefix is undefined.\n", "* @since JXPath 1.3\n", "*/\n", "String uri = (String) namespaceMap.get(prefix);\n", "if (uri == null && pointer != null) {\n", "uri = pointer.getNamespaceURI(prefix);\n", "}\n", "if (uri == null && parent != null) {\n", "return parent.getNamespaceURI(prefix);\n", "}\n", "return uri;\n", "}\n"], "faulty_lines": [10, 11, 12, 13, 14, 15, 16, 17], "cluster": 2}, {"pid": "JxPath", "bid": 13, "method_path": "./dataset/JxPath/13/NamespaceResolver.java", "method": ["public synchronized String getPrefix(String namespaceURI) {\n", "\n", "/**\n", "* Get the nearest prefix found that matches an externally-registered namespace.\n", "* @param namespaceURI\n", "* @return String prefix if found.\n", "* @since JXPath 1.3\n", "*/\n", "if (reverseMap == null) {\n", "reverseMap = new HashMap();\n", "NodeIterator ni = pointer.namespaceIterator();\n", "if (ni != null) {\n", "for (int position = 1; ni.setPosition(position); position++) {\n", "NodePointer nsPointer = ni.getNodePointer();\n", "String uri = nsPointer.getNamespaceURI();\n", "String prefix = nsPointer.getName().getName();\n", "if (!\"\".equals(prefix)) {\n", "reverseMap.put(uri, prefix);\n", "}\n", "}\n", "}\n", "Iterator it = namespaceMap.entrySet().iterator();\n", "while (it.hasNext()) {\n", "Map.Entry entry = (Map.Entry) it.next();\n", "reverseMap.put(entry.getValue(), entry.getKey());\n", "}\n", "}\n", "String prefix = (String) reverseMap.get(namespaceURI);\n", "if (prefix == null && parent != null) {\n", "return parent.getPrefix(namespaceURI);\n", "}\n", "return prefix;\n", "}\n"], "faulty_lines": [2], "cluster": 8}, {"pid": "JxPath", "bid": 13, "method_path": "./dataset/JxPath/13/NamespaceResolver.java", "method": ["public synchronized String getPrefix(String namespaceURI) {\n", "\n", "/**\n", "* Get the nearest prefix found that matches an externally-registered namespace.\n", "* @param namespaceURI\n", "* @return String prefix if found.\n", "* @since JXPath 1.3\n", "*/\n", "if (reverseMap == null) {\n", "reverseMap = new HashMap();\n", "NodeIterator ni = pointer.namespaceIterator();\n", "if (ni != null) {\n", "for (int position = 1; ni.setPosition(position); position++) {\n", "NodePointer nsPointer = ni.getNodePointer();\n", "String uri = nsPointer.getNamespaceURI();\n", "String prefix = nsPointer.getName().getName();\n", "if (!\"\".equals(prefix)) {\n", "reverseMap.put(uri, prefix);\n", "}\n", "}\n", "}\n", "Iterator it = namespaceMap.entrySet().iterator();\n", "while (it.hasNext()) {\n", "Map.Entry entry = (Map.Entry) it.next();\n", "reverseMap.put(entry.getValue(), entry.getKey());\n", "}\n", "}\n", "String prefix = (String) reverseMap.get(namespaceURI);\n", "if (prefix == null && parent != null) {\n", "return parent.getPrefix(namespaceURI);\n", "}\n", "return prefix;\n", "}\n"], "faulty_lines": [9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21], "cluster": 8}, {"pid": "JxPath", "bid": 13, "method_path": "./dataset/JxPath/13/NamespaceResolver.java", "method": ["public synchronized String getPrefix(String namespaceURI) {\n", "\n", "/**\n", "* Get the nearest prefix found that matches an externally-registered namespace.\n", "* @param namespaceURI\n", "* @return String prefix if found.\n", "* @since JXPath 1.3\n", "*/\n", "if (reverseMap == null) {\n", "reverseMap = new HashMap();\n", "NodeIterator ni = pointer.namespaceIterator();\n", "if (ni != null) {\n", "for (int position = 1; ni.setPosition(position); position++) {\n", "NodePointer nsPointer = ni.getNodePointer();\n", "String uri = nsPointer.getNamespaceURI();\n", "String prefix = nsPointer.getName().getName();\n", "if (!\"\".equals(prefix)) {\n", "reverseMap.put(uri, prefix);\n", "}\n", "}\n", "}\n", "Iterator it = namespaceMap.entrySet().iterator();\n", "while (it.hasNext()) {\n", "Map.Entry entry = (Map.Entry) it.next();\n", "reverseMap.put(entry.getValue(), entry.getKey());\n", "}\n", "}\n", "String prefix = (String) reverseMap.get(namespaceURI);\n", "if (prefix == null && parent != null) {\n", "return parent.getPrefix(namespaceURI);\n", "}\n", "return prefix;\n", "}\n"], "faulty_lines": [29, 30, 31, 32], "cluster": 8}, {"pid": "JxPath", "bid": 13, "method_path": "./dataset/JxPath/13/DOMNodePointer.java", "method": ["public NodePointer createAttribute(JXPathContext context, QName name) {\n", "if (!(node instanceof Element)) {\n", "return super.createAttribute(context, name);\n", "}\n", "Element element = (Element) node;\n", "String prefix = name.getPrefix();\n", "if (prefix != null) {\n", "String ns = getNamespaceURI(prefix);\n", "if (ns == null) {\n", "throw new JXPathException(\n", "\"Unknown namespace prefix: \" + prefix);\n", "}\n", "element.setAttributeNS(ns, name.toString(), \"\");\n", "}\n", "else {\n", "if (!element.hasAttribute(name.getName())) {\n", "element.setAttribute(name.getName(), \"\");\n", "}\n", "}\n", "NodeIterator it = attributeIterator(name);\n", "it.setPosition(1);\n", "return it.getNodePointer();\n", "}\n"], "faulty_lines": [8], "cluster": 2}, {"pid": "JxPath", "bid": 17, "method_path": "./dataset/JxPath/17/DOMAttributeIterator.java", "method": ["private boolean testAttr(Attr attr) {\n", "String nodePrefix = DOMNodePointer.getPrefix(attr);\n", "String nodeLocalName = DOMNodePointer.getLocalName(attr);\n", "\n", "if (nodePrefix != null && nodePrefix.equals(\"xmlns\")) {\n", "return false;\n", "}\n", "\n", "if (nodePrefix == null && nodeLocalName.equals(\"xmlns\")) {\n", "return false;\n", "}\n", "\n", "String testLocalName = name.getName();\n", "if (testLocalName.equals(\"*\") || testLocalName.equals(nodeLocalName)) {\n", "String testPrefix = name.getPrefix();\n", "\n", "if (equalStrings(testPrefix, nodePrefix)) {\n", "return true;\n", "}\n", "String testNS = null;\n", "if (testPrefix != null) {\n", "testNS = parent.getNamespaceURI(testPrefix);\n", "}\n", "String nodeNS = null;\n", "if (nodePrefix != null) {\n", "nodeNS = parent.getNamespaceURI(nodePrefix);\n", "}\n", "return equalStrings(testNS, nodeNS);\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [17, 20, 21, 22, 24, 25, 26, 27, 28], "cluster": 8}, {"pid": "JxPath", "bid": 17, "method_path": "./dataset/JxPath/17/JDOMAttributeIterator.java", "method": ["public JDOMAttributeIterator(NodePointer parent, QName name) {\n", "this.parent = parent;\n", "if (parent.getNode() instanceof Element) {\n", "Element element = (Element) parent.getNode();\n", "String prefix = name.getPrefix();\n", "Namespace ns = null;\n", "if (prefix != null) {\n", "if (prefix.equals(\"xml\")) {\n", "ns = Namespace.XML_NAMESPACE;\n", "}\n", "else {\n", "String uri = parent.getNamespaceResolver().getNamespaceURI(prefix);\n", "if (uri != null) {\n", "ns = Namespace.getNamespace(prefix, uri);\n", "}\n", "if (ns == null) {\n", "// TBD: no attributes\n", "attributes = Collections.EMPTY_LIST;\n", "return;\n", "}\n", "}\n", "}\n", "else {\n", "ns = Namespace.NO_NAMESPACE;\n", "}\n", "\n", "String lname = name.getName();\n", "if (!lname.equals(\"*\")) {\n", "attributes = new ArrayList();\n", "if (ns != null) {\n", "Attribute attr = element.getAttribute(lname, ns);\n", "if (attr != null) {\n", "attributes.add(attr);\n", "}\n", "}\n", "}\n", "else {\n", "attributes = new ArrayList();\n", "List allAttributes = element.getAttributes();\n", "for (int i = 0; i < allAttributes.size(); i++) {\n", "Attribute attr = (Attribute) allAttributes.get(i);\n", "if (attr.getNamespace().equals(ns)) {\n", "attributes.add(attr);\n", "}\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [30, 34], "cluster": 1}, {"pid": "JxPath", "bid": 17, "method_path": "./dataset/JxPath/17/JDOMAttributeIterator.java", "method": ["public JDOMAttributeIterator(NodePointer parent, QName name) {\n", "this.parent = parent;\n", "if (parent.getNode() instanceof Element) {\n", "Element element = (Element) parent.getNode();\n", "String prefix = name.getPrefix();\n", "Namespace ns = null;\n", "if (prefix != null) {\n", "if (prefix.equals(\"xml\")) {\n", "ns = Namespace.XML_NAMESPACE;\n", "}\n", "else {\n", "String uri = parent.getNamespaceResolver().getNamespaceURI(prefix);\n", "if (uri != null) {\n", "ns = Namespace.getNamespace(prefix, uri);\n", "}\n", "if (ns == null) {\n", "// TBD: no attributes\n", "attributes = Collections.EMPTY_LIST;\n", "return;\n", "}\n", "}\n", "}\n", "else {\n", "ns = Namespace.NO_NAMESPACE;\n", "}\n", "\n", "String lname = name.getName();\n", "if (!lname.equals(\"*\")) {\n", "attributes = new ArrayList();\n", "if (ns != null) {\n", "Attribute attr = element.getAttribute(lname, ns);\n", "if (attr != null) {\n", "attributes.add(attr);\n", "}\n", "}\n", "}\n", "else {\n", "attributes = new ArrayList();\n", "List allAttributes = element.getAttributes();\n", "for (int i = 0; i < allAttributes.size(); i++) {\n", "Attribute attr = (Attribute) allAttributes.get(i);\n", "if (attr.getNamespace().equals(ns)) {\n", "attributes.add(attr);\n", "}\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [42], "cluster": 1}, {"pid": "JxPath", "bid": 18, "method_path": "./dataset/JxPath/18/AttributeContext.java", "method": ["public class AttributeContext extends EvalContext {\n", "\n", "private NodeTest nodeTest;\n", "private boolean setStarted = false;\n", "private NodeIterator iterator;\n", "private NodePointer currentNodePointer;\n", "\n", "/**\n", "* @param parentContext represents the previous step on the path\n", "* @param nodeTest is the name of the attribute we are looking for\n", "*/\n", "public AttributeContext(EvalContext parentContext, NodeTest nodeTest) {\n", "super(parentContext);\n", "this.nodeTest = nodeTest;\n", "}\n", "\n", "public NodePointer getCurrentNodePointer() {\n", "return currentNodePointer;\n", "}\n", "\n", "public void reset() {\n", "setStarted = false;\n", "iterator = null;\n", "super.reset();\n", "}\n", "\n", "public boolean setPosition(int position) {\n", "if (position < getCurrentPosition()) {\n", "reset();\n", "}\n", "\n", "while (getCurrentPosition() < position) {\n", "if (!nextNode()) {\n", "return false;\n", "}\n", "}\n", "return true;\n", "}\n", "\n", "public boolean nextNode() {\n", "super.setPosition(getCurrentPosition() + 1);\n", "if (!setStarted) {\n", "setStarted = true;\n", "if (!(nodeTest instanceof NodeNameTest)) {\n", "return false;\n", "}\n", "QName name = ((NodeNameTest) nodeTest).getNodeName();\n", "iterator =\n", "parentContext.getCurrentNodePointer().attributeIterator(name);\n", "}\n", "if (iterator == null) {\n", "return false;\n", "}\n", "if (!iterator.setPosition(iterator.getPosition() + 1)) {\n", "return false;\n", "}\n", "currentNodePointer = iterator.getNodePointer();\n", "return true;\n", "}\n", "}\n"], "faulty_lines": [2], "cluster": 5}, {"pid": "JxPath", "bid": 18, "method_path": "./dataset/JxPath/18/AttributeContext.java", "method": ["public boolean nextNode() {\n", "super.setPosition(getCurrentPosition() + 1);\n", "if (!setStarted) {\n", "setStarted = true;\n", "if (!(nodeTest instanceof NodeNameTest)) {\n", "return false;\n", "}\n", "QName name = ((NodeNameTest) nodeTest).getNodeName();\n", "iterator =\n", "parentContext.getCurrentNodePointer().attributeIterator(name);\n", "}\n", "if (iterator == null) {\n", "return false;\n", "}\n", "if (!iterator.setPosition(iterator.getPosition() + 1)) {\n", "return false;\n", "}\n", "currentNodePointer = iterator.getNodePointer();\n", "return true;\n", "}\n"], "faulty_lines": [5, 8, 9, 10], "cluster": 2}, {"pid": "JxPath", "bid": 19, "method_path": "./dataset/JxPath/19/JDOMNodePointer.java", "method": ["private int getRelativePositionByQName() {\n", "if (node instanceof Element) {\n", "Object parent = ((Element) node).getParent();\n", "if (!(parent instanceof Element)) {\n", "return 1;\n", "}\n", "\n", "List children = ((Element) parent).getContent();\n", "int count = 0;\n", "String name = ((Element) node).getQualifiedName();\n", "for (int i = 0; i < children.size(); i++) {\n", "Object child = children.get(i);\n", "if ((child instanceof Element)\n", "&& ((Element) child).getQualifiedName().equals(name)) {\n", "count++;\n", "}\n", "if (child == node) {\n", "break;\n", "}\n", "}\n", "return count;\n", "}\n", "return 1;\n", "}\n"], "faulty_lines": [13, 14], "cluster": 2}, {"pid": "JxPath", "bid": 20, "method_path": "./dataset/JxPath/20/CoreOperationRelationalExpression.java", "method": ["private boolean compute(Object left, Object right) {\n", "left = reduce(left);\n", "right = reduce(right);\n", "\n", "if (left instanceof InitialContext) {\n", "((InitialContext) left).reset();\n", "}\n", "if (right instanceof InitialContext) {\n", "((InitialContext) right).reset();\n", "}\n", "if (left instanceof Iterator && right instanceof Iterator) {\n", "return findMatch((Iterator) left, (Iterator) right);\n", "}\n", "if (left instanceof Iterator) {\n", "return containsMatch((Iterator) left, right);\n", "}\n", "if (right instanceof Iterator) {\n", "return containsMatch((Iterator) right, left);\n", "}\n", "double ld = InfoSetUtil.doubleValue(left);\n", "if (Double.isNaN(ld)) {\n", "return false;\n", "}\n", "double rd = InfoSetUtil.doubleValue(right);\n", "if (Double.isNaN(rd)) {\n", "return false;\n", "}\n", "return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n", "}\n"], "faulty_lines": [18], "cluster": 8}, {"pid": "JxPath", "bid": 21, "method_path": "./dataset/JxPath/21/PropertyPointer.java", "method": ["public int getLength() {\n", "return ValueUtils.getLength(getBaseValue());\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "JxPath", "bid": 22, "method_path": "./dataset/JxPath/22/DOMNodePointer.java", "method": ["public static String getNamespaceURI(Node node) {\n", "if (node instanceof Document) {\n", "node = ((Document) node).getDocumentElement();\n", "}\n", "\n", "Element element = (Element) node;\n", "\n", "String uri = element.getNamespaceURI();\n", "if (uri == null) {\n", "String prefix = getPrefix(node);\n", "String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n", "\n", "Node aNode = node;\n", "while (aNode != null) {\n", "if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n", "Attr attr = ((Element) aNode).getAttributeNode(qname);\n", "if (attr != null) {\n", "return attr.getValue();\n", "}\n", "}\n", "aNode = aNode.getParentNode();\n", "}\n", "return null;\n", "}\n", "return uri;\n", "}\n"], "faulty_lines": [18, 23, 25], "cluster": 2}, {"pid": "Time", "bid": 1, "method_path": "./dataset/Time/1/Partial.java", "method": ["public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n", "super();\n", "chronology = DateTimeUtils.getChronology(chronology).withUTC();\n", "iChronology = chronology;\n", "if (types == null) {\n", "throw new IllegalArgumentException(\"Types array must not be null\");\n", "}\n", "if (values == null) {\n", "throw new IllegalArgumentException(\"Values array must not be null\");\n", "}\n", "if (values.length != types.length) {\n", "throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n", "}\n", "if (types.length == 0) {\n", "iTypes = types;\n", "iValues = values;\n", "return;\n", "}\n", "for (int i = 0; i < types.length; i++) {\n", "if (types[i] == null) {\n", "throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n", "}\n", "}\n", "DurationField lastUnitField = null;\n", "for (int i = 0; i < types.length; i++) {\n", "DateTimeFieldType loopType = types[i];\n", "DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n", "if (i > 0) {\n", "int compare = lastUnitField.compareTo(loopUnitField);\n", "if (compare < 0) {\n", "throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n", "types[i - 1].getName() + \" < \" + loopType.getName());\n", "} else if (compare == 0) {\n", "if (types[i - 1].getRangeDurationType() == null) {\n", "if (loopType.getRangeDurationType() == null) {\n", "throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n", "types[i - 1].getName() + \" and \" + loopType.getName());\n", "}\n", "} else {\n", "if (loopType.getRangeDurationType() == null) {\n", "throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n", "types[i - 1].getName() + \" < \" + loopType.getName());\n", "}\n", "DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n", "DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n", "if (lastRangeField.compareTo(loopRangeField) < 0) {\n", "throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n", "types[i - 1].getName() + \" < \" + loopType.getName());\n", "}\n", "if (lastRangeField.compareTo(loopRangeField) == 0) {\n", "throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n", "types[i - 1].getName() + \" and \" + loopType.getName());\n", "}\n", "}\n", "}\n", "}\n", "lastUnitField = loopUnitField;\n", "}\n", "\n", "iTypes = (DateTimeFieldType[]) types.clone();\n", "chronology.validate(this, values);\n", "iValues = (int[]) values.clone();\n", "}\n"], "faulty_lines": [29, 33], "cluster": 3}, {"pid": "Time", "bid": 1, "method_path": "./dataset/Time/1/UnsupportedDurationField.java", "method": ["public int compareTo(DurationField durationField) {\n", "if (durationField.isSupported()) {\n", "return 1;\n", "}\n", "return 0;\n", "}\n"], "faulty_lines": [2, 3, 4], "cluster": 0}, {"pid": "Time", "bid": 2, "method_path": "./dataset/Time/2/Partial.java", "method": ["public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n", "super();\n", "chronology = DateTimeUtils.getChronology(chronology).withUTC();\n", "iChronology = chronology;\n", "if (types == null) {\n", "throw new IllegalArgumentException(\"Types array must not be null\");\n", "}\n", "if (values == null) {\n", "throw new IllegalArgumentException(\"Values array must not be null\");\n", "}\n", "if (values.length != types.length) {\n", "throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n", "}\n", "if (types.length == 0) {\n", "iTypes = types;\n", "iValues = values;\n", "return;\n", "}\n", "for (int i = 0; i < types.length; i++) {\n", "if (types[i] == null) {\n", "throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n", "}\n", "}\n", "DurationField lastUnitField = null;\n", "for (int i = 0; i < types.length; i++) {\n", "DateTimeFieldType loopType = types[i];\n", "DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n", "if (i > 0) {\n", "int compare = lastUnitField.compareTo(loopUnitField);\n", "if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n", "throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n", "types[i - 1].getName() + \" < \" + loopType.getName());\n", "} else if (compare == 0) {\n", "if (types[i - 1].getRangeDurationType() == null) {\n", "if (loopType.getRangeDurationType() == null) {\n", "throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n", "types[i - 1].getName() + \" and \" + loopType.getName());\n", "}\n", "} else {\n", "if (loopType.getRangeDurationType() == null) {\n", "throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n", "types[i - 1].getName() + \" < \" + loopType.getName());\n", "}\n", "DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n", "DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n", "if (lastRangeField.compareTo(loopRangeField) < 0) {\n", "throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n", "types[i - 1].getName() + \" < \" + loopType.getName());\n", "}\n", "if (lastRangeField.compareTo(loopRangeField) == 0) {\n", "throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n", "types[i - 1].getName() + \" and \" + loopType.getName());\n", "}\n", "}\n", "}\n", "}\n", "lastUnitField = loopUnitField;\n", "}\n", "\n", "iTypes = (DateTimeFieldType[]) types.clone();\n", "chronology.validate(this, values);\n", "iValues = (int[]) values.clone();\n", "}\n"], "faulty_lines": [30], "cluster": 3}, {"pid": "Time", "bid": 2, "method_path": "./dataset/Time/2/Partial.java", "method": ["public Partial with(DateTimeFieldType fieldType, int value) {\n", "if (fieldType == null) {\n", "throw new IllegalArgumentException(\"The field type must not be null\");\n", "}\n", "int index = indexOf(fieldType);\n", "if (index == -1) {\n", "DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n", "int[] newValues = new int[newTypes.length];\n", "\n", "// find correct insertion point to keep largest-smallest order\n", "int i = 0;\n", "DurationField unitField = fieldType.getDurationType().getField(iChronology);\n", "if (unitField.isSupported()) {\n", "for (; i < iTypes.length; i++) {\n", "DateTimeFieldType loopType = iTypes[i];\n", "DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n", "if (loopUnitField.isSupported()) {\n", "int compare = unitField.compareTo(loopUnitField);\n", "if (compare > 0) {\n", "break;\n", "} else if (compare == 0) {\n", "DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n", "DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n", "if (rangeField.compareTo(loopRangeField) > 0) {\n", "break;\n", "}\n", "}\n", "}\n", "}\n", "}\n", "System.arraycopy(iTypes, 0, newTypes, 0, i);\n", "System.arraycopy(iValues, 0, newValues, 0, i);\n", "newTypes[i] = fieldType;\n", "newValues[i] = value;\n", "System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n", "System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n", "// use public constructor to ensure full validation\n", "// this isn't overly efficient, but is safe\n", "Partial newPartial = new Partial(newTypes, newValues, iChronology);\n", "iChronology.validate(newPartial, newValues);\n", "return newPartial;\n", "}\n", "if (value == getValue(index)) {\n", "return this;\n", "}\n", "int[] newValues = getValues();\n", "newValues = getField(index).set(this, index, newValues, value);\n", "return new Partial(this, newValues);\n", "}\n"], "faulty_lines": [22], "cluster": 3}, {"pid": "Time", "bid": 2, "method_path": "./dataset/Time/2/UnsupportedDurationField.java", "method": ["public int compareTo(DurationField durationField) {\n", "return 0;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Time", "bid": 3, "method_path": "./dataset/Time/3/MutableDateTime.java", "method": ["public void add(DurationFieldType type, int amount) {\n", "if (type == null) {\n", "throw new IllegalArgumentException(\"Field must not be null\");\n", "}\n", "setMillis(type.getField(getChronology()).add(getMillis(), amount));\n", "}\n"], "faulty_lines": [5, 6], "cluster": 0}, {"pid": "Time", "bid": 3, "method_path": "./dataset/Time/3/MutableDateTime.java", "method": ["public void addYears(final int years) {\n", "setMillis(getChronology().years().add(getMillis(), years));\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Time", "bid": 3, "method_path": "./dataset/Time/3/MutableDateTime.java", "method": ["public void addWeekyears(final int weekyears) {\n", "setMillis(getChronology().weekyears().add(getMillis(), weekyears));\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Time", "bid": 3, "method_path": "./dataset/Time/3/MutableDateTime.java", "method": ["public void addMonths(final int months) {\n", "setMillis(getChronology().months().add(getMillis(), months));\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Time", "bid": 3, "method_path": "./dataset/Time/3/MutableDateTime.java", "method": ["public void addWeeks(final int weeks) {\n", "setMillis(getChronology().weeks().add(getMillis(), weeks));\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Time", "bid": 3, "method_path": "./dataset/Time/3/MutableDateTime.java", "method": ["public void addDays(final int days) {\n", "setMillis(getChronology().days().add(getMillis(), days));\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Time", "bid": 3, "method_path": "./dataset/Time/3/MutableDateTime.java", "method": ["public void addHours(final int hours) {\n", "setMillis(getChronology().hours().add(getMillis(), hours));\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Time", "bid": 3, "method_path": "./dataset/Time/3/MutableDateTime.java", "method": ["public void addMinutes(final int minutes) {\n", "setMillis(getChronology().minutes().add(getMillis(), minutes));\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Time", "bid": 3, "method_path": "./dataset/Time/3/MutableDateTime.java", "method": ["public void addSeconds(final int seconds) {\n", "setMillis(getChronology().seconds().add(getMillis(), seconds));\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Time", "bid": 3, "method_path": "./dataset/Time/3/MutableDateTime.java", "method": ["public void addMillis(final int millis) {\n", "setMillis(getChronology().millis().add(getMillis(), millis));\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Time", "bid": 4, "method_path": "./dataset/Time/4/Partial.java", "method": ["public Partial with(DateTimeFieldType fieldType, int value) {\n", "if (fieldType == null) {\n", "throw new IllegalArgumentException(\"The field type must not be null\");\n", "}\n", "int index = indexOf(fieldType);\n", "if (index == -1) {\n", "DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n", "int[] newValues = new int[newTypes.length];\n", "\n", "// find correct insertion point to keep largest-smallest order\n", "int i = 0;\n", "DurationField unitField = fieldType.getDurationType().getField(iChronology);\n", "if (unitField.isSupported()) {\n", "for (; i < iTypes.length; i++) {\n", "DateTimeFieldType loopType = iTypes[i];\n", "DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n", "if (loopUnitField.isSupported()) {\n", "int compare = unitField.compareTo(loopUnitField);\n", "if (compare > 0) {\n", "break;\n", "} else if (compare == 0) {\n", "DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n", "DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n", "if (rangeField.compareTo(loopRangeField) > 0) {\n", "break;\n", "}\n", "}\n", "}\n", "}\n", "}\n", "System.arraycopy(iTypes, 0, newTypes, 0, i);\n", "System.arraycopy(iValues, 0, newValues, 0, i);\n", "newTypes[i] = fieldType;\n", "newValues[i] = value;\n", "System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n", "System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n", "// use public constructor to ensure full validation\n", "// this isn't overly efficient, but is safe\n", "Partial newPartial = new Partial(iChronology, newTypes, newValues);\n", "iChronology.validate(newPartial, newValues);\n", "return newPartial;\n", "}\n", "if (value == getValue(index)) {\n", "return this;\n", "}\n", "int[] newValues = getValues();\n", "newValues = getField(index).set(this, index, newValues, value);\n", "return new Partial(this, newValues);\n", "}\n"], "faulty_lines": [39], "cluster": 3}, {"pid": "Time", "bid": 5, "method_path": "./dataset/Time/5/Period.java", "method": ["public Period normalizedStandard(PeriodType type) {\n", "type = DateTimeUtils.getPeriodType(type);\n", "long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n", "millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n", "millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n", "millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n", "millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n", "millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n", "Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n", "int years = getYears();\n", "int months = getMonths();\n", "if (years != 0 || months != 0) {\n", "years = FieldUtils.safeAdd(years, months / 12);\n", "months = months % 12;\n", "if (years != 0) {\n", "result = result.withYears(years);\n", "}\n", "if (months != 0) {\n", "result = result.withMonths(months);\n", "}\n", "}\n", "return result;\n", "}\n"], "faulty_lines": [13, 14, 15, 16, 18, 19], "cluster": 8}, {"pid": "Time", "bid": 6, "method_path": "./dataset/Time/6/GJChronology.java", "method": ["public static synchronized GJChronology getInstance(\n", "DateTimeZone zone,\n", "ReadableInstant gregorianCutover,\n", "int minDaysInFirstWeek) {\n", "\n", "zone = DateTimeUtils.getZone(zone);\n", "Instant cutoverInstant;\n", "if (gregorianCutover == null) {\n", "cutoverInstant = DEFAULT_CUTOVER;\n", "} else {\n", "cutoverInstant = gregorianCutover.toInstant();\n", "}\n", "\n", "GJChronology chrono;\n", "synchronized (cCache) {\n", "ArrayList<GJChronology> chronos = cCache.get(zone);\n", "if (chronos == null) {\n", "chronos = new ArrayList<GJChronology>(2);\n", "cCache.put(zone, chronos);\n", "} else {\n", "for (int i = chronos.size(); --i >= 0;) {\n", "chrono = chronos.get(i);\n", "if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n", "cutoverInstant.equals(chrono.getGregorianCutover())) {\n", "\n", "return chrono;\n", "}\n", "}\n", "}\n", "if (zone == DateTimeZone.UTC) {\n", "chrono = new GJChronology\n", "(JulianChronology.getInstance(zone, minDaysInFirstWeek),\n", "GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n", "cutoverInstant);\n", "} else {\n", "chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n", "chrono = new GJChronology\n", "(ZonedChronology.getInstance(chrono, zone),\n", "chrono.iJulianChronology,\n", "chrono.iGregorianChronology,\n", "chrono.iCutoverInstant);\n", "}\n", "chronos.add(chrono);\n", "}\n", "return chrono;\n", "}\n"], "faulty_lines": [12], "cluster": 5}, {"pid": "Time", "bid": 6, "method_path": "./dataset/Time/6/GJChronology.java", "method": ["public long add(long instant, int value) {\n", "if (instant >= iCutover) {\n", "instant = iGregorianField.add(instant, value);\n", "if (instant < iCutover) {\n", "// Only adjust if gap fully crossed.\n", "if (instant + iGapDuration < iCutover) {\n", "instant = gregorianToJulian(instant);\n", "}\n", "}\n", "} else {\n", "instant = iJulianField.add(instant, value);\n", "if (instant >= iCutover) {\n", "// Only adjust if gap fully crossed.\n", "if (instant - iGapDuration >= iCutover) {\n", "// no special handling for year zero as cutover always after year zero\n", "instant = julianToGregorian(instant);\n", "}\n", "}\n", "}\n", "return instant;\n", "}\n"], "faulty_lines": [7], "cluster": 2}, {"pid": "Time", "bid": 6, "method_path": "./dataset/Time/6/GJChronology.java", "method": ["public long add(long instant, long value) {\n", "if (instant >= iCutover) {\n", "instant = iGregorianField.add(instant, value);\n", "if (instant < iCutover) {\n", "// Only adjust if gap fully crossed.\n", "if (instant + iGapDuration < iCutover) {\n", "instant = gregorianToJulian(instant);\n", "}\n", "}\n", "} else {\n", "instant = iJulianField.add(instant, value);\n", "if (instant >= iCutover) {\n", "// Only adjust if gap fully crossed.\n", "if (instant - iGapDuration >= iCutover) {\n", "// no special handling for year zero as cutover always after year zero\n", "instant = julianToGregorian(instant);\n", "}\n", "}\n", "}\n", "return instant;\n", "}\n"], "faulty_lines": [7], "cluster": 2}, {"pid": "Time", "bid": 7, "method_path": "./dataset/Time/7/DateTimeFormatter.java", "method": ["public int parseInto(ReadWritableInstant instant, String text, int position) {\n", "DateTimeParser parser = requireParser();\n", "if (instant == null) {\n", "throw new IllegalArgumentException(\"Instant must not be null\");\n", "}\n", "\n", "long instantMillis = instant.getMillis();\n", "Chronology chrono = instant.getChronology();\n", "long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n", "chrono = selectChronology(chrono);\n", "int defaultYear = chrono.year().get(instantLocal);\n", "\n", "DateTimeParserBucket bucket = new DateTimeParserBucket(\n", "instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n", "int newPos = parser.parseInto(bucket, text, position);\n", "instant.setMillis(bucket.computeMillis(false, text));\n", "if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n", "int parsedOffset = bucket.getOffsetInteger();\n", "DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n", "chrono = chrono.withZone(parsedZone);\n", "} else if (bucket.getZone() != null) {\n", "chrono = chrono.withZone(bucket.getZone());\n", "}\n", "instant.setChronology(chrono);\n", "if (iZone != null) {\n", "instant.setZone(iZone);\n", "}\n", "return newPos;\n", "}\n"], "faulty_lines": [9, 11], "cluster": 1}, {"pid": "Time", "bid": 8, "method_path": "./dataset/Time/8/DateTimeZone.java", "method": ["public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n", "if (hoursOffset == 0 && minutesOffset == 0) {\n", "return DateTimeZone.UTC;\n", "}\n", "if (hoursOffset < -23 || hoursOffset > 23) {\n", "throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n", "}\n", "if (minutesOffset < 0 || minutesOffset > 59) {\n", "throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n", "}\n", "int offset = 0;\n", "try {\n", "int hoursInMinutes = hoursOffset * 60;\n", "if (hoursInMinutes < 0) {\n", "minutesOffset = hoursInMinutes - minutesOffset;\n", "} else {\n", "minutesOffset = hoursInMinutes + minutesOffset;\n", "}\n", "offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n", "} catch (ArithmeticException ex) {\n", "throw new IllegalArgumentException(\"Offset is too large\");\n", "}\n", "return forOffsetMillis(offset);\n", "}\n"], "faulty_lines": [8, 11, 15], "cluster": 8}, {"pid": "Time", "bid": 9, "method_path": "./dataset/Time/9/DateTimeZone.java", "method": ["public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\n", "if (hoursOffset == 0 && minutesOffset == 0) {\n", "return DateTimeZone.UTC;\n", "}\n", "if (minutesOffset < 0 || minutesOffset > 59) {\n", "throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n", "}\n", "int offset = 0;\n", "try {\n", "int hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\n", "if (hoursInMinutes < 0) {\n", "minutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n", "} else {\n", "minutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n", "}\n", "offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n", "} catch (ArithmeticException ex) {\n", "throw new IllegalArgumentException(\"Offset is too large\");\n", "}\n", "return forOffsetMillis(offset);\n", "}\n"], "faulty_lines": [5, 10, 12, 14], "cluster": 8}, {"pid": "Time", "bid": 9, "method_path": "./dataset/Time/9/DateTimeZone.java", "method": ["public static DateTimeZone forOffsetMillis(int millisOffset) {\n", "String id = printOffset(millisOffset);\n", "return fixedOffsetZone(id, millisOffset);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Time", "bid": 10, "method_path": "./dataset/Time/10/BaseSingleFieldPeriod.java", "method": ["protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\n", "if (start == null || end == null) {\n", "throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n", "}\n", "if (start.size() != end.size()) {\n", "throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n", "}\n", "for (int i = 0, isize = start.size(); i < isize; i++) {\n", "if (start.getFieldType(i) != end.getFieldType(i)) {\n", "throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n", "}\n", "}\n", "if (DateTimeUtils.isContiguous(start) == false) {\n", "throw new IllegalArgumentException(\"ReadablePartial objects must be contiguous\");\n", "}\n", "Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\n", "int[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\n", "return values[0];\n", "}\n"], "faulty_lines": [17], "cluster": 8}, {"pid": "Time", "bid": 11, "method_path": "./dataset/Time/11/ZoneInfoCompiler.java", "method": ["public class ZoneInfoCompiler {\n", "static DateTimeOfYear cStartOfYear;\n", "\n", "static Chronology cLenientISO;\n", "\n", "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n", "static {\n", "cVerbose.set(Boolean.FALSE);\n", "}\n", "\n", "/**\n", "* Gets a flag indicating that verbose logging is required.\n", "* @return true to log verbosely\n", "*/\n", "public static boolean verbose() {\n", "return cVerbose.get();\n", "}\n", "\n", "//-----------------------------------------------------------------------\n", "/**\n", "* Launches the ZoneInfoCompiler tool.\n", "*\n", "* <pre>\n", "* Usage: java org.joda.time.tz.ZoneInfoCompiler &lt;options&gt; &lt;source files&gt;\n", "* where possible options include:\n", "*   -src &lt;directory&gt;    Specify where to read source files\n", "*   -dst &lt;directory&gt;    Specify where to write generated files\n", "*   -verbose            Output verbosely (default false)\n", "* </pre>\n", "*/\n", "public static void main(String[] args) throws Exception {\n", "if (args.length == 0) {\n", "printUsage();\n", "return;\n", "}\n", "\n", "File inputDir = null;\n", "File outputDir = null;\n", "boolean verbose = false;\n", "\n", "int i;\n", "for (i=0; i<args.length; i++) {\n", "try {\n", "if (\"-src\".equals(args[i])) {\n", "inputDir = new File(args[++i]);\n", "} else if (\"-dst\".equals(args[i])) {\n", "outputDir = new File(args[++i]);\n", "} else if (\"-verbose\".equals(args[i])) {\n", "verbose = true;\n", "} else if (\"-?\".equals(args[i])) {\n", "printUsage();\n", "return;\n", "} else {\n", "break;\n", "}\n", "} catch (IndexOutOfBoundsException e) {\n", "printUsage();\n", "return;\n", "}\n", "}\n", "\n", "if (i >= args.length) {\n", "printUsage();\n", "return;\n", "}\n", "\n", "File[] sources = new File[args.length - i];\n", "for (int j=0; i<args.length; i++,j++) {\n", "sources[j] = inputDir == null ? new File(args[i]) : new File(inputDir, args[i]);\n", "}\n", "\n", "cVerbose.set(verbose);\n", "ZoneInfoCompiler zic = new ZoneInfoCompiler();\n", "zic.compile(outputDir, sources);\n", "}\n", "\n", "private static void printUsage() {\n", "System.out.println(\"Usage: java org.joda.time.tz.ZoneInfoCompiler <options> <source files>\");\n", "System.out.println(\"where possible options include:\");\n", "System.out.println(\"  -src <directory>    Specify where to read source files\");\n", "System.out.println(\"  -dst <directory>    Specify where to write generated files\");\n", "System.out.println(\"  -verbose            Output verbosely (default false)\");\n", "}\n", "\n", "static DateTimeOfYear getStartOfYear() {\n", "if (cStartOfYear == null) {\n", "cStartOfYear = new DateTimeOfYear();\n", "}\n", "return cStartOfYear;\n", "}\n", "\n", "static Chronology getLenientISOChronology() {\n", "if (cLenientISO == null) {\n", "cLenientISO = LenientChronology.getInstance(ISOChronology.getInstanceUTC());\n", "}\n", "return cLenientISO;\n", "}\n", "\n", "/**\n", "* @param zimap maps string ids to DateTimeZone objects.\n", "*/\n", "static void writeZoneInfoMap(DataOutputStream dout, Map<String, DateTimeZone> zimap) throws IOException {\n", "// Build the string pool.\n", "Map<String, Short> idToIndex = new HashMap<String, Short>(zimap.size());\n", "TreeMap<Short, String> indexToId = new TreeMap<Short, String>();\n", "\n", "short count = 0;\n", "for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n", "String id = (String)entry.getKey();\n", "if (!idToIndex.containsKey(id)) {\n", "Short index = Short.valueOf(count);\n", "idToIndex.put(id, index);\n", "indexToId.put(index, id);\n", "if (++count == 0) {\n", "throw new InternalError(\"Too many time zone ids\");\n", "}\n", "}\n", "id = ((DateTimeZone)entry.getValue()).getID();\n", "if (!idToIndex.containsKey(id)) {\n", "Short index = Short.valueOf(count);\n", "idToIndex.put(id, index);\n", "indexToId.put(index, id);\n", "if (++count == 0) {\n", "throw new InternalError(\"Too many time zone ids\");\n", "}\n", "}\n", "}\n", "\n", "// Write the string pool, ordered by index.\n", "dout.writeShort(indexToId.size());\n", "for (String id : indexToId.values()) {\n", "dout.writeUTF(id);\n", "}\n", "\n", "// Write the mappings.\n", "dout.writeShort(zimap.size());\n", "for (Entry<String, DateTimeZone> entry : zimap.entrySet()) {\n", "String id = entry.getKey();\n", "dout.writeShort(idToIndex.get(id).shortValue());\n", "id = entry.getValue().getID();\n", "dout.writeShort(idToIndex.get(id).shortValue());\n", "}\n", "}\n", "\n", "static int parseYear(String str, int def) {\n", "str = str.toLowerCase();\n", "if (str.equals(\"minimum\") || str.equals(\"min\")) {\n", "return Integer.MIN_VALUE;\n", "} else if (str.equals(\"maximum\") || str.equals(\"max\")) {\n", "return Integer.MAX_VALUE;\n", "} else if (str.equals(\"only\")) {\n", "return def;\n", "}\n", "return Integer.parseInt(str);\n", "}\n", "\n", "static int parseMonth(String str) {\n", "DateTimeField field = ISOChronology.getInstanceUTC().monthOfYear();\n", "return field.get(field.set(0, str, Locale.ENGLISH));\n", "}\n", "\n", "static int parseDayOfWeek(String str) {\n", "DateTimeField field = ISOChronology.getInstanceUTC().dayOfWeek();\n", "return field.get(field.set(0, str, Locale.ENGLISH));\n", "}\n", "\n", "static String parseOptional(String str) {\n", "return (str.equals(\"-\")) ? null : str;\n", "}\n", "\n", "static int parseTime(String str) {\n", "DateTimeFormatter p = ISODateTimeFormat.hourMinuteSecondFraction();\n", "MutableDateTime mdt = new MutableDateTime(0, getLenientISOChronology());\n", "int pos = 0;\n", "if (str.startsWith(\"-\")) {\n", "pos = 1;\n", "}\n", "int newPos = p.parseInto(mdt, str, pos);\n", "if (newPos == ~pos) {\n", "throw new IllegalArgumentException(str);\n", "}\n", "int millis = (int)mdt.getMillis();\n", "if (pos == 1) {\n", "millis = -millis;\n", "}\n", "return millis;\n", "}\n", "\n", "static char parseZoneChar(char c) {\n", "switch (c) {\n", "case 's': case 'S':\n", "// Standard time\n", "return 's';\n", "case 'u': case 'U': case 'g': case 'G': case 'z': case 'Z':\n", "// UTC\n", "return 'u';\n", "case 'w': case 'W': default:\n", "// Wall time\n", "return 'w';\n", "}\n", "}\n", "\n", "/**\n", "* @return false if error.\n", "*/\n", "static boolean test(String id, DateTimeZone tz) {\n", "if (!id.equals(tz.getID())) {\n", "return true;\n", "}\n", "\n", "// Test to ensure that reported transitions are not duplicated.\n", "\n", "long millis = ISOChronology.getInstanceUTC().year().set(0, 1850);\n", "long end = ISOChronology.getInstanceUTC().year().set(0, 2050);\n", "\n", "int offset = tz.getOffset(millis);\n", "String key = tz.getNameKey(millis);\n", "\n", "List<Long> transitions = new ArrayList<Long>();\n", "\n", "while (true) {\n", "long next = tz.nextTransition(millis);\n", "if (next == millis || next > end) {\n", "break;\n", "}\n", "\n", "millis = next;\n", "\n", "int nextOffset = tz.getOffset(millis);\n", "String nextKey = tz.getNameKey(millis);\n", "\n", "if (offset == nextOffset\n", "&& key.equals(nextKey)) {\n", "System.out.println(\"*d* Error in \" + tz.getID() + \" \"\n", "+ new DateTime(millis,\n", "ISOChronology.getInstanceUTC()));\n", "return false;\n", "}\n", "\n", "if (nextKey == null || (nextKey.length() < 3 && !\"??\".equals(nextKey))) {\n", "System.out.println(\"*s* Error in \" + tz.getID() + \" \"\n", "+ new DateTime(millis,\n", "ISOChronology.getInstanceUTC())\n", "+ \", nameKey=\" + nextKey);\n", "return false;\n", "}\n", "\n", "transitions.add(Long.valueOf(millis));\n", "\n", "offset = nextOffset;\n", "key = nextKey;\n", "}\n", "\n", "// Now verify that reverse transitions match up.\n", "\n", "millis = ISOChronology.getInstanceUTC().year().set(0, 2050);\n", "end = ISOChronology.getInstanceUTC().year().set(0, 1850);\n", "\n", "for (int i=transitions.size(); --i>= 0; ) {\n", "long prev = tz.previousTransition(millis);\n", "if (prev == millis || prev < end) {\n", "break;\n", "}\n", "\n", "millis = prev;\n", "\n", "long trans = transitions.get(i).longValue();\n", "\n", "if (trans - 1 != millis) {\n", "System.out.println(\"*r* Error in \" + tz.getID() + \" \"\n", "+ new DateTime(millis,\n", "ISOChronology.getInstanceUTC()) + \" != \"\n", "+ new DateTime(trans - 1,\n", "ISOChronology.getInstanceUTC()));\n", "\n", "return false;\n", "}\n", "}\n", "\n", "return true;\n", "}\n", "\n", "// Maps names to RuleSets.\n", "private Map<String, RuleSet> iRuleSets;\n", "\n", "// List of Zone objects.\n", "private List<Zone> iZones;\n", "\n", "// List String pairs to link.\n", "private List<String> iLinks;\n", "\n", "public ZoneInfoCompiler() {\n", "iRuleSets = new HashMap<String, RuleSet>();\n", "iZones = new ArrayList<Zone>();\n", "iLinks = new ArrayList<String>();\n", "}\n", "\n", "/**\n", "* Returns a map of ids to DateTimeZones.\n", "*\n", "* @param outputDir optional directory to write compiled data files to\n", "* @param sources optional list of source files to parse\n", "*/\n", "public Map<String, DateTimeZone> compile(File outputDir, File[] sources) throws IOException {\n", "if (sources != null) {\n", "for (int i=0; i<sources.length; i++) {\n", "BufferedReader in = new BufferedReader(new FileReader(sources[i]));\n", "parseDataFile(in);\n", "in.close();\n", "}\n", "}\n", "\n", "if (outputDir != null) {\n", "if (!outputDir.exists()) {\n", "if (!outputDir.mkdirs()) {\n", "throw new IOException(\"Destination directory doesn't exist and cannot be created: \" + outputDir);\n", "}\n", "}\n", "if (!outputDir.isDirectory()) {\n", "throw new IOException(\"Destination is not a directory: \" + outputDir);\n", "}\n", "}\n", "\n", "Map<String, DateTimeZone> map = new TreeMap<String, DateTimeZone>();\n", "\n", "System.out.println(\"Writing zoneinfo files\");\n", "for (int i=0; i<iZones.size(); i++) {\n", "Zone zone = iZones.get(i);\n", "DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n", "zone.addToBuilder(builder, iRuleSets);\n", "final DateTimeZone original = builder.toDateTimeZone(zone.iName, true);\n", "DateTimeZone tz = original;\n", "if (test(tz.getID(), tz)) {\n", "map.put(tz.getID(), tz);\n", "if (outputDir != null) {\n", "if (ZoneInfoCompiler.verbose()) {\n", "System.out.println(\"Writing \" + tz.getID());\n", "}\n", "File file = new File(outputDir, tz.getID());\n", "if (!file.getParentFile().exists()) {\n", "file.getParentFile().mkdirs();\n", "}\n", "OutputStream out = new FileOutputStream(file);\n", "try {\n", "builder.writeTo(zone.iName, out);\n", "} finally {\n", "out.close();\n", "}\n", "\n", "// Test if it can be read back.\n", "InputStream in = new FileInputStream(file);\n", "DateTimeZone tz2 = DateTimeZoneBuilder.readFrom(in, tz.getID());\n", "in.close();\n", "\n", "if (!original.equals(tz2)) {\n", "System.out.println(\"*e* Error in \" + tz.getID() +\n", "\": Didn't read properly from file\");\n", "}\n", "}\n", "}\n", "}\n", "\n", "for (int pass=0; pass<2; pass++) {\n", "for (int i=0; i<iLinks.size(); i += 2) {\n", "String id = iLinks.get(i);\n", "String alias = iLinks.get(i + 1);\n", "DateTimeZone tz = map.get(id);\n", "if (tz == null) {\n", "if (pass > 0) {\n", "System.out.println(\"Cannot find time zone '\" + id +\n", "\"' to link alias '\" + alias + \"' to\");\n", "}\n", "} else {\n", "map.put(alias, tz);\n", "}\n", "}\n", "}\n", "\n", "if (outputDir != null) {\n", "System.out.println(\"Writing ZoneInfoMap\");\n", "File file = new File(outputDir, \"ZoneInfoMap\");\n", "if (!file.getParentFile().exists()) {\n", "file.getParentFile().mkdirs();\n", "}\n", "\n", "OutputStream out = new FileOutputStream(file);\n", "DataOutputStream dout = new DataOutputStream(out);\n", "try {\n", "// Sort and filter out any duplicates that match case.\n", "Map<String, DateTimeZone> zimap = new TreeMap<String, DateTimeZone>(String.CASE_INSENSITIVE_ORDER);\n", "zimap.putAll(map);\n", "writeZoneInfoMap(dout, zimap);\n", "} finally {\n", "dout.close();\n", "}\n", "}\n", "\n", "return map;\n", "}\n", "\n", "public void parseDataFile(BufferedReader in) throws IOException {\n", "Zone zone = null;\n", "String line;\n", "while ((line = in.readLine()) != null) {\n", "String trimmed = line.trim();\n", "if (trimmed.length() == 0 || trimmed.charAt(0) == '#') {\n", "continue;\n", "}\n", "\n", "int index = line.indexOf('#');\n", "if (index >= 0) {\n", "line = line.substring(0, index);\n", "}\n", "\n", "//System.out.println(line);\n", "\n", "StringTokenizer st = new StringTokenizer(line, \" \\t\");\n", "\n", "if (Character.isWhitespace(line.charAt(0)) && st.hasMoreTokens()) {\n", "if (zone != null) {\n", "// Zone continuation\n", "zone.chain(st);\n", "}\n", "continue;\n", "} else {\n", "if (zone != null) {\n", "iZones.add(zone);\n", "}\n", "zone = null;\n", "}\n", "\n", "if (st.hasMoreTokens()) {\n", "String token = st.nextToken();\n", "if (token.equalsIgnoreCase(\"Rule\")) {\n", "Rule r = new Rule(st);\n", "RuleSet rs = iRuleSets.get(r.iName);\n", "if (rs == null) {\n", "rs = new RuleSet(r);\n", "iRuleSets.put(r.iName, rs);\n", "} else {\n", "rs.addRule(r);\n", "}\n", "} else if (token.equalsIgnoreCase(\"Zone\")) {\n", "zone = new Zone(st);\n", "} else if (token.equalsIgnoreCase(\"Link\")) {\n", "iLinks.add(st.nextToken());\n", "iLinks.add(st.nextToken());\n", "} else {\n", "System.out.println(\"Unknown line: \" + line);\n", "}\n", "}\n", "}\n", "\n", "if (zone != null) {\n", "iZones.add(zone);\n", "}\n", "}\n", "\n", "static class DateTimeOfYear {\n", "public final int iMonthOfYear;\n", "public final int iDayOfMonth;\n", "public final int iDayOfWeek;\n", "public final boolean iAdvanceDayOfWeek;\n", "public final int iMillisOfDay;\n", "public final char iZoneChar;\n", "\n", "DateTimeOfYear() {\n", "iMonthOfYear = 1;\n", "iDayOfMonth = 1;\n", "iDayOfWeek = 0;\n", "iAdvanceDayOfWeek = false;\n", "iMillisOfDay = 0;\n", "iZoneChar = 'w';\n", "}\n", "\n", "DateTimeOfYear(StringTokenizer st) {\n", "int month = 1;\n", "int day = 1;\n", "int dayOfWeek = 0;\n", "int millis = 0;\n", "boolean advance = false;\n", "char zoneChar = 'w';\n", "\n", "if (st.hasMoreTokens()) {\n", "month = parseMonth(st.nextToken());\n", "\n", "if (st.hasMoreTokens()) {\n", "String str = st.nextToken();\n", "if (str.startsWith(\"last\")) {\n", "day = -1;\n", "dayOfWeek = parseDayOfWeek(str.substring(4));\n", "advance = false;\n", "} else {\n", "try {\n", "day = Integer.parseInt(str);\n", "dayOfWeek = 0;\n", "advance = false;\n", "} catch (NumberFormatException e) {\n", "int index = str.indexOf(\">=\");\n", "if (index > 0) {\n", "day = Integer.parseInt(str.substring(index + 2));\n", "dayOfWeek = parseDayOfWeek(str.substring(0, index));\n", "advance = true;\n", "} else {\n", "index = str.indexOf(\"<=\");\n", "if (index > 0) {\n", "day = Integer.parseInt(str.substring(index + 2));\n", "dayOfWeek = parseDayOfWeek(str.substring(0, index));\n", "advance = false;\n", "} else {\n", "throw new IllegalArgumentException(str);\n", "}\n", "}\n", "}\n", "}\n", "\n", "if (st.hasMoreTokens()) {\n", "str = st.nextToken();\n", "zoneChar = parseZoneChar(str.charAt(str.length() - 1));\n", "if (str.equals(\"24:00\")) {\n", "LocalDate date = (day == -1 ?\n", "new LocalDate(2001, month, 1).plusMonths(1) :\n", "new LocalDate(2001, month, day).plusDays(1));\n", "advance = (day != -1);\n", "month = date.getMonthOfYear();\n", "day = date.getDayOfMonth();\n", "dayOfWeek = ((dayOfWeek - 1 + 1) % 7) + 1;\n", "} else {\n", "millis = parseTime(str);\n", "}\n", "}\n", "}\n", "}\n", "\n", "iMonthOfYear = month;\n", "iDayOfMonth = day;\n", "iDayOfWeek = dayOfWeek;\n", "iAdvanceDayOfWeek = advance;\n", "iMillisOfDay = millis;\n", "iZoneChar = zoneChar;\n", "}\n", "\n", "/**\n", "* Adds a recurring savings rule to the builder.\n", "*/\n", "public void addRecurring(DateTimeZoneBuilder builder, String nameKey,\n", "int saveMillis, int fromYear, int toYear)\n", "{\n", "builder.addRecurringSavings(nameKey, saveMillis,\n", "fromYear, toYear,\n", "iZoneChar,\n", "iMonthOfYear,\n", "iDayOfMonth,\n", "iDayOfWeek,\n", "iAdvanceDayOfWeek,\n", "iMillisOfDay);\n", "}\n", "\n", "/**\n", "* Adds a cutover to the builder.\n", "*/\n", "public void addCutover(DateTimeZoneBuilder builder, int year) {\n", "builder.addCutover(year,\n", "iZoneChar,\n", "iMonthOfYear,\n", "iDayOfMonth,\n", "iDayOfWeek,\n", "iAdvanceDayOfWeek,\n", "iMillisOfDay);\n", "}\n", "\n", "public String toString() {\n", "return\n", "\"MonthOfYear: \" + iMonthOfYear + \"\\n\" +\n", "\"DayOfMonth: \" + iDayOfMonth + \"\\n\" +\n", "\"DayOfWeek: \" + iDayOfWeek + \"\\n\" +\n", "\"AdvanceDayOfWeek: \" + iAdvanceDayOfWeek + \"\\n\" +\n", "\"MillisOfDay: \" + iMillisOfDay + \"\\n\" +\n", "\"ZoneChar: \" + iZoneChar + \"\\n\";\n", "}\n", "}\n", "\n", "private static class Rule {\n", "public final String iName;\n", "public final int iFromYear;\n", "public final int iToYear;\n", "public final String iType;\n", "public final DateTimeOfYear iDateTimeOfYear;\n", "public final int iSaveMillis;\n", "public final String iLetterS;\n", "\n", "Rule(StringTokenizer st) {\n", "iName = st.nextToken().intern();\n", "iFromYear = parseYear(st.nextToken(), 0);\n", "iToYear = parseYear(st.nextToken(), iFromYear);\n", "if (iToYear < iFromYear) {\n", "throw new IllegalArgumentException();\n", "}\n", "iType = parseOptional(st.nextToken());\n", "iDateTimeOfYear = new DateTimeOfYear(st);\n", "iSaveMillis = parseTime(st.nextToken());\n", "iLetterS = parseOptional(st.nextToken());\n", "}\n", "\n", "/**\n", "* Adds a recurring savings rule to the builder.\n", "*/\n", "public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n", "String nameKey = formatName(nameFormat);\n", "iDateTimeOfYear.addRecurring\n", "(builder, nameKey, iSaveMillis, iFromYear, iToYear);\n", "}\n", "\n", "private String formatName(String nameFormat) {\n", "int index = nameFormat.indexOf('/');\n", "if (index > 0) {\n", "if (iSaveMillis == 0) {\n", "// Extract standard name.\n", "return nameFormat.substring(0, index).intern();\n", "} else {\n", "return nameFormat.substring(index + 1).intern();\n", "}\n", "}\n", "index = nameFormat.indexOf(\"%s\");\n", "if (index < 0) {\n", "return nameFormat;\n", "}\n", "String left = nameFormat.substring(0, index);\n", "String right = nameFormat.substring(index + 2);\n", "String name;\n", "if (iLetterS == null) {\n", "name = left.concat(right);\n", "} else {\n", "name = left + iLetterS + right;\n", "}\n", "return name.intern();\n", "}\n", "\n", "public String toString() {\n", "return\n", "\"[Rule]\\n\" +\n", "\"Name: \" + iName + \"\\n\" +\n", "\"FromYear: \" + iFromYear + \"\\n\" +\n", "\"ToYear: \" + iToYear + \"\\n\" +\n", "\"Type: \" + iType + \"\\n\" +\n", "iDateTimeOfYear +\n", "\"SaveMillis: \" + iSaveMillis + \"\\n\" +\n", "\"LetterS: \" + iLetterS + \"\\n\";\n", "}\n", "}\n", "\n", "private static class RuleSet {\n", "private List<Rule> iRules;\n", "\n", "RuleSet(Rule rule) {\n", "iRules = new ArrayList<Rule>();\n", "iRules.add(rule);\n", "}\n", "\n", "void addRule(Rule rule) {\n", "if (!(rule.iName.equals(iRules.get(0).iName))) {\n", "throw new IllegalArgumentException(\"Rule name mismatch\");\n", "}\n", "iRules.add(rule);\n", "}\n", "\n", "/**\n", "* Adds recurring savings rules to the builder.\n", "*/\n", "public void addRecurring(DateTimeZoneBuilder builder, String nameFormat) {\n", "for (int i=0; i<iRules.size(); i++) {\n", "Rule rule = iRules.get(i);\n", "rule.addRecurring(builder, nameFormat);\n", "}\n", "}\n", "}\n", "\n", "private static class Zone {\n", "public final String iName;\n", "public final int iOffsetMillis;\n", "public final String iRules;\n", "public final String iFormat;\n", "public final int iUntilYear;\n", "public final DateTimeOfYear iUntilDateTimeOfYear;\n", "\n", "private Zone iNext;\n", "\n", "Zone(StringTokenizer st) {\n", "this(st.nextToken(), st);\n", "}\n", "\n", "private Zone(String name, StringTokenizer st) {\n", "iName = name.intern();\n", "iOffsetMillis = parseTime(st.nextToken());\n", "iRules = parseOptional(st.nextToken());\n", "iFormat = st.nextToken().intern();\n", "\n", "int year = Integer.MAX_VALUE;\n", "DateTimeOfYear dtOfYear = getStartOfYear();\n", "\n", "if (st.hasMoreTokens()) {\n", "year = Integer.parseInt(st.nextToken());\n", "if (st.hasMoreTokens()) {\n", "dtOfYear = new DateTimeOfYear(st);\n", "}\n", "}\n", "\n", "iUntilYear = year;\n", "iUntilDateTimeOfYear = dtOfYear;\n", "}\n", "\n", "void chain(StringTokenizer st) {\n", "if (iNext != null) {\n", "iNext.chain(st);\n", "} else {\n", "iNext = new Zone(iName, st);\n", "}\n", "}\n", "\n", "/*\n", "public DateTimeZone buildDateTimeZone(Map ruleSets) {\n", "DateTimeZoneBuilder builder = new DateTimeZoneBuilder();\n", "addToBuilder(builder, ruleSets);\n", "return builder.toDateTimeZone(iName);\n", "}\n", "*/\n", "\n", "/**\n", "* Adds zone info to the builder.\n", "*/\n", "public void addToBuilder(DateTimeZoneBuilder builder, Map<String, RuleSet> ruleSets) {\n", "addToBuilder(this, builder, ruleSets);\n", "}\n", "\n", "private static void addToBuilder(Zone zone,\n", "DateTimeZoneBuilder builder,\n", "Map<String, RuleSet> ruleSets)\n", "{\n", "for (; zone != null; zone = zone.iNext) {\n", "builder.setStandardOffset(zone.iOffsetMillis);\n", "\n", "if (zone.iRules == null) {\n", "builder.setFixedSavings(zone.iFormat, 0);\n", "} else {\n", "try {\n", "// Check if iRules actually just refers to a savings.\n", "int saveMillis = parseTime(zone.iRules);\n", "builder.setFixedSavings(zone.iFormat, saveMillis);\n", "}\n", "catch (Exception e) {\n", "RuleSet rs = ruleSets.get(zone.iRules);\n", "if (rs == null) {\n", "throw new IllegalArgumentException\n", "(\"Rules not found: \" + zone.iRules);\n", "}\n", "rs.addRecurring(builder, zone.iFormat);\n", "}\n", "}\n", "\n", "if (zone.iUntilYear == Integer.MAX_VALUE) {\n", "break;\n", "}\n", "\n", "zone.iUntilDateTimeOfYear.addCutover(builder, zone.iUntilYear);\n", "}\n", "}\n", "\n", "public String toString() {\n", "String str =\n", "\"[Zone]\\n\" +\n", "\"Name: \" + iName + \"\\n\" +\n", "\"OffsetMillis: \" + iOffsetMillis + \"\\n\" +\n", "\"Rules: \" + iRules + \"\\n\" +\n", "\"Format: \" + iFormat + \"\\n\" +\n", "\"UntilYear: \" + iUntilYear + \"\\n\" +\n", "iUntilDateTimeOfYear;\n", "\n", "if (iNext == null) {\n", "return str;\n", "}\n", "\n", "return str + \"...\\n\" + iNext.toString();\n", "}\n", "}\n", "}\n"], "faulty_lines": [6, 7, 8, 9], "cluster": 3}, {"pid": "Time", "bid": 12, "method_path": "./dataset/Time/12/LocalDate.java", "method": ["public static LocalDate fromCalendarFields(Calendar calendar) {\n", "if (calendar == null) {\n", "throw new IllegalArgumentException(\"The calendar must not be null\");\n", "}\n", "int yearOfEra = calendar.get(Calendar.YEAR);\n", "return new LocalDate(\n", "yearOfEra,\n", "calendar.get(Calendar.MONTH) + 1,\n", "calendar.get(Calendar.DAY_OF_MONTH)\n", ");\n", "}\n"], "faulty_lines": [5, 7], "cluster": 4}, {"pid": "Time", "bid": 12, "method_path": "./dataset/Time/12/LocalDate.java", "method": ["public static LocalDate fromDateFields(Date date) {\n", "if (date == null) {\n", "throw new IllegalArgumentException(\"The date must not be null\");\n", "}\n", "// handle years in era BC\n", "return new LocalDate(\n", "date.getYear() + 1900,\n", "date.getMonth() + 1,\n", "date.getDate()\n", ");\n", "}\n"], "faulty_lines": [5, 6], "cluster": 4}, {"pid": "Time", "bid": 12, "method_path": "./dataset/Time/12/LocalDateTime.java", "method": ["public static LocalDateTime fromCalendarFields(Calendar calendar) {\n", "if (calendar == null) {\n", "throw new IllegalArgumentException(\"The calendar must not be null\");\n", "}\n", "int yearOfEra = calendar.get(Calendar.YEAR);\n", "return new LocalDateTime(\n", "yearOfEra,\n", "calendar.get(Calendar.MONTH) + 1,\n", "calendar.get(Calendar.DAY_OF_MONTH),\n", "calendar.get(Calendar.HOUR_OF_DAY),\n", "calendar.get(Calendar.MINUTE),\n", "calendar.get(Calendar.SECOND),\n", "calendar.get(Calendar.MILLISECOND)\n", ");\n", "}\n"], "faulty_lines": [5, 7], "cluster": 2}, {"pid": "Time", "bid": 12, "method_path": "./dataset/Time/12/LocalDateTime.java", "method": ["public static LocalDateTime fromDateFields(Date date) {\n", "if (date == null) {\n", "throw new IllegalArgumentException(\"The date must not be null\");\n", "}\n", "// handle years in era BC\n", "return new LocalDateTime(\n", "date.getYear() + 1900,\n", "date.getMonth() + 1,\n", "date.getDate(),\n", "date.getHours(),\n", "date.getMinutes(),\n", "date.getSeconds(),\n", "(((int) (date.getTime() % 1000)) + 1000) % 1000\n", ");\n", "}\n"], "faulty_lines": [5, 6], "cluster": 4}, {"pid": "Time", "bid": 13, "method_path": "./dataset/Time/13/PeriodFormatterBuilder.java", "method": ["public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n", "long valueLong = getFieldValue(period);\n", "if (valueLong == Long.MAX_VALUE) {\n", "return 0;\n", "}\n", "\n", "int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\n", "if (iFieldType >= SECONDS_MILLIS) {\n", "// valueLong contains the seconds and millis fields\n", "// the minimum output is 0.000, which is 4 or 5 digits with a negative\n", "sum = Math.max(sum, 4);\n", "// plus one for the decimal point\n", "sum++;\n", "if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n", "(Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {\n", "sum -= 4; // remove three digits and decimal point\n", "}\n", "// reset valueLong to refer to the seconds part for the prefic/suffix calculation\n", "valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;\n", "}\n", "int value = (int) valueLong;\n", "\n", "if (iPrefix != null) {\n", "sum += iPrefix.calculatePrintedLength(value);\n", "}\n", "if (iSuffix != null) {\n", "sum += iSuffix.calculatePrintedLength(value);\n", "}\n", "\n", "return sum;\n", "}\n"], "faulty_lines": [11], "cluster": 1}, {"pid": "Time", "bid": 13, "method_path": "./dataset/Time/13/PeriodFormatterBuilder.java", "method": ["public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n", "long valueLong = getFieldValue(period);\n", "if (valueLong == Long.MAX_VALUE) {\n", "return;\n", "}\n", "int value = (int) valueLong;\n", "if (iFieldType >= SECONDS_MILLIS) {\n", "value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n", "}\n", "\n", "if (iPrefix != null) {\n", "iPrefix.printTo(buf, value);\n", "}\n", "int minDigits = iMinPrintedDigits;\n", "if (minDigits <= 1) {\n", "FormatUtils.appendUnpaddedInteger(buf, value);\n", "} else {\n", "FormatUtils.appendPaddedInteger(buf, value, minDigits);\n", "}\n", "if (iFieldType >= SECONDS_MILLIS) {\n", "int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n", "if (iFieldType == SECONDS_MILLIS || dp > 0) {\n", "buf.append('.');\n", "FormatUtils.appendPaddedInteger(buf, dp, 3);\n", "}\n", "}\n", "if (iSuffix != null) {\n", "iSuffix.printTo(buf, value);\n", "}\n", "}\n"], "faulty_lines": [14], "cluster": 8}, {"pid": "Time", "bid": 13, "method_path": "./dataset/Time/13/PeriodFormatterBuilder.java", "method": ["public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n", "long valueLong = getFieldValue(period);\n", "if (valueLong == Long.MAX_VALUE) {\n", "return;\n", "}\n", "int value = (int) valueLong;\n", "if (iFieldType >= SECONDS_MILLIS) {\n", "value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n", "}\n", "\n", "if (iPrefix != null) {\n", "iPrefix.printTo(buf, value);\n", "}\n", "int minDigits = iMinPrintedDigits;\n", "if (minDigits <= 1) {\n", "FormatUtils.appendUnpaddedInteger(buf, value);\n", "} else {\n", "FormatUtils.appendPaddedInteger(buf, value, minDigits);\n", "}\n", "if (iFieldType >= SECONDS_MILLIS) {\n", "int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n", "if (iFieldType == SECONDS_MILLIS || dp > 0) {\n", "buf.append('.');\n", "FormatUtils.appendPaddedInteger(buf, dp, 3);\n", "}\n", "}\n", "if (iSuffix != null) {\n", "iSuffix.printTo(buf, value);\n", "}\n", "}\n"], "faulty_lines": [23], "cluster": 8}, {"pid": "Time", "bid": 14, "method_path": "./dataset/Time/14/BasicMonthOfYearDateTimeField.java", "method": ["public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n", "// overridden as superclass algorithm can't handle\n", "// 2004-02-29 + 48 months -> 2008-02-29 type dates\n", "if (valueToAdd == 0) {\n", "return values;\n", "}\n", "// month is largest field and being added to, such as month-day\n", "if (DateTimeUtils.isContiguous(partial)) {\n", "long instant = 0L;\n", "for (int i = 0, isize = partial.size(); i < isize; i++) {\n", "instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n", "}\n", "instant = add(instant, valueToAdd);\n", "return iChronology.get(partial, instant);\n", "} else {\n", "return super.add(partial, fieldIndex, values, valueToAdd);\n", "}\n", "}\n"], "faulty_lines": [7, 8], "cluster": 2}, {"pid": "Time", "bid": 15, "method_path": "./dataset/Time/15/FieldUtils.java", "method": ["public static long safeMultiply(long val1, int val2) {\n", "switch (val2) {\n", "case -1:\n", "return -val1;\n", "case 0:\n", "return 0L;\n", "case 1:\n", "return val1;\n", "}\n", "long total = val1 * val2;\n", "if (total / val2 != val1) {\n", "throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2);\n", "}\n", "return total;\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Time", "bid": 16, "method_path": "./dataset/Time/16/DateTimeFormatter.java", "method": ["public int parseInto(ReadWritableInstant instant, String text, int position) {\n", "DateTimeParser parser = requireParser();\n", "if (instant == null) {\n", "throw new IllegalArgumentException(\"Instant must not be null\");\n", "}\n", "\n", "long instantMillis = instant.getMillis();\n", "Chronology chrono = instant.getChronology();\n", "long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n", "chrono = selectChronology(chrono);\n", "\n", "DateTimeParserBucket bucket = new DateTimeParserBucket(\n", "instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n", "int newPos = parser.parseInto(bucket, text, position);\n", "instant.setMillis(bucket.computeMillis(false, text));\n", "if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n", "int parsedOffset = bucket.getOffsetInteger();\n", "DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n", "chrono = chrono.withZone(parsedZone);\n", "} else if (bucket.getZone() != null) {\n", "chrono = chrono.withZone(bucket.getZone());\n", "}\n", "instant.setChronology(chrono);\n", "if (iZone != null) {\n", "instant.setZone(iZone);\n", "}\n", "return newPos;\n", "}\n"], "faulty_lines": [13], "cluster": 1}, {"pid": "Time", "bid": 17, "method_path": "./dataset/Time/17/DateTimeZone.java", "method": ["public long adjustOffset(long instant, boolean earlierOrLater) {\n", "// a bit messy, but will work in all non-pathological cases\n", "\n", "// evaluate 3 hours before and after to work out if anything is happening\n", "long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n", "long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n", "if (instantBefore == instantAfter) {\n", "return instant;  // not an overlap (less than is a gap, equal is normal case)\n", "}\n", "\n", "// work out range of instants that have duplicate local times\n", "long local = convertUTCToLocal(instant);\n", "return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n", "\n", "// calculate result\n", "// currently in later offset\n", "// currently in earlier offset\n", "}\n"], "faulty_lines": [5, 6, 7, 12, 13, 16, 17, 18], "cluster": 2}, {"pid": "Time", "bid": 18, "method_path": "./dataset/Time/18/GJChronology.java", "method": ["public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n", "int hourOfDay, int minuteOfHour,\n", "int secondOfMinute, int millisOfSecond)\n", "throws IllegalArgumentException\n", "{\n", "Chronology base;\n", "if ((base = getBase()) != null) {\n", "return base.getDateTimeMillis\n", "(year, monthOfYear, dayOfMonth,\n", "hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n", "}\n", "\n", "// Assume date is Gregorian.\n", "long instant;\n", "instant = iGregorianChronology.getDateTimeMillis\n", "(year, monthOfYear, dayOfMonth,\n", "hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n", "if (instant < iCutoverMillis) {\n", "// Maybe it's Julian.\n", "instant = iJulianChronology.getDateTimeMillis\n", "(year, monthOfYear, dayOfMonth,\n", "hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n", "if (instant >= iCutoverMillis) {\n", "// Okay, it's in the illegal cutover gap.\n", "throw new IllegalArgumentException(\"Specified date does not exist\");\n", "}\n", "}\n", "return instant;\n", "}\n"], "faulty_lines": [15, 18], "cluster": 8}, {"pid": "Time", "bid": 19, "method_path": "./dataset/Time/19/DateTimeZone.java", "method": ["public int getOffsetFromLocal(long instantLocal) {\n", "// get the offset at instantLocal (first estimate)\n", "final int offsetLocal = getOffset(instantLocal);\n", "// adjust instantLocal using the estimate and recalc the offset\n", "final long instantAdjusted = instantLocal - offsetLocal;\n", "final int offsetAdjusted = getOffset(instantAdjusted);\n", "// if the offsets differ, we must be near a DST boundary\n", "if (offsetLocal != offsetAdjusted) {\n", "// we need to ensure that time is always after the DST gap\n", "// this happens naturally for positive offsets, but not for negative\n", "if ((offsetLocal - offsetAdjusted) < 0) {\n", "// if we just return offsetAdjusted then the time is pushed\n", "// back before the transition, whereas it should be\n", "// on or after the transition\n", "long nextLocal = nextTransition(instantAdjusted);\n", "long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n", "if (nextLocal != nextAdjusted) {\n", "return offsetLocal;\n", "}\n", "}\n", "} else if (offsetLocal > 0) {\n", "long prev = previousTransition(instantAdjusted);\n", "if (prev < instantAdjusted) {\n", "int offsetPrev = getOffset(prev);\n", "int diff = offsetPrev - offsetLocal;\n", "if (instantAdjusted - prev <= diff) {\n", "return offsetPrev;\n", "}\n", "}\n", "}\n", "return offsetAdjusted;\n", "}\n"], "faulty_lines": [21], "cluster": 1}, {"pid": "Time", "bid": 20, "method_path": "./dataset/Time/20/DateTimeFormatterBuilder.java", "method": ["public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n", "String str = text.substring(position);\n", "for (String id : ALL_IDS) {\n", "if (str.startsWith(id)) {\n", "bucket.setZone(DateTimeZone.forID(id));\n", "return position + id.length();\n", "}\n", "}\n", "return ~position;\n", "}\n"], "faulty_lines": [3, 5, 6, 9], "cluster": 4}, {"pid": "Time", "bid": 22, "method_path": "./dataset/Time/22/BasePeriod.java", "method": ["protected BasePeriod(long duration) {\n", "this(duration, null, null);\n", "// bug [3264409]\n", "}\n"], "faulty_lines": [2, 4], "cluster": 0}, {"pid": "Time", "bid": 23, "method_path": "./dataset/Time/23/DateTimeZone.java", "method": ["private static synchronized String getConvertedId(String id) {\n", "Map<String, String> map = cZoneIdConversion;\n", "if (map == null) {\n", "// Backwards compatibility with TimeZone.\n", "map = new HashMap<String, String>();\n", "map.put(\"GMT\", \"UTC\");\n", "map.put(\"MIT\", \"Pacific/Apia\");\n", "map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n", "map.put(\"AST\", \"America/Anchorage\");\n", "map.put(\"PST\", \"America/Los_Angeles\");\n", "map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n", "map.put(\"PNT\", \"America/Phoenix\");\n", "map.put(\"CST\", \"America/Chicago\");\n", "map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n", "map.put(\"IET\", \"America/Indianapolis\");\n", "map.put(\"PRT\", \"America/Puerto_Rico\");\n", "map.put(\"CNT\", \"America/St_Johns\");\n", "map.put(\"AGT\", \"America/Buenos_Aires\");\n", "map.put(\"BET\", \"America/Sao_Paulo\");\n", "map.put(\"WET\", \"Europe/London\");\n", "map.put(\"ECT\", \"Europe/Paris\");\n", "map.put(\"ART\", \"Africa/Cairo\");\n", "map.put(\"CAT\", \"Africa/Harare\");\n", "map.put(\"EET\", \"Europe/Bucharest\");\n", "map.put(\"EAT\", \"Africa/Addis_Ababa\");\n", "map.put(\"MET\", \"Asia/Tehran\");\n", "map.put(\"NET\", \"Asia/Yerevan\");\n", "map.put(\"PLT\", \"Asia/Karachi\");\n", "map.put(\"IST\", \"Asia/Calcutta\");\n", "map.put(\"BST\", \"Asia/Dhaka\");\n", "map.put(\"VST\", \"Asia/Saigon\");\n", "map.put(\"CTT\", \"Asia/Shanghai\");\n", "map.put(\"JST\", \"Asia/Tokyo\");\n", "map.put(\"ACT\", \"Australia/Darwin\");\n", "map.put(\"AET\", \"Australia/Sydney\");\n", "map.put(\"SST\", \"Pacific/Guadalcanal\");\n", "map.put(\"NST\", \"Pacific/Auckland\");\n", "cZoneIdConversion = map;\n", "}\n", "return map.get(id);\n", "}\n"], "faulty_lines": [7], "cluster": 5}, {"pid": "Time", "bid": 23, "method_path": "./dataset/Time/23/DateTimeZone.java", "method": ["private static synchronized String getConvertedId(String id) {\n", "Map<String, String> map = cZoneIdConversion;\n", "if (map == null) {\n", "// Backwards compatibility with TimeZone.\n", "map = new HashMap<String, String>();\n", "map.put(\"GMT\", \"UTC\");\n", "map.put(\"MIT\", \"Pacific/Apia\");\n", "map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n", "map.put(\"AST\", \"America/Anchorage\");\n", "map.put(\"PST\", \"America/Los_Angeles\");\n", "map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n", "map.put(\"PNT\", \"America/Phoenix\");\n", "map.put(\"CST\", \"America/Chicago\");\n", "map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n", "map.put(\"IET\", \"America/Indianapolis\");\n", "map.put(\"PRT\", \"America/Puerto_Rico\");\n", "map.put(\"CNT\", \"America/St_Johns\");\n", "map.put(\"AGT\", \"America/Buenos_Aires\");\n", "map.put(\"BET\", \"America/Sao_Paulo\");\n", "map.put(\"WET\", \"Europe/London\");\n", "map.put(\"ECT\", \"Europe/Paris\");\n", "map.put(\"ART\", \"Africa/Cairo\");\n", "map.put(\"CAT\", \"Africa/Harare\");\n", "map.put(\"EET\", \"Europe/Bucharest\");\n", "map.put(\"EAT\", \"Africa/Addis_Ababa\");\n", "map.put(\"MET\", \"Asia/Tehran\");\n", "map.put(\"NET\", \"Asia/Yerevan\");\n", "map.put(\"PLT\", \"Asia/Karachi\");\n", "map.put(\"IST\", \"Asia/Calcutta\");\n", "map.put(\"BST\", \"Asia/Dhaka\");\n", "map.put(\"VST\", \"Asia/Saigon\");\n", "map.put(\"CTT\", \"Asia/Shanghai\");\n", "map.put(\"JST\", \"Asia/Tokyo\");\n", "map.put(\"ACT\", \"Australia/Darwin\");\n", "map.put(\"AET\", \"Australia/Sydney\");\n", "map.put(\"SST\", \"Pacific/Guadalcanal\");\n", "map.put(\"NST\", \"Pacific/Auckland\");\n", "cZoneIdConversion = map;\n", "}\n", "return map.get(id);\n", "}\n"], "faulty_lines": [15, 18, 20, 21, 24, 26, 29, 31], "cluster": 5}, {"pid": "Time", "bid": 24, "method_path": "./dataset/Time/24/DateTimeParserBucket.java", "method": ["public long computeMillis(boolean resetFields, String text) {\n", "SavedField[] savedFields = iSavedFields;\n", "int count = iSavedFieldsCount;\n", "if (iSavedFieldsShared) {\n", "iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n", "iSavedFieldsShared = false;\n", "}\n", "sort(savedFields, count);\n", "if (count > 0) {\n", "// alter base year for parsing if first field is month or day\n", "DurationField months = DurationFieldType.months().getField(iChrono);\n", "DurationField days = DurationFieldType.days().getField(iChrono);\n", "DurationField first = savedFields[0].iField.getDurationField();\n", "if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n", "saveField(DateTimeFieldType.year(), iDefaultYear);\n", "return computeMillis(resetFields, text);\n", "}\n", "}\n", "\n", "long millis = iMillis;\n", "try {\n", "for (int i = 0; i < count; i++) {\n", "millis = savedFields[i].set(millis, resetFields);\n", "}\n", "} catch (IllegalFieldValueException e) {\n", "if (text != null) {\n", "e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n", "}\n", "throw e;\n", "}\n", "\n", "if (iZone == null) {\n", "millis -= iOffset;\n", "} else {\n", "int offset = iZone.getOffsetFromLocal(millis);\n", "millis -= offset;\n", "if (offset != iZone.getOffset(millis)) {\n", "String message =\n", "\"Illegal instant due to time zone offset transition (\" + iZone + ')';\n", "if (text != null) {\n", "message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n", "}\n", "throw new IllegalArgumentException(message);\n", "}\n", "}\n", "\n", "return millis;\n", "}\n"], "faulty_lines": [25], "cluster": 3}, {"pid": "Time", "bid": 25, "method_path": "./dataset/Time/25/DateTimeZone.java", "method": ["public int getOffsetFromLocal(long instantLocal) {\n", "// get the offset at instantLocal (first estimate)\n", "final int offsetLocal = getOffset(instantLocal);\n", "// adjust instantLocal using the estimate and recalc the offset\n", "final long instantAdjusted = instantLocal - offsetLocal;\n", "final int offsetAdjusted = getOffset(instantAdjusted);\n", "// if the offsets differ, we must be near a DST boundary\n", "if (offsetLocal != offsetAdjusted) {\n", "// we need to ensure that time is always after the DST gap\n", "// this happens naturally for positive offsets, but not for negative\n", "if ((offsetLocal - offsetAdjusted) < 0) {\n", "// if we just return offsetAdjusted then the time is pushed\n", "// back before the transition, whereas it should be\n", "// on or after the transition\n", "long nextLocal = nextTransition(instantAdjusted);\n", "long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n", "if (nextLocal != nextAdjusted) {\n", "return offsetLocal;\n", "}\n", "}\n", "}\n", "return offsetAdjusted;\n", "}\n"], "faulty_lines": [21], "cluster": 8}, {"pid": "Time", "bid": 26, "method_path": "./dataset/Time/26/ZonedChronology.java", "method": ["public long add(long instant, int value) {\n", "if (iTimeField) {\n", "int offset = getOffsetToAdd(instant);\n", "long localInstant = iField.add(instant + offset, value);\n", "return localInstant - offset;\n", "} else {\n", "long localInstant = iZone.convertUTCToLocal(instant);\n", "localInstant = iField.add(localInstant, value);\n", "return iZone.convertLocalToUTC(localInstant, false);\n", "}\n", "}\n"], "faulty_lines": [9], "cluster": 4}, {"pid": "Time", "bid": 26, "method_path": "./dataset/Time/26/ZonedChronology.java", "method": ["public long add(long instant, long value) {\n", "if (iTimeField) {\n", "int offset = getOffsetToAdd(instant);\n", "long localInstant = iField.add(instant + offset, value);\n", "return localInstant - offset;\n", "} else {\n", "long localInstant = iZone.convertUTCToLocal(instant);\n", "localInstant = iField.add(localInstant, value);\n", "return iZone.convertLocalToUTC(localInstant, false);\n", "}\n", "}\n"], "faulty_lines": [9], "cluster": 4}, {"pid": "Time", "bid": 26, "method_path": "./dataset/Time/26/ZonedChronology.java", "method": ["public long set(long instant, String text, Locale locale) {\n", "// cannot verify that new value stuck because set may be lenient\n", "long localInstant = iZone.convertUTCToLocal(instant);\n", "localInstant = iField.set(localInstant, text, locale);\n", "return iZone.convertLocalToUTC(localInstant, false);\n", "}\n"], "faulty_lines": [5], "cluster": 4}, {"pid": "Time", "bid": 26, "method_path": "./dataset/Time/26/ZonedChronology.java", "method": ["public long roundFloor(long instant) {\n", "if (iTimeField) {\n", "int offset = getOffsetToAdd(instant);\n", "instant = iField.roundFloor(instant + offset);\n", "return instant - offset;\n", "} else {\n", "long localInstant = iZone.convertUTCToLocal(instant);\n", "localInstant = iField.roundFloor(localInstant);\n", "return iZone.convertLocalToUTC(localInstant, false);\n", "}\n", "}\n"], "faulty_lines": [9], "cluster": 4}, {"pid": "Time", "bid": 26, "method_path": "./dataset/Time/26/ZonedChronology.java", "method": ["public long roundCeiling(long instant) {\n", "if (iTimeField) {\n", "int offset = getOffsetToAdd(instant);\n", "instant = iField.roundCeiling(instant + offset);\n", "return instant - offset;\n", "} else {\n", "long localInstant = iZone.convertUTCToLocal(instant);\n", "localInstant = iField.roundCeiling(localInstant);\n", "return iZone.convertLocalToUTC(localInstant, false);\n", "}\n", "}\n"], "faulty_lines": [9], "cluster": 4}, {"pid": "Time", "bid": 26, "method_path": "./dataset/Time/26/LenientDateTimeField.java", "method": ["public long set(long instant, int value) {\n", "// lenient needs to handle time zone chronologies\n", "// so we do the calculation using local milliseconds\n", "long localInstant = iBase.getZone().convertUTCToLocal(instant);\n", "long difference = FieldUtils.safeSubtract(value, get(instant));\n", "localInstant = getType().getField(iBase.withUTC()).add(localInstant, difference);\n", "return iBase.getZone().convertLocalToUTC(localInstant, false);\n", "}\n"], "faulty_lines": [7], "cluster": 4}, {"pid": "Time", "bid": 27, "method_path": "./dataset/Time/27/PeriodFormatterBuilder.java", "method": ["private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n", "if (notPrinter && notParser) {\n", "throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n", "}\n", "int size = elementPairs.size();\n", "if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n", "Separator sep = (Separator) elementPairs.get(0);\n", "PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n", "sep = sep.finish(f.getPrinter(), f.getParser());\n", "return new PeriodFormatter(sep, sep);\n", "}\n", "Object[] comp = createComposite(elementPairs);\n", "if (notPrinter) {\n", "return new PeriodFormatter(null, (PeriodParser) comp[1]);\n", "} else if (notParser) {\n", "return new PeriodFormatter((PeriodPrinter) comp[0], null);\n", "} else {\n", "return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n", "}\n", "}\n"], "faulty_lines": [8, 11], "cluster": 8}, {"pid": "Compress", "bid": 1, "method_path": "./dataset/Compress/1/CpioArchiveOutputStream.java", "method": ["public void close() throws IOException {\n", "if (!this.closed) {\n", "super.close();\n", "this.closed = true;\n", "}\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Compress", "bid": 2, "method_path": "./dataset/Compress/2/ArArchiveInputStream.java", "method": ["public ArArchiveEntry getNextArEntry() throws IOException {\n", "// hit EOF before previous entry was complete\n", "// TODO: throw an exception instead?\n", "\n", "if (offset == 0) {\n", "final byte[] expected = ArArchiveEntry.HEADER.getBytes();\n", "final byte[] realized = new byte[expected.length];\n", "final int read = read(realized);\n", "if (read != expected.length) {\n", "throw new IOException(\"failed to read header\");\n", "}\n", "for (int i = 0; i < expected.length; i++) {\n", "if (expected[i] != realized[i]) {\n", "throw new IOException(\"invalid header \" + new String(realized));\n", "}\n", "}\n", "}\n", "\n", "// hit eof\n", "\n", "if (input.available() == 0) {\n", "return null;\n", "}\n", "\n", "if (offset % 2 != 0) {\n", "read();\n", "}\n", "final byte[] name = new byte[16];\n", "final byte[] lastmodified = new byte[12];\n", "final byte[] userid = new byte[6];\n", "final byte[] groupid = new byte[6];\n", "final byte[] filemode = new byte[8];\n", "final byte[] length = new byte[10];\n", "\n", "read(name);\n", "read(lastmodified);\n", "read(userid);\n", "read(groupid);\n", "read(filemode);\n", "read(length);\n", "\n", "{\n", "final byte[] expected = ArArchiveEntry.TRAILER.getBytes();\n", "final byte[] realized = new byte[expected.length];\n", "final int read = read(realized);\n", "if (read != expected.length) {\n", "throw new IOException(\"failed to read entry header\");\n", "}\n", "for (int i = 0; i < expected.length; i++) {\n", "if (expected[i] != realized[i]) {\n", "throw new IOException(\"invalid entry header. not read the content?\");\n", "}\n", "}\n", "}\n", "\n", "return new ArArchiveEntry(new String(name).trim(),\n", "Long.parseLong(new String(length)\n", ".trim()));\n", "}\n"], "faulty_lines": [2, 4], "cluster": 5}, {"pid": "Compress", "bid": 2, "method_path": "./dataset/Compress/2/ArArchiveInputStream.java", "method": ["public ArArchiveEntry getNextArEntry() throws IOException {\n", "// hit EOF before previous entry was complete\n", "// TODO: throw an exception instead?\n", "\n", "if (offset == 0) {\n", "final byte[] expected = ArArchiveEntry.HEADER.getBytes();\n", "final byte[] realized = new byte[expected.length];\n", "final int read = read(realized);\n", "if (read != expected.length) {\n", "throw new IOException(\"failed to read header\");\n", "}\n", "for (int i = 0; i < expected.length; i++) {\n", "if (expected[i] != realized[i]) {\n", "throw new IOException(\"invalid header \" + new String(realized));\n", "}\n", "}\n", "}\n", "\n", "// hit eof\n", "\n", "if (input.available() == 0) {\n", "return null;\n", "}\n", "\n", "if (offset % 2 != 0) {\n", "read();\n", "}\n", "final byte[] name = new byte[16];\n", "final byte[] lastmodified = new byte[12];\n", "final byte[] userid = new byte[6];\n", "final byte[] groupid = new byte[6];\n", "final byte[] filemode = new byte[8];\n", "final byte[] length = new byte[10];\n", "\n", "read(name);\n", "read(lastmodified);\n", "read(userid);\n", "read(groupid);\n", "read(filemode);\n", "read(length);\n", "\n", "{\n", "final byte[] expected = ArArchiveEntry.TRAILER.getBytes();\n", "final byte[] realized = new byte[expected.length];\n", "final int read = read(realized);\n", "if (read != expected.length) {\n", "throw new IOException(\"failed to read entry header\");\n", "}\n", "for (int i = 0; i < expected.length; i++) {\n", "if (expected[i] != realized[i]) {\n", "throw new IOException(\"invalid entry header. not read the content?\");\n", "}\n", "}\n", "}\n", "\n", "return new ArArchiveEntry(new String(name).trim(),\n", "Long.parseLong(new String(length)\n", ".trim()));\n", "}\n"], "faulty_lines": [19, 20, 25, 26, 27], "cluster": 5}, {"pid": "Compress", "bid": 2, "method_path": "./dataset/Compress/2/ArArchiveInputStream.java", "method": ["public ArArchiveEntry getNextArEntry() throws IOException {\n", "// hit EOF before previous entry was complete\n", "// TODO: throw an exception instead?\n", "\n", "if (offset == 0) {\n", "final byte[] expected = ArArchiveEntry.HEADER.getBytes();\n", "final byte[] realized = new byte[expected.length];\n", "final int read = read(realized);\n", "if (read != expected.length) {\n", "throw new IOException(\"failed to read header\");\n", "}\n", "for (int i = 0; i < expected.length; i++) {\n", "if (expected[i] != realized[i]) {\n", "throw new IOException(\"invalid header \" + new String(realized));\n", "}\n", "}\n", "}\n", "\n", "// hit eof\n", "\n", "if (input.available() == 0) {\n", "return null;\n", "}\n", "\n", "if (offset % 2 != 0) {\n", "read();\n", "}\n", "final byte[] name = new byte[16];\n", "final byte[] lastmodified = new byte[12];\n", "final byte[] userid = new byte[6];\n", "final byte[] groupid = new byte[6];\n", "final byte[] filemode = new byte[8];\n", "final byte[] length = new byte[10];\n", "\n", "read(name);\n", "read(lastmodified);\n", "read(userid);\n", "read(groupid);\n", "read(filemode);\n", "read(length);\n", "\n", "{\n", "final byte[] expected = ArArchiveEntry.TRAILER.getBytes();\n", "final byte[] realized = new byte[expected.length];\n", "final int read = read(realized);\n", "if (read != expected.length) {\n", "throw new IOException(\"failed to read entry header\");\n", "}\n", "for (int i = 0; i < expected.length; i++) {\n", "if (expected[i] != realized[i]) {\n", "throw new IOException(\"invalid entry header. not read the content?\");\n", "}\n", "}\n", "}\n", "\n", "return new ArArchiveEntry(new String(name).trim(),\n", "Long.parseLong(new String(length)\n", ".trim()));\n", "}\n"], "faulty_lines": [56, 59], "cluster": 5}, {"pid": "Compress", "bid": 2, "method_path": "./dataset/Compress/2/ArArchiveInputStream.java", "method": ["public int read(byte[] b, final int off, final int len) throws IOException {\n", "int toRead = len;\n", "final int ret = this.input.read(b, off, toRead);\n", "offset += (ret > 0 ? ret : 0);\n", "return ret;\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Compress", "bid": 3, "method_path": "./dataset/Compress/3/TarArchiveOutputStream.java", "method": ["public void finish() throws IOException {\n", "writeEOFRecord();\n", "writeEOFRecord();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Compress", "bid": 3, "method_path": "./dataset/Compress/3/TarArchiveOutputStream.java", "method": ["public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\n", "TarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\n", "if (entry.getName().length() >= TarConstants.NAMELEN) {\n", "\n", "if (longFileMode == LONGFILE_GNU) {\n", "// create a TarEntry for the LongLink, the contents\n", "// of which are the entry's name\n", "TarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\n", "TarConstants.LF_GNUTYPE_LONGNAME);\n", "\n", "final byte[] nameBytes = entry.getName().getBytes(); // TODO is it correct to use the default charset here?\n", "longLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\n", "putArchiveEntry(longLinkEntry);\n", "write(nameBytes);\n", "write(0); // NUL terminator\n", "closeArchiveEntry();\n", "} else if (longFileMode != LONGFILE_TRUNCATE) {\n", "throw new RuntimeException(\"file name '\" + entry.getName()\n", "+ \"' is too long ( > \"\n", "+ TarConstants.NAMELEN + \" bytes)\");\n", "}\n", "}\n", "\n", "entry.writeEntryHeader(recordBuf);\n", "buffer.writeRecord(recordBuf);\n", "\n", "currBytes = 0;\n", "\n", "if (entry.isDirectory()) {\n", "currSize = 0;\n", "} else {\n", "currSize = entry.getSize();\n", "}\n", "currName = entry.getName();\n", "}\n"], "faulty_lines": [35], "cluster": 1}, {"pid": "Compress", "bid": 3, "method_path": "./dataset/Compress/3/TarArchiveOutputStream.java", "method": ["public void closeArchiveEntry() throws IOException {\n", "if (assemLen > 0) {\n", "for (int i = assemLen; i < assemBuf.length; ++i) {\n", "assemBuf[i] = 0;\n", "}\n", "\n", "buffer.writeRecord(assemBuf);\n", "\n", "currBytes += assemLen;\n", "assemLen = 0;\n", "}\n", "\n", "if (currBytes < currSize) {\n", "throw new IOException(\"entry '\" + currName + \"' closed at '\"\n", "+ currBytes\n", "+ \"' before the '\" + currSize\n", "+ \"' bytes specified in the header were written\");\n", "}\n", "}\n"], "faulty_lines": [19], "cluster": 2}, {"pid": "Compress", "bid": 4, "method_path": "./dataset/Compress/4/CpioArchiveOutputStream.java", "method": ["public void close() throws IOException {\n", "if (!this.closed) {\n", "this.finish();\n", "out.close();\n", "this.closed = true;\n", "}\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Compress", "bid": 4, "method_path": "./dataset/Compress/4/TarArchiveOutputStream.java", "method": ["public void close() throws IOException {\n", "if (!closed) {\n", "finish();\n", "buffer.close();\n", "out.close();\n", "closed = true;\n", "}\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Compress", "bid": 4, "method_path": "./dataset/Compress/4/ZipArchiveOutputStream.java", "method": ["public void close() throws IOException {\n", "finish();\n", "if (raf != null) {\n", "raf.close();\n", "}\n", "if (out != null) {\n", "out.close();\n", "}\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Compress", "bid": 5, "method_path": "./dataset/Compress/5/ZipArchiveInputStream.java", "method": ["public int read(byte[] buffer, int start, int length) throws IOException {\n", "if (closed) {\n", "throw new IOException(\"The stream is closed\");\n", "}\n", "if (inf.finished() || current == null) {\n", "return -1;\n", "}\n", "\n", "// avoid int overflow, check null buffer\n", "if (start <= buffer.length && length >= 0 && start >= 0\n", "&& buffer.length - start >= length) {\n", "if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n", "int csize = (int) current.getSize();\n", "if (readBytesOfEntry >= csize) {\n", "return -1;\n", "}\n", "if (offsetInBuffer >= lengthOfLastRead) {\n", "offsetInBuffer = 0;\n", "if ((lengthOfLastRead = in.read(buf)) == -1) {\n", "return -1;\n", "}\n", "count(lengthOfLastRead);\n", "bytesReadFromStream += lengthOfLastRead;\n", "}\n", "int toRead = length > lengthOfLastRead\n", "? lengthOfLastRead - offsetInBuffer\n", ": length;\n", "if ((csize - readBytesOfEntry) < toRead) {\n", "toRead = csize - readBytesOfEntry;\n", "}\n", "System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n", "offsetInBuffer += toRead;\n", "readBytesOfEntry += toRead;\n", "crc.update(buffer, start, toRead);\n", "return toRead;\n", "}\n", "if (inf.needsInput()) {\n", "fill();\n", "if (lengthOfLastRead > 0) {\n", "bytesReadFromStream += lengthOfLastRead;\n", "}\n", "}\n", "int read = 0;\n", "try {\n", "read = inf.inflate(buffer, start, length);\n", "} catch (DataFormatException e) {\n", "throw new ZipException(e.getMessage());\n", "}\n", "if (read == 0 && inf.finished()) {\n", "return -1;\n", "}\n", "crc.update(buffer, start, read);\n", "return read;\n", "}\n", "throw new ArrayIndexOutOfBoundsException();\n", "}\n"], "faulty_lines": [49, 50], "cluster": 5}, {"pid": "Compress", "bid": 6, "method_path": "./dataset/Compress/6/ZipArchiveEntry.java", "method": ["public ZipArchiveEntry(String name) {\n", "super(name);\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Compress", "bid": 6, "method_path": "./dataset/Compress/6/ZipArchiveEntry.java", "method": ["public boolean equals(Object obj) {\n", "if (this == obj) {\n", "return true;\n", "}\n", "if (obj == null || getClass() != obj.getClass()) {\n", "return false;\n", "}\n", "ZipArchiveEntry other = (ZipArchiveEntry) obj;\n", "if (name == null) {\n", "if (other.name != null) {\n", "return false;\n", "}\n", "} else if (!name.equals(other.name)) {\n", "return false;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [9, 10, 13], "cluster": 4}, {"pid": "Compress", "bid": 7, "method_path": "./dataset/Compress/7/TarUtils.java", "method": ["public static String parseName(byte[] buffer, final int offset, final int length) {\n", "StringBuffer result = new StringBuffer(length);\n", "int          end = offset + length;\n", "\n", "for (int i = offset; i < end; ++i) {\n", "if (buffer[i] == 0) {\n", "break;\n", "}\n", "result.append((char) buffer[i]);\n", "}\n", "\n", "return result.toString();\n", "}\n"], "faulty_lines": [6, 9], "cluster": 4}, {"pid": "Compress", "bid": 8, "method_path": "./dataset/Compress/8/TarUtils.java", "method": ["public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n", "long    result = 0;\n", "boolean stillPadding = true;\n", "int     end = offset + length;\n", "int     start = offset;\n", "\n", "for (int i = start; i < end; i++){\n", "final byte currentByte = buffer[i];\n", "if (currentByte == 0) {\n", "break;\n", "}\n", "\n", "// Skip leading spaces\n", "if (currentByte == (byte) ' ' || currentByte == '0') {\n", "if (stillPadding) {\n", "continue;\n", "}\n", "if (currentByte == (byte) ' ') {\n", "break;\n", "}\n", "}\n", "\n", "// Must have trailing NUL or space\n", "// May have additional NUL or space\n", "\n", "stillPadding = false;\n", "// CheckStyle:MagicNumber OFF\n", "if (currentByte < '0' || currentByte > '7'){\n", "throw new IllegalArgumentException(\n", "exceptionMessage(buffer, offset, length, start, currentByte));\n", "}\n", "result = (result << 3) + (currentByte - '0'); // convert from ASCII\n", "// CheckStyle:MagicNumber ON\n", "}\n", "\n", "return result;\n", "}\n"], "faulty_lines": [3, 7, 8, 9, 12, 14, 15, 16, 17, 18, 20, 22, 24, 25, 26], "cluster": 8}, {"pid": "Compress", "bid": 9, "method_path": "./dataset/Compress/9/TarArchiveOutputStream.java", "method": ["public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\n", "if ((currBytes + numToWrite) > currSize) {\n", "throw new IOException(\"request to write '\" + numToWrite\n", "+ \"' bytes exceeds size in header of '\"\n", "+ currSize + \"' bytes for entry '\"\n", "+ currName + \"'\");\n", "\n", "//\n", "// We have to deal with assembly!!!\n", "// The programmer can be writing little 32 byte chunks for all\n", "// we know, and we must assemble complete records for writing.\n", "// REVIEW Maybe this should be in TarBuffer? Could that help to\n", "// eliminate some of the buffer copying.\n", "//\n", "}\n", "\n", "if (assemLen > 0) {\n", "if ((assemLen + numToWrite) >= recordBuf.length) {\n", "int aLen = recordBuf.length - assemLen;\n", "\n", "System.arraycopy(assemBuf, 0, recordBuf, 0,\n", "assemLen);\n", "System.arraycopy(wBuf, wOffset, recordBuf,\n", "assemLen, aLen);\n", "buffer.writeRecord(recordBuf);\n", "\n", "currBytes += recordBuf.length;\n", "wOffset += aLen;\n", "numToWrite -= aLen;\n", "assemLen = 0;\n", "} else {\n", "System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n", "numToWrite);\n", "\n", "wOffset += numToWrite;\n", "assemLen += numToWrite;\n", "numToWrite = 0;\n", "}\n", "}\n", "\n", "//\n", "// When we get here we have EITHER:\n", "// o An empty \"assemble\" buffer.\n", "// o No bytes to write (numToWrite == 0)\n", "//\n", "while (numToWrite > 0) {\n", "if (numToWrite < recordBuf.length) {\n", "System.arraycopy(wBuf, wOffset, assemBuf, assemLen,\n", "numToWrite);\n", "\n", "assemLen += numToWrite;\n", "\n", "break;\n", "}\n", "\n", "buffer.writeRecord(wBuf, wOffset);\n", "\n", "int num = recordBuf.length;\n", "\n", "currBytes += num;\n", "numToWrite -= num;\n", "wOffset += num;\n", "}\n", "count(numToWrite);\n", "}\n"], "faulty_lines": [64], "cluster": 3}, {"pid": "Compress", "bid": 10, "method_path": "./dataset/Compress/10/ZipFile.java", "method": ["private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n", "entriesWithoutUTF8Flag)\n", "throws IOException {\n", "// changing the name of a ZipArchiveEntry is going to change\n", "// the hashcode - see COMPRESS-164\n", "// Map needs to be reconstructed in order to keep central\n", "// directory order\n", "for (ZipArchiveEntry ze : entries.keySet()) {\n", "OffsetEntry offsetEntry = entries.get(ze);\n", "long offset = offsetEntry.headerOffset;\n", "archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n", "byte[] b = new byte[SHORT];\n", "archive.readFully(b);\n", "int fileNameLen = ZipShort.getValue(b);\n", "archive.readFully(b);\n", "int extraFieldLen = ZipShort.getValue(b);\n", "int lenToSkip = fileNameLen;\n", "while (lenToSkip > 0) {\n", "int skipped = archive.skipBytes(lenToSkip);\n", "if (skipped <= 0) {\n", "throw new RuntimeException(\"failed to skip file name in\"\n", "+ \" local file header\");\n", "}\n", "lenToSkip -= skipped;\n", "}\n", "byte[] localExtraData = new byte[extraFieldLen];\n", "archive.readFully(localExtraData);\n", "ze.setExtra(localExtraData);\n", "offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n", "+ SHORT + SHORT + fileNameLen + extraFieldLen;\n", "\n", "if (entriesWithoutUTF8Flag.containsKey(ze)) {\n", "String orig = ze.getName();\n", "NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n", "ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n", "nc.comment);\n", "if (!orig.equals(ze.getName())) {\n", "nameMap.remove(orig);\n", "nameMap.put(ze.getName(), ze);\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [8, 9], "cluster": 5}, {"pid": "Compress", "bid": 10, "method_path": "./dataset/Compress/10/ZipFile.java", "method": ["private void resolveLocalFileHeaderData(Map<ZipArchiveEntry, NameAndComment>\n", "entriesWithoutUTF8Flag)\n", "throws IOException {\n", "// changing the name of a ZipArchiveEntry is going to change\n", "// the hashcode - see COMPRESS-164\n", "// Map needs to be reconstructed in order to keep central\n", "// directory order\n", "for (ZipArchiveEntry ze : entries.keySet()) {\n", "OffsetEntry offsetEntry = entries.get(ze);\n", "long offset = offsetEntry.headerOffset;\n", "archive.seek(offset + LFH_OFFSET_FOR_FILENAME_LENGTH);\n", "byte[] b = new byte[SHORT];\n", "archive.readFully(b);\n", "int fileNameLen = ZipShort.getValue(b);\n", "archive.readFully(b);\n", "int extraFieldLen = ZipShort.getValue(b);\n", "int lenToSkip = fileNameLen;\n", "while (lenToSkip > 0) {\n", "int skipped = archive.skipBytes(lenToSkip);\n", "if (skipped <= 0) {\n", "throw new RuntimeException(\"failed to skip file name in\"\n", "+ \" local file header\");\n", "}\n", "lenToSkip -= skipped;\n", "}\n", "byte[] localExtraData = new byte[extraFieldLen];\n", "archive.readFully(localExtraData);\n", "ze.setExtra(localExtraData);\n", "offsetEntry.dataOffset = offset + LFH_OFFSET_FOR_FILENAME_LENGTH\n", "+ SHORT + SHORT + fileNameLen + extraFieldLen;\n", "\n", "if (entriesWithoutUTF8Flag.containsKey(ze)) {\n", "String orig = ze.getName();\n", "NameAndComment nc = entriesWithoutUTF8Flag.get(ze);\n", "ZipUtil.setNameAndCommentFromExtraFields(ze, nc.name,\n", "nc.comment);\n", "if (!orig.equals(ze.getName())) {\n", "nameMap.remove(orig);\n", "nameMap.put(ze.getName(), ze);\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [42], "cluster": 5}, {"pid": "Compress", "bid": 11, "method_path": "./dataset/Compress/11/ArchiveStreamFactory.java", "method": ["public ArchiveInputStream createArchiveInputStream(final InputStream in)\n", "throws ArchiveException {\n", "if (in == null) {\n", "throw new IllegalArgumentException(\"Stream must not be null.\");\n", "}\n", "\n", "if (!in.markSupported()) {\n", "throw new IllegalArgumentException(\"Mark is not supported.\");\n", "}\n", "\n", "final byte[] signature = new byte[12];\n", "in.mark(signature.length);\n", "try {\n", "int signatureLength = in.read(signature);\n", "in.reset();\n", "if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n", "return new ZipArchiveInputStream(in);\n", "} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n", "return new JarArchiveInputStream(in);\n", "} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n", "return new ArArchiveInputStream(in);\n", "} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n", "return new CpioArchiveInputStream(in);\n", "}\n", "\n", "// Dump needs a bigger buffer to check the signature;\n", "final byte[] dumpsig = new byte[32];\n", "in.mark(dumpsig.length);\n", "signatureLength = in.read(dumpsig);\n", "in.reset();\n", "if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n", "return new DumpArchiveInputStream(in);\n", "}\n", "\n", "// Tar needs an even bigger buffer to check the signature; read the first block\n", "final byte[] tarheader = new byte[512];\n", "in.mark(tarheader.length);\n", "signatureLength = in.read(tarheader);\n", "in.reset();\n", "if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n", "return new TarArchiveInputStream(in);\n", "}\n", "// COMPRESS-117 - improve auto-recognition\n", "try {\n", "TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n", "tais.getNextEntry();\n", "return new TarArchiveInputStream(in);\n", "} catch (Exception e) { // NOPMD\n", "// can generate IllegalArgumentException as well as IOException\n", "// autodetection, simply not a TAR\n", "// ignored\n", "}\n", "} catch (IOException e) {\n", "throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n", "}\n", "\n", "throw new ArchiveException(\"No Archiver found for the stream signature\");\n", "}\n"], "faulty_lines": [44], "cluster": 6}, {"pid": "Compress", "bid": 11, "method_path": "./dataset/Compress/11/ArchiveStreamFactory.java", "method": ["public ArchiveInputStream createArchiveInputStream(final InputStream in)\n", "throws ArchiveException {\n", "if (in == null) {\n", "throw new IllegalArgumentException(\"Stream must not be null.\");\n", "}\n", "\n", "if (!in.markSupported()) {\n", "throw new IllegalArgumentException(\"Mark is not supported.\");\n", "}\n", "\n", "final byte[] signature = new byte[12];\n", "in.mark(signature.length);\n", "try {\n", "int signatureLength = in.read(signature);\n", "in.reset();\n", "if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n", "return new ZipArchiveInputStream(in);\n", "} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n", "return new JarArchiveInputStream(in);\n", "} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n", "return new ArArchiveInputStream(in);\n", "} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n", "return new CpioArchiveInputStream(in);\n", "}\n", "\n", "// Dump needs a bigger buffer to check the signature;\n", "final byte[] dumpsig = new byte[32];\n", "in.mark(dumpsig.length);\n", "signatureLength = in.read(dumpsig);\n", "in.reset();\n", "if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n", "return new DumpArchiveInputStream(in);\n", "}\n", "\n", "// Tar needs an even bigger buffer to check the signature; read the first block\n", "final byte[] tarheader = new byte[512];\n", "in.mark(tarheader.length);\n", "signatureLength = in.read(tarheader);\n", "in.reset();\n", "if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n", "return new TarArchiveInputStream(in);\n", "}\n", "// COMPRESS-117 - improve auto-recognition\n", "try {\n", "TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n", "tais.getNextEntry();\n", "return new TarArchiveInputStream(in);\n", "} catch (Exception e) { // NOPMD\n", "// can generate IllegalArgumentException as well as IOException\n", "// autodetection, simply not a TAR\n", "// ignored\n", "}\n", "} catch (IOException e) {\n", "throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n", "}\n", "\n", "throw new ArchiveException(\"No Archiver found for the stream signature\");\n", "}\n"], "faulty_lines": [53], "cluster": 6}, {"pid": "Compress", "bid": 12, "method_path": "./dataset/Compress/12/TarArchiveInputStream.java", "method": ["public TarArchiveEntry getNextTarEntry() throws IOException {\n", "if (hasHitEOF) {\n", "return null;\n", "}\n", "\n", "if (currEntry != null) {\n", "long numToSkip = entrySize - entryOffset;\n", "\n", "while (numToSkip > 0) {\n", "long skipped = skip(numToSkip);\n", "if (skipped <= 0) {\n", "throw new RuntimeException(\"failed to skip current tar entry\");\n", "}\n", "numToSkip -= skipped;\n", "}\n", "\n", "readBuf = null;\n", "}\n", "\n", "byte[] headerBuf = getRecord();\n", "\n", "if (hasHitEOF) {\n", "currEntry = null;\n", "return null;\n", "}\n", "\n", "currEntry = new TarArchiveEntry(headerBuf);\n", "entryOffset = 0;\n", "entrySize = currEntry.getSize();\n", "\n", "if (currEntry.isGNULongNameEntry()) {\n", "// read in the name\n", "StringBuffer longName = new StringBuffer();\n", "byte[] buf = new byte[SMALL_BUFFER_SIZE];\n", "int length = 0;\n", "while ((length = read(buf)) >= 0) {\n", "longName.append(new String(buf, 0, length));\n", "}\n", "getNextEntry();\n", "if (currEntry == null) {\n", "// Bugzilla: 40334\n", "// Malformed tar file - long entry name not followed by entry\n", "return null;\n", "}\n", "// remove trailing null terminator\n", "if (longName.length() > 0\n", "&& longName.charAt(longName.length() - 1) == 0) {\n", "longName.deleteCharAt(longName.length() - 1);\n", "}\n", "currEntry.setName(longName.toString());\n", "}\n", "\n", "if (currEntry.isPaxHeader()){ // Process Pax headers\n", "paxHeaders();\n", "}\n", "\n", "if (currEntry.isGNUSparse()){ // Process sparse files\n", "readGNUSparse();\n", "}\n", "\n", "// If the size of the next element in the archive has changed\n", "// due to a new size being reported in the posix header\n", "// information, we update entrySize here so that it contains\n", "// the correct value.\n", "entrySize = currEntry.getSize();\n", "return currEntry;\n", "}\n"], "faulty_lines": [27], "cluster": 3}, {"pid": "Compress", "bid": 13, "method_path": "./dataset/Compress/13/ZipArchiveEntry.java", "method": ["protected void setName(String name) {\n", "this.name = name;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Compress", "bid": 14, "method_path": "./dataset/Compress/14/TarUtils.java", "method": ["public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n", "long    result = 0;\n", "int     end = offset + length;\n", "int     start = offset;\n", "\n", "if (length < 2){\n", "throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n", "}\n", "\n", "boolean allNUL = true;\n", "for (int i = start; i < end; i++){\n", "if (buffer[i] != 0){\n", "allNUL = false;\n", "break;\n", "}\n", "}\n", "if (allNUL) {\n", "return 0L;\n", "}\n", "\n", "// Skip leading spaces\n", "while (start < end){\n", "if (buffer[start] == ' '){\n", "start++;\n", "} else {\n", "break;\n", "}\n", "}\n", "\n", "// Must have trailing NUL or space\n", "byte trailer;\n", "trailer = buffer[end-1];\n", "if (trailer == 0 || trailer == ' '){\n", "end--;\n", "} else {\n", "throw new IllegalArgumentException(\n", "exceptionMessage(buffer, offset, length, end-1, trailer));\n", "}\n", "// May have additional NUL or space\n", "trailer = buffer[end-1];\n", "if (trailer == 0 || trailer == ' '){\n", "end--;\n", "}\n", "\n", "for ( ;start < end; start++) {\n", "final byte currentByte = buffer[start];\n", "// CheckStyle:MagicNumber OFF\n", "if (currentByte < '0' || currentByte > '7'){\n", "throw new IllegalArgumentException(\n", "exceptionMessage(buffer, offset, length, start, currentByte));\n", "}\n", "result = (result << 3) + (currentByte - '0'); // convert from ASCII\n", "// CheckStyle:MagicNumber ON\n", "}\n", "\n", "return result;\n", "}\n"], "faulty_lines": [10, 11, 12, 13, 14, 15, 16, 17], "cluster": 5}, {"pid": "Compress", "bid": 15, "method_path": "./dataset/Compress/15/ZipArchiveEntry.java", "method": ["public boolean equals(Object obj) {\n", "if (this == obj) {\n", "return true;\n", "}\n", "if (obj == null || getClass() != obj.getClass()) {\n", "return false;\n", "}\n", "ZipArchiveEntry other = (ZipArchiveEntry) obj;\n", "String myName = getName();\n", "String otherName = other.getName();\n", "if (myName == null) {\n", "if (otherName != null) {\n", "return false;\n", "}\n", "} else if (!myName.equals(otherName)) {\n", "return false;\n", "}\n", "String myComment = getComment();\n", "String otherComment = other.getComment();\n", "if (myComment == null) {\n", "if (otherComment != null) {\n", "return false;\n", "}\n", "} else if (!myComment.equals(otherComment)) {\n", "return false;\n", "}\n", "return getTime() == other.getTime()\n", "&& getInternalAttributes() == other.getInternalAttributes()\n", "&& getPlatform() == other.getPlatform()\n", "&& getExternalAttributes() == other.getExternalAttributes()\n", "&& getMethod() == other.getMethod()\n", "&& getSize() == other.getSize()\n", "&& getCrc() == other.getCrc()\n", "&& getCompressedSize() == other.getCompressedSize()\n", "&& Arrays.equals(getCentralDirectoryExtra(),\n", "other.getCentralDirectoryExtra())\n", "&& Arrays.equals(getLocalFileDataExtra(),\n", "other.getLocalFileDataExtra())\n", "&& gpb.equals(other.gpb);\n", "}\n"], "faulty_lines": [21, 22, 23, 24, 25, 28], "cluster": 1}, {"pid": "Compress", "bid": 16, "method_path": "./dataset/Compress/16/ArchiveStreamFactory.java", "method": ["public ArchiveInputStream createArchiveInputStream(final InputStream in)\n", "throws ArchiveException {\n", "if (in == null) {\n", "throw new IllegalArgumentException(\"Stream must not be null.\");\n", "}\n", "\n", "if (!in.markSupported()) {\n", "throw new IllegalArgumentException(\"Mark is not supported.\");\n", "}\n", "\n", "final byte[] signature = new byte[12];\n", "in.mark(signature.length);\n", "try {\n", "int signatureLength = in.read(signature);\n", "in.reset();\n", "if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n", "return new ZipArchiveInputStream(in);\n", "} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n", "return new JarArchiveInputStream(in);\n", "} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n", "return new ArArchiveInputStream(in);\n", "} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n", "return new CpioArchiveInputStream(in);\n", "}\n", "\n", "// Dump needs a bigger buffer to check the signature;\n", "final byte[] dumpsig = new byte[32];\n", "in.mark(dumpsig.length);\n", "signatureLength = in.read(dumpsig);\n", "in.reset();\n", "if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n", "return new DumpArchiveInputStream(in);\n", "}\n", "\n", "// Tar needs an even bigger buffer to check the signature; read the first block\n", "final byte[] tarheader = new byte[512];\n", "in.mark(tarheader.length);\n", "signatureLength = in.read(tarheader);\n", "in.reset();\n", "if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n", "return new TarArchiveInputStream(in);\n", "}\n", "// COMPRESS-117 - improve auto-recognition\n", "if (signatureLength >= 512) {\n", "try {\n", "TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n", "// COMPRESS-191 - verify the header checksum\n", "tais.getNextEntry();\n", "return new TarArchiveInputStream(in);\n", "} catch (Exception e) { // NOPMD\n", "// can generate IllegalArgumentException as well\n", "// as IOException\n", "// autodetection, simply not a TAR\n", "// ignored\n", "}\n", "}\n", "} catch (IOException e) {\n", "throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n", "}\n", "\n", "throw new ArchiveException(\"No Archiver found for the stream signature\");\n", "}\n"], "faulty_lines": [48, 50], "cluster": 6}, {"pid": "Compress", "bid": 17, "method_path": "./dataset/Compress/17/TarUtils.java", "method": ["public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n", "long    result = 0;\n", "int     end = offset + length;\n", "int     start = offset;\n", "\n", "if (length < 2){\n", "throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n", "}\n", "\n", "if (buffer[start] == 0) {\n", "return 0L;\n", "}\n", "\n", "// Skip leading spaces\n", "while (start < end){\n", "if (buffer[start] == ' '){\n", "start++;\n", "} else {\n", "break;\n", "}\n", "}\n", "\n", "// Must have trailing NUL or space\n", "byte trailer;\n", "trailer = buffer[end-1];\n", "if (trailer == 0 || trailer == ' '){\n", "end--;\n", "} else {\n", "throw new IllegalArgumentException(\n", "exceptionMessage(buffer, offset, length, end-1, trailer));\n", "}\n", "// May have additional NULs or spaces\n", "trailer = buffer[end - 1];\n", "if (trailer == 0 || trailer == ' '){\n", "end--;\n", "}\n", "\n", "for ( ;start < end; start++) {\n", "final byte currentByte = buffer[start];\n", "// CheckStyle:MagicNumber OFF\n", "if (currentByte < '0' || currentByte > '7'){\n", "throw new IllegalArgumentException(\n", "exceptionMessage(buffer, offset, length, start, currentByte));\n", "}\n", "result = (result << 3) + (currentByte - '0'); // convert from ASCII\n", "// CheckStyle:MagicNumber ON\n", "}\n", "\n", "return result;\n", "}\n"], "faulty_lines": [34, 36], "cluster": 1}, {"pid": "Compress", "bid": 18, "method_path": "./dataset/Compress/18/TarArchiveOutputStream.java", "method": ["void writePaxHeaders(String entryName,\n", "Map<String, String> headers) throws IOException {\n", "String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n", "// TarEntry's constructor would think this is a directory\n", "// and not allow any data to be written\n", "if (name.length() >= TarConstants.NAMELEN) {\n", "name = name.substring(0, TarConstants.NAMELEN - 1);\n", "}\n", "TarArchiveEntry pex = new TarArchiveEntry(name,\n", "TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n", "\n", "StringWriter w = new StringWriter();\n", "for (Map.Entry<String, String> h : headers.entrySet()) {\n", "String key = h.getKey();\n", "String value = h.getValue();\n", "int len = key.length() + value.length()\n", "+ 3 /* blank, equals and newline */\n", "+ 2 /* guess 9 < actual length < 100 */;\n", "String line = len + \" \" + key + \"=\" + value + \"\\n\";\n", "int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n", "while (len != actualLength) {\n", "// Adjust for cases where length < 10 or > 100\n", "// or where UTF-8 encoding isn't a single octet\n", "// per character.\n", "// Must be in loop as size may go from 99 to 100 in\n", "// first pass so we'd need a second.\n", "len = actualLength;\n", "line = len + \" \" + key + \"=\" + value + \"\\n\";\n", "actualLength = line.getBytes(CharsetNames.UTF_8).length;\n", "}\n", "w.write(line);\n", "}\n", "byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n", "pex.setSize(data.length);\n", "putArchiveEntry(pex);\n", "write(data);\n", "closeArchiveEntry();\n", "}\n"], "faulty_lines": [4, 6], "cluster": 5}, {"pid": "Compress", "bid": 20, "method_path": "./dataset/Compress/20/CpioArchiveInputStream.java", "method": ["private CpioArchiveEntry readNewEntry(final boolean hasCrc)\n", "throws IOException {\n", "CpioArchiveEntry ret;\n", "if (hasCrc) {\n", "ret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n", "} else {\n", "ret = new CpioArchiveEntry(FORMAT_NEW);\n", "}\n", "\n", "ret.setInode(readAsciiLong(8, 16));\n", "long mode = readAsciiLong(8, 16);\n", "if (mode != 0){\n", "ret.setMode(mode);\n", "}\n", "ret.setUID(readAsciiLong(8, 16));\n", "ret.setGID(readAsciiLong(8, 16));\n", "ret.setNumberOfLinks(readAsciiLong(8, 16));\n", "ret.setTime(readAsciiLong(8, 16));\n", "ret.setSize(readAsciiLong(8, 16));\n", "ret.setDeviceMaj(readAsciiLong(8, 16));\n", "ret.setDeviceMin(readAsciiLong(8, 16));\n", "ret.setRemoteDeviceMaj(readAsciiLong(8, 16));\n", "ret.setRemoteDeviceMin(readAsciiLong(8, 16));\n", "long namesize = readAsciiLong(8, 16);\n", "ret.setChksum(readAsciiLong(8, 16));\n", "String name = readCString((int) namesize);\n", "ret.setName(name);\n", "if (mode == 0 && !name.equals(CPIO_TRAILER)){\n", "throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead());\n", "}\n", "skip(ret.getHeaderPadCount());\n", "\n", "return ret;\n", "}\n"], "faulty_lines": [12], "cluster": 5}, {"pid": "Compress", "bid": 20, "method_path": "./dataset/Compress/20/CpioArchiveInputStream.java", "method": ["private CpioArchiveEntry readNewEntry(final boolean hasCrc)\n", "throws IOException {\n", "CpioArchiveEntry ret;\n", "if (hasCrc) {\n", "ret = new CpioArchiveEntry(FORMAT_NEW_CRC);\n", "} else {\n", "ret = new CpioArchiveEntry(FORMAT_NEW);\n", "}\n", "\n", "ret.setInode(readAsciiLong(8, 16));\n", "long mode = readAsciiLong(8, 16);\n", "if (mode != 0){\n", "ret.setMode(mode);\n", "}\n", "ret.setUID(readAsciiLong(8, 16));\n", "ret.setGID(readAsciiLong(8, 16));\n", "ret.setNumberOfLinks(readAsciiLong(8, 16));\n", "ret.setTime(readAsciiLong(8, 16));\n", "ret.setSize(readAsciiLong(8, 16));\n", "ret.setDeviceMaj(readAsciiLong(8, 16));\n", "ret.setDeviceMin(readAsciiLong(8, 16));\n", "ret.setRemoteDeviceMaj(readAsciiLong(8, 16));\n", "ret.setRemoteDeviceMin(readAsciiLong(8, 16));\n", "long namesize = readAsciiLong(8, 16);\n", "ret.setChksum(readAsciiLong(8, 16));\n", "String name = readCString((int) namesize);\n", "ret.setName(name);\n", "if (mode == 0 && !name.equals(CPIO_TRAILER)){\n", "throw new IOException(\"Mode 0 only allowed in the trailer. Found entry name: \"+name + \" Occured at byte: \" + getBytesRead());\n", "}\n", "skip(ret.getHeaderPadCount());\n", "\n", "return ret;\n", "}\n"], "faulty_lines": [28], "cluster": 5}, {"pid": "Compress", "bid": 20, "method_path": "./dataset/Compress/20/CpioArchiveInputStream.java", "method": ["private CpioArchiveEntry readOldAsciiEntry() throws IOException {\n", "CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);\n", "\n", "ret.setDevice(readAsciiLong(6, 8));\n", "ret.setInode(readAsciiLong(6, 8));\n", "final long mode = readAsciiLong(6, 8);\n", "if (mode != 0) {\n", "ret.setMode(mode);\n", "}\n", "ret.setUID(readAsciiLong(6, 8));\n", "ret.setGID(readAsciiLong(6, 8));\n", "ret.setNumberOfLinks(readAsciiLong(6, 8));\n", "ret.setRemoteDevice(readAsciiLong(6, 8));\n", "ret.setTime(readAsciiLong(11, 8));\n", "long namesize = readAsciiLong(6, 8);\n", "ret.setSize(readAsciiLong(11, 8));\n", "final String name = readCString((int) namesize);\n", "ret.setName(name);\n", "if (mode == 0 && !name.equals(CPIO_TRAILER)){\n", "throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead());\n", "}\n", "\n", "return ret;\n", "}\n"], "faulty_lines": [7], "cluster": 8}, {"pid": "Compress", "bid": 20, "method_path": "./dataset/Compress/20/CpioArchiveInputStream.java", "method": ["private CpioArchiveEntry readOldAsciiEntry() throws IOException {\n", "CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_ASCII);\n", "\n", "ret.setDevice(readAsciiLong(6, 8));\n", "ret.setInode(readAsciiLong(6, 8));\n", "final long mode = readAsciiLong(6, 8);\n", "if (mode != 0) {\n", "ret.setMode(mode);\n", "}\n", "ret.setUID(readAsciiLong(6, 8));\n", "ret.setGID(readAsciiLong(6, 8));\n", "ret.setNumberOfLinks(readAsciiLong(6, 8));\n", "ret.setRemoteDevice(readAsciiLong(6, 8));\n", "ret.setTime(readAsciiLong(11, 8));\n", "long namesize = readAsciiLong(6, 8);\n", "ret.setSize(readAsciiLong(11, 8));\n", "final String name = readCString((int) namesize);\n", "ret.setName(name);\n", "if (mode == 0 && !name.equals(CPIO_TRAILER)){\n", "throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+ name + \" Occured at byte: \" + getBytesRead());\n", "}\n", "\n", "return ret;\n", "}\n"], "faulty_lines": [19], "cluster": 8}, {"pid": "Compress", "bid": 20, "method_path": "./dataset/Compress/20/CpioArchiveInputStream.java", "method": ["private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord)\n", "throws IOException {\n", "CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n", "\n", "ret.setDevice(readBinaryLong(2, swapHalfWord));\n", "ret.setInode(readBinaryLong(2, swapHalfWord));\n", "final long mode = readBinaryLong(2, swapHalfWord);\n", "if (mode != 0){\n", "ret.setMode(mode);\n", "}\n", "ret.setUID(readBinaryLong(2, swapHalfWord));\n", "ret.setGID(readBinaryLong(2, swapHalfWord));\n", "ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\n", "ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));\n", "ret.setTime(readBinaryLong(4, swapHalfWord));\n", "long namesize = readBinaryLong(2, swapHalfWord);\n", "ret.setSize(readBinaryLong(4, swapHalfWord));\n", "final String name = readCString((int) namesize);\n", "ret.setName(name);\n", "if (mode == 0 && !name.equals(CPIO_TRAILER)){\n", "throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead());\n", "}\n", "skip(ret.getHeaderPadCount());\n", "\n", "return ret;\n", "}\n"], "faulty_lines": [8], "cluster": 1}, {"pid": "Compress", "bid": 20, "method_path": "./dataset/Compress/20/CpioArchiveInputStream.java", "method": ["private CpioArchiveEntry readOldBinaryEntry(final boolean swapHalfWord)\n", "throws IOException {\n", "CpioArchiveEntry ret = new CpioArchiveEntry(FORMAT_OLD_BINARY);\n", "\n", "ret.setDevice(readBinaryLong(2, swapHalfWord));\n", "ret.setInode(readBinaryLong(2, swapHalfWord));\n", "final long mode = readBinaryLong(2, swapHalfWord);\n", "if (mode != 0){\n", "ret.setMode(mode);\n", "}\n", "ret.setUID(readBinaryLong(2, swapHalfWord));\n", "ret.setGID(readBinaryLong(2, swapHalfWord));\n", "ret.setNumberOfLinks(readBinaryLong(2, swapHalfWord));\n", "ret.setRemoteDevice(readBinaryLong(2, swapHalfWord));\n", "ret.setTime(readBinaryLong(4, swapHalfWord));\n", "long namesize = readBinaryLong(2, swapHalfWord);\n", "ret.setSize(readBinaryLong(4, swapHalfWord));\n", "final String name = readCString((int) namesize);\n", "ret.setName(name);\n", "if (mode == 0 && !name.equals(CPIO_TRAILER)){\n", "throw new IOException(\"Mode 0 only allowed in the trailer. Found entry: \"+name + \"Occured at byte: \" + getBytesRead());\n", "}\n", "skip(ret.getHeaderPadCount());\n", "\n", "return ret;\n", "}\n"], "faulty_lines": [20], "cluster": 1}, {"pid": "Compress", "bid": 21, "method_path": "./dataset/Compress/21/SevenZOutputFile.java", "method": ["private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n", "int cache = 0;\n", "int shift = 7;\n", "for (int i = 0; i < length; i++) {\n", "cache |= ((bits.get(i) ? 1 : 0) << shift);\n", "--shift;\n", "if (shift == 0) {\n", "header.write(cache);\n", "shift = 7;\n", "cache = 0;\n", "}\n", "}\n", "if (length > 0 && shift > 0) {\n", "header.write(cache);\n", "}\n", "}\n"], "faulty_lines": [6, 7, 13], "cluster": 4}, {"pid": "Compress", "bid": 22, "method_path": "./dataset/Compress/22/BZip2CompressorInputStream.java", "method": ["public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException {\n", "this.in = in;\n", "this.decompressConcatenated = decompressConcatenated;\n", "\n", "init(true);\n", "initBlock();\n", "setupBlock();\n", "}\n"], "faulty_lines": [7], "cluster": 0}, {"pid": "Compress", "bid": 22, "method_path": "./dataset/Compress/22/BZip2CompressorInputStream.java", "method": ["private int read0() throws IOException {\n", "final int retChar = this.currentChar;\n", "switch (currentState) {\n", "case EOF:\n", "return -1;\n", "\n", "case START_BLOCK_STATE:\n", "throw new IllegalStateException();\n", "\n", "case RAND_PART_A_STATE:\n", "throw new IllegalStateException();\n", "\n", "case RAND_PART_B_STATE:\n", "setupRandPartB();\n", "break;\n", "\n", "case RAND_PART_C_STATE:\n", "setupRandPartC();\n", "break;\n", "\n", "case NO_RAND_PART_A_STATE:\n", "throw new IllegalStateException();\n", "\n", "case NO_RAND_PART_B_STATE:\n", "setupNoRandPartB();\n", "break;\n", "\n", "case NO_RAND_PART_C_STATE:\n", "setupNoRandPartC();\n", "break;\n", "\n", "default:\n", "throw new IllegalStateException();\n", "}\n", "return retChar;\n", "}\n"], "faulty_lines": [2, 8, 14, 15, 18, 19, 25, 26, 29, 30, 35], "cluster": 2}, {"pid": "Compress", "bid": 22, "method_path": "./dataset/Compress/22/BZip2CompressorInputStream.java", "method": ["private int setupRandPartA() throws IOException {\n", "if (this.su_i2 <= this.last) {\n", "this.su_chPrev = this.su_ch2;\n", "int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\n", "this.su_tPos = this.data.tt[this.su_tPos];\n", "if (this.su_rNToGo == 0) {\n", "this.su_rNToGo = Rand.rNums(this.su_rTPos) - 1;\n", "if (++this.su_rTPos == 512) {\n", "this.su_rTPos = 0;\n", "}\n", "} else {\n", "this.su_rNToGo--;\n", "}\n", "this.su_ch2 = su_ch2Shadow ^= (this.su_rNToGo == 1) ? 1 : 0;\n", "this.su_i2++;\n", "this.currentChar = su_ch2Shadow;\n", "this.currentState = RAND_PART_B_STATE;\n", "this.crc.updateCRC(su_ch2Shadow);\n", "return su_ch2Shadow;\n", "} else {\n", "endBlock();\n", "initBlock();\n", "return setupBlock();\n", "}\n", "}\n"], "faulty_lines": [16], "cluster": 8}, {"pid": "Compress", "bid": 22, "method_path": "./dataset/Compress/22/BZip2CompressorInputStream.java", "method": ["private int setupNoRandPartA() throws IOException {\n", "if (this.su_i2 <= this.last) {\n", "this.su_chPrev = this.su_ch2;\n", "int su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\n", "this.su_ch2 = su_ch2Shadow;\n", "this.su_tPos = this.data.tt[this.su_tPos];\n", "this.su_i2++;\n", "this.currentChar = su_ch2Shadow;\n", "this.currentState = NO_RAND_PART_B_STATE;\n", "this.crc.updateCRC(su_ch2Shadow);\n", "return su_ch2Shadow;\n", "} else {\n", "this.currentState = NO_RAND_PART_A_STATE;\n", "endBlock();\n", "initBlock();\n", "return setupBlock();\n", "}\n", "}\n"], "faulty_lines": [8], "cluster": 2}, {"pid": "Compress", "bid": 22, "method_path": "./dataset/Compress/22/BZip2CompressorInputStream.java", "method": ["private int setupRandPartC() throws IOException {\n", "if (this.su_j2 < this.su_z) {\n", "this.currentChar = this.su_ch2;\n", "this.crc.updateCRC(this.su_ch2);\n", "this.su_j2++;\n", "return this.su_ch2;\n", "} else {\n", "this.currentState = RAND_PART_A_STATE;\n", "this.su_i2++;\n", "this.su_count = 0;\n", "return setupRandPartA();\n", "}\n", "}\n"], "faulty_lines": [3], "cluster": 4}, {"pid": "Compress", "bid": 22, "method_path": "./dataset/Compress/22/BZip2CompressorInputStream.java", "method": ["private int setupNoRandPartC() throws IOException {\n", "if (this.su_j2 < this.su_z) {\n", "int su_ch2Shadow = this.su_ch2;\n", "this.currentChar = su_ch2Shadow;\n", "this.crc.updateCRC(su_ch2Shadow);\n", "this.su_j2++;\n", "this.currentState = NO_RAND_PART_C_STATE;\n", "return su_ch2Shadow;\n", "} else {\n", "this.su_i2++;\n", "this.su_count = 0;\n", "return setupNoRandPartA();\n", "}\n", "}\n"], "faulty_lines": [4], "cluster": 2}, {"pid": "Compress", "bid": 24, "method_path": "./dataset/Compress/24/TarUtils.java", "method": ["public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n", "long    result = 0;\n", "int     end = offset + length;\n", "int     start = offset;\n", "\n", "if (length < 2){\n", "throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n", "}\n", "\n", "if (buffer[start] == 0) {\n", "return 0L;\n", "}\n", "\n", "// Skip leading spaces\n", "while (start < end){\n", "if (buffer[start] == ' '){\n", "start++;\n", "} else {\n", "break;\n", "}\n", "}\n", "\n", "// Trim all trailing NULs and spaces.\n", "// The ustar and POSIX tar specs require a trailing NUL or\n", "// space but some implementations use the extra digit for big\n", "// sizes/uids/gids ...\n", "byte trailer = buffer[end - 1];\n", "if (trailer == 0 || trailer == ' '){\n", "end--;\n", "} else {\n", "throw new IllegalArgumentException(\n", "exceptionMessage(buffer, offset, length, end-1, trailer));\n", "}\n", "trailer = buffer[end - 1];\n", "while (start < end - 1 && (trailer == 0 || trailer == ' ')) {\n", "end--;\n", "trailer = buffer[end - 1];\n", "}\n", "\n", "for ( ;start < end; start++) {\n", "final byte currentByte = buffer[start];\n", "// CheckStyle:MagicNumber OFF\n", "if (currentByte < '0' || currentByte > '7'){\n", "throw new IllegalArgumentException(\n", "exceptionMessage(buffer, offset, length, start, currentByte));\n", "}\n", "result = (result << 3) + (currentByte - '0'); // convert from ASCII\n", "// CheckStyle:MagicNumber ON\n", "}\n", "\n", "return result;\n", "}\n"], "faulty_lines": [28, 30, 32, 33, 34, 35, 36, 37], "cluster": 5}, {"pid": "Compress", "bid": 25, "method_path": "./dataset/Compress/25/ZipArchiveInputStream.java", "method": ["boolean allowStoredEntriesWithDataDescriptor) {\n", "zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n", "this.useUnicodeExtraFields = useUnicodeExtraFields;\n", "in = new PushbackInputStream(inputStream, buf.capacity());\n", "this.allowStoredEntriesWithDataDescriptor =\n", "allowStoredEntriesWithDataDescriptor;\n", "// haven't read anything so far\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Compress", "bid": 26, "method_path": "./dataset/Compress/26/IOUtils.java", "method": ["public static long skip(InputStream input, long numToSkip) throws IOException {\n", "long available = numToSkip;\n", "while (numToSkip > 0) {\n", "long skipped = input.skip(numToSkip);\n", "if (skipped == 0) {\n", "break;\n", "}\n", "numToSkip -= skipped;\n", "}\n", "\n", "return available - numToSkip;\n", "}\n"], "faulty_lines": [11], "cluster": 4}, {"pid": "Compress", "bid": 27, "method_path": "./dataset/Compress/27/TarUtils.java", "method": ["public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n", "long    result = 0;\n", "int     end = offset + length;\n", "int     start = offset;\n", "\n", "if (length < 2){\n", "throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n", "}\n", "\n", "if (buffer[start] == 0) {\n", "return 0L;\n", "}\n", "\n", "// Skip leading spaces\n", "while (start < end){\n", "if (buffer[start] == ' '){\n", "start++;\n", "} else {\n", "break;\n", "}\n", "}\n", "\n", "// Trim all trailing NULs and spaces.\n", "// The ustar and POSIX tar specs require a trailing NUL or\n", "// space but some implementations use the extra digit for big\n", "// sizes/uids/gids ...\n", "byte trailer = buffer[end - 1];\n", "while (start < end && (trailer == 0 || trailer == ' ')) {\n", "end--;\n", "trailer = buffer[end - 1];\n", "}\n", "if (start == end) {\n", "throw new IllegalArgumentException(\n", "exceptionMessage(buffer, offset, length, start, trailer));\n", "}\n", "\n", "for ( ;start < end; start++) {\n", "final byte currentByte = buffer[start];\n", "// CheckStyle:MagicNumber OFF\n", "if (currentByte < '0' || currentByte > '7'){\n", "throw new IllegalArgumentException(\n", "exceptionMessage(buffer, offset, length, start, currentByte));\n", "}\n", "result = (result << 3) + (currentByte - '0'); // convert from ASCII\n", "// CheckStyle:MagicNumber ON\n", "}\n", "\n", "return result;\n", "}\n"], "faulty_lines": [32, 33, 34, 35], "cluster": 5}, {"pid": "Compress", "bid": 28, "method_path": "./dataset/Compress/28/TarArchiveInputStream.java", "method": ["public int read(byte[] buf, int offset, int numToRead) throws IOException {\n", "int totalRead = 0;\n", "\n", "if (hasHitEOF || entryOffset >= entrySize) {\n", "return -1;\n", "}\n", "\n", "if (currEntry == null) {\n", "throw new IllegalStateException(\"No current tar entry\");\n", "}\n", "\n", "numToRead = Math.min(numToRead, available());\n", "\n", "totalRead = is.read(buf, offset, numToRead);\n", "count(totalRead);\n", "\n", "if (totalRead == -1) {\n", "hasHitEOF = true;\n", "} else {\n", "entryOffset += totalRead;\n", "}\n", "\n", "return totalRead;\n", "}\n"], "faulty_lines": [15, 18, 20], "cluster": 2}, {"pid": "Compress", "bid": 29, "method_path": "./dataset/Compress/29/ArchiveStreamFactory.java", "method": ["public ArchiveOutputStream createArchiveOutputStream(\n", "final String archiverName, final OutputStream out)\n", "throws ArchiveException {\n", "if (archiverName == null) {\n", "throw new IllegalArgumentException(\"Archivername must not be null.\");\n", "}\n", "if (out == null) {\n", "throw new IllegalArgumentException(\"OutputStream must not be null.\");\n", "}\n", "\n", "if (AR.equalsIgnoreCase(archiverName)) {\n", "return new ArArchiveOutputStream(out);\n", "}\n", "if (ZIP.equalsIgnoreCase(archiverName)) {\n", "ZipArchiveOutputStream zip = new ZipArchiveOutputStream(out);\n", "if (entryEncoding != null) {\n", "zip.setEncoding(entryEncoding);\n", "}\n", "return zip;\n", "}\n", "if (TAR.equalsIgnoreCase(archiverName)) {\n", "if (entryEncoding != null) {\n", "return new TarArchiveOutputStream(out, entryEncoding);\n", "} else {\n", "return new TarArchiveOutputStream(out);\n", "}\n", "}\n", "if (JAR.equalsIgnoreCase(archiverName)) {\n", "return new JarArchiveOutputStream(out);\n", "}\n", "if (CPIO.equalsIgnoreCase(archiverName)) {\n", "if (entryEncoding != null) {\n", "return new CpioArchiveOutputStream(out, entryEncoding);\n", "} else {\n", "return new CpioArchiveOutputStream(out);\n", "}\n", "}\n", "if (SEVEN_Z.equalsIgnoreCase(archiverName)) {\n", "throw new StreamingNotSupportedException(SEVEN_Z);\n", "}\n", "throw new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n", "}\n"], "faulty_lines": [29, 30], "cluster": 5}, {"pid": "Compress", "bid": 29, "method_path": "./dataset/Compress/29/ArchiveStreamFactory.java", "method": ["public ArchiveInputStream createArchiveInputStream(final InputStream in)\n", "throws ArchiveException {\n", "if (in == null) {\n", "throw new IllegalArgumentException(\"Stream must not be null.\");\n", "}\n", "\n", "if (!in.markSupported()) {\n", "throw new IllegalArgumentException(\"Mark is not supported.\");\n", "}\n", "\n", "final byte[] signature = new byte[12];\n", "in.mark(signature.length);\n", "try {\n", "int signatureLength = IOUtils.readFully(in, signature);\n", "in.reset();\n", "if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n", "if (entryEncoding != null) {\n", "return new ZipArchiveInputStream(in, entryEncoding);\n", "} else {\n", "return new ZipArchiveInputStream(in);\n", "}\n", "} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n", "if (entryEncoding != null) {\n", "return new JarArchiveInputStream(in, entryEncoding);\n", "} else {\n", "return new JarArchiveInputStream(in);\n", "}\n", "} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n", "return new ArArchiveInputStream(in);\n", "} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n", "if (entryEncoding != null) {\n", "return new CpioArchiveInputStream(in, entryEncoding);\n", "} else {\n", "return new CpioArchiveInputStream(in);\n", "}\n", "} else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n", "return new ArjArchiveInputStream(in);\n", "} else if (SevenZFile.matches(signature, signatureLength)) {\n", "throw new StreamingNotSupportedException(SEVEN_Z);\n", "}\n", "\n", "// Dump needs a bigger buffer to check the signature;\n", "final byte[] dumpsig = new byte[32];\n", "in.mark(dumpsig.length);\n", "signatureLength = IOUtils.readFully(in, dumpsig);\n", "in.reset();\n", "if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n", "return new DumpArchiveInputStream(in, entryEncoding);\n", "}\n", "\n", "// Tar needs an even bigger buffer to check the signature; read the first block\n", "final byte[] tarheader = new byte[512];\n", "in.mark(tarheader.length);\n", "signatureLength = IOUtils.readFully(in, tarheader);\n", "in.reset();\n", "if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n", "return new TarArchiveInputStream(in, entryEncoding);\n", "}\n", "// COMPRESS-117 - improve auto-recognition\n", "if (signatureLength >= 512) {\n", "TarArchiveInputStream tais = null;\n", "try {\n", "tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n", "// COMPRESS-191 - verify the header checksum\n", "if (tais.getNextTarEntry().isCheckSumOK()) {\n", "return new TarArchiveInputStream(in, encoding);\n", "}\n", "} catch (Exception e) { // NOPMD\n", "// can generate IllegalArgumentException as well\n", "// as IOException\n", "// autodetection, simply not a TAR\n", "// ignored\n", "} finally {\n", "IOUtils.closeQuietly(tais);\n", "}\n", "}\n", "} catch (IOException e) {\n", "throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n", "}\n", "\n", "throw new ArchiveException(\"No Archiver found for the stream signature\");\n", "}\n"], "faulty_lines": [37, 38], "cluster": 6}, {"pid": "Compress", "bid": 29, "method_path": "./dataset/Compress/29/CpioArchiveInputStream.java", "method": ["public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n", "this.in = in;\n", "this.blockSize = blockSize;\n", "this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Compress", "bid": 29, "method_path": "./dataset/Compress/29/CpioArchiveOutputStream.java", "method": ["public CpioArchiveOutputStream(final OutputStream out, final short format,\n", "final int blockSize, final String encoding) {\n", "this.out = out;\n", "switch (format) {\n", "case FORMAT_NEW:\n", "case FORMAT_NEW_CRC:\n", "case FORMAT_OLD_ASCII:\n", "case FORMAT_OLD_BINARY:\n", "break;\n", "default:\n", "throw new IllegalArgumentException(\"Unknown format: \"+format);\n", "\n", "}\n", "this.entryFormat = format;\n", "this.blockSize = blockSize;\n", "this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n", "}\n"], "faulty_lines": [16], "cluster": 2}, {"pid": "Compress", "bid": 29, "method_path": "./dataset/Compress/29/DumpArchiveInputStream.java", "method": ["public DumpArchiveInputStream(InputStream is, String encoding)\n", "throws ArchiveException {\n", "this.raw = new TapeInputStream(is);\n", "this.hasHitEOF = false;\n", "this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n", "\n", "try {\n", "// read header, verify it's a dump archive.\n", "byte[] headerBytes = raw.readRecord();\n", "\n", "if (!DumpArchiveUtil.verify(headerBytes)) {\n", "throw new UnrecognizedFormatException();\n", "}\n", "\n", "// get summary information\n", "summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n", "\n", "// reset buffer with actual block size.\n", "raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n", "\n", "// allocate our read buffer.\n", "blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n", "\n", "// skip past CLRI and BITS segments since we don't handle them yet.\n", "readCLRI();\n", "readBITS();\n", "} catch (IOException ex) {\n", "throw new ArchiveException(ex.getMessage(), ex);\n", "}\n", "\n", "// put in a dummy record for the root node.\n", "Dirent root = new Dirent(2, 2, 4, \".\");\n", "names.put(2, root);\n", "\n", "// use priority based on queue to ensure parent directories are\n", "// released first.\n", "queue = new PriorityQueue<DumpArchiveEntry>(10,\n", "new Comparator<DumpArchiveEntry>() {\n", "public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n", "if (p.getOriginalName() == null || q.getOriginalName() == null) {\n", "return Integer.MAX_VALUE;\n", "}\n", "\n", "return p.getOriginalName().compareTo(q.getOriginalName());\n", "}\n", "});\n", "}\n"], "faulty_lines": [5], "cluster": 5}, {"pid": "Compress", "bid": 29, "method_path": "./dataset/Compress/29/TarArchiveInputStream.java", "method": ["public TarArchiveInputStream(InputStream is, int blockSize, int recordSize,\n", "String encoding) {\n", "this.is = is;\n", "this.hasHitEOF = false;\n", "this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n", "this.recordSize = recordSize;\n", "this.blockSize = blockSize;\n", "}\n"], "faulty_lines": [5], "cluster": 4}, {"pid": "Compress", "bid": 29, "method_path": "./dataset/Compress/29/TarArchiveOutputStream.java", "method": ["public TarArchiveOutputStream(OutputStream os, int blockSize,\n", "int recordSize, String encoding) {\n", "out = new CountingOutputStream(os);\n", "this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n", "\n", "this.assemLen = 0;\n", "this.assemBuf = new byte[recordSize];\n", "this.recordBuf = new byte[recordSize];\n", "this.recordSize = recordSize;\n", "this.recordsPerBlock = blockSize / recordSize;\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Compress", "bid": 29, "method_path": "./dataset/Compress/29/ZipArchiveInputStream.java", "method": ["boolean useUnicodeExtraFields,\n", "boolean allowStoredEntriesWithDataDescriptor) {\n", "zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n", "this.useUnicodeExtraFields = useUnicodeExtraFields;\n", "in = new PushbackInputStream(inputStream, buf.capacity());\n", "this.allowStoredEntriesWithDataDescriptor =\n", "allowStoredEntriesWithDataDescriptor;\n", "// haven't read anything so far\n", "buf.limit(0);\n", "}\n"], "faulty_lines": [3], "cluster": 4}, {"pid": "Compress", "bid": 30, "method_path": "./dataset/Compress/30/BZip2CompressorInputStream.java", "method": ["public int read(final byte[] dest, final int offs, final int len)\n", "throws IOException {\n", "if (offs < 0) {\n", "throw new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n", "}\n", "if (len < 0) {\n", "throw new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n", "}\n", "if (offs + len > dest.length) {\n", "throw new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n", "+ len + \") > dest.length(\" + dest.length + \").\");\n", "}\n", "if (this.in == null) {\n", "throw new IOException(\"stream closed\");\n", "}\n", "\n", "final int hi = offs + len;\n", "int destOffs = offs;\n", "int b;\n", "while (destOffs < hi && ((b = read0()) >= 0)) {\n", "dest[destOffs++] = (byte) b;\n", "count(1);\n", "}\n", "\n", "int c = (destOffs == offs) ? -1 : (destOffs - offs);\n", "return c;\n", "}\n"], "faulty_lines": [16], "cluster": 8}, {"pid": "Compress", "bid": 31, "method_path": "./dataset/Compress/31/TarUtils.java", "method": ["public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n", "long    result = 0;\n", "int     end = offset + length;\n", "int     start = offset;\n", "\n", "if (length < 2){\n", "throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n", "}\n", "\n", "if (buffer[start] == 0) {\n", "return 0L;\n", "}\n", "\n", "// Skip leading spaces\n", "while (start < end){\n", "if (buffer[start] == ' '){\n", "start++;\n", "} else {\n", "break;\n", "}\n", "}\n", "\n", "// Trim all trailing NULs and spaces.\n", "// The ustar and POSIX tar specs require a trailing NUL or\n", "// space but some implementations use the extra digit for big\n", "// sizes/uids/gids ...\n", "byte trailer = buffer[end - 1];\n", "while (start < end && (trailer == 0 || trailer == ' ')) {\n", "end--;\n", "trailer = buffer[end - 1];\n", "}\n", "\n", "for ( ;start < end; start++) {\n", "final byte currentByte = buffer[start];\n", "if (currentByte == 0) {\n", "break;\n", "}\n", "// CheckStyle:MagicNumber OFF\n", "if (currentByte < '0' || currentByte > '7'){\n", "throw new IllegalArgumentException(\n", "exceptionMessage(buffer, offset, length, start, currentByte));\n", "}\n", "result = (result << 3) + (currentByte - '0'); // convert from ASCII\n", "// CheckStyle:MagicNumber ON\n", "}\n", "\n", "return result;\n", "}\n"], "faulty_lines": [35, 36, 37], "cluster": 1}, {"pid": "Compress", "bid": 32, "method_path": "./dataset/Compress/32/TarArchiveInputStream.java", "method": ["private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n", "/*\n", "* The following headers are defined for Pax.\n", "* atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n", "* mtime\n", "* comment\n", "* gid, gname\n", "* linkpath\n", "* size\n", "* uid,uname\n", "* SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n", "*/\n", "for (Entry<String, String> ent : headers.entrySet()){\n", "String key = ent.getKey();\n", "String val = ent.getValue();\n", "if (\"path\".equals(key)){\n", "currEntry.setName(val);\n", "} else if (\"linkpath\".equals(key)){\n", "currEntry.setLinkName(val);\n", "} else if (\"gid\".equals(key)){\n", "currEntry.setGroupId(Integer.parseInt(val));\n", "} else if (\"gname\".equals(key)){\n", "currEntry.setGroupName(val);\n", "} else if (\"uid\".equals(key)){\n", "currEntry.setUserId(Integer.parseInt(val));\n", "} else if (\"uname\".equals(key)){\n", "currEntry.setUserName(val);\n", "} else if (\"size\".equals(key)){\n", "currEntry.setSize(Long.parseLong(val));\n", "} else if (\"mtime\".equals(key)){\n", "currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n", "} else if (\"SCHILY.devminor\".equals(key)){\n", "currEntry.setDevMinor(Integer.parseInt(val));\n", "} else if (\"SCHILY.devmajor\".equals(key)){\n", "currEntry.setDevMajor(Integer.parseInt(val));\n", "}\n", "}\n", "}\n"], "faulty_lines": [21, 25], "cluster": 5}, {"pid": "Compress", "bid": 33, "method_path": "./dataset/Compress/33/CompressorStreamFactory.java", "method": ["public CompressorInputStream createCompressorInputStream(final InputStream in)\n", "throws CompressorException {\n", "if (in == null) {\n", "throw new IllegalArgumentException(\"Stream must not be null.\");\n", "}\n", "\n", "if (!in.markSupported()) {\n", "throw new IllegalArgumentException(\"Mark is not supported.\");\n", "}\n", "\n", "final byte[] signature = new byte[12];\n", "in.mark(signature.length);\n", "try {\n", "int signatureLength = IOUtils.readFully(in, signature);\n", "in.reset();\n", "\n", "if (BZip2CompressorInputStream.matches(signature, signatureLength)) {\n", "return new BZip2CompressorInputStream(in, decompressConcatenated);\n", "}\n", "\n", "if (GzipCompressorInputStream.matches(signature, signatureLength)) {\n", "return new GzipCompressorInputStream(in, decompressConcatenated);\n", "}\n", "\n", "if (Pack200CompressorInputStream.matches(signature, signatureLength)) {\n", "return new Pack200CompressorInputStream(in);\n", "}\n", "\n", "if (FramedSnappyCompressorInputStream.matches(signature, signatureLength)) {\n", "return new FramedSnappyCompressorInputStream(in);\n", "}\n", "\n", "if (ZCompressorInputStream.matches(signature, signatureLength)) {\n", "return new ZCompressorInputStream(in);\n", "}\n", "\n", "\n", "if (XZUtils.matches(signature, signatureLength) &&\n", "XZUtils.isXZCompressionAvailable()) {\n", "return new XZCompressorInputStream(in, decompressConcatenated);\n", "}\n", "\n", "if (LZMAUtils.matches(signature, signatureLength) &&\n", "LZMAUtils.isLZMACompressionAvailable()) {\n", "return new LZMACompressorInputStream(in);\n", "}\n", "\n", "} catch (IOException e) {\n", "throw new CompressorException(\"Failed to detect Compressor from InputStream.\", e);\n", "}\n", "\n", "throw new CompressorException(\"No Compressor found for the stream signature.\");\n", "}\n"], "faulty_lines": [37], "cluster": 5}, {"pid": "Compress", "bid": 33, "method_path": "./dataset/Compress/33/DeflateCompressorInputStream.java", "method": ["public class DeflateCompressorInputStream extends CompressorInputStream {\n", "\n", "private final InputStream in;\n", "\n", "/**\n", "* Creates a new input stream that decompresses Deflate-compressed data\n", "* from the specified input stream.\n", "*\n", "* @param       inputStream where to read the compressed data\n", "*\n", "*/\n", "public DeflateCompressorInputStream(InputStream inputStream) {\n", "this(inputStream, new DeflateParameters());\n", "}\n", "\n", "/**\n", "* Creates a new input stream that decompresses Deflate-compressed data\n", "* from the specified input stream.\n", "*\n", "* @param       inputStream where to read the compressed data\n", "* @param       parameters parameters\n", "*/\n", "public DeflateCompressorInputStream(InputStream inputStream,\n", "DeflateParameters parameters) {\n", "in = new InflaterInputStream(inputStream, new Inflater(!parameters.withZlibHeader()));\n", "}\n", "\n", "/** {@inheritDoc} */\n", "@Override\n", "public int read() throws IOException {\n", "int ret = in.read();\n", "count(ret == -1 ? 0 : 1);\n", "return ret;\n", "}\n", "\n", "/** {@inheritDoc} */\n", "@Override\n", "public int read(byte[] buf, int off, int len) throws IOException {\n", "int ret = in.read(buf, off, len);\n", "count(ret);\n", "return ret;\n", "}\n", "\n", "/** {@inheritDoc} */\n", "@Override\n", "public long skip(long n) throws IOException {\n", "return in.skip(n);\n", "}\n", "\n", "/** {@inheritDoc} */\n", "@Override\n", "public int available() throws IOException {\n", "return in.available();\n", "}\n", "\n", "/** {@inheritDoc} */\n", "@Override\n", "public void close() throws IOException {\n", "in.close();\n", "}\n", "\n", "/**\n", "* Checks if the signature matches what is expected for a zlib / deflated file\n", "*  with the zlib header.\n", "*\n", "* @param signature\n", "*            the bytes to check\n", "* @param length\n", "*            the number of bytes to check\n", "* @return true, if this stream is zlib / deflate compressed with a header\n", "* stream, false otherwise\n", "*\n", "* @since 1.9\n", "*/\n", "}\n"], "faulty_lines": [2], "cluster": 3}, {"pid": "Compress", "bid": 34, "method_path": "./dataset/Compress/34/X7875_NewUnix.java", "method": ["public class X7875_NewUnix implements ZipExtraField, Cloneable, Serializable {\n", "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\n", "private static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\n", "private static final long serialVersionUID = 1L;\n", "\n", "private int version = 1; // always '1' according to current info-zip spec.\n", "\n", "// BigInteger helps us with little-endian / big-endian conversions.\n", "// (thanks to BigInteger.toByteArray() and a reverse() method we created).\n", "// Also, the spec theoretically allows UID/GID up to 255 bytes long!\n", "//\n", "// NOTE:  equals() and hashCode() currently assume these can never be null.\n", "private BigInteger uid;\n", "private BigInteger gid;\n", "\n", "/**\n", "* Constructor for X7875_NewUnix.\n", "*/\n", "public X7875_NewUnix() {\n", "reset();\n", "}\n", "\n", "/**\n", "* The Header-ID.\n", "*\n", "* @return the value for the header id for this extrafield\n", "*/\n", "public ZipShort getHeaderId() {\n", "return HEADER_ID;\n", "}\n", "\n", "/**\n", "* Gets the UID as a long.  UID is typically a 32 bit unsigned\n", "* value on most UNIX systems, so we return a long to avoid\n", "* integer overflow into the negatives in case values above\n", "* and including 2^31 are being used.\n", "*\n", "* @return the UID value.\n", "*/\n", "public long getUID() { return ZipUtil.bigToLong(uid); }\n", "\n", "/**\n", "* Gets the GID as a long.  GID is typically a 32 bit unsigned\n", "* value on most UNIX systems, so we return a long to avoid\n", "* integer overflow into the negatives in case values above\n", "* and including 2^31 are being used.\n", "*\n", "* @return the GID value.\n", "*/\n", "public long getGID() { return ZipUtil.bigToLong(gid); }\n", "\n", "/**\n", "* Sets the UID.\n", "*\n", "* @param l UID value to set on this extra field.\n", "*/\n", "public void setUID(long l) {\n", "this.uid = ZipUtil.longToBig(l);\n", "}\n", "\n", "/**\n", "* Sets the GID.\n", "*\n", "* @param l GID value to set on this extra field.\n", "*/\n", "public void setGID(long l) {\n", "this.gid = ZipUtil.longToBig(l);\n", "}\n", "\n", "/**\n", "* Length of the extra field in the local file data - without\n", "* Header-ID or length specifier.\n", "*\n", "* @return a <code>ZipShort</code> for the length of the data of this extra field\n", "*/\n", "public ZipShort getLocalFileDataLength() {\n", "int uidSize = trimLeadingZeroesForceMinLength(uid.toByteArray()).length;\n", "int gidSize = trimLeadingZeroesForceMinLength(gid.toByteArray()).length;\n", "\n", "// The 3 comes from:  version=1 + uidsize=1 + gidsize=1\n", "return new ZipShort(3 + uidSize + gidSize);\n", "}\n", "\n", "/**\n", "* Length of the extra field in the central directory data - without\n", "* Header-ID or length specifier.\n", "*\n", "* @return a <code>ZipShort</code> for the length of the data of this extra field\n", "*/\n", "public ZipShort getCentralDirectoryLength() {\n", "return getLocalFileDataLength();\n", "}\n", "\n", "/**\n", "* The actual data to put into local file data - without Header-ID\n", "* or length specifier.\n", "*\n", "* @return get the data\n", "*/\n", "public byte[] getLocalFileDataData() {\n", "byte[] uidBytes = uid.toByteArray();\n", "byte[] gidBytes = gid.toByteArray();\n", "\n", "// BigInteger might prepend a leading-zero to force a positive representation\n", "// (e.g., so that the sign-bit is set to zero).  We need to remove that\n", "// before sending the number over the wire.\n", "uidBytes = trimLeadingZeroesForceMinLength(uidBytes);\n", "gidBytes = trimLeadingZeroesForceMinLength(gidBytes);\n", "\n", "// Couldn't bring myself to just call getLocalFileDataLength() when we've\n", "// already got the arrays right here.  Yeah, yeah, I know, premature\n", "// optimization is the root of all...\n", "//\n", "// The 3 comes from:  version=1 + uidsize=1 + gidsize=1\n", "byte[] data = new byte[3 + uidBytes.length + gidBytes.length];\n", "\n", "// reverse() switches byte array from big-endian to little-endian.\n", "reverse(uidBytes);\n", "reverse(gidBytes);\n", "\n", "int pos = 0;\n", "data[pos++] = unsignedIntToSignedByte(version);\n", "data[pos++] = unsignedIntToSignedByte(uidBytes.length);\n", "System.arraycopy(uidBytes, 0, data, pos, uidBytes.length);\n", "pos += uidBytes.length;\n", "data[pos++] = unsignedIntToSignedByte(gidBytes.length);\n", "System.arraycopy(gidBytes, 0, data, pos, gidBytes.length);\n", "return data;\n", "}\n", "\n", "/**\n", "* The actual data to put into central directory data - without Header-ID\n", "* or length specifier.\n", "*\n", "* @return get the data\n", "*/\n", "public byte[] getCentralDirectoryData() {\n", "return new byte[0];\n", "}\n", "\n", "/**\n", "* Populate data from this array as if it was in local file data.\n", "*\n", "* @param data   an array of bytes\n", "* @param offset the start offset\n", "* @param length the number of bytes in the array from offset\n", "* @throws java.util.zip.ZipException on error\n", "*/\n", "public void parseFromLocalFileData(\n", "byte[] data, int offset, int length\n", ") throws ZipException {\n", "reset();\n", "this.version = signedByteToUnsignedInt(data[offset++]);\n", "int uidSize = signedByteToUnsignedInt(data[offset++]);\n", "byte[] uidBytes = new byte[uidSize];\n", "System.arraycopy(data, offset, uidBytes, 0, uidSize);\n", "offset += uidSize;\n", "this.uid = new BigInteger(1, reverse(uidBytes)); // sign-bit forced positive\n", "\n", "int gidSize = signedByteToUnsignedInt(data[offset++]);\n", "byte[] gidBytes = new byte[gidSize];\n", "System.arraycopy(data, offset, gidBytes, 0, gidSize);\n", "this.gid = new BigInteger(1, reverse(gidBytes)); // sign-bit forced positive\n", "}\n", "\n", "/**\n", "* Doesn't do anything since this class doesn't store anything\n", "* inside the central directory.\n", "*/\n", "public void parseFromCentralDirectoryData(\n", "byte[] buffer, int offset, int length\n", ") throws ZipException {\n", "}\n", "\n", "/**\n", "* Reset state back to newly constructed state.  Helps us make sure\n", "* parse() calls always generate clean results.\n", "*/\n", "private void reset() {\n", "// Typical UID/GID of the first non-root user created on a unix system.\n", "uid = ONE_THOUSAND;\n", "gid = ONE_THOUSAND;\n", "}\n", "\n", "/**\n", "* Returns a String representation of this class useful for\n", "* debugging purposes.\n", "*\n", "* @return A String representation of this class useful for\n", "*         debugging purposes.\n", "*/\n", "@Override\n", "public String toString() {\n", "return \"0x7875 Zip Extra Field: UID=\" + uid + \" GID=\" + gid;\n", "}\n", "\n", "@Override\n", "public Object clone() throws CloneNotSupportedException {\n", "return super.clone();\n", "}\n", "\n", "@Override\n", "public boolean equals(Object o) {\n", "if (o instanceof X7875_NewUnix) {\n", "X7875_NewUnix xf = (X7875_NewUnix) o;\n", "// We assume uid and gid can never be null.\n", "return version == xf.version && uid.equals(xf.uid) && gid.equals(xf.gid);\n", "}\n", "return false;\n", "}\n", "\n", "@Override\n", "public int hashCode() {\n", "int hc = -1234567 * version;\n", "// Since most UID's and GID's are below 65,536, this is (hopefully!)\n", "// a nice way to make sure typical UID and GID values impact the hash\n", "// as much as possible.\n", "hc ^= Integer.rotateLeft(uid.hashCode(), 16);\n", "hc ^= gid.hashCode();\n", "return hc;\n", "}\n", "\n", "/**\n", "* Not really for external usage, but marked \"package\" visibility\n", "* to help us JUnit it.   Trims a byte array of leading zeroes while\n", "* also enforcing a minimum length, and thus it really trims AND pads\n", "* at the same time.\n", "*\n", "* @param array byte[] array to trim & pad.\n", "* @return trimmed & padded byte[] array.\n", "*/\n", "static byte[] trimLeadingZeroesForceMinLength(byte[] array) {\n", "if (array == null) {\n", "return array;\n", "}\n", "\n", "int pos = 0;\n", "for (byte b : array) {\n", "if (b == 0) {\n", "pos++;\n", "} else {\n", "break;\n", "}\n", "}\n", "\n", "/*\n", "\n", "I agonized over my choice of MIN_LENGTH=1.  Here's the situation:\n", "InfoZip (the tool I am using to test interop) always sets these\n", "to length=4.  And so a UID of 0 (typically root) for example is\n", "encoded as {4,0,0,0,0} (len=4, 32 bits of zero), when it could just\n", "as easily be encoded as {1,0} (len=1, 8 bits of zero) according to\n", "the spec.\n", "\n", "In the end I decided on MIN_LENGTH=1 for four reasons:\n", "\n", "1.)  We are adhering to the spec as far as I can tell, and so\n", "a consumer that cannot parse this is broken.\n", "\n", "2.)  Fundamentally, zip files are about shrinking things, so\n", "let's save a few bytes per entry while we can.\n", "\n", "3.)  Of all the people creating zip files using commons-\n", "compress, how many care about UNIX UID/GID attributes\n", "of the files they store?   (e.g., I am probably thinking\n", "way too hard about this and no one cares!)\n", "\n", "4.)  InfoZip's tool, even though it carefully stores every UID/GID\n", "for every file zipped on a unix machine (by default) currently\n", "appears unable to ever restore UID/GID.\n", "unzip -X has no effect on my machine, even when run as root!!!!\n", "\n", "And thus it is decided:  MIN_LENGTH=1.\n", "\n", "If anyone runs into interop problems from this, feel free to set\n", "it to MIN_LENGTH=4 at some future time, and then we will behave\n", "exactly like InfoZip (requires changes to unit tests, though).\n", "\n", "And I am sorry that the time you spent reading this comment is now\n", "gone and you can never have it back.\n", "\n", "*/\n", "final int MIN_LENGTH = 1;\n", "\n", "byte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\n", "int startPos = trimmedArray.length - (array.length - pos);\n", "System.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\n", "return trimmedArray;\n", "}\n", "}\n"], "faulty_lines": [3], "cluster": 3}, {"pid": "Compress", "bid": 34, "method_path": "./dataset/Compress/34/X7875_NewUnix.java", "method": ["public ZipShort getCentralDirectoryLength() {\n", "return getLocalFileDataLength();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Compress", "bid": 35, "method_path": "./dataset/Compress/35/TarUtils.java", "method": ["public static boolean verifyCheckSum(byte[] header) {\n", "long storedSum = 0;\n", "long unsignedSum = 0;\n", "long signedSum = 0;\n", "\n", "int digits = 0;\n", "for (int i = 0; i < header.length; i++) {\n", "byte b = header[i];\n", "if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n", "if ('0' <= b && b <= '7' && digits++ < 6) {\n", "storedSum = storedSum * 8 + b - '0';\n", "} else if (digits > 0) {\n", "digits = 6;\n", "}\n", "b = ' ';\n", "}\n", "unsignedSum += 0xff & b;\n", "signedSum += b;\n", "}\n", "return storedSum == unsignedSum || storedSum == signedSum;\n", "}\n"], "faulty_lines": [2], "cluster": 2}, {"pid": "Compress", "bid": 35, "method_path": "./dataset/Compress/35/TarUtils.java", "method": ["public static boolean verifyCheckSum(byte[] header) {\n", "long storedSum = 0;\n", "long unsignedSum = 0;\n", "long signedSum = 0;\n", "\n", "int digits = 0;\n", "for (int i = 0; i < header.length; i++) {\n", "byte b = header[i];\n", "if (CHKSUM_OFFSET  <= i && i < CHKSUM_OFFSET + CHKSUMLEN) {\n", "if ('0' <= b && b <= '7' && digits++ < 6) {\n", "storedSum = storedSum * 8 + b - '0';\n", "} else if (digits > 0) {\n", "digits = 6;\n", "}\n", "b = ' ';\n", "}\n", "unsignedSum += 0xff & b;\n", "signedSum += b;\n", "}\n", "return storedSum == unsignedSum || storedSum == signedSum;\n", "}\n"], "faulty_lines": [10, 11, 12, 13, 14], "cluster": 2}, {"pid": "Compress", "bid": 36, "method_path": "./dataset/Compress/36/SevenZFile.java", "method": ["private InputStream getCurrentStream() throws IOException {\n", "if (deferredBlockStreams.isEmpty()) {\n", "throw new IllegalStateException(\"No current 7z entry (call getNextEntry() first).\");\n", "}\n", "\n", "while (deferredBlockStreams.size() > 1) {\n", "// In solid compression mode we need to decompress all leading folder'\n", "// streams to get access to an entry. We defer this until really needed\n", "// so that entire blocks can be skipped without wasting time for decompression.\n", "final InputStream stream = deferredBlockStreams.remove(0);\n", "IOUtils.skip(stream, Long.MAX_VALUE);\n", "stream.close();\n", "}\n", "\n", "return deferredBlockStreams.get(0);\n", "}\n"], "faulty_lines": [2], "cluster": 2}, {"pid": "Compress", "bid": 38, "method_path": "./dataset/Compress/38/TarArchiveEntry.java", "method": ["public boolean isDirectory() {\n", "if (file != null) {\n", "return file.isDirectory();\n", "}\n", "\n", "if (linkFlag == LF_DIR) {\n", "return true;\n", "}\n", "\n", "if (getName().endsWith(\"/\")) {\n", "return true;\n", "}\n", "\n", "return false;\n", "}\n"], "faulty_lines": [10], "cluster": 0}, {"pid": "Compress", "bid": 39, "method_path": "./dataset/Compress/39/ArchiveUtils.java", "method": ["public class ArchiveUtils {\n", "\n", "\n", "/** Private constructor to prevent instantiation of this utility class. */\n", "private ArchiveUtils(){\n", "}\n", "\n", "/**\n", "* Generates a string containing the name, isDirectory setting and size of an entry.\n", "* <p>\n", "* For example:\n", "* <pre>\n", "* -    2000 main.c\n", "* d     100 testfiles\n", "* </pre>\n", "*\n", "* @param entry the entry\n", "* @return the representation of the entry\n", "*/\n", "public static String toString(final ArchiveEntry entry){\n", "final StringBuilder sb = new StringBuilder();\n", "sb.append(entry.isDirectory()? 'd' : '-');// c.f. \"ls -l\" output\n", "final String size = Long.toString(entry.getSize());\n", "sb.append(' ');\n", "// Pad output to 7 places, leading spaces\n", "for(int i=7; i > size.length(); i--){\n", "sb.append(' ');\n", "}\n", "sb.append(size);\n", "sb.append(' ').append(entry.getName());\n", "return sb.toString();\n", "}\n", "\n", "/**\n", "* Check if buffer contents matches Ascii String.\n", "*\n", "* @param expected expected string\n", "* @param buffer the buffer\n", "* @param offset offset to read from\n", "* @param length length of the buffer\n", "* @return {@code true} if buffer is the same as the expected string\n", "*/\n", "public static boolean matchAsciiBuffer(\n", "final String expected, final byte[] buffer, final int offset, final int length){\n", "byte[] buffer1;\n", "try {\n", "buffer1 = expected.getBytes(CharsetNames.US_ASCII);\n", "} catch (final UnsupportedEncodingException e) {\n", "throw new RuntimeException(e); // Should not happen\n", "}\n", "return isEqual(buffer1, 0, buffer1.length, buffer, offset, length, false);\n", "}\n", "\n", "/**\n", "* Check if buffer contents matches Ascii String.\n", "*\n", "* @param expected the expected strin\n", "* @param buffer the buffer\n", "* @return {@code true} if buffer is the same as the expected string\n", "*/\n", "public static boolean matchAsciiBuffer(final String expected, final byte[] buffer){\n", "return matchAsciiBuffer(expected, buffer, 0, buffer.length);\n", "}\n", "\n", "/**\n", "* Convert a string to Ascii bytes.\n", "* Used for comparing \"magic\" strings which need to be independent of the default Locale.\n", "*\n", "* @param inputString string to convert\n", "* @return the bytes\n", "*/\n", "public static byte[] toAsciiBytes(final String inputString){\n", "try {\n", "return inputString.getBytes(CharsetNames.US_ASCII);\n", "} catch (final UnsupportedEncodingException e) {\n", "throw new RuntimeException(e); // Should never happen\n", "}\n", "}\n", "\n", "/**\n", "* Convert an input byte array to a String using the ASCII character set.\n", "*\n", "* @param inputBytes bytes to convert\n", "* @return the bytes, interpreted as an Ascii string\n", "*/\n", "public static String toAsciiString(final byte[] inputBytes){\n", "try {\n", "return new String(inputBytes, CharsetNames.US_ASCII);\n", "} catch (final UnsupportedEncodingException e) {\n", "throw new RuntimeException(e); // Should never happen\n", "}\n", "}\n", "\n", "/**\n", "* Convert an input byte array to a String using the ASCII character set.\n", "*\n", "* @param inputBytes input byte array\n", "* @param offset offset within array\n", "* @param length length of array\n", "* @return the bytes, interpreted as an Ascii string\n", "*/\n", "public static String toAsciiString(final byte[] inputBytes, final int offset, final int length){\n", "try {\n", "return new String(inputBytes, offset, length, CharsetNames.US_ASCII);\n", "} catch (final UnsupportedEncodingException e) {\n", "throw new RuntimeException(e); // Should never happen\n", "}\n", "}\n", "\n", "/**\n", "* Compare byte buffers, optionally ignoring trailing nulls\n", "*\n", "* @param buffer1 first buffer\n", "* @param offset1 first offset\n", "* @param length1 first length\n", "* @param buffer2 second buffer\n", "* @param offset2 second offset\n", "* @param length2 second length\n", "* @param ignoreTrailingNulls whether to ignore trailing nulls\n", "* @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls\n", "*/\n", "public static boolean isEqual(\n", "final byte[] buffer1, final int offset1, final int length1,\n", "final byte[] buffer2, final int offset2, final int length2,\n", "final boolean ignoreTrailingNulls){\n", "final int minLen=length1 < length2 ? length1 : length2;\n", "for (int i=0; i < minLen; i++){\n", "if (buffer1[offset1+i] != buffer2[offset2+i]){\n", "return false;\n", "}\n", "}\n", "if (length1 == length2){\n", "return true;\n", "}\n", "if (ignoreTrailingNulls){\n", "if (length1 > length2){\n", "for(int i = length2; i < length1; i++){\n", "if (buffer1[offset1+i] != 0){\n", "return false;\n", "}\n", "}\n", "} else {\n", "for(int i = length1; i < length2; i++){\n", "if (buffer2[offset2+i] != 0){\n", "return false;\n", "}\n", "}\n", "}\n", "return true;\n", "}\n", "return false;\n", "}\n", "\n", "/**\n", "* Compare byte buffers\n", "*\n", "* @param buffer1 the first buffer\n", "* @param offset1 the first offset\n", "* @param length1 the first length\n", "* @param buffer2 the second buffer\n", "* @param offset2 the second offset\n", "* @param length2 the second length\n", "* @return {@code true} if buffer1 and buffer2 have same contents\n", "*/\n", "public static boolean isEqual(\n", "final byte[] buffer1, final int offset1, final int length1,\n", "final byte[] buffer2, final int offset2, final int length2){\n", "return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, false);\n", "}\n", "\n", "/**\n", "* Compare byte buffers\n", "*\n", "* @param buffer1 the first buffer\n", "* @param buffer2 the second buffer\n", "* @return {@code true} if buffer1 and buffer2 have same contents\n", "*/\n", "public static boolean isEqual(final byte[] buffer1, final byte[] buffer2 ){\n", "return isEqual(buffer1, 0, buffer1.length, buffer2, 0, buffer2.length, false);\n", "}\n", "\n", "/**\n", "* Compare byte buffers, optionally ignoring trailing nulls\n", "*\n", "* @param buffer1 the first buffer\n", "* @param buffer2 the second buffer\n", "* @param ignoreTrailingNulls whether to ignore tariling nulls\n", "* @return {@code true} if buffer1 and buffer2 have same contents\n", "*/\n", "public static boolean isEqual(final byte[] buffer1, final byte[] buffer2, final boolean ignoreTrailingNulls){\n", "return isEqual(buffer1, 0, buffer1.length, buffer2, 0, buffer2.length, ignoreTrailingNulls);\n", "}\n", "\n", "/**\n", "* Compare byte buffers, ignoring trailing nulls\n", "*\n", "* @param buffer1 the first buffer\n", "* @param offset1 the first offset\n", "* @param length1 the first length\n", "* @param buffer2 the second buffer\n", "* @param offset2 the second offset\n", "* @param length2 the second length\n", "* @return {@code true} if buffer1 and buffer2 have same contents, having regard to trailing nulls\n", "*/\n", "public static boolean isEqualWithNull(\n", "final byte[] buffer1, final int offset1, final int length1,\n", "final byte[] buffer2, final int offset2, final int length2){\n", "return isEqual(buffer1, offset1, length1, buffer2, offset2, length2, true);\n", "}\n", "\n", "/**\n", "* Returns true if the first N bytes of an array are all zero\n", "*\n", "* @param a\n", "*            The array to check\n", "* @param size\n", "*            The number of characters to check (not the size of the array)\n", "* @return true if the first N bytes are zero\n", "*/\n", "public static boolean isArrayZero(final byte[] a, final int size) {\n", "for (int i = 0; i < size; i++) {\n", "if (a[i] != 0) {\n", "return false;\n", "}\n", "}\n", "return true;\n", "}\n", "\n", "/**\n", "* Returns a \"sanitized\" version of the string given as arguments,\n", "* where sanitized means non-printable characters have been\n", "* replaced with a question mark and the outcome is not longer\n", "* than 255 chars.\n", "*\n", "* <p>This method is used to clean up file names when they are\n", "* used in exception messages as they may end up in log files or\n", "* as console output and may have been read from a corrupted\n", "* input.</p>\n", "*\n", "* @param s the string to sanitize\n", "* @return a sanitized version of the argument\n", "* @since Compress 1.12\n", "*/\n", "public static String sanitize(String s) {\n", "final char[] chars = s.toCharArray();\n", "final int len = chars.length;\n", "final StringBuilder sb = new StringBuilder();\n", "for (int i = 0; i < len; i++) {\n", "final char c = chars[i];\n", "if (!Character.isISOControl(c)) {\n", "Character.UnicodeBlock block = Character.UnicodeBlock.of(c);\n", "if (block != null && block != Character.UnicodeBlock.SPECIALS) {\n", "sb.append(c);\n", "continue;\n", "}\n", "}\n", "sb.append('?');\n", "}\n", "return sb.toString();\n", "}\n", "\n", "}\n"], "faulty_lines": [3], "cluster": 3}, {"pid": "Compress", "bid": 39, "method_path": "./dataset/Compress/39/ArchiveUtils.java", "method": ["public static String sanitize(String s) {\n", "final char[] chars = s.toCharArray();\n", "final int len = chars.length;\n", "final StringBuilder sb = new StringBuilder();\n", "for (int i = 0; i < len; i++) {\n", "final char c = chars[i];\n", "if (!Character.isISOControl(c)) {\n", "Character.UnicodeBlock block = Character.UnicodeBlock.of(c);\n", "if (block != null && block != Character.UnicodeBlock.SPECIALS) {\n", "sb.append(c);\n", "continue;\n", "}\n", "}\n", "sb.append('?');\n", "}\n", "return sb.toString();\n", "}\n"], "faulty_lines": [2], "cluster": 2}, {"pid": "Compress", "bid": 40, "method_path": "./dataset/Compress/40/BitInputStream.java", "method": ["public long readBits(final int count) throws IOException {\n", "if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n", "throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n", "}\n", "while (bitsCachedSize < count) {\n", "final long nextByte = in.read();\n", "if (nextByte < 0) {\n", "return nextByte;\n", "}\n", "if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n", "bitsCached |= (nextByte << bitsCachedSize);\n", "} else {\n", "bitsCached <<= 8;\n", "bitsCached |= nextByte;\n", "}\n", "bitsCachedSize += 8;\n", "}\n", "// bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n", "\n", "final long bitsOut;\n", "if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n", "bitsOut = (bitsCached & MASKS[count]);\n", "bitsCached >>>= count;\n", "} else {\n", "bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n", "}\n", "bitsCachedSize -= count;\n", "return bitsOut;\n", "}\n"], "faulty_lines": [5], "cluster": 8}, {"pid": "Compress", "bid": 40, "method_path": "./dataset/Compress/40/BitInputStream.java", "method": ["public long readBits(final int count) throws IOException {\n", "if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n", "throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n", "}\n", "while (bitsCachedSize < count) {\n", "final long nextByte = in.read();\n", "if (nextByte < 0) {\n", "return nextByte;\n", "}\n", "if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n", "bitsCached |= (nextByte << bitsCachedSize);\n", "} else {\n", "bitsCached <<= 8;\n", "bitsCached |= nextByte;\n", "}\n", "bitsCachedSize += 8;\n", "}\n", "// bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n", "\n", "final long bitsOut;\n", "if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n", "bitsOut = (bitsCached & MASKS[count]);\n", "bitsCached >>>= count;\n", "} else {\n", "bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n", "}\n", "bitsCachedSize -= count;\n", "return bitsOut;\n", "}\n"], "faulty_lines": [18, 19, 21], "cluster": 8}, {"pid": "Compress", "bid": 40, "method_path": "./dataset/Compress/40/BitInputStream.java", "method": ["public long readBits(final int count) throws IOException {\n", "if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n", "throw new IllegalArgumentException(\"count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE);\n", "}\n", "while (bitsCachedSize < count) {\n", "final long nextByte = in.read();\n", "if (nextByte < 0) {\n", "return nextByte;\n", "}\n", "if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n", "bitsCached |= (nextByte << bitsCachedSize);\n", "} else {\n", "bitsCached <<= 8;\n", "bitsCached |= nextByte;\n", "}\n", "bitsCachedSize += 8;\n", "}\n", "// bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow\n", "\n", "final long bitsOut;\n", "if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n", "bitsOut = (bitsCached & MASKS[count]);\n", "bitsCached >>>= count;\n", "} else {\n", "bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n", "}\n", "bitsCachedSize -= count;\n", "return bitsOut;\n", "}\n"], "faulty_lines": [28], "cluster": 8}, {"pid": "Compress", "bid": 42, "method_path": "./dataset/Compress/42/UnixStat.java", "method": ["public interface UnixStat {\n", "\n", "/**\n", "* Bits used for permissions (and sticky bit)\n", "*/\n", "int PERM_MASK = 07777;\n", "/**\n", "* Bits used to indicate the filesystem object type.\n", "* @since 1.14\n", "*/\n", "/**\n", "* Indicates symbolic links.\n", "*/\n", "int LINK_FLAG = 0120000;\n", "/**\n", "* Indicates plain files.\n", "*/\n", "int FILE_FLAG = 0100000;\n", "/**\n", "* Indicates directories.\n", "*/\n", "int DIR_FLAG = 040000;\n", "\n", "// ----------------------------------------------------------\n", "// somewhat arbitrary choices that are quite common for shared\n", "// installations\n", "// -----------------------------------------------------------\n", "\n", "/**\n", "* Default permissions for symbolic links.\n", "*/\n", "int DEFAULT_LINK_PERM = 0777;\n", "\n", "/**\n", "* Default permissions for directories.\n", "*/\n", "int DEFAULT_DIR_PERM = 0755;\n", "\n", "/**\n", "* Default permissions for plain files.\n", "*/\n", "int DEFAULT_FILE_PERM = 0644;\n", "}\n"], "faulty_lines": [11], "cluster": 2}, {"pid": "Compress", "bid": 42, "method_path": "./dataset/Compress/42/ZipArchiveEntry.java", "method": ["public boolean isUnixSymlink() {\n", "return (getUnixMode() & UnixStat.LINK_FLAG) == UnixStat.LINK_FLAG;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Compress", "bid": 43, "method_path": "./dataset/Compress/43/ZipArchiveOutputStream.java", "method": ["private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n", "final boolean encodable = zipEncoding.canEncode(ze.getName());\n", "final ByteBuffer name = getName(ze);\n", "\n", "if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n", "addUnicodeExtraFields(ze, encodable, name);\n", "}\n", "\n", "final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n", "final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n", "metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n", "entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\n", "writeCounted(localHeader);\n", "entry.dataStart = streamCompressor.getTotalBytesWritten();\n", "}\n"], "faulty_lines": [11], "cluster": 2}, {"pid": "Compress", "bid": 43, "method_path": "./dataset/Compress/43/ZipArchiveOutputStream.java", "method": ["private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\n", "final boolean phased, long archiveOffset) throws IOException {\n", "ResourceAlignmentExtraField oldAlignmentEx =\n", "(ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n", "if (oldAlignmentEx != null) {\n", "ze.removeExtraField(ResourceAlignmentExtraField.ID);\n", "}\n", "\n", "int alignment = ze.getAlignment();\n", "if (alignment <= 0 && oldAlignmentEx != null) {\n", "alignment = oldAlignmentEx.getAlignment();\n", "}\n", "\n", "if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n", "int oldLength = LFH_FILENAME_OFFSET +\n", "name.limit() - name.position() +\n", "ze.getLocalFileDataExtra().length;\n", "\n", "int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE\n", "- ResourceAlignmentExtraField.BASE_SIZE) &\n", "(alignment - 1));\n", "ze.addExtraField(new ResourceAlignmentExtraField(alignment,\n", "oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n", "}\n", "\n", "final byte[] extra = ze.getLocalFileDataExtra();\n", "final int nameLen = name.limit() - name.position();\n", "final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n", "final byte[] buf = new byte[len];\n", "\n", "System.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\n", "\n", "//store method in local variable to prevent multiple method calls\n", "final int zipMethod = ze.getMethod();\n", "final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n", "\n", "putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n", "\n", "final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n", "generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n", "\n", "// compression method\n", "putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n", "\n", "ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n", "\n", "// CRC\n", "if (phased){\n", "putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n", "} else if (zipMethod == DEFLATED || channel != null) {\n", "System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n", "} else {\n", "putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n", "}\n", "\n", "// compressed length\n", "// uncompressed length\n", "if (hasZip64Extra(entry.entry)){\n", "// point to ZIP64 extended information extra field for\n", "// sizes, may get rewritten once sizes are known if\n", "// stream is seekable\n", "ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n", "ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n", "} else if (phased) {\n", "putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n", "putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n", "} else if (zipMethod == DEFLATED || channel != null) {\n", "System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n", "System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n", "} else { // Stored\n", "putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n", "putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n", "}\n", "// file name length\n", "putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n", "\n", "// extra field length\n", "putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n", "\n", "// file name\n", "System.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n", "\n", "// extra fields\n", "System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n", "\n", "return buf;\n", "}\n"], "faulty_lines": [35], "cluster": 3}, {"pid": "Compress", "bid": 43, "method_path": "./dataset/Compress/43/ZipArchiveOutputStream.java", "method": ["protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n", "if (ze.getMethod() != DEFLATED || channel != null) {\n", "return;\n", "}\n", "writeCounted(DD_SIG);\n", "writeCounted(ZipLong.getBytes(ze.getCrc()));\n", "if (!hasZip64Extra(ze)) {\n", "writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n", "writeCounted(ZipLong.getBytes(ze.getSize()));\n", "} else {\n", "writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n", "writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n", "}\n", "}\n"], "faulty_lines": [2], "cluster": 2}, {"pid": "Compress", "bid": 44, "method_path": "./dataset/Compress/44/ChecksumCalculatingInputStream.java", "method": ["public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n", "\n", "\n", "\n", "this.checksum = checksum;\n", "this.in = in;\n", "}\n"], "faulty_lines": [3, 4], "cluster": 0}, {"pid": "Compress", "bid": 45, "method_path": "./dataset/Compress/45/TarUtils.java", "method": ["public static int formatLongOctalOrBinaryBytes(\n", "final long value, final byte[] buf, final int offset, final int length) {\n", "\n", "// Check whether we are dealing with UID/GID or SIZE field\n", "final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n", "\n", "final boolean negative = value < 0;\n", "if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n", "return formatLongOctalBytes(value, buf, offset, length);\n", "}\n", "\n", "if (length < 9) {\n", "formatLongBinary(value, buf, offset, length, negative);\n", "}\n", "formatBigIntegerBinary(value, buf, offset, length, negative);\n", "\n", "buf[offset] = (byte) (negative ? 0xff : 0x80);\n", "return offset + length;\n", "}\n"], "faulty_lines": [14, 15], "cluster": 2}, {"pid": "Compress", "bid": 46, "method_path": "./dataset/Compress/46/X5455_ExtendedTimestamp.java", "method": ["private static ZipLong unixTimeToZipLong(long l) {\n", "final long TWO_TO_32 = 0x100000000L;\n", "if (l >= TWO_TO_32) {\n", "throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n", "}\n", "return new ZipLong(l);\n", "}\n"], "faulty_lines": [2, 3], "cluster": 4}, {"pid": "Compress", "bid": 47, "method_path": "./dataset/Compress/47/ZipArchiveInputStream.java", "method": ["public boolean canReadEntryData(final ArchiveEntry ae) {\n", "if (ae instanceof ZipArchiveEntry) {\n", "final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n", "return ZipUtil.canHandleEntryData(ze)\n", "&& supportsDataDescriptorFor(ze);\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [5], "cluster": 4}, {"pid": "Compress", "bid": 47, "method_path": "./dataset/Compress/47/ZipArchiveInputStream.java", "method": ["public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n", "if (closed) {\n", "throw new IOException(\"The stream is closed\");\n", "}\n", "\n", "if (current == null) {\n", "return -1;\n", "}\n", "\n", "// avoid int overflow, check null buffer\n", "if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n", "throw new ArrayIndexOutOfBoundsException();\n", "}\n", "\n", "ZipUtil.checkRequestedFeatures(current.entry);\n", "if (!supportsDataDescriptorFor(current.entry)) {\n", "throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,\n", "current.entry);\n", "}\n", "\n", "int read;\n", "if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n", "read = readStored(buffer, offset, length);\n", "} else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n", "read = readDeflated(buffer, offset, length);\n", "} else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n", "|| current.entry.getMethod() == ZipMethod.IMPLODING.getCode()\n", "|| current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()\n", "|| current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n", "read = current.in.read(buffer, offset, length);\n", "} else {\n", "throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),\n", "current.entry);\n", "}\n", "\n", "if (read >= 0) {\n", "current.crc.update(buffer, offset, read);\n", "}\n", "\n", "return read;\n", "}\n"], "faulty_lines": [20], "cluster": 5}, {"pid": "JacksonXml", "bid": 1, "method_path": "./dataset/JacksonXml/1/FromXmlParser.java", "method": ["public JsonToken nextToken() throws IOException\n", "{\n", "_binaryValue = null;\n", "if (_nextToken != null) {\n", "JsonToken t = _nextToken;\n", "_currToken = t;\n", "_nextToken = null;\n", "switch (t) {\n", "case START_OBJECT:\n", "_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n", "break;\n", "case START_ARRAY:\n", "_parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n", "break;\n", "case END_OBJECT:\n", "case END_ARRAY:\n", "_parsingContext = _parsingContext.getParent();\n", "_namesToWrap = _parsingContext.getNamesToWrap();\n", "break;\n", "case FIELD_NAME:\n", "_parsingContext.setCurrentName(_xmlTokens.getLocalName());\n", "break;\n", "default: // VALUE_STRING, VALUE_NULL\n", "// should be fine as is?\n", "}\n", "return t;\n", "}\n", "int token = _xmlTokens.next();\n", "\n", "// Need to have a loop just because we may have to eat/convert\n", "// a start-element that indicates an array element.\n", "while (token == XmlTokenStream.XML_START_ELEMENT) {\n", "// If we thought we might get leaf, no such luck\n", "if (_mayBeLeaf) {\n", "// leave _mayBeLeaf set, as we start a new context\n", "_nextToken = JsonToken.FIELD_NAME;\n", "_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n", "return (_currToken = JsonToken.START_OBJECT);\n", "}\n", "if (_parsingContext.inArray()) {\n", "// Yup: in array, so this element could be verified; but it won't be\n", "// reported anyway, and we need to process following event.\n", "token = _xmlTokens.next();\n", "_mayBeLeaf = true;\n", "continue;\n", "}\n", "String name = _xmlTokens.getLocalName();\n", "_parsingContext.setCurrentName(name);\n", "\n", "// Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n", "// Couple of ways to do it; but start by making _xmlTokens replay the thing...\n", "if (_namesToWrap != null && _namesToWrap.contains(name)) {\n", "_xmlTokens.repeatStartElement();\n", "}\n", "\n", "_mayBeLeaf = true;\n", "// Ok: in array context we need to skip reporting field names.\n", "// But what's the best way to find next token?\n", "return (_currToken = JsonToken.FIELD_NAME);\n", "}\n", "\n", "// Ok; beyond start element, what do we get?\n", "switch (token) {\n", "case XmlTokenStream.XML_END_ELEMENT:\n", "// Simple, except that if this is a leaf, need to suppress end:\n", "if (_mayBeLeaf) {\n", "_mayBeLeaf = false;\n", "// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n", "//    expose as empty Object, not null\n", "return (_currToken = JsonToken.VALUE_NULL);\n", "}\n", "_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n", "_parsingContext = _parsingContext.getParent();\n", "_namesToWrap = _parsingContext.getNamesToWrap();\n", "return _currToken;\n", "\n", "case XmlTokenStream.XML_ATTRIBUTE_NAME:\n", "// If there was a chance of leaf node, no more...\n", "if (_mayBeLeaf) {\n", "_mayBeLeaf = false;\n", "_nextToken = JsonToken.FIELD_NAME;\n", "_currText = _xmlTokens.getText();\n", "_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n", "return (_currToken = JsonToken.START_OBJECT);\n", "}\n", "_parsingContext.setCurrentName(_xmlTokens.getLocalName());\n", "return (_currToken = JsonToken.FIELD_NAME);\n", "case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n", "_currText = _xmlTokens.getText();\n", "return (_currToken = JsonToken.VALUE_STRING);\n", "case XmlTokenStream.XML_TEXT:\n", "_currText = _xmlTokens.getText();\n", "if (_mayBeLeaf) {\n", "_mayBeLeaf = false;\n", "/* One more refinement (pronunced like \"hack\") is that if\n", "* we had an empty String (or all white space), and we are\n", "* deserializing an array, we better hide the empty text.\n", "*/\n", "// Also: must skip following END_ELEMENT\n", "_xmlTokens.skipEndElement();\n", "if (_parsingContext.inArray()) {\n", "if (_isEmpty(_currText)) {\n", "// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n", "//    expose as empty Object, not null (or, worse, as used to\n", "//    be done, by swallowing the token)\n", "_currToken = JsonToken.END_ARRAY;\n", "_parsingContext = _parsingContext.getParent();\n", "_namesToWrap = _parsingContext.getNamesToWrap();\n", "return _currToken;\n", "}\n", "}\n", "return (_currToken = JsonToken.VALUE_STRING);\n", "} else {\n", "// [dataformat-xml#177]: empty text may also need to be skipped\n", "if (_parsingContext.inObject()\n", "&& (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n", "_currToken = JsonToken.END_OBJECT;\n", "_parsingContext = _parsingContext.getParent();\n", "_namesToWrap = _parsingContext.getNamesToWrap();\n", "return _currToken;\n", "}\n", "}\n", "// If not a leaf (or otherwise ignorable), need to transform into property...\n", "_parsingContext.setCurrentName(_cfgNameForTextElement);\n", "_nextToken = JsonToken.VALUE_STRING;\n", "return (_currToken = JsonToken.FIELD_NAME);\n", "case XmlTokenStream.XML_END:\n", "return (_currToken = null);\n", "}\n", "\n", "// should never get here\n", "_throwInternal();\n", "return null;\n", "}\n"], "faulty_lines": [68, 70], "cluster": 6}, {"pid": "JacksonXml", "bid": 1, "method_path": "./dataset/JacksonXml/1/FromXmlParser.java", "method": ["public JsonToken nextToken() throws IOException\n", "{\n", "_binaryValue = null;\n", "if (_nextToken != null) {\n", "JsonToken t = _nextToken;\n", "_currToken = t;\n", "_nextToken = null;\n", "switch (t) {\n", "case START_OBJECT:\n", "_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n", "break;\n", "case START_ARRAY:\n", "_parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n", "break;\n", "case END_OBJECT:\n", "case END_ARRAY:\n", "_parsingContext = _parsingContext.getParent();\n", "_namesToWrap = _parsingContext.getNamesToWrap();\n", "break;\n", "case FIELD_NAME:\n", "_parsingContext.setCurrentName(_xmlTokens.getLocalName());\n", "break;\n", "default: // VALUE_STRING, VALUE_NULL\n", "// should be fine as is?\n", "}\n", "return t;\n", "}\n", "int token = _xmlTokens.next();\n", "\n", "// Need to have a loop just because we may have to eat/convert\n", "// a start-element that indicates an array element.\n", "while (token == XmlTokenStream.XML_START_ELEMENT) {\n", "// If we thought we might get leaf, no such luck\n", "if (_mayBeLeaf) {\n", "// leave _mayBeLeaf set, as we start a new context\n", "_nextToken = JsonToken.FIELD_NAME;\n", "_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n", "return (_currToken = JsonToken.START_OBJECT);\n", "}\n", "if (_parsingContext.inArray()) {\n", "// Yup: in array, so this element could be verified; but it won't be\n", "// reported anyway, and we need to process following event.\n", "token = _xmlTokens.next();\n", "_mayBeLeaf = true;\n", "continue;\n", "}\n", "String name = _xmlTokens.getLocalName();\n", "_parsingContext.setCurrentName(name);\n", "\n", "// Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n", "// Couple of ways to do it; but start by making _xmlTokens replay the thing...\n", "if (_namesToWrap != null && _namesToWrap.contains(name)) {\n", "_xmlTokens.repeatStartElement();\n", "}\n", "\n", "_mayBeLeaf = true;\n", "// Ok: in array context we need to skip reporting field names.\n", "// But what's the best way to find next token?\n", "return (_currToken = JsonToken.FIELD_NAME);\n", "}\n", "\n", "// Ok; beyond start element, what do we get?\n", "switch (token) {\n", "case XmlTokenStream.XML_END_ELEMENT:\n", "// Simple, except that if this is a leaf, need to suppress end:\n", "if (_mayBeLeaf) {\n", "_mayBeLeaf = false;\n", "// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n", "//    expose as empty Object, not null\n", "return (_currToken = JsonToken.VALUE_NULL);\n", "}\n", "_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n", "_parsingContext = _parsingContext.getParent();\n", "_namesToWrap = _parsingContext.getNamesToWrap();\n", "return _currToken;\n", "\n", "case XmlTokenStream.XML_ATTRIBUTE_NAME:\n", "// If there was a chance of leaf node, no more...\n", "if (_mayBeLeaf) {\n", "_mayBeLeaf = false;\n", "_nextToken = JsonToken.FIELD_NAME;\n", "_currText = _xmlTokens.getText();\n", "_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n", "return (_currToken = JsonToken.START_OBJECT);\n", "}\n", "_parsingContext.setCurrentName(_xmlTokens.getLocalName());\n", "return (_currToken = JsonToken.FIELD_NAME);\n", "case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n", "_currText = _xmlTokens.getText();\n", "return (_currToken = JsonToken.VALUE_STRING);\n", "case XmlTokenStream.XML_TEXT:\n", "_currText = _xmlTokens.getText();\n", "if (_mayBeLeaf) {\n", "_mayBeLeaf = false;\n", "/* One more refinement (pronunced like \"hack\") is that if\n", "* we had an empty String (or all white space), and we are\n", "* deserializing an array, we better hide the empty text.\n", "*/\n", "// Also: must skip following END_ELEMENT\n", "_xmlTokens.skipEndElement();\n", "if (_parsingContext.inArray()) {\n", "if (_isEmpty(_currText)) {\n", "// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n", "//    expose as empty Object, not null (or, worse, as used to\n", "//    be done, by swallowing the token)\n", "_currToken = JsonToken.END_ARRAY;\n", "_parsingContext = _parsingContext.getParent();\n", "_namesToWrap = _parsingContext.getNamesToWrap();\n", "return _currToken;\n", "}\n", "}\n", "return (_currToken = JsonToken.VALUE_STRING);\n", "} else {\n", "// [dataformat-xml#177]: empty text may also need to be skipped\n", "if (_parsingContext.inObject()\n", "&& (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n", "_currToken = JsonToken.END_OBJECT;\n", "_parsingContext = _parsingContext.getParent();\n", "_namesToWrap = _parsingContext.getNamesToWrap();\n", "return _currToken;\n", "}\n", "}\n", "// If not a leaf (or otherwise ignorable), need to transform into property...\n", "_parsingContext.setCurrentName(_cfgNameForTextElement);\n", "_nextToken = JsonToken.VALUE_STRING;\n", "return (_currToken = JsonToken.FIELD_NAME);\n", "case XmlTokenStream.XML_END:\n", "return (_currToken = null);\n", "}\n", "\n", "// should never get here\n", "_throwInternal();\n", "return null;\n", "}\n"], "faulty_lines": [106, 107, 108, 109], "cluster": 6}, {"pid": "JacksonXml", "bid": 2, "method_path": "./dataset/JacksonXml/2/XmlTokenStream.java", "method": ["private final int _next() throws XMLStreamException\n", "{\n", "switch (_currentState) {\n", "case XML_ATTRIBUTE_VALUE:\n", "++_nextAttributeIndex;\n", "// fall through\n", "case XML_START_ELEMENT: // attributes to return?\n", "if (_nextAttributeIndex < _attributeCount) {\n", "_localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n", "_namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n", "_textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);\n", "return (_currentState = XML_ATTRIBUTE_NAME);\n", "}\n", "// otherwise need to find START/END_ELEMENT or text\n", "String text = _collectUntilTag();\n", "// If we have no/all-whitespace text followed by START_ELEMENT, ignore text\n", "if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\n", "return _initStartElement();\n", "}\n", "// For END_ELEMENT we will return text, if any\n", "if (text != null) {\n", "_textValue = text;\n", "return (_currentState = XML_TEXT);\n", "}\n", "return _handleEndElement();\n", "\n", "case XML_ATTRIBUTE_NAME:\n", "// if we just returned name, will need to just send value next\n", "return (_currentState = XML_ATTRIBUTE_VALUE);\n", "case XML_TEXT:\n", "// mixed text with other elements\n", "// text followed by END_ELEMENT\n", "return _handleEndElement();\n", "case XML_END:\n", "return XML_END;\n", "//            throw new IllegalStateException(\"No more XML tokens available (end of input)\");\n", "}\n", "\n", "// Ok: must be END_ELEMENT; see what tag we get (or end)\n", "switch (_skipUntilTag()) {\n", "case XMLStreamConstants.END_DOCUMENT:\n", "return (_currentState = XML_END);\n", "case XMLStreamConstants.END_ELEMENT:\n", "return _handleEndElement();\n", "}\n", "// START_ELEMENT...\n", "return _initStartElement();\n", "}\n"], "faulty_lines": [16, 17, 19, 22, 25], "cluster": 6}, {"pid": "JacksonXml", "bid": 2, "method_path": "./dataset/JacksonXml/2/XmlTokenStream.java", "method": ["private final int _next() throws XMLStreamException\n", "{\n", "switch (_currentState) {\n", "case XML_ATTRIBUTE_VALUE:\n", "++_nextAttributeIndex;\n", "// fall through\n", "case XML_START_ELEMENT: // attributes to return?\n", "if (_nextAttributeIndex < _attributeCount) {\n", "_localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n", "_namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n", "_textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);\n", "return (_currentState = XML_ATTRIBUTE_NAME);\n", "}\n", "// otherwise need to find START/END_ELEMENT or text\n", "String text = _collectUntilTag();\n", "// If we have no/all-whitespace text followed by START_ELEMENT, ignore text\n", "if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\n", "return _initStartElement();\n", "}\n", "// For END_ELEMENT we will return text, if any\n", "if (text != null) {\n", "_textValue = text;\n", "return (_currentState = XML_TEXT);\n", "}\n", "return _handleEndElement();\n", "\n", "case XML_ATTRIBUTE_NAME:\n", "// if we just returned name, will need to just send value next\n", "return (_currentState = XML_ATTRIBUTE_VALUE);\n", "case XML_TEXT:\n", "// mixed text with other elements\n", "// text followed by END_ELEMENT\n", "return _handleEndElement();\n", "case XML_END:\n", "return XML_END;\n", "//            throw new IllegalStateException(\"No more XML tokens available (end of input)\");\n", "}\n", "\n", "// Ok: must be END_ELEMENT; see what tag we get (or end)\n", "switch (_skipUntilTag()) {\n", "case XMLStreamConstants.END_DOCUMENT:\n", "return (_currentState = XML_END);\n", "case XMLStreamConstants.END_ELEMENT:\n", "return _handleEndElement();\n", "}\n", "// START_ELEMENT...\n", "return _initStartElement();\n", "}\n"], "faulty_lines": [32], "cluster": 6}, {"pid": "JacksonXml", "bid": 3, "method_path": "./dataset/JacksonXml/3/FromXmlParser.java", "method": ["public String nextTextValue() throws IOException\n", "{\n", "_binaryValue = null;\n", "if (_nextToken != null) {\n", "JsonToken t = _nextToken;\n", "_currToken = t;\n", "_nextToken = null;\n", "\n", "// expected case; yes, got a String\n", "if (t == JsonToken.VALUE_STRING) {\n", "return _currText;\n", "}\n", "_updateState(t);\n", "return null;\n", "}\n", "\n", "int token = _xmlTokens.next();\n", "\n", "// mostly copied from 'nextToken()'\n", "while (token == XmlTokenStream.XML_START_ELEMENT) {\n", "if (_mayBeLeaf) {\n", "_nextToken = JsonToken.FIELD_NAME;\n", "_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n", "_currToken = JsonToken.START_OBJECT;\n", "return null;\n", "}\n", "if (_parsingContext.inArray()) {\n", "token = _xmlTokens.next();\n", "_mayBeLeaf = true;\n", "continue;\n", "}\n", "String name = _xmlTokens.getLocalName();\n", "_parsingContext.setCurrentName(name);\n", "if (_namesToWrap != null && _namesToWrap.contains(name)) {\n", "_xmlTokens.repeatStartElement();\n", "}\n", "_mayBeLeaf = true;\n", "_currToken = JsonToken.FIELD_NAME;\n", "return null;\n", "}\n", "\n", "// Ok; beyond start element, what do we get?\n", "switch (token) {\n", "case XmlTokenStream.XML_END_ELEMENT:\n", "if (_mayBeLeaf) {\n", "// NOTE: this is different from nextToken() -- produce \"\", NOT null\n", "_mayBeLeaf = false;\n", "_currToken = JsonToken.VALUE_STRING;\n", "return (_currText = \"\");\n", "}\n", "_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n", "_parsingContext = _parsingContext.getParent();\n", "_namesToWrap = _parsingContext.getNamesToWrap();\n", "break;\n", "case XmlTokenStream.XML_ATTRIBUTE_NAME:\n", "// If there was a chance of leaf node, no more...\n", "if (_mayBeLeaf) {\n", "_mayBeLeaf = false;\n", "_nextToken = JsonToken.FIELD_NAME;\n", "_currText = _xmlTokens.getText();\n", "_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n", "_currToken = JsonToken.START_OBJECT;\n", "} else {\n", "_parsingContext.setCurrentName(_xmlTokens.getLocalName());\n", "_currToken = JsonToken.FIELD_NAME;\n", "}\n", "break;\n", "case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n", "_currText = _xmlTokens.getText();\n", "_currToken = JsonToken.VALUE_STRING;\n", "break;\n", "case XmlTokenStream.XML_TEXT:\n", "_currText = _xmlTokens.getText();\n", "if (_mayBeLeaf) {\n", "_mayBeLeaf = false;\n", "// Also: must skip following END_ELEMENT\n", "_xmlTokens.skipEndElement();\n", "\n", "// NOTE: this is different from nextToken() -- NO work-around\n", "// for otherwise empty List/array\n", "_currToken = JsonToken.VALUE_STRING;\n", "return _currText;\n", "}\n", "// If not a leaf, need to transform into property...\n", "_parsingContext.setCurrentName(_cfgNameForTextElement);\n", "_nextToken = JsonToken.VALUE_STRING;\n", "_currToken = JsonToken.FIELD_NAME;\n", "break;\n", "case XmlTokenStream.XML_END:\n", "_currToken = null;\n", "}\n", "return null;\n", "}\n"], "faulty_lines": [69, 71], "cluster": 6}, {"pid": "JacksonXml", "bid": 4, "method_path": "./dataset/JacksonXml/4/XmlSerializerProvider.java", "method": ["protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n", "{\n", "// 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n", "//    configured root name...\n", "if (jgen instanceof ToXmlGenerator) {\n", "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n", "}\n", "super.serializeValue(jgen, null);\n", "}\n"], "faulty_lines": [5, 6], "cluster": 4}, {"pid": "JacksonXml", "bid": 5, "method_path": "./dataset/JacksonXml/5/XmlSerializerProvider.java", "method": ["protected XmlSerializerProvider(XmlSerializerProvider src) {\n", "super(src);\n", "// 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n", "//    root name lookup as that may link back to diff version, configuration\n", "_rootNameLookup = src._rootNameLookup;\n", "}\n"], "faulty_lines": [5], "cluster": 4}, {"pid": "Lang", "bid": 1, "method_path": "./dataset/Lang/1/NumberUtils.java", "method": ["public static Number createNumber(final String str) throws NumberFormatException {\n", "if (str == null) {\n", "return null;\n", "}\n", "if (StringUtils.isBlank(str)) {\n", "throw new NumberFormatException(\"A blank string is not a valid number\");\n", "}\n", "// Need to deal with all possible hex prefixes here\n", "final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n", "int pfxLen = 0;\n", "for(final String pfx : hex_prefixes) {\n", "if (str.startsWith(pfx)) {\n", "pfxLen += pfx.length();\n", "break;\n", "}\n", "}\n", "if (pfxLen > 0) { // we have a hex number\n", "final int hexDigits = str.length() - pfxLen;\n", "if (hexDigits > 16) { // too many for Long\n", "return createBigInteger(str);\n", "}\n", "if (hexDigits > 8) { // too many for an int\n", "return createLong(str);\n", "}\n", "return createInteger(str);\n", "}\n", "final char lastChar = str.charAt(str.length() - 1);\n", "String mant;\n", "String dec;\n", "String exp;\n", "final int decPos = str.indexOf('.');\n", "final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n", "// if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n", "// and the parsing which will detect if e or E appear in a number due to using the wrong offset\n", "\n", "int numDecimals = 0; // Check required precision (LANG-693)\n", "if (decPos > -1) { // there is a decimal point\n", "\n", "if (expPos > -1) { // there is an exponent\n", "if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "}\n", "dec = str.substring(decPos + 1, expPos);\n", "} else {\n", "dec = str.substring(decPos + 1);\n", "}\n", "mant = str.substring(0, decPos);\n", "numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n", "} else {\n", "if (expPos > -1) {\n", "if (expPos > str.length()) { // prevents double exponent causing IOOBE\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "}\n", "mant = str.substring(0, expPos);\n", "} else {\n", "mant = str;\n", "}\n", "dec = null;\n", "}\n", "if (!Character.isDigit(lastChar) && lastChar != '.') {\n", "if (expPos > -1 && expPos < str.length() - 1) {\n", "exp = str.substring(expPos + 1, str.length() - 1);\n", "} else {\n", "exp = null;\n", "}\n", "//Requesting a specific type..\n", "final String numeric = str.substring(0, str.length() - 1);\n", "final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "switch (lastChar) {\n", "case 'l' :\n", "case 'L' :\n", "if (dec == null\n", "&& exp == null\n", "&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n", "try {\n", "return createLong(numeric);\n", "} catch (final NumberFormatException nfe) { // NOPMD\n", "// Too big for a long\n", "}\n", "return createBigInteger(numeric);\n", "\n", "}\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "case 'f' :\n", "case 'F' :\n", "try {\n", "final Float f = NumberUtils.createFloat(numeric);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "//If it's too big for a float or the float value = 0 and the string\n", "//has non-zeros in it, then float does not have the precision we want\n", "return f;\n", "}\n", "\n", "} catch (final NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "//$FALL-THROUGH$\n", "case 'd' :\n", "case 'D' :\n", "try {\n", "final Double d = NumberUtils.createDouble(numeric);\n", "if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (final NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "try {\n", "return createBigDecimal(numeric);\n", "} catch (final NumberFormatException e) { // NOPMD\n", "// ignore the bad number\n", "}\n", "//$FALL-THROUGH$\n", "default :\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "\n", "}\n", "}\n", "//User doesn't have a preference on the return type, so let's start\n", "//small and go from there...\n", "if (expPos > -1 && expPos < str.length() - 1) {\n", "exp = str.substring(expPos + 1, str.length());\n", "} else {\n", "exp = null;\n", "}\n", "if (dec == null && exp == null) { // no decimal point and no exponent\n", "//Must be an Integer, Long, Biginteger\n", "try {\n", "return createInteger(str);\n", "} catch (final NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "try {\n", "return createLong(str);\n", "} catch (final NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "return createBigInteger(str);\n", "}\n", "\n", "//Must be a Float, Double, BigDecimal\n", "final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "try {\n", "if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float\n", "final Float f = createFloat(str);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "return f;\n", "}\n", "}\n", "} catch (final NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "try {\n", "if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double\n", "final Double d = createDouble(str);\n", "if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "}\n", "} catch (final NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "\n", "return createBigDecimal(str);\n", "}\n"], "faulty_lines": [18, 19, 22], "cluster": 3}, {"pid": "Lang", "bid": 3, "method_path": "./dataset/Lang/3/NumberUtils.java", "method": ["public static Number createNumber(final String str) throws NumberFormatException {\n", "if (str == null) {\n", "return null;\n", "}\n", "if (StringUtils.isBlank(str)) {\n", "throw new NumberFormatException(\"A blank string is not a valid number\");\n", "}\n", "// Need to deal with all possible hex prefixes here\n", "final String[] hex_prefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"#\", \"-#\"};\n", "int pfxLen = 0;\n", "for(final String pfx : hex_prefixes) {\n", "if (str.startsWith(pfx)) {\n", "pfxLen += pfx.length();\n", "break;\n", "}\n", "}\n", "if (pfxLen > 0) { // we have a hex number\n", "final int hexDigits = str.length() - pfxLen;\n", "if (hexDigits > 16) { // too many for Long\n", "return createBigInteger(str);\n", "}\n", "if (hexDigits > 8) { // too many for an int\n", "return createLong(str);\n", "}\n", "return createInteger(str);\n", "}\n", "final char lastChar = str.charAt(str.length() - 1);\n", "String mant;\n", "String dec;\n", "String exp;\n", "final int decPos = str.indexOf('.');\n", "final int expPos = str.indexOf('e') + str.indexOf('E') + 1; // assumes both not present\n", "// if both e and E are present, this is caught by the checks on expPos (which prevent IOOBE)\n", "// and the parsing which will detect if e or E appear in a number due to using the wrong offset\n", "\n", "int numDecimals = 0; // Check required precision (LANG-693)\n", "if (decPos > -1) { // there is a decimal point\n", "\n", "if (expPos > -1) { // there is an exponent\n", "if (expPos < decPos || expPos > str.length()) { // prevents double exponent causing IOOBE\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "}\n", "dec = str.substring(decPos + 1, expPos);\n", "} else {\n", "dec = str.substring(decPos + 1);\n", "}\n", "mant = str.substring(0, decPos);\n", "numDecimals = dec.length(); // gets number of digits past the decimal to ensure no loss of precision for floating point numbers.\n", "} else {\n", "if (expPos > -1) {\n", "if (expPos > str.length()) { // prevents double exponent causing IOOBE\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "}\n", "mant = str.substring(0, expPos);\n", "} else {\n", "mant = str;\n", "}\n", "dec = null;\n", "}\n", "if (!Character.isDigit(lastChar) && lastChar != '.') {\n", "if (expPos > -1 && expPos < str.length() - 1) {\n", "exp = str.substring(expPos + 1, str.length() - 1);\n", "} else {\n", "exp = null;\n", "}\n", "//Requesting a specific type..\n", "final String numeric = str.substring(0, str.length() - 1);\n", "final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "switch (lastChar) {\n", "case 'l' :\n", "case 'L' :\n", "if (dec == null\n", "&& exp == null\n", "&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n", "try {\n", "return createLong(numeric);\n", "} catch (final NumberFormatException nfe) { // NOPMD\n", "// Too big for a long\n", "}\n", "return createBigInteger(numeric);\n", "\n", "}\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "case 'f' :\n", "case 'F' :\n", "try {\n", "final Float f = NumberUtils.createFloat(numeric);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "//If it's too big for a float or the float value = 0 and the string\n", "//has non-zeros in it, then float does not have the precision we want\n", "return f;\n", "}\n", "\n", "} catch (final NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "//$FALL-THROUGH$\n", "case 'd' :\n", "case 'D' :\n", "try {\n", "final Double d = NumberUtils.createDouble(numeric);\n", "if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (final NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "try {\n", "return createBigDecimal(numeric);\n", "} catch (final NumberFormatException e) { // NOPMD\n", "// ignore the bad number\n", "}\n", "//$FALL-THROUGH$\n", "default :\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "\n", "}\n", "}\n", "//User doesn't have a preference on the return type, so let's start\n", "//small and go from there...\n", "if (expPos > -1 && expPos < str.length() - 1) {\n", "exp = str.substring(expPos + 1, str.length());\n", "} else {\n", "exp = null;\n", "}\n", "if (dec == null && exp == null) { // no decimal point and no exponent\n", "//Must be an Integer, Long, Biginteger\n", "try {\n", "return createInteger(str);\n", "} catch (final NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "try {\n", "return createLong(str);\n", "} catch (final NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "return createBigInteger(str);\n", "}\n", "\n", "//Must be a Float, Double, BigDecimal\n", "final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "try {\n", "final Float f = createFloat(str);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "return f;\n", "}\n", "} catch (final NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "try {\n", "final Double d = createDouble(str);\n", "if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (final NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "\n", "return createBigDecimal(str);\n", "}\n"], "faulty_lines": [144, 148, 152, 156], "cluster": 3}, {"pid": "Lang", "bid": 4, "method_path": "./dataset/Lang/4/LookupTranslator.java", "method": ["public class LookupTranslator extends CharSequenceTranslator {\n", "\n", "private final HashMap<CharSequence, CharSequence> lookupMap;\n", "private final int shortest;\n", "private final int longest;\n", "\n", "/**\n", "* Define the lookup table to be used in translation\n", "*\n", "* Note that, as of Lang 3.1, the key to the lookup table is converted to a\n", "* java.lang.String, while the value remains as a java.lang.CharSequence.\n", "* This is because we need the key to support hashCode and equals(Object),\n", "* allowing it to be the key for a HashMap. See LANG-882.\n", "*\n", "* @param lookup CharSequence[][] table of size [*][2]\n", "*/\n", "public LookupTranslator(final CharSequence[]... lookup) {\n", "lookupMap = new HashMap<CharSequence, CharSequence>();\n", "int _shortest = Integer.MAX_VALUE;\n", "int _longest = 0;\n", "if (lookup != null) {\n", "for (final CharSequence[] seq : lookup) {\n", "this.lookupMap.put(seq[0], seq[1]);\n", "final int sz = seq[0].length();\n", "if (sz < _shortest) {\n", "_shortest = sz;\n", "}\n", "if (sz > _longest) {\n", "_longest = sz;\n", "}\n", "}\n", "}\n", "shortest = _shortest;\n", "longest = _longest;\n", "}\n", "\n", "/**\n", "* {@inheritDoc}\n", "*/\n", "@Override\n", "public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n", "int max = longest;\n", "if (index + longest > input.length()) {\n", "max = input.length() - index;\n", "}\n", "// descend so as to get a greedy algorithm\n", "for (int i = max; i >= shortest; i--) {\n", "final CharSequence subSeq = input.subSequence(index, index + i);\n", "final CharSequence result = lookupMap.get(subSeq);\n", "if (result != null) {\n", "out.write(result.toString());\n", "return i;\n", "}\n", "}\n", "return 0;\n", "}\n", "}\n"], "faulty_lines": [3], "cluster": 3}, {"pid": "Lang", "bid": 4, "method_path": "./dataset/Lang/4/LookupTranslator.java", "method": ["public LookupTranslator(final CharSequence[]... lookup) {\n", "lookupMap = new HashMap<CharSequence, CharSequence>();\n", "int _shortest = Integer.MAX_VALUE;\n", "int _longest = 0;\n", "if (lookup != null) {\n", "for (final CharSequence[] seq : lookup) {\n", "this.lookupMap.put(seq[0], seq[1]);\n", "final int sz = seq[0].length();\n", "if (sz < _shortest) {\n", "_shortest = sz;\n", "}\n", "if (sz > _longest) {\n", "_longest = sz;\n", "}\n", "}\n", "}\n", "shortest = _shortest;\n", "longest = _longest;\n", "}\n"], "faulty_lines": [2, 7], "cluster": 2}, {"pid": "Lang", "bid": 4, "method_path": "./dataset/Lang/4/LookupTranslator.java", "method": ["public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n", "int max = longest;\n", "if (index + longest > input.length()) {\n", "max = input.length() - index;\n", "}\n", "// descend so as to get a greedy algorithm\n", "for (int i = max; i >= shortest; i--) {\n", "final CharSequence subSeq = input.subSequence(index, index + i);\n", "final CharSequence result = lookupMap.get(subSeq);\n", "if (result != null) {\n", "out.write(result.toString());\n", "return i;\n", "}\n", "}\n", "return 0;\n", "}\n"], "faulty_lines": [9], "cluster": 2}, {"pid": "Lang", "bid": 5, "method_path": "./dataset/Lang/5/LocaleUtils.java", "method": ["public static Locale toLocale(final String str) {\n", "if (str == null) {\n", "return null;\n", "}\n", "final int len = str.length();\n", "if (len < 2) {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "final char ch0 = str.charAt(0);\n", "final char ch1 = str.charAt(1);\n", "if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "if (len == 2) {\n", "return new Locale(str);\n", "}\n", "if (len < 5) {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "if (str.charAt(2) != '_') {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "final char ch3 = str.charAt(3);\n", "if (ch3 == '_') {\n", "return new Locale(str.substring(0, 2), \"\", str.substring(4));\n", "}\n", "final char ch4 = str.charAt(4);\n", "if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "if (len == 5) {\n", "return new Locale(str.substring(0, 2), str.substring(3, 5));\n", "}\n", "if (len < 7) {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "if (str.charAt(5) != '_') {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n", "}\n"], "faulty_lines": [10], "cluster": 5}, {"pid": "Lang", "bid": 5, "method_path": "./dataset/Lang/5/LocaleUtils.java", "method": ["public static Locale toLocale(final String str) {\n", "if (str == null) {\n", "return null;\n", "}\n", "final int len = str.length();\n", "if (len < 2) {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "final char ch0 = str.charAt(0);\n", "final char ch1 = str.charAt(1);\n", "if (!Character.isLowerCase(ch0) || !Character.isLowerCase(ch1)) {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "if (len == 2) {\n", "return new Locale(str);\n", "}\n", "if (len < 5) {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "if (str.charAt(2) != '_') {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "final char ch3 = str.charAt(3);\n", "if (ch3 == '_') {\n", "return new Locale(str.substring(0, 2), \"\", str.substring(4));\n", "}\n", "final char ch4 = str.charAt(4);\n", "if (!Character.isUpperCase(ch3) || !Character.isUpperCase(ch4)) {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "if (len == 5) {\n", "return new Locale(str.substring(0, 2), str.substring(3, 5));\n", "}\n", "if (len < 7) {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "if (str.charAt(5) != '_') {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n", "}\n"], "faulty_lines": [41], "cluster": 5}, {"pid": "Lang", "bid": 6, "method_path": "./dataset/Lang/6/CharSequenceTranslator.java", "method": ["public final void translate(CharSequence input, Writer out) throws IOException {\n", "if (out == null) {\n", "throw new IllegalArgumentException(\"The Writer must not be null\");\n", "}\n", "if (input == null) {\n", "return;\n", "}\n", "int pos = 0;\n", "int len = input.length();\n", "while (pos < len) {\n", "int consumed = translate(input, pos, out);\n", "if (consumed == 0) {\n", "char[] c = Character.toChars(Character.codePointAt(input, pos));\n", "out.write(c);\n", "pos+= c.length;\n", "continue;\n", "}\n", "//          // contract with translators is that they have to understand codepoints\n", "//          // and they just took care of a surrogate pair\n", "for (int pt = 0; pt < consumed; pt++) {\n", "pos += Character.charCount(Character.codePointAt(input, pos));\n", "}\n", "}\n", "}\n"], "faulty_lines": [21], "cluster": 8}, {"pid": "Lang", "bid": 7, "method_path": "./dataset/Lang/7/NumberUtils.java", "method": ["public static Number createNumber(String str) throws NumberFormatException {\n", "if (str == null) {\n", "return null;\n", "}\n", "if (StringUtils.isBlank(str)) {\n", "throw new NumberFormatException(\"A blank string is not a valid number\");\n", "}\n", "if (str.startsWith(\"--\")) {\n", "return null;\n", "}\n", "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n", "int hexDigits = str.length() - 2; // drop 0x\n", "if (str.startsWith(\"-\")) { // drop -\n", "hexDigits--;\n", "}\n", "if (hexDigits > 8) { // too many for an int\n", "return createLong(str);\n", "}\n", "return createInteger(str);\n", "}\n", "char lastChar = str.charAt(str.length() - 1);\n", "String mant;\n", "String dec;\n", "String exp;\n", "int decPos = str.indexOf('.');\n", "int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n", "\n", "if (decPos > -1) {\n", "\n", "if (expPos > -1) {\n", "if (expPos < decPos || expPos > str.length()) {\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "}\n", "dec = str.substring(decPos + 1, expPos);\n", "} else {\n", "dec = str.substring(decPos + 1);\n", "}\n", "mant = str.substring(0, decPos);\n", "} else {\n", "if (expPos > -1) {\n", "if (expPos > str.length()) {\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "}\n", "mant = str.substring(0, expPos);\n", "} else {\n", "mant = str;\n", "}\n", "dec = null;\n", "}\n", "if (!Character.isDigit(lastChar) && lastChar != '.') {\n", "if (expPos > -1 && expPos < str.length() - 1) {\n", "exp = str.substring(expPos + 1, str.length() - 1);\n", "} else {\n", "exp = null;\n", "}\n", "//Requesting a specific type..\n", "String numeric = str.substring(0, str.length() - 1);\n", "boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "switch (lastChar) {\n", "case 'l' :\n", "case 'L' :\n", "if (dec == null\n", "&& exp == null\n", "&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n", "try {\n", "return createLong(numeric);\n", "} catch (NumberFormatException nfe) { // NOPMD\n", "// Too big for a long\n", "}\n", "return createBigInteger(numeric);\n", "\n", "}\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "case 'f' :\n", "case 'F' :\n", "try {\n", "Float f = NumberUtils.createFloat(numeric);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "//If it's too big for a float or the float value = 0 and the string\n", "//has non-zeros in it, then float does not have the precision we want\n", "return f;\n", "}\n", "\n", "} catch (NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "//$FALL-THROUGH$\n", "case 'd' :\n", "case 'D' :\n", "try {\n", "Double d = NumberUtils.createDouble(numeric);\n", "if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "try {\n", "return createBigDecimal(numeric);\n", "} catch (NumberFormatException e) { // NOPMD\n", "// ignore the bad number\n", "}\n", "//$FALL-THROUGH$\n", "default :\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "\n", "}\n", "} else {\n", "//User doesn't have a preference on the return type, so let's start\n", "//small and go from there...\n", "if (expPos > -1 && expPos < str.length() - 1) {\n", "exp = str.substring(expPos + 1, str.length());\n", "} else {\n", "exp = null;\n", "}\n", "if (dec == null && exp == null) {\n", "//Must be an int,long,bigint\n", "try {\n", "return createInteger(str);\n", "} catch (NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "try {\n", "return createLong(str);\n", "} catch (NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "return createBigInteger(str);\n", "\n", "} else {\n", "//Must be a float,double,BigDec\n", "boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "try {\n", "Float f = createFloat(str);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "return f;\n", "}\n", "} catch (NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "try {\n", "Double d = createDouble(str);\n", "if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "\n", "return createBigDecimal(str);\n", "\n", "}\n", "}\n", "}\n"], "faulty_lines": [8, 9, 10], "cluster": 3}, {"pid": "Lang", "bid": 7, "method_path": "./dataset/Lang/7/NumberUtils.java", "method": ["public static BigDecimal createBigDecimal(String str) {\n", "if (str == null) {\n", "return null;\n", "}\n", "// handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n", "if (StringUtils.isBlank(str)) {\n", "throw new NumberFormatException(\"A blank string is not a valid number\");\n", "}\n", "// this is protection for poorness in java.lang.BigDecimal.\n", "// it accepts this as a legal value, but it does not appear\n", "// to be in specification of class. OS X Java parses it to\n", "// a wrong value.\n", "return new BigDecimal(str);\n", "}\n"], "faulty_lines": [9, 13], "cluster": 2}, {"pid": "Lang", "bid": 8, "method_path": "./dataset/Lang/8/FastDatePrinter.java", "method": ["public void appendTo(StringBuffer buffer, Calendar calendar) {\n", "if (zone.useDaylightTime()\n", "&& calendar.get(Calendar.DST_OFFSET) != 0) {\n", "buffer.append(getTimeZoneDisplay(zone, true, mStyle, mLocale));\n", "} else {\n", "buffer.append(getTimeZoneDisplay(zone, false, mStyle, mLocale));\n", "}\n", "}\n"], "faulty_lines": [2], "cluster": 4}, {"pid": "Lang", "bid": 9, "method_path": "./dataset/Lang/9/FastDateParser.java", "method": ["private void init() {\n", "thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n", "\n", "nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n", "\n", "StringBuilder regex= new StringBuilder();\n", "List<Strategy> collector = new ArrayList<Strategy>();\n", "\n", "Matcher patternMatcher= formatPattern.matcher(pattern);\n", "if(!patternMatcher.lookingAt()) {\n", "throw new IllegalArgumentException(\"Invalid pattern\");\n", "}\n", "\n", "currentFormatField= patternMatcher.group();\n", "Strategy currentStrategy= getStrategy(currentFormatField);\n", "for(;;) {\n", "patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n", "if(!patternMatcher.lookingAt()) {\n", "nextStrategy = null;\n", "break;\n", "}\n", "String nextFormatField= patternMatcher.group();\n", "nextStrategy = getStrategy(nextFormatField);\n", "if(currentStrategy.addRegex(this, regex)) {\n", "collector.add(currentStrategy);\n", "}\n", "currentFormatField= nextFormatField;\n", "currentStrategy= nextStrategy;\n", "}\n", "if(currentStrategy.addRegex(this, regex)) {\n", "collector.add(currentStrategy);\n", "}\n", "currentFormatField= null;\n", "strategies= collector.toArray(new Strategy[collector.size()]);\n", "parsePattern= Pattern.compile(regex.toString());\n", "}\n"], "faulty_lines": [30], "cluster": 1}, {"pid": "Lang", "bid": 10, "method_path": "./dataset/Lang/10/FastDateParser.java", "method": ["private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n", "boolean wasWhite= false;\n", "for(int i= 0; i<value.length(); ++i) {\n", "char c= value.charAt(i);\n", "if(Character.isWhitespace(c)) {\n", "if(!wasWhite) {\n", "wasWhite= true;\n", "regex.append(\"\\\\s*+\");\n", "}\n", "continue;\n", "}\n", "wasWhite= false;\n", "switch(c) {\n", "case '\\'':\n", "if(unquote) {\n", "if(++i==value.length()) {\n", "return regex;\n", "}\n", "c= value.charAt(i);\n", "}\n", "break;\n", "case '?':\n", "case '[':\n", "case ']':\n", "case '(':\n", "case ')':\n", "case '{':\n", "case '}':\n", "case '\\\\':\n", "case '|':\n", "case '*':\n", "case '+':\n", "case '^':\n", "case '$':\n", "case '.':\n", "regex.append('\\\\');\n", "}\n", "regex.append(c);\n", "}\n", "return regex;\n", "}\n"], "faulty_lines": [2, 5, 6, 7, 8, 9, 10, 11, 12], "cluster": 8}, {"pid": "Lang", "bid": 11, "method_path": "./dataset/Lang/11/RandomStringUtils.java", "method": ["public static String random(int count, int start, int end, boolean letters, boolean numbers,\n", "char[] chars, Random random) {\n", "if (count == 0) {\n", "return \"\";\n", "} else if (count < 0) {\n", "throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n", "}\n", "if (chars != null && chars.length == 0) {\n", "throw new IllegalArgumentException(\"The chars array must not be empty\");\n", "}\n", "\n", "if (start == 0 && end == 0) {\n", "if (chars != null) {\n", "end = chars.length;\n", "} else {\n", "if (!letters && !numbers) {\n", "end = Integer.MAX_VALUE;\n", "} else {\n", "end = 'z' + 1;\n", "start = ' ';\n", "}\n", "}\n", "}\n", "\n", "char[] buffer = new char[count];\n", "int gap = end - start;\n", "\n", "while (count-- != 0) {\n", "char ch;\n", "if (chars == null) {\n", "ch = (char) (random.nextInt(gap) + start);\n", "} else {\n", "ch = chars[random.nextInt(gap) + start];\n", "}\n", "if (letters && Character.isLetter(ch)\n", "|| numbers && Character.isDigit(ch)\n", "|| !letters && !numbers) {\n", "if(ch >= 56320 && ch <= 57343) {\n", "if(count == 0) {\n", "count++;\n", "} else {\n", "// low surrogate, insert high surrogate after putting it in\n", "buffer[count] = ch;\n", "count--;\n", "buffer[count] = (char) (55296 + random.nextInt(128));\n", "}\n", "} else if(ch >= 55296 && ch <= 56191) {\n", "if(count == 0) {\n", "count++;\n", "} else {\n", "// high surrogate, insert low surrogate before putting it in\n", "buffer[count] = (char) (56320 + random.nextInt(128));\n", "count--;\n", "buffer[count] = ch;\n", "}\n", "} else if(ch >= 56192 && ch <= 56319) {\n", "// private high surrogate, no effing clue, so skip it\n", "count++;\n", "} else {\n", "buffer[count] = ch;\n", "}\n", "} else {\n", "count++;\n", "}\n", "}\n", "return new String(buffer);\n", "}\n"], "faulty_lines": [23], "cluster": 3}, {"pid": "Lang", "bid": 12, "method_path": "./dataset/Lang/12/RandomStringUtils.java", "method": ["public static String random(int count, int start, int end, boolean letters, boolean numbers,\n", "char[] chars, Random random) {\n", "if (count == 0) {\n", "return \"\";\n", "} else if (count < 0) {\n", "throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n", "}\n", "\n", "if (start == 0 && end == 0) {\n", "if (!letters && !numbers) {\n", "end = Integer.MAX_VALUE;\n", "} else {\n", "end = 'z' + 1;\n", "start = ' ';\n", "}\n", "}\n", "\n", "char[] buffer = new char[count];\n", "int gap = end - start;\n", "\n", "while (count-- != 0) {\n", "char ch;\n", "if (chars == null) {\n", "ch = (char) (random.nextInt(gap) + start);\n", "} else {\n", "ch = chars[random.nextInt(gap) + start];\n", "}\n", "if (letters && Character.isLetter(ch)\n", "|| numbers && Character.isDigit(ch)\n", "|| !letters && !numbers) {\n", "if(ch >= 56320 && ch <= 57343) {\n", "if(count == 0) {\n", "count++;\n", "} else {\n", "// low surrogate, insert high surrogate after putting it in\n", "buffer[count] = ch;\n", "count--;\n", "buffer[count] = (char) (55296 + random.nextInt(128));\n", "}\n", "} else if(ch >= 55296 && ch <= 56191) {\n", "if(count == 0) {\n", "count++;\n", "} else {\n", "// high surrogate, insert low surrogate before putting it in\n", "buffer[count] = (char) (56320 + random.nextInt(128));\n", "count--;\n", "buffer[count] = ch;\n", "}\n", "} else if(ch >= 56192 && ch <= 56319) {\n", "// private high surrogate, no effing clue, so skip it\n", "count++;\n", "} else {\n", "buffer[count] = ch;\n", "}\n", "} else {\n", "count++;\n", "}\n", "}\n", "return new String(buffer);\n", "}\n"], "faulty_lines": [8, 10, 16], "cluster": 3}, {"pid": "Lang", "bid": 13, "method_path": "./dataset/Lang/13/SerializationUtils.java", "method": ["private ClassLoader classLoader;\n", "\n", "/**\n", "* Constructor.\n", "* @param in The <code>InputStream</code>.\n", "* @param classLoader classloader to use\n", "* @throws IOException if an I/O error occurs while reading stream header.\n", "* @see java.io.ObjectInputStream\n", "*/\n", "public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {\n", "super(in);\n", "this.classLoader = classLoader;\n", "\n", "}\n"], "faulty_lines": [1], "cluster": 4}, {"pid": "Lang", "bid": 13, "method_path": "./dataset/Lang/13/SerializationUtils.java", "method": ["public ClassLoaderAwareObjectInputStream(InputStream in, ClassLoader classLoader) throws IOException {\n", "super(in);\n", "this.classLoader = classLoader;\n", "\n", "}\n"], "faulty_lines": [5], "cluster": 0}, {"pid": "Lang", "bid": 13, "method_path": "./dataset/Lang/13/SerializationUtils.java", "method": ["protected Class<?> resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n", "String name = desc.getName();\n", "try {\n", "return Class.forName(name, false, classLoader);\n", "} catch (ClassNotFoundException ex) {\n", "return Class.forName(name, false, Thread.currentThread().getContextClassLoader());\n", "}\n", "}\n"], "faulty_lines": [6, 7], "cluster": 4}, {"pid": "Lang", "bid": 14, "method_path": "./dataset/Lang/14/StringUtils.java", "method": ["public static boolean equals(CharSequence cs1, CharSequence cs2) {\n", "if (cs1 == cs2) {\n", "return true;\n", "}\n", "if (cs1 == null || cs2 == null) {\n", "return false;\n", "}\n", "return cs1.equals(cs2);\n", "}\n"], "faulty_lines": [8, 9], "cluster": 0}, {"pid": "Lang", "bid": 15, "method_path": "./dataset/Lang/15/TypeUtils.java", "method": ["private static boolean isAssignable(Type type, ParameterizedType toParameterizedType,\n", "Map<TypeVariable<?>, Type> typeVarAssigns) {\n", "if (type == null) {\n", "return true;\n", "}\n", "\n", "// only a null type can be assigned to null type which\n", "// would have cause the previous to return true\n", "if (toParameterizedType == null) {\n", "return false;\n", "}\n", "\n", "// all types are assignable to themselves\n", "if (toParameterizedType.equals(type)) {\n", "return true;\n", "}\n", "\n", "// get the target type's raw type\n", "Class<?> toClass = getRawType(toParameterizedType);\n", "// get the subject type's type arguments including owner type arguments\n", "// and supertype arguments up to and including the target class.\n", "Map<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);\n", "\n", "// null means the two types are not compatible\n", "if (fromTypeVarAssigns == null) {\n", "return false;\n", "}\n", "\n", "// compatible types, but there's no type arguments. this is equivalent\n", "// to comparing Map< ?, ? > to Map, and raw types are always assignable\n", "// to parameterized types.\n", "if (fromTypeVarAssigns.isEmpty()) {\n", "return true;\n", "}\n", "\n", "// get the target type's type arguments including owner type arguments\n", "Map<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType,\n", "toClass, typeVarAssigns);\n", "\n", "// now to check each type argument\n", "for (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\n", "Type toTypeArg = entry.getValue();\n", "Type fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n", "\n", "// parameters must either be absent from the subject type, within\n", "// the bounds of the wildcard type, or be an exact match to the\n", "// parameters of the target type.\n", "if (fromTypeArg != null\n", "&& !toTypeArg.equals(fromTypeArg)\n", "&& !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\n", "typeVarAssigns))) {\n", "return false;\n", "}\n", "}\n", "\n", "return true;\n", "}\n"], "faulty_lines": [41, 42, 43], "cluster": 3}, {"pid": "Lang", "bid": 15, "method_path": "./dataset/Lang/15/TypeUtils.java", "method": ["private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass,\n", "Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n", "// make sure they're assignable\n", "if (!isAssignable(cls, toClass)) {\n", "return null;\n", "}\n", "\n", "// can't work with primitives\n", "if (cls.isPrimitive()) {\n", "// both classes are primitives?\n", "if (toClass.isPrimitive()) {\n", "// dealing with widening here. No type arguments to be\n", "// harvested with these two types.\n", "return new HashMap<TypeVariable<?>, Type>();\n", "}\n", "\n", "// work with wrapper the wrapper class instead of the primitive\n", "cls = ClassUtils.primitiveToWrapper(cls);\n", "}\n", "\n", "// create a copy of the incoming map, or an empty one if it's null\n", "HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n", ": new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n", "\n", "// has target class been reached?\n", "if (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\n", "return typeVarAssigns;\n", "}\n", "\n", "// walk the inheritance hierarchy until the target class is reached\n", "return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n", "}\n"], "faulty_lines": [26], "cluster": 1}, {"pid": "Lang", "bid": 16, "method_path": "./dataset/Lang/16/NumberUtils.java", "method": ["public static Number createNumber(String str) throws NumberFormatException {\n", "if (str == null) {\n", "return null;\n", "}\n", "if (StringUtils.isBlank(str)) {\n", "throw new NumberFormatException(\"A blank string is not a valid number\");\n", "}\n", "if (str.startsWith(\"--\")) {\n", "// this is protection for poorness in java.lang.BigDecimal.\n", "// it accepts this as a legal value, but it does not appear\n", "// to be in specification of class. OS X Java parses it to\n", "// a wrong value.\n", "return null;\n", "}\n", "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n", "return createInteger(str);\n", "}\n", "char lastChar = str.charAt(str.length() - 1);\n", "String mant;\n", "String dec;\n", "String exp;\n", "int decPos = str.indexOf('.');\n", "int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n", "\n", "if (decPos > -1) {\n", "\n", "if (expPos > -1) {\n", "if (expPos < decPos || expPos > str.length()) {\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "}\n", "dec = str.substring(decPos + 1, expPos);\n", "} else {\n", "dec = str.substring(decPos + 1);\n", "}\n", "mant = str.substring(0, decPos);\n", "} else {\n", "if (expPos > -1) {\n", "if (expPos > str.length()) {\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "}\n", "mant = str.substring(0, expPos);\n", "} else {\n", "mant = str;\n", "}\n", "dec = null;\n", "}\n", "if (!Character.isDigit(lastChar) && lastChar != '.') {\n", "if (expPos > -1 && expPos < str.length() - 1) {\n", "exp = str.substring(expPos + 1, str.length() - 1);\n", "} else {\n", "exp = null;\n", "}\n", "//Requesting a specific type..\n", "String numeric = str.substring(0, str.length() - 1);\n", "boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "switch (lastChar) {\n", "case 'l' :\n", "case 'L' :\n", "if (dec == null\n", "&& exp == null\n", "&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n", "try {\n", "return createLong(numeric);\n", "} catch (NumberFormatException nfe) { // NOPMD\n", "// Too big for a long\n", "}\n", "return createBigInteger(numeric);\n", "\n", "}\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "case 'f' :\n", "case 'F' :\n", "try {\n", "Float f = NumberUtils.createFloat(numeric);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "//If it's too big for a float or the float value = 0 and the string\n", "//has non-zeros in it, then float does not have the precision we want\n", "return f;\n", "}\n", "\n", "} catch (NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "//$FALL-THROUGH$\n", "case 'd' :\n", "case 'D' :\n", "try {\n", "Double d = NumberUtils.createDouble(numeric);\n", "if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "try {\n", "return createBigDecimal(numeric);\n", "} catch (NumberFormatException e) { // NOPMD\n", "// ignore the bad number\n", "}\n", "//$FALL-THROUGH$\n", "default :\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "\n", "}\n", "} else {\n", "//User doesn't have a preference on the return type, so let's start\n", "//small and go from there...\n", "if (expPos > -1 && expPos < str.length() - 1) {\n", "exp = str.substring(expPos + 1, str.length());\n", "} else {\n", "exp = null;\n", "}\n", "if (dec == null && exp == null) {\n", "//Must be an int,long,bigint\n", "try {\n", "return createInteger(str);\n", "} catch (NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "try {\n", "return createLong(str);\n", "} catch (NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "return createBigInteger(str);\n", "\n", "} else {\n", "//Must be a float,double,BigDec\n", "boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "try {\n", "Float f = createFloat(str);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "return f;\n", "}\n", "} catch (NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "try {\n", "Double d = createDouble(str);\n", "if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (NumberFormatException nfe) { // NOPMD\n", "// ignore the bad number\n", "}\n", "\n", "return createBigDecimal(str);\n", "\n", "}\n", "}\n", "}\n"], "faulty_lines": [15], "cluster": 3}, {"pid": "Lang", "bid": 17, "method_path": "./dataset/Lang/17/CharSequenceTranslator.java", "method": ["public final void translate(CharSequence input, Writer out) throws IOException {\n", "if (out == null) {\n", "throw new IllegalArgumentException(\"The Writer must not be null\");\n", "}\n", "if (input == null) {\n", "return;\n", "}\n", "int pos = 0;\n", "int len = Character.codePointCount(input, 0, input.length());\n", "while (pos < len) {\n", "int consumed = translate(input, pos, out);\n", "if (consumed == 0) {\n", "char[] c = Character.toChars(Character.codePointAt(input, pos));\n", "out.write(c);\n", "}\n", "else {\n", "//          // contract with translators is that they have to understand codepoints\n", "//          // and they just took care of a surrogate pair\n", "for (int pt = 0; pt < consumed; pt++) {\n", "if (pos < len - 2) {\n", "pos += Character.charCount(Character.codePointAt(input, pos));\n", "} else {\n", "pos++;\n", "}\n", "}\n", "pos--;\n", "}\n", "pos++;\n", "}\n", "}\n"], "faulty_lines": [9, 15, 16, 20, 22, 23, 24, 25, 26, 28], "cluster": 8}, {"pid": "Lang", "bid": 18, "method_path": "./dataset/Lang/18/FastDateFormat.java", "method": ["protected List<Rule> parsePattern() {\n", "DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n", "List<Rule> rules = new ArrayList<Rule>();\n", "\n", "String[] ERAs = symbols.getEras();\n", "String[] months = symbols.getMonths();\n", "String[] shortMonths = symbols.getShortMonths();\n", "String[] weekdays = symbols.getWeekdays();\n", "String[] shortWeekdays = symbols.getShortWeekdays();\n", "String[] AmPmStrings = symbols.getAmPmStrings();\n", "\n", "int length = mPattern.length();\n", "int[] indexRef = new int[1];\n", "\n", "for (int i = 0; i < length; i++) {\n", "indexRef[0] = i;\n", "String token = parseToken(mPattern, indexRef);\n", "i = indexRef[0];\n", "\n", "int tokenLen = token.length();\n", "if (tokenLen == 0) {\n", "break;\n", "}\n", "\n", "Rule rule;\n", "char c = token.charAt(0);\n", "\n", "switch (c) {\n", "case 'G': // era designator (text)\n", "rule = new TextField(Calendar.ERA, ERAs);\n", "break;\n", "case 'y': // year (number)\n", "if (tokenLen >= 4) {\n", "rule = selectNumberRule(Calendar.YEAR, tokenLen);\n", "} else {\n", "rule = TwoDigitYearField.INSTANCE;\n", "}\n", "break;\n", "case 'M': // month in year (text and number)\n", "if (tokenLen >= 4) {\n", "rule = new TextField(Calendar.MONTH, months);\n", "} else if (tokenLen == 3) {\n", "rule = new TextField(Calendar.MONTH, shortMonths);\n", "} else if (tokenLen == 2) {\n", "rule = TwoDigitMonthField.INSTANCE;\n", "} else {\n", "rule = UnpaddedMonthField.INSTANCE;\n", "}\n", "break;\n", "case 'd': // day in month (number)\n", "rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n", "break;\n", "case 'h': // hour in am/pm (number, 1..12)\n", "rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n", "break;\n", "case 'H': // hour in day (number, 0..23)\n", "rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n", "break;\n", "case 'm': // minute in hour (number)\n", "rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n", "break;\n", "case 's': // second in minute (number)\n", "rule = selectNumberRule(Calendar.SECOND, tokenLen);\n", "break;\n", "case 'S': // millisecond (number)\n", "rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n", "break;\n", "case 'E': // day in week (text)\n", "rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n", "break;\n", "case 'D': // day in year (number)\n", "rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n", "break;\n", "case 'F': // day of week in month (number)\n", "rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n", "break;\n", "case 'w': // week in year (number)\n", "rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n", "break;\n", "case 'W': // week in month (number)\n", "rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n", "break;\n", "case 'a': // am/pm marker (text)\n", "rule = new TextField(Calendar.AM_PM, AmPmStrings);\n", "break;\n", "case 'k': // hour in day (1..24)\n", "rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n", "break;\n", "case 'K': // hour in am/pm (0..11)\n", "rule = selectNumberRule(Calendar.HOUR, tokenLen);\n", "break;\n", "case 'z': // time zone (text)\n", "if (tokenLen >= 4) {\n", "rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n", "} else {\n", "rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n", "}\n", "break;\n", "case 'Z': // time zone (value)\n", "if (tokenLen == 1) {\n", "rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n", "} else {\n", "rule = TimeZoneNumberRule.INSTANCE_COLON;\n", "}\n", "break;\n", "case '\\'': // literal text\n", "String sub = token.substring(1);\n", "if (sub.length() == 1) {\n", "rule = new CharacterLiteral(sub.charAt(0));\n", "} else {\n", "rule = new StringLiteral(sub);\n", "}\n", "break;\n", "default:\n", "throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n", "}\n", "\n", "rules.add(rule);\n", "}\n", "\n", "return rules;\n", "}\n"], "faulty_lines": [33, 34, 36], "cluster": 3}, {"pid": "Lang", "bid": 19, "method_path": "./dataset/Lang/19/NumericEntityUnescaper.java", "method": ["public int translate(CharSequence input, int index, Writer out) throws IOException {\n", "int seqEnd = input.length();\n", "// Uses -2 to ensure there is something after the &#\n", "if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n", "int start = index + 2;\n", "boolean isHex = false;\n", "\n", "char firstChar = input.charAt(start);\n", "if(firstChar == 'x' || firstChar == 'X') {\n", "start++;\n", "isHex = true;\n", "\n", "// Check there's more than just an x after the &#\n", "}\n", "\n", "int end = start;\n", "// Note that this supports character codes without a ; on the end\n", "while(input.charAt(end) != ';')\n", "{\n", "end++;\n", "}\n", "\n", "int entityValue;\n", "try {\n", "if(isHex) {\n", "entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n", "} else {\n", "entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n", "}\n", "} catch(NumberFormatException nfe) {\n", "System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n", "return 0;\n", "}\n", "\n", "if(entityValue > 0xFFFF) {\n", "char[] chrs = Character.toChars(entityValue);\n", "out.write(chrs[0]);\n", "out.write(chrs[1]);\n", "} else {\n", "out.write(entityValue);\n", "}\n", "\n", "\n", "return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n", "}\n", "return 0;\n", "}\n"], "faulty_lines": [4], "cluster": 5}, {"pid": "Lang", "bid": 20, "method_path": "./dataset/Lang/20/StringUtils.java", "method": ["public static String join(Object[] array, char separator, int startIndex, int endIndex) {\n", "if (array == null) {\n", "return null;\n", "}\n", "int noOfItems = (endIndex - startIndex);\n", "if (noOfItems <= 0) {\n", "return EMPTY;\n", "}\n", "\n", "StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);\n", "\n", "for (int i = startIndex; i < endIndex; i++) {\n", "if (i > startIndex) {\n", "buf.append(separator);\n", "}\n", "if (array[i] != null) {\n", "buf.append(array[i]);\n", "}\n", "}\n", "return buf.toString();\n", "}\n"], "faulty_lines": [10], "cluster": 2}, {"pid": "Lang", "bid": 20, "method_path": "./dataset/Lang/20/StringUtils.java", "method": ["public static String join(Object[] array, String separator, int startIndex, int endIndex) {\n", "if (array == null) {\n", "return null;\n", "}\n", "if (separator == null) {\n", "separator = EMPTY;\n", "}\n", "\n", "// endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator))\n", "//           (Assuming that all Strings are roughly equally long)\n", "int noOfItems = (endIndex - startIndex);\n", "if (noOfItems <= 0) {\n", "return EMPTY;\n", "}\n", "\n", "StringBuilder buf = new StringBuilder((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + separator.length());\n", "\n", "for (int i = startIndex; i < endIndex; i++) {\n", "if (i > startIndex) {\n", "buf.append(separator);\n", "}\n", "if (array[i] != null) {\n", "buf.append(array[i]);\n", "}\n", "}\n", "return buf.toString();\n", "}\n"], "faulty_lines": [16], "cluster": 8}, {"pid": "Lang", "bid": 21, "method_path": "./dataset/Lang/21/DateUtils.java", "method": ["public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n", "if (cal1 == null || cal2 == null) {\n", "throw new IllegalArgumentException(\"The date must not be null\");\n", "}\n", "return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n", "cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n", "cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n", "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n", "cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n", "cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n", "cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n", "cal1.getClass() == cal2.getClass());\n", "}\n"], "faulty_lines": [8], "cluster": 8}, {"pid": "Lang", "bid": 22, "method_path": "./dataset/Lang/22/Fraction.java", "method": ["private static int greatestCommonDivisor(int u, int v) {\n", "// From Commons Math:\n", "//if either operand is abs 1, return 1:\n", "if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n", "return 1;\n", "}\n", "// keep u and v negative, as negative integers range down to\n", "// -2^31, while positive numbers can only be as large as 2^31-1\n", "// (i.e. we can't necessarily negate a negative number without\n", "// overflow)\n", "if (u>0) { u=-u; } // make u negative\n", "if (v>0) { v=-v; } // make v negative\n", "// B1. [Find power of 2]\n", "int k=0;\n", "while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n", "u/=2; v/=2; k++; // cast out twos.\n", "}\n", "if (k==31) {\n", "throw new ArithmeticException(\"overflow: gcd is 2^31\");\n", "}\n", "// B2. Initialize: u and v have been divided by 2^k and at least\n", "//     one is odd.\n", "int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n", "// t negative: u was odd, v may be even (t replaces v)\n", "// t positive: u was even, v is odd (t replaces u)\n", "do {\n", "/* assert u<0 && v<0; */\n", "// B4/B3: cast out twos from t.\n", "while ((t&1)==0) { // while t is even..\n", "t/=2; // cast out twos\n", "}\n", "// B5 [reset max(u,v)]\n", "if (t>0) {\n", "u = -t;\n", "} else {\n", "v = t;\n", "}\n", "// B6/B3. at this point both u and v should be odd.\n", "t = (v - u)/2;\n", "// |u| larger: t positive (replace u)\n", "// |v| larger: t negative (replace v)\n", "} while (t!=0);\n", "return -u*(1<<k); // gcd is u*2^k\n", "}\n"], "faulty_lines": [3, 4], "cluster": 9}, {"pid": "Lang", "bid": 23, "method_path": "./dataset/Lang/23/ExtendedMessageFormat.java", "method": ["public class ExtendedMessageFormat extends MessageFormat {\n", "private static final long serialVersionUID = -2362048321261811743L;\n", "\n", "private static final String DUMMY_PATTERN = \"\";\n", "private static final String ESCAPED_QUOTE = \"''\";\n", "private static final char START_FMT = ',';\n", "private static final char END_FE = '}';\n"], "faulty_lines": [3], "cluster": 4}, {"pid": "Lang", "bid": 26, "method_path": "./dataset/Lang/26/FastDateFormat.java", "method": ["public String format(Date date) {\n", "Calendar c = new GregorianCalendar(mTimeZone);\n", "c.setTime(date);\n", "return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Lang", "bid": 27, "method_path": "./dataset/Lang/27/NumberUtils.java", "method": ["public static Number createNumber(String str) throws NumberFormatException {\n", "if (str == null) {\n", "return null;\n", "}\n", "if (StringUtils.isBlank(str)) {\n", "throw new NumberFormatException(\"A blank string is not a valid number\");\n", "}\n", "if (str.startsWith(\"--\")) {\n", "// this is protection for poorness in java.lang.BigDecimal.\n", "// it accepts this as a legal value, but it does not appear\n", "// to be in specification of class. OS X Java parses it to\n", "// a wrong value.\n", "return null;\n", "}\n", "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n", "return createInteger(str);\n", "}\n", "char lastChar = str.charAt(str.length() - 1);\n", "String mant;\n", "String dec;\n", "String exp;\n", "int decPos = str.indexOf('.');\n", "int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n", "\n", "if (decPos > -1) {\n", "\n", "if (expPos > -1) {\n", "if (expPos < decPos) {\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "}\n", "dec = str.substring(decPos + 1, expPos);\n", "} else {\n", "dec = str.substring(decPos + 1);\n", "}\n", "mant = str.substring(0, decPos);\n", "} else {\n", "if (expPos > -1) {\n", "mant = str.substring(0, expPos);\n", "} else {\n", "mant = str;\n", "}\n", "dec = null;\n", "}\n", "if (!Character.isDigit(lastChar) && lastChar != '.') {\n", "if (expPos > -1 && expPos < str.length() - 1) {\n", "exp = str.substring(expPos + 1, str.length() - 1);\n", "} else {\n", "exp = null;\n", "}\n", "//Requesting a specific type..\n", "String numeric = str.substring(0, str.length() - 1);\n", "boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "switch (lastChar) {\n", "case 'l' :\n", "case 'L' :\n", "if (dec == null\n", "&& exp == null\n", "&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n", "try {\n", "return createLong(numeric);\n", "} catch (NumberFormatException nfe) {\n", "//Too big for a long\n", "}\n", "return createBigInteger(numeric);\n", "\n", "}\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "case 'f' :\n", "case 'F' :\n", "try {\n", "Float f = NumberUtils.createFloat(numeric);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "//If it's too big for a float or the float value = 0 and the string\n", "//has non-zeros in it, then float does not have the precision we want\n", "return f;\n", "}\n", "\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "//$FALL-THROUGH$\n", "case 'd' :\n", "case 'D' :\n", "try {\n", "Double d = NumberUtils.createDouble(numeric);\n", "if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "try {\n", "return createBigDecimal(numeric);\n", "} catch (NumberFormatException e) {\n", "// ignore the bad number\n", "}\n", "//$FALL-THROUGH$\n", "default :\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "\n", "}\n", "} else {\n", "//User doesn't have a preference on the return type, so let's start\n", "//small and go from there...\n", "if (expPos > -1 && expPos < str.length() - 1) {\n", "exp = str.substring(expPos + 1, str.length());\n", "} else {\n", "exp = null;\n", "}\n", "if (dec == null && exp == null) {\n", "//Must be an int,long,bigint\n", "try {\n", "return createInteger(str);\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "try {\n", "return createLong(str);\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "return createBigInteger(str);\n", "\n", "} else {\n", "//Must be a float,double,BigDec\n", "boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "try {\n", "Float f = createFloat(str);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "return f;\n", "}\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "try {\n", "Double d = createDouble(str);\n", "if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "\n", "return createBigDecimal(str);\n", "\n", "}\n", "}\n", "}\n"], "faulty_lines": [28], "cluster": 3}, {"pid": "Lang", "bid": 27, "method_path": "./dataset/Lang/27/NumberUtils.java", "method": ["public static Number createNumber(String str) throws NumberFormatException {\n", "if (str == null) {\n", "return null;\n", "}\n", "if (StringUtils.isBlank(str)) {\n", "throw new NumberFormatException(\"A blank string is not a valid number\");\n", "}\n", "if (str.startsWith(\"--\")) {\n", "// this is protection for poorness in java.lang.BigDecimal.\n", "// it accepts this as a legal value, but it does not appear\n", "// to be in specification of class. OS X Java parses it to\n", "// a wrong value.\n", "return null;\n", "}\n", "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n", "return createInteger(str);\n", "}\n", "char lastChar = str.charAt(str.length() - 1);\n", "String mant;\n", "String dec;\n", "String exp;\n", "int decPos = str.indexOf('.');\n", "int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n", "\n", "if (decPos > -1) {\n", "\n", "if (expPos > -1) {\n", "if (expPos < decPos) {\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "}\n", "dec = str.substring(decPos + 1, expPos);\n", "} else {\n", "dec = str.substring(decPos + 1);\n", "}\n", "mant = str.substring(0, decPos);\n", "} else {\n", "if (expPos > -1) {\n", "mant = str.substring(0, expPos);\n", "} else {\n", "mant = str;\n", "}\n", "dec = null;\n", "}\n", "if (!Character.isDigit(lastChar) && lastChar != '.') {\n", "if (expPos > -1 && expPos < str.length() - 1) {\n", "exp = str.substring(expPos + 1, str.length() - 1);\n", "} else {\n", "exp = null;\n", "}\n", "//Requesting a specific type..\n", "String numeric = str.substring(0, str.length() - 1);\n", "boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "switch (lastChar) {\n", "case 'l' :\n", "case 'L' :\n", "if (dec == null\n", "&& exp == null\n", "&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n", "try {\n", "return createLong(numeric);\n", "} catch (NumberFormatException nfe) {\n", "//Too big for a long\n", "}\n", "return createBigInteger(numeric);\n", "\n", "}\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "case 'f' :\n", "case 'F' :\n", "try {\n", "Float f = NumberUtils.createFloat(numeric);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "//If it's too big for a float or the float value = 0 and the string\n", "//has non-zeros in it, then float does not have the precision we want\n", "return f;\n", "}\n", "\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "//$FALL-THROUGH$\n", "case 'd' :\n", "case 'D' :\n", "try {\n", "Double d = NumberUtils.createDouble(numeric);\n", "if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "try {\n", "return createBigDecimal(numeric);\n", "} catch (NumberFormatException e) {\n", "// ignore the bad number\n", "}\n", "//$FALL-THROUGH$\n", "default :\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "\n", "}\n", "} else {\n", "//User doesn't have a preference on the return type, so let's start\n", "//small and go from there...\n", "if (expPos > -1 && expPos < str.length() - 1) {\n", "exp = str.substring(expPos + 1, str.length());\n", "} else {\n", "exp = null;\n", "}\n", "if (dec == null && exp == null) {\n", "//Must be an int,long,bigint\n", "try {\n", "return createInteger(str);\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "try {\n", "return createLong(str);\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "return createBigInteger(str);\n", "\n", "} else {\n", "//Must be a float,double,BigDec\n", "boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "try {\n", "Float f = createFloat(str);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "return f;\n", "}\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "try {\n", "Double d = createDouble(str);\n", "if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "\n", "return createBigDecimal(str);\n", "\n", "}\n", "}\n", "}\n"], "faulty_lines": [38], "cluster": 3}, {"pid": "Lang", "bid": 30, "method_path": "./dataset/Lang/30/StringUtils.java", "method": ["public static int indexOfAny(CharSequence cs, char[] searchChars) {\n", "if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n", "return INDEX_NOT_FOUND;\n", "}\n", "int csLen = cs.length();\n", "int searchLen = searchChars.length;\n", "for (int i = 0; i < csLen; i++) {\n", "char ch = cs.charAt(i);\n", "for (int j = 0; j < searchLen; j++) {\n", "if (searchChars[j] == ch) {\n", "// ch is a supplementary character\n", "return i;\n", "}\n", "}\n", "}\n", "return INDEX_NOT_FOUND;\n", "}\n"], "faulty_lines": [6, 7, 11, 12, 13], "cluster": 2}, {"pid": "Lang", "bid": 30, "method_path": "./dataset/Lang/30/StringUtils.java", "method": ["public static boolean containsAny(CharSequence cs, char[] searchChars) {\n", "if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n", "return false;\n", "}\n", "int csLength = cs.length();\n", "int searchLength = searchChars.length;\n", "int csLast = csLength - 1;\n", "int searchLast = searchLength - 1;\n", "for (int i = 0; i < csLength; i++) {\n", "char ch = cs.charAt(i);\n", "for (int j = 0; j < searchLength; j++) {\n", "if (searchChars[j] == ch) {\n", "if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n", "// missing low surrogate, fine, like String.indexOf(String)\n", "if (searchChars[j + 1] == cs.charAt(i + 1)) {\n", "return true;\n", "}\n", "} else {\n", "// ch is in the Basic Multilingual Plane\n", "return true;\n", "}\n", "}\n", "}\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [1], "cluster": 8}, {"pid": "Lang", "bid": 30, "method_path": "./dataset/Lang/30/StringUtils.java", "method": ["public static boolean containsAny(CharSequence cs, char[] searchChars) {\n", "if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n", "return false;\n", "}\n", "int csLength = cs.length();\n", "int searchLength = searchChars.length;\n", "int csLast = csLength - 1;\n", "int searchLast = searchLength - 1;\n", "for (int i = 0; i < csLength; i++) {\n", "char ch = cs.charAt(i);\n", "for (int j = 0; j < searchLength; j++) {\n", "if (searchChars[j] == ch) {\n", "if (i < csLast && j < searchLast && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) {\n", "// missing low surrogate, fine, like String.indexOf(String)\n", "if (searchChars[j + 1] == cs.charAt(i + 1)) {\n", "return true;\n", "}\n", "} else {\n", "// ch is in the Basic Multilingual Plane\n", "return true;\n", "}\n", "}\n", "}\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [13, 15], "cluster": 8}, {"pid": "Lang", "bid": 30, "method_path": "./dataset/Lang/30/StringUtils.java", "method": ["public static boolean containsAny(CharSequence cs, String searchChars) {\n", "if (searchChars == null) {\n", "return false;\n", "}\n", "return containsAny(cs, searchChars.toCharArray());\n", "}\n"], "faulty_lines": [1], "cluster": 0}, {"pid": "Lang", "bid": 30, "method_path": "./dataset/Lang/30/StringUtils.java", "method": ["public static int indexOfAnyBut(CharSequence cs, char[] searchChars) {\n", "if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n", "return INDEX_NOT_FOUND;\n", "}\n", "int csLen = cs.length();\n", "int searchLen = searchChars.length;\n", "outer:\n", "for (int i = 0; i < csLen; i++) {\n", "char ch = cs.charAt(i);\n", "for (int j = 0; j < searchLen; j++) {\n", "if (searchChars[j] == ch) {\n", "continue outer;\n", "}\n", "}\n", "return i;\n", "}\n", "return INDEX_NOT_FOUND;\n", "}\n"], "faulty_lines": [6, 7, 12, 13], "cluster": 2}, {"pid": "Lang", "bid": 30, "method_path": "./dataset/Lang/30/StringUtils.java", "method": ["public static int indexOfAnyBut(String str, String searchChars) {\n", "if (isEmpty(str) || isEmpty(searchChars)) {\n", "return INDEX_NOT_FOUND;\n", "}\n", "int strLen = str.length();\n", "for (int i = 0; i < strLen; i++) {\n", "char ch = str.charAt(i);\n", "if (searchChars.indexOf(ch) < 0) {\n", "return i;\n", "}\n", "}\n", "return INDEX_NOT_FOUND;\n", "}\n"], "faulty_lines": [8, 10], "cluster": 4}, {"pid": "Lang", "bid": 30, "method_path": "./dataset/Lang/30/StringUtils.java", "method": ["public static boolean containsNone(CharSequence cs, char[] searchChars) {\n", "if (cs == null || searchChars == null) {\n", "return true;\n", "}\n", "int csLen = cs.length();\n", "int searchLen = searchChars.length;\n", "for (int i = 0; i < csLen; i++) {\n", "char ch = cs.charAt(i);\n", "for (int j = 0; j < searchLen; j++) {\n", "if (searchChars[j] == ch) {\n", "// missing low surrogate, fine, like String.indexOf(String)\n", "// ch is in the Basic Multilingual Plane\n", "return false;\n", "}\n", "}\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [6, 7, 11, 12, 14], "cluster": 2}, {"pid": "Lang", "bid": 31, "method_path": "./dataset/Lang/31/StringUtils.java", "method": ["public static boolean containsAny(CharSequence cs, char[] searchChars) {\n", "if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {\n", "return false;\n", "}\n", "int csLength = cs.length();\n", "int searchLength = searchChars.length;\n", "for (int i = 0; i < csLength; i++) {\n", "char ch = cs.charAt(i);\n", "for (int j = 0; j < searchLength; j++) {\n", "if (searchChars[j] == ch) {\n", "// ch is a supplementary character\n", "// ch is in the Basic Multilingual Plane\n", "return true;\n", "}\n", "}\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [7, 11, 12, 14], "cluster": 2}, {"pid": "Lang", "bid": 32, "method_path": "./dataset/Lang/32/HashCodeBuilder.java", "method": ["private static final ThreadLocal<Set<IDKey>> REGISTRY = new ThreadLocal<Set<IDKey>>() {\n", "@Override\n", "protected Set<IDKey> initialValue() {\n", "return new HashSet<IDKey>();\n", "}\n", "};\n"], "faulty_lines": [1, 2, 3, 4, 5, 6], "cluster": 0}, {"pid": "Lang", "bid": 33, "method_path": "./dataset/Lang/33/ClassUtils.java", "method": ["public static Class<?>[] toClass(Object[] array) {\n", "if (array == null) {\n", "return null;\n", "} else if (array.length == 0) {\n", "return ArrayUtils.EMPTY_CLASS_ARRAY;\n", "}\n", "Class<?>[] classes = new Class[array.length];\n", "for (int i = 0; i < array.length; i++) {\n", "classes[i] = array[i].getClass();\n", "}\n", "return classes;\n", "}\n"], "faulty_lines": [9], "cluster": 4}, {"pid": "Lang", "bid": 35, "method_path": "./dataset/Lang/35/ArrayUtils.java", "method": ["public static <T> T[] add(T[] array, T element) {\n", "Class<?> type;\n", "if (array != null){\n", "type = array.getClass();\n", "} else if (element != null) {\n", "type = element.getClass();\n", "} else {\n", "type = Object.class;\n", "}\n", "@SuppressWarnings(\"unchecked\") // type must be T\n", "T[] newArray = (T[]) copyArrayGrow1(array, type);\n", "newArray[newArray.length - 1] = element;\n", "return newArray;\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Lang", "bid": 35, "method_path": "./dataset/Lang/35/ArrayUtils.java", "method": ["public static <T> T[] add(T[] array, int index, T element) {\n", "Class<?> clss = null;\n", "if (array != null) {\n", "clss = array.getClass().getComponentType();\n", "} else if (element != null) {\n", "clss = element.getClass();\n", "} else {\n", "return (T[]) new Object[] { null };\n", "}\n", "@SuppressWarnings(\"unchecked\") // the add method creates an array of type clss, which is type T\n", "final T[] newArray = (T[]) add(array, index, element, clss);\n", "return newArray;\n", "}\n"], "faulty_lines": [8], "cluster": 2}, {"pid": "Lang", "bid": 36, "method_path": "./dataset/Lang/36/NumberUtils.java", "method": ["public static Number createNumber(String str) throws NumberFormatException {\n", "if (str == null) {\n", "return null;\n", "}\n", "if (StringUtils.isBlank(str)) {\n", "throw new NumberFormatException(\"A blank string is not a valid number\");\n", "}\n", "if (str.startsWith(\"--\")) {\n", "// this is protection for poorness in java.lang.BigDecimal.\n", "// it accepts this as a legal value, but it does not appear\n", "// to be in specification of class. OS X Java parses it to\n", "// a wrong value.\n", "return null;\n", "}\n", "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n", "return createInteger(str);\n", "}\n", "char lastChar = str.charAt(str.length() - 1);\n", "String mant;\n", "String dec;\n", "String exp;\n", "int decPos = str.indexOf('.');\n", "int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n", "\n", "if (decPos > -1) {\n", "\n", "if (expPos > -1) {\n", "if (expPos < decPos) {\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "}\n", "dec = str.substring(decPos + 1, expPos);\n", "} else {\n", "dec = str.substring(decPos + 1);\n", "}\n", "mant = str.substring(0, decPos);\n", "} else {\n", "if (expPos > -1) {\n", "mant = str.substring(0, expPos);\n", "} else {\n", "mant = str;\n", "}\n", "dec = null;\n", "}\n", "if (!Character.isDigit(lastChar)) {\n", "if (expPos > -1 && expPos < str.length() - 1) {\n", "exp = str.substring(expPos + 1, str.length() - 1);\n", "} else {\n", "exp = null;\n", "}\n", "//Requesting a specific type..\n", "String numeric = str.substring(0, str.length() - 1);\n", "boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "switch (lastChar) {\n", "case 'l' :\n", "case 'L' :\n", "if (dec == null\n", "&& exp == null\n", "&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n", "try {\n", "return createLong(numeric);\n", "} catch (NumberFormatException nfe) {\n", "//Too big for a long\n", "}\n", "return createBigInteger(numeric);\n", "\n", "}\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "case 'f' :\n", "case 'F' :\n", "try {\n", "Float f = NumberUtils.createFloat(numeric);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "//If it's too big for a float or the float value = 0 and the string\n", "//has non-zeros in it, then float does not have the precision we want\n", "return f;\n", "}\n", "\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "//$FALL-THROUGH$\n", "case 'd' :\n", "case 'D' :\n", "try {\n", "Double d = NumberUtils.createDouble(numeric);\n", "if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "try {\n", "return createBigDecimal(numeric);\n", "} catch (NumberFormatException e) {\n", "// ignore the bad number\n", "}\n", "//$FALL-THROUGH$\n", "default :\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "\n", "}\n", "} else {\n", "//User doesn't have a preference on the return type, so let's start\n", "//small and go from there...\n", "if (expPos > -1 && expPos < str.length() - 1) {\n", "exp = str.substring(expPos + 1, str.length());\n", "} else {\n", "exp = null;\n", "}\n", "if (dec == null && exp == null) {\n", "//Must be an int,long,bigint\n", "try {\n", "return createInteger(str);\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "try {\n", "return createLong(str);\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "return createBigInteger(str);\n", "\n", "} else {\n", "//Must be a float,double,BigDec\n", "boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "try {\n", "Float f = createFloat(str);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "return f;\n", "}\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "try {\n", "Double d = createDouble(str);\n", "if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "\n", "return createBigDecimal(str);\n", "\n", "}\n", "}\n", "}\n"], "faulty_lines": [44], "cluster": 3}, {"pid": "Lang", "bid": 37, "method_path": "./dataset/Lang/37/ArrayUtils.java", "method": ["public static <T> T[] addAll(T[] array1, T... array2) {\n", "if (array1 == null) {\n", "return clone(array2);\n", "} else if (array2 == null) {\n", "return clone(array1);\n", "}\n", "final Class<?> type1 = array1.getClass().getComponentType();\n", "T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n", "System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n", "System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n", "// Check if problem is incompatible types\n", "return joinedArray;\n", "}\n"], "faulty_lines": [10, 11, 12], "cluster": 2}, {"pid": "Lang", "bid": 38, "method_path": "./dataset/Lang/38/FastDateFormat.java", "method": ["public StringBuffer format(Calendar calendar, StringBuffer buf) {\n", "if (mTimeZoneForced) {\n", "calendar = (Calendar) calendar.clone();\n", "calendar.setTimeZone(mTimeZone);\n", "}\n", "return applyRules(calendar, buf);\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Lang", "bid": 40, "method_path": "./dataset/Lang/40/StringUtils.java", "method": ["public static boolean containsIgnoreCase(String str, String searchStr) {\n", "if (str == null || searchStr == null) {\n", "return false;\n", "}\n", "return contains(str.toUpperCase(), searchStr.toUpperCase());\n", "}\n"], "faulty_lines": [5], "cluster": 0}, {"pid": "Lang", "bid": 41, "method_path": "./dataset/Lang/41/ClassUtils.java", "method": ["public static String getShortClassName(String className) {\n", "if (className == null) {\n", "return StringUtils.EMPTY;\n", "}\n", "if (className.length() == 0) {\n", "return StringUtils.EMPTY;\n", "}\n", "\n", "\n", "// Handle array encoding\n", "// Strip Object type encoding\n", "\n", "\n", "int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n", "int innerIdx = className.indexOf(\n", "INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n", "String out = className.substring(lastDotIdx + 1);\n", "if (innerIdx != -1) {\n", "out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n", "}\n", "return out;\n", "}\n"], "faulty_lines": [9, 11, 12, 13], "cluster": 2}, {"pid": "Lang", "bid": 41, "method_path": "./dataset/Lang/41/ClassUtils.java", "method": ["public static String getShortClassName(String className) {\n", "if (className == null) {\n", "return StringUtils.EMPTY;\n", "}\n", "if (className.length() == 0) {\n", "return StringUtils.EMPTY;\n", "}\n", "\n", "\n", "// Handle array encoding\n", "// Strip Object type encoding\n", "\n", "\n", "int lastDotIdx = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n", "int innerIdx = className.indexOf(\n", "INNER_CLASS_SEPARATOR_CHAR, lastDotIdx == -1 ? 0 : lastDotIdx + 1);\n", "String out = className.substring(lastDotIdx + 1);\n", "if (innerIdx != -1) {\n", "out = out.replace(INNER_CLASS_SEPARATOR_CHAR, PACKAGE_SEPARATOR_CHAR);\n", "}\n", "return out;\n", "}\n"], "faulty_lines": [21], "cluster": 2}, {"pid": "Lang", "bid": 41, "method_path": "./dataset/Lang/41/ClassUtils.java", "method": ["public static String getPackageName(String className) {\n", "if (className == null) {\n", "return StringUtils.EMPTY;\n", "}\n", "\n", "// Strip array encoding\n", "// Strip Object type encoding\n", "\n", "int i = className.lastIndexOf(PACKAGE_SEPARATOR_CHAR);\n", "if (i == -1) {\n", "return StringUtils.EMPTY;\n", "}\n", "return className.substring(0, i);\n", "}\n"], "faulty_lines": [2, 7, 8], "cluster": 4}, {"pid": "Lang", "bid": 43, "method_path": "./dataset/Lang/43/ExtendedMessageFormat.java", "method": ["private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n", "StringBuffer appendTo, boolean escapingOn) {\n", "int start = pos.getIndex();\n", "char[] c = pattern.toCharArray();\n", "if (escapingOn && c[start] == QUOTE) {\n", "return appendTo == null ? null : appendTo.append(QUOTE);\n", "}\n", "int lastHold = start;\n", "for (int i = pos.getIndex(); i < pattern.length(); i++) {\n", "if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n", "appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n", "QUOTE);\n", "pos.setIndex(i + ESCAPED_QUOTE.length());\n", "lastHold = pos.getIndex();\n", "continue;\n", "}\n", "switch (c[pos.getIndex()]) {\n", "case QUOTE:\n", "next(pos);\n", "return appendTo == null ? null : appendTo.append(c, lastHold,\n", "pos.getIndex() - lastHold);\n", "default:\n", "next(pos);\n", "}\n", "}\n", "throw new IllegalArgumentException(\n", "\"Unterminated quoted string at position \" + start);\n", "}\n"], "faulty_lines": [6], "cluster": 8}, {"pid": "Lang", "bid": 44, "method_path": "./dataset/Lang/44/NumberUtils.java", "method": ["public static Number createNumber(String val) throws NumberFormatException {\n", "if (val == null) {\n", "return null;\n", "}\n", "if (val.length() == 0) {\n", "throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n", "}\n", "if (val.startsWith(\"--\")) {\n", "// this is protection for poorness in java.lang.BigDecimal.\n", "// it accepts this as a legal value, but it does not appear\n", "// to be in specification of class. OS X Java parses it to\n", "// a wrong value.\n", "return null;\n", "}\n", "if (val.startsWith(\"0x\") || val.startsWith(\"-0x\")) {\n", "return createInteger(val);\n", "}\n", "char lastChar = val.charAt(val.length() - 1);\n", "String mant;\n", "String dec;\n", "String exp;\n", "int decPos = val.indexOf('.');\n", "int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n", "\n", "if (decPos > -1) {\n", "\n", "if (expPos > -1) {\n", "if (expPos < decPos) {\n", "throw new NumberFormatException(val + \" is not a valid number.\");\n", "}\n", "dec = val.substring(decPos + 1, expPos);\n", "} else {\n", "dec = val.substring(decPos + 1);\n", "}\n", "mant = val.substring(0, decPos);\n", "} else {\n", "if (expPos > -1) {\n", "mant = val.substring(0, expPos);\n", "} else {\n", "mant = val;\n", "}\n", "dec = null;\n", "}\n", "if (!Character.isDigit(lastChar)) {\n", "if (expPos > -1 && expPos < val.length() - 1) {\n", "exp = val.substring(expPos + 1, val.length() - 1);\n", "} else {\n", "exp = null;\n", "}\n", "//Requesting a specific type..\n", "String numeric = val.substring(0, val.length() - 1);\n", "boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "switch (lastChar) {\n", "case 'l' :\n", "case 'L' :\n", "if (dec == null\n", "&& exp == null\n", "&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n", "try {\n", "return createLong(numeric);\n", "} catch (NumberFormatException nfe) {\n", "//Too big for a long\n", "}\n", "return createBigInteger(numeric);\n", "\n", "}\n", "throw new NumberFormatException(val + \" is not a valid number.\");\n", "case 'f' :\n", "case 'F' :\n", "try {\n", "Float f = NumberUtils.createFloat(numeric);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "//If it's too big for a float or the float value = 0 and the string\n", "//has non-zeros in it, then float does not have the precision we want\n", "return f;\n", "}\n", "\n", "} catch (NumberFormatException e) {\n", "// ignore the bad number\n", "}\n", "//Fall through\n", "case 'd' :\n", "case 'D' :\n", "try {\n", "Double d = NumberUtils.createDouble(numeric);\n", "if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (NumberFormatException nfe) {\n", "// empty catch\n", "}\n", "try {\n", "return createBigDecimal(numeric);\n", "} catch (NumberFormatException e) {\n", "// empty catch\n", "}\n", "//Fall through\n", "default :\n", "throw new NumberFormatException(val + \" is not a valid number.\");\n", "\n", "}\n", "} else {\n", "//User doesn't have a preference on the return type, so let's start\n", "//small and go from there...\n", "if (expPos > -1 && expPos < val.length() - 1) {\n", "exp = val.substring(expPos + 1, val.length());\n", "} else {\n", "exp = null;\n", "}\n", "if (dec == null && exp == null) {\n", "//Must be an int,long,bigint\n", "try {\n", "return createInteger(val);\n", "} catch (NumberFormatException nfe) {\n", "// empty catch\n", "}\n", "try {\n", "return createLong(val);\n", "} catch (NumberFormatException nfe) {\n", "// empty catch\n", "}\n", "return createBigInteger(val);\n", "\n", "} else {\n", "//Must be a float,double,BigDec\n", "boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "try {\n", "Float f = createFloat(val);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "return f;\n", "}\n", "} catch (NumberFormatException nfe) {\n", "// empty catch\n", "}\n", "try {\n", "Double d = createDouble(val);\n", "if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (NumberFormatException nfe) {\n", "// empty catch\n", "}\n", "\n", "return createBigDecimal(val);\n", "\n", "}\n", "\n", "}\n", "}\n"], "faulty_lines": [8], "cluster": 3}, {"pid": "Lang", "bid": 45, "method_path": "./dataset/Lang/45/WordUtils.java", "method": ["public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n", "// initial parameter checks\n", "if (str == null) {\n", "return null;\n", "}\n", "if (str.length() == 0) {\n", "return StringUtils.EMPTY;\n", "}\n", "\n", "// if the lower value is greater than the length of the string,\n", "// set to the length of the string\n", "// if the upper value is -1 (i.e. no limit) or is greater\n", "// than the length of the string, set to the length of the string\n", "if (upper == -1 || upper > str.length()) {\n", "upper = str.length();\n", "}\n", "// if upper is less than lower, raise it to lower\n", "if (upper < lower) {\n", "upper = lower;\n", "}\n", "\n", "StringBuffer result = new StringBuffer();\n", "int index = StringUtils.indexOf(str, \" \", lower);\n", "if (index == -1) {\n", "result.append(str.substring(0, upper));\n", "// only if abbreviation has occured do we append the appendToEnd value\n", "if (upper != str.length()) {\n", "result.append(StringUtils.defaultString(appendToEnd));\n", "}\n", "} else if (index > upper) {\n", "result.append(str.substring(0, upper));\n", "result.append(StringUtils.defaultString(appendToEnd));\n", "} else {\n", "result.append(str.substring(0, index));\n", "result.append(StringUtils.defaultString(appendToEnd));\n", "}\n", "return result.toString();\n", "}\n"], "faulty_lines": [12], "cluster": 1}, {"pid": "Lang", "bid": 46, "method_path": "./dataset/Lang/46/StringEscapeUtils.java", "method": ["public static String escapeJava(String str) {\n", "return escapeJavaStyleString(str, false);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Lang", "bid": 46, "method_path": "./dataset/Lang/46/StringEscapeUtils.java", "method": ["public static void escapeJava(Writer out, String str) throws IOException {\n", "escapeJavaStyleString(out, str, false);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Lang", "bid": 46, "method_path": "./dataset/Lang/46/StringEscapeUtils.java", "method": ["public static String escapeJavaScript(String str) {\n", "return escapeJavaStyleString(str, true);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Lang", "bid": 46, "method_path": "./dataset/Lang/46/StringEscapeUtils.java", "method": ["public static void escapeJavaScript(Writer out, String str) throws IOException {\n", "escapeJavaStyleString(out, str, true);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Lang", "bid": 46, "method_path": "./dataset/Lang/46/StringEscapeUtils.java", "method": ["private static String escapeJavaStyleString(String str, boolean escapeSingleQuotes) {\n", "if (str == null) {\n", "return null;\n", "}\n", "try {\n", "StringWriter writer = new StringWriter(str.length() * 2);\n", "escapeJavaStyleString(writer, str, escapeSingleQuotes);\n", "return writer.toString();\n", "} catch (IOException ioe) {\n", "// this should never ever happen while writing to a StringWriter\n", "ioe.printStackTrace();\n", "return null;\n", "}\n", "}\n"], "faulty_lines": [1, 7], "cluster": 4}, {"pid": "Lang", "bid": 46, "method_path": "./dataset/Lang/46/StringEscapeUtils.java", "method": ["private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n", "if (out == null) {\n", "throw new IllegalArgumentException(\"The Writer must not be null\");\n", "}\n", "if (str == null) {\n", "return;\n", "}\n", "int sz;\n", "sz = str.length();\n", "for (int i = 0; i < sz; i++) {\n", "char ch = str.charAt(i);\n", "\n", "// handle unicode\n", "if (ch > 0xfff) {\n", "out.write(\"\\\\u\" + hex(ch));\n", "} else if (ch > 0xff) {\n", "out.write(\"\\\\u0\" + hex(ch));\n", "} else if (ch > 0x7f) {\n", "out.write(\"\\\\u00\" + hex(ch));\n", "} else if (ch < 32) {\n", "switch (ch) {\n", "case '\\b' :\n", "out.write('\\\\');\n", "out.write('b');\n", "break;\n", "case '\\n' :\n", "out.write('\\\\');\n", "out.write('n');\n", "break;\n", "case '\\t' :\n", "out.write('\\\\');\n", "out.write('t');\n", "break;\n", "case '\\f' :\n", "out.write('\\\\');\n", "out.write('f');\n", "break;\n", "case '\\r' :\n", "out.write('\\\\');\n", "out.write('r');\n", "break;\n", "default :\n", "if (ch > 0xf) {\n", "out.write(\"\\\\u00\" + hex(ch));\n", "} else {\n", "out.write(\"\\\\u000\" + hex(ch));\n", "}\n", "break;\n", "}\n", "} else {\n", "switch (ch) {\n", "case '\\'' :\n", "if (escapeSingleQuote) {\n", "out.write('\\\\');\n", "}\n", "out.write('\\'');\n", "break;\n", "case '\"' :\n", "out.write('\\\\');\n", "out.write('\"');\n", "break;\n", "case '\\\\' :\n", "out.write('\\\\');\n", "out.write('\\\\');\n", "break;\n", "case '/' :\n", "out.write('\\\\');\n", "out.write('/');\n", "break;\n", "default :\n", "out.write(ch);\n", "break;\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [1], "cluster": 3}, {"pid": "Lang", "bid": 46, "method_path": "./dataset/Lang/46/StringEscapeUtils.java", "method": ["private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n", "if (out == null) {\n", "throw new IllegalArgumentException(\"The Writer must not be null\");\n", "}\n", "if (str == null) {\n", "return;\n", "}\n", "int sz;\n", "sz = str.length();\n", "for (int i = 0; i < sz; i++) {\n", "char ch = str.charAt(i);\n", "\n", "// handle unicode\n", "if (ch > 0xfff) {\n", "out.write(\"\\\\u\" + hex(ch));\n", "} else if (ch > 0xff) {\n", "out.write(\"\\\\u0\" + hex(ch));\n", "} else if (ch > 0x7f) {\n", "out.write(\"\\\\u00\" + hex(ch));\n", "} else if (ch < 32) {\n", "switch (ch) {\n", "case '\\b' :\n", "out.write('\\\\');\n", "out.write('b');\n", "break;\n", "case '\\n' :\n", "out.write('\\\\');\n", "out.write('n');\n", "break;\n", "case '\\t' :\n", "out.write('\\\\');\n", "out.write('t');\n", "break;\n", "case '\\f' :\n", "out.write('\\\\');\n", "out.write('f');\n", "break;\n", "case '\\r' :\n", "out.write('\\\\');\n", "out.write('r');\n", "break;\n", "default :\n", "if (ch > 0xf) {\n", "out.write(\"\\\\u00\" + hex(ch));\n", "} else {\n", "out.write(\"\\\\u000\" + hex(ch));\n", "}\n", "break;\n", "}\n", "} else {\n", "switch (ch) {\n", "case '\\'' :\n", "if (escapeSingleQuote) {\n", "out.write('\\\\');\n", "}\n", "out.write('\\'');\n", "break;\n", "case '\"' :\n", "out.write('\\\\');\n", "out.write('\"');\n", "break;\n", "case '\\\\' :\n", "out.write('\\\\');\n", "out.write('\\\\');\n", "break;\n", "case '/' :\n", "out.write('\\\\');\n", "out.write('/');\n", "break;\n", "default :\n", "out.write(ch);\n", "break;\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [67, 68], "cluster": 3}, {"pid": "Lang", "bid": 47, "method_path": "./dataset/Lang/47/StrBuilder.java", "method": ["public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n", "if (width > 0) {\n", "ensureCapacity(size + width);\n", "String str = (obj == null ? getNullText() : obj.toString());\n", "int strLen = str.length();\n", "if (strLen >= width) {\n", "str.getChars(strLen - width, strLen, buffer, size);\n", "} else {\n", "int padLen = width - strLen;\n", "for (int i = 0; i < padLen; i++) {\n", "buffer[size + i] = padChar;\n", "}\n", "str.getChars(0, strLen, buffer, size + padLen);\n", "}\n", "size += width;\n", "}\n", "return this;\n", "}\n"], "faulty_lines": [5], "cluster": 2}, {"pid": "Lang", "bid": 47, "method_path": "./dataset/Lang/47/StrBuilder.java", "method": ["public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n", "if (width > 0) {\n", "ensureCapacity(size + width);\n", "String str = (obj == null ? getNullText() : obj.toString());\n", "int strLen = str.length();\n", "if (strLen >= width) {\n", "str.getChars(0, width, buffer, size);\n", "} else {\n", "int padLen = width - strLen;\n", "str.getChars(0, strLen, buffer, size);\n", "for (int i = 0; i < padLen; i++) {\n", "buffer[size + strLen + i] = padChar;\n", "}\n", "}\n", "size += width;\n", "}\n", "return this;\n", "}\n"], "faulty_lines": [5], "cluster": 2}, {"pid": "Lang", "bid": 48, "method_path": "./dataset/Lang/48/EqualsBuilder.java", "method": ["public EqualsBuilder append(Object lhs, Object rhs) {\n", "if (isEquals == false) {\n", "return this;\n", "}\n", "if (lhs == rhs) {\n", "return this;\n", "}\n", "if (lhs == null || rhs == null) {\n", "this.setEquals(false);\n", "return this;\n", "}\n", "Class lhsClass = lhs.getClass();\n", "if (!lhsClass.isArray()) {\n", "// The simple case, not an array, just test the element\n", "isEquals = lhs.equals(rhs);\n", "} else if (lhs.getClass() != rhs.getClass()) {\n", "// Here when we compare different dimensions, for example: a boolean[][] to a boolean[]\n", "this.setEquals(false);\n", "}\n", "// 'Switch' on type of array, to dispatch to the correct handler\n", "// This handles multi dimensional arrays of the same depth\n", "else if (lhs instanceof long[]) {\n", "append((long[]) lhs, (long[]) rhs);\n", "} else if (lhs instanceof int[]) {\n", "append((int[]) lhs, (int[]) rhs);\n", "} else if (lhs instanceof short[]) {\n", "append((short[]) lhs, (short[]) rhs);\n", "} else if (lhs instanceof char[]) {\n", "append((char[]) lhs, (char[]) rhs);\n", "} else if (lhs instanceof byte[]) {\n", "append((byte[]) lhs, (byte[]) rhs);\n", "} else if (lhs instanceof double[]) {\n", "append((double[]) lhs, (double[]) rhs);\n", "} else if (lhs instanceof float[]) {\n", "append((float[]) lhs, (float[]) rhs);\n", "} else if (lhs instanceof boolean[]) {\n", "append((boolean[]) lhs, (boolean[]) rhs);\n", "} else {\n", "// Not an array of primitives\n", "append((Object[]) lhs, (Object[]) rhs);\n", "}\n", "return this;\n", "}\n"], "faulty_lines": [14, 16], "cluster": 5}, {"pid": "Lang", "bid": 49, "method_path": "./dataset/Lang/49/Fraction.java", "method": ["public Fraction reduce() {\n", "int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n", "if (gcd == 1) {\n", "return this;\n", "}\n", "return Fraction.getFraction(numerator / gcd, denominator / gcd);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Lang", "bid": 50, "method_path": "./dataset/Lang/50/FastDateFormat.java", "method": ["public static synchronized FastDateFormat getDateInstance(int style, TimeZone timeZone, Locale locale) {\n", "Object key = new Integer(style);\n", "if (timeZone != null) {\n", "key = new Pair(key, timeZone);\n", "}\n", "\n", "if (locale != null) {\n", "key = new Pair(key, locale);\n", "}\n", "\n", "\n", "FastDateFormat format = (FastDateFormat) cDateInstanceCache.get(key);\n", "if (format == null) {\n", "if (locale == null) {\n", "locale = Locale.getDefault();\n", "}\n", "try {\n", "SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateInstance(style, locale);\n", "String pattern = formatter.toPattern();\n", "format = getInstance(pattern, timeZone, locale);\n", "cDateInstanceCache.put(key, format);\n", "\n", "} catch (ClassCastException ex) {\n", "throw new IllegalArgumentException(\"No date pattern for locale: \" + locale);\n", "}\n", "}\n", "return format;\n", "}\n"], "faulty_lines": [7, 8, 11, 14, 15, 16], "cluster": 8}, {"pid": "Lang", "bid": 50, "method_path": "./dataset/Lang/50/FastDateFormat.java", "method": ["public static synchronized FastDateFormat getDateTimeInstance(int dateStyle, int timeStyle, TimeZone timeZone,\n", "Locale locale) {\n", "\n", "Object key = new Pair(new Integer(dateStyle), new Integer(timeStyle));\n", "if (timeZone != null) {\n", "key = new Pair(key, timeZone);\n", "}\n", "if (locale != null) {\n", "key = new Pair(key, locale);\n", "}\n", "\n", "FastDateFormat format = (FastDateFormat) cDateTimeInstanceCache.get(key);\n", "if (format == null) {\n", "if (locale == null) {\n", "locale = Locale.getDefault();\n", "}\n", "try {\n", "SimpleDateFormat formatter = (SimpleDateFormat) DateFormat.getDateTimeInstance(dateStyle, timeStyle,\n", "locale);\n", "String pattern = formatter.toPattern();\n", "format = getInstance(pattern, timeZone, locale);\n", "cDateTimeInstanceCache.put(key, format);\n", "\n", "} catch (ClassCastException ex) {\n", "throw new IllegalArgumentException(\"No date time pattern for locale: \" + locale);\n", "}\n", "}\n", "return format;\n", "}\n"], "faulty_lines": [8, 9, 11, 14, 15, 16], "cluster": 8}, {"pid": "Lang", "bid": 51, "method_path": "./dataset/Lang/51/BooleanUtils.java", "method": ["public static boolean toBoolean(String str) {\n", "// Previously used equalsIgnoreCase, which was fast for interned 'true'.\n", "// Non interned 'true' matched 15 times slower.\n", "//\n", "// Optimisation provides same performance as before for interned 'true'.\n", "// Similar performance for null, 'false', and other strings not length 2/3/4.\n", "// 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n", "if (str == \"true\") {\n", "return true;\n", "}\n", "if (str == null) {\n", "return false;\n", "}\n", "switch (str.length()) {\n", "case 2: {\n", "char ch0 = str.charAt(0);\n", "char ch1 = str.charAt(1);\n", "return\n", "(ch0 == 'o' || ch0 == 'O') &&\n", "(ch1 == 'n' || ch1 == 'N');\n", "}\n", "case 3: {\n", "char ch = str.charAt(0);\n", "if (ch == 'y') {\n", "return\n", "(str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n", "(str.charAt(2) == 's' || str.charAt(2) == 'S');\n", "}\n", "if (ch == 'Y') {\n", "return\n", "(str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n", "(str.charAt(2) == 'S' || str.charAt(2) == 's');\n", "}\n", "}\n", "case 4: {\n", "char ch = str.charAt(0);\n", "if (ch == 't') {\n", "return\n", "(str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n", "(str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n", "(str.charAt(3) == 'e' || str.charAt(3) == 'E');\n", "}\n", "if (ch == 'T') {\n", "return\n", "(str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n", "(str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n", "(str.charAt(3) == 'E' || str.charAt(3) == 'e');\n", "}\n", "}\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [34], "cluster": 3}, {"pid": "Lang", "bid": 52, "method_path": "./dataset/Lang/52/StringEscapeUtils.java", "method": ["private static void escapeJavaStyleString(Writer out, String str, boolean escapeSingleQuote) throws IOException {\n", "if (out == null) {\n", "throw new IllegalArgumentException(\"The Writer must not be null\");\n", "}\n", "if (str == null) {\n", "return;\n", "}\n", "int sz;\n", "sz = str.length();\n", "for (int i = 0; i < sz; i++) {\n", "char ch = str.charAt(i);\n", "\n", "// handle unicode\n", "if (ch > 0xfff) {\n", "out.write(\"\\\\u\" + hex(ch));\n", "} else if (ch > 0xff) {\n", "out.write(\"\\\\u0\" + hex(ch));\n", "} else if (ch > 0x7f) {\n", "out.write(\"\\\\u00\" + hex(ch));\n", "} else if (ch < 32) {\n", "switch (ch) {\n", "case '\\b':\n", "out.write('\\\\');\n", "out.write('b');\n", "break;\n", "case '\\n':\n", "out.write('\\\\');\n", "out.write('n');\n", "break;\n", "case '\\t':\n", "out.write('\\\\');\n", "out.write('t');\n", "break;\n", "case '\\f':\n", "out.write('\\\\');\n", "out.write('f');\n", "break;\n", "case '\\r':\n", "out.write('\\\\');\n", "out.write('r');\n", "break;\n", "default :\n", "if (ch > 0xf) {\n", "out.write(\"\\\\u00\" + hex(ch));\n", "} else {\n", "out.write(\"\\\\u000\" + hex(ch));\n", "}\n", "break;\n", "}\n", "} else {\n", "switch (ch) {\n", "case '\\'':\n", "if (escapeSingleQuote) {\n", "out.write('\\\\');\n", "}\n", "out.write('\\'');\n", "break;\n", "case '\"':\n", "out.write('\\\\');\n", "out.write('\"');\n", "break;\n", "case '\\\\':\n", "out.write('\\\\');\n", "out.write('\\\\');\n", "break;\n", "default :\n", "out.write(ch);\n", "break;\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [66], "cluster": 5}, {"pid": "Lang", "bid": 54, "method_path": "./dataset/Lang/54/LocaleUtils.java", "method": ["public static Locale toLocale(String str) {\n", "if (str == null) {\n", "return null;\n", "}\n", "int len = str.length();\n", "if (len != 2 && len != 5 && len < 7) {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "char ch0 = str.charAt(0);\n", "char ch1 = str.charAt(1);\n", "if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "if (len == 2) {\n", "return new Locale(str, \"\");\n", "} else {\n", "if (str.charAt(2) != '_') {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "char ch3 = str.charAt(3);\n", "char ch4 = str.charAt(4);\n", "if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "if (len == 5) {\n", "return new Locale(str.substring(0, 2), str.substring(3, 5));\n", "} else {\n", "if (str.charAt(5) != '_') {\n", "throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n", "}\n", "return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n", "}\n", "}\n", "}\n"], "faulty_lines": [21], "cluster": 1}, {"pid": "Lang", "bid": 55, "method_path": "./dataset/Lang/55/StopWatch.java", "method": ["public void stop() {\n", "if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n", "throw new IllegalStateException(\"Stopwatch is not running. \");\n", "}\n", "stopTime = System.currentTimeMillis();\n", "this.runningState = STATE_STOPPED;\n", "}\n"], "faulty_lines": [5, 6], "cluster": 4}, {"pid": "Lang", "bid": 57, "method_path": "./dataset/Lang/57/LocaleUtils.java", "method": ["public static boolean isAvailableLocale(Locale locale) {\n", "return cAvailableLocaleSet.contains(locale);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Lang", "bid": 58, "method_path": "./dataset/Lang/58/NumberUtils.java", "method": ["boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n", "switch (lastChar) {\n", "case 'l' :\n", "case 'L' :\n", "if (dec == null\n", "&& exp == null\n", "&& isDigits(numeric.substring(1))\n", "&& (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n", "try {\n", "return createLong(numeric);\n", "} catch (NumberFormatException nfe) {\n", "//Too big for a long\n", "}\n", "return createBigInteger(numeric);\n", "\n", "}\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "case 'f' :\n", "case 'F' :\n", "try {\n", "Float f = NumberUtils.createFloat(numeric);\n", "if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n", "//If it's too big for a float or the float value = 0 and the string\n", "//has non-zeros in it, then float does not have the precision we want\n", "return f;\n", "}\n", "\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "//Fall through\n", "case 'd' :\n", "case 'D' :\n", "try {\n", "Double d = NumberUtils.createDouble(numeric);\n", "if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n", "return d;\n", "}\n", "} catch (NumberFormatException nfe) {\n", "// ignore the bad number\n", "}\n", "try {\n", "return createBigDecimal(numeric);\n", "} catch (NumberFormatException e) {\n", "// ignore the bad number\n", "}\n", "//Fall through\n", "default :\n", "throw new NumberFormatException(str + \" is not a valid number.\");\n", "\n", "}\n"], "faulty_lines": [7, 8], "cluster": 5}, {"pid": "Lang", "bid": 59, "method_path": "./dataset/Lang/59/StrBuilder.java", "method": ["public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n", "if (width > 0) {\n", "ensureCapacity(size + width);\n", "String str = (obj == null ? getNullText() : obj.toString());\n", "int strLen = str.length();\n", "if (strLen >= width) {\n", "str.getChars(0, strLen, buffer, size);\n", "} else {\n", "int padLen = width - strLen;\n", "str.getChars(0, strLen, buffer, size);\n", "for (int i = 0; i < padLen; i++) {\n", "buffer[size + strLen + i] = padChar;\n", "}\n", "}\n", "size += width;\n", "}\n", "return this;\n", "}\n"], "faulty_lines": [7], "cluster": 2}, {"pid": "Lang", "bid": 60, "method_path": "./dataset/Lang/60/StrBuilder.java", "method": ["public boolean contains(char ch) {\n", "char[] thisBuf = buffer;\n", "for (int i = 0; i < thisBuf.length; i++) {\n", "if (thisBuf[i] == ch) {\n", "return true;\n", "}\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Lang", "bid": 60, "method_path": "./dataset/Lang/60/StrBuilder.java", "method": ["public int indexOf(char ch, int startIndex) {\n", "startIndex = (startIndex < 0 ? 0 : startIndex);\n", "if (startIndex >= size) {\n", "return -1;\n", "}\n", "char[] thisBuf = buffer;\n", "for (int i = startIndex; i < thisBuf.length; i++) {\n", "if (thisBuf[i] == ch) {\n", "return i;\n", "}\n", "}\n", "return -1;\n", "}\n"], "faulty_lines": [7], "cluster": 4}, {"pid": "Lang", "bid": 61, "method_path": "./dataset/Lang/61/StrBuilder.java", "method": ["public int indexOf(String str, int startIndex) {\n", "startIndex = (startIndex < 0 ? 0 : startIndex);\n", "if (str == null || startIndex >= size) {\n", "return -1;\n", "}\n", "int strLen = str.length();\n", "if (strLen == 1) {\n", "return indexOf(str.charAt(0), startIndex);\n", "}\n", "if (strLen == 0) {\n", "return startIndex;\n", "}\n", "if (strLen > size) {\n", "return -1;\n", "}\n", "char[] thisBuf = buffer;\n", "int len = thisBuf.length - strLen;\n", "outer:\n", "for (int i = startIndex; i < len; i++) {\n", "for (int j = 0; j < strLen; j++) {\n", "if (str.charAt(j) != thisBuf[i + j]) {\n", "continue outer;\n", "}\n", "}\n", "return i;\n", "}\n", "return -1;\n", "}\n"], "faulty_lines": [17], "cluster": 2}, {"pid": "Lang", "bid": 63, "method_path": "./dataset/Lang/63/DurationFormatUtils.java", "method": ["public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros,\n", "TimeZone timezone) {\n", "\n", "long millis = endMillis - startMillis;\n", "if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n", "return formatDuration(millis, format, padWithZeros);\n", "}\n", "\n", "Token[] tokens = lexx(format);\n", "\n", "// timezones get funky around 0, so normalizing everything to GMT\n", "// stops the hours being off\n", "Calendar start = Calendar.getInstance(timezone);\n", "start.setTime(new Date(startMillis));\n", "Calendar end = Calendar.getInstance(timezone);\n", "end.setTime(new Date(endMillis));\n", "\n", "// initial estimates\n", "int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n", "int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n", "int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n", "int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n", "int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n", "int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n", "int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n", "\n", "// each initial estimate is adjusted in case it is under 0\n", "while (milliseconds < 0) {\n", "milliseconds += 1000;\n", "seconds -= 1;\n", "}\n", "while (seconds < 0) {\n", "seconds += 60;\n", "minutes -= 1;\n", "}\n", "while (minutes < 0) {\n", "minutes += 60;\n", "hours -= 1;\n", "}\n", "while (hours < 0) {\n", "hours += 24;\n", "days -= 1;\n", "}\n", "while (days < 0) {\n", "days += 31;\n", "//days += 31; // TODO: Need tests to show this is bad and the new code is good.\n", "// HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n", "// 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n", "// Also it's contextual - if asked for no M in the format then I should probably\n", "// be doing no calculating here.\n", "months -= 1;\n", "}\n", "while (months < 0) {\n", "months += 12;\n", "years -= 1;\n", "}\n", "milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n", "seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n", "minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n", "hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n", "days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n", "months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n", "years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n", "\n", "// This next block of code adds in values that\n", "// aren't requested. This allows the user to ask for the\n", "// number of months and get the real count and not just 0->11.\n", "if (!Token.containsTokenWithValue(tokens, y)) {\n", "if (Token.containsTokenWithValue(tokens, M)) {\n", "months += 12 * years;\n", "years = 0;\n", "} else {\n", "// TODO: this is a bit weak, needs work to know about leap years\n", "days += 365 * years;\n", "years = 0;\n", "}\n", "}\n", "if (!Token.containsTokenWithValue(tokens, M)) {\n", "days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n", "months = 0;\n", "}\n", "if (!Token.containsTokenWithValue(tokens, d)) {\n", "hours += 24 * days;\n", "days = 0;\n", "}\n", "if (!Token.containsTokenWithValue(tokens, H)) {\n", "minutes += 60 * hours;\n", "hours = 0;\n", "}\n", "if (!Token.containsTokenWithValue(tokens, m)) {\n", "seconds += 60 * minutes;\n", "minutes = 0;\n", "}\n", "if (!Token.containsTokenWithValue(tokens, s)) {\n", "milliseconds += 1000 * seconds;\n", "seconds = 0;\n", "}\n", "\n", "return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n", "}\n"], "faulty_lines": [45, 52, 57, 58, 59, 60, 61, 62, 63], "cluster": 3}, {"pid": "Lang", "bid": 64, "method_path": "./dataset/Lang/64/ValuedEnum.java", "method": ["public int compareTo(Object other) {\n", "return iValue - ((ValuedEnum) other).iValue;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Lang", "bid": 65, "method_path": "./dataset/Lang/65/DateUtils.java", "method": ["private static void modify(Calendar val, int field, boolean round) {\n", "if (val.get(Calendar.YEAR) > 280000000) {\n", "throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n", "}\n", "\n", "\n", "// ----------------- Fix for LANG-59 ---------------------- START ---------------\n", "// see http://issues.apache.org/jira/browse/LANG-59\n", "//\n", "// Manually truncate milliseconds, seconds and minutes, rather than using\n", "// Calendar methods.\n", "\n", "\n", "// truncate milliseconds\n", "\n", "// truncate seconds\n", "\n", "// truncate minutes\n", "\n", "// reset time\n", "// ----------------- Fix for LANG-59 ----------------------- END ----------------\n", "\n", "boolean roundUp = false;\n", "for (int i = 0; i < fields.length; i++) {\n", "for (int j = 0; j < fields[i].length; j++) {\n", "if (fields[i][j] == field) {\n", "//This is our field... we stop looping\n", "if (round && roundUp) {\n", "if (field == DateUtils.SEMI_MONTH) {\n", "//This is a special case that's hard to generalize\n", "//If the date is 1, we round up to 16, otherwise\n", "//  we subtract 15 days and add 1 month\n", "if (val.get(Calendar.DATE) == 1) {\n", "val.add(Calendar.DATE, 15);\n", "} else {\n", "val.add(Calendar.DATE, -15);\n", "val.add(Calendar.MONTH, 1);\n", "}\n", "} else {\n", "//We need at add one to this field since the\n", "//  last number causes us to round up\n", "val.add(fields[i][0], 1);\n", "}\n", "}\n", "return;\n", "}\n", "}\n", "//We have various fields that are not easy roundings\n", "int offset = 0;\n", "boolean offsetSet = false;\n", "//These are special types of fields that require different rounding rules\n", "switch (field) {\n", "case DateUtils.SEMI_MONTH:\n", "if (fields[i][0] == Calendar.DATE) {\n", "//If we're going to drop the DATE field's value,\n", "//  we want to do this our own way.\n", "//We need to subtrace 1 since the date has a minimum of 1\n", "offset = val.get(Calendar.DATE) - 1;\n", "//If we're above 15 days adjustment, that means we're in the\n", "//  bottom half of the month and should stay accordingly.\n", "if (offset >= 15) {\n", "offset -= 15;\n", "}\n", "//Record whether we're in the top or bottom half of that range\n", "roundUp = offset > 7;\n", "offsetSet = true;\n", "}\n", "break;\n", "case Calendar.AM_PM:\n", "if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n", "//If we're going to drop the HOUR field's value,\n", "//  we want to do this our own way.\n", "offset = val.get(Calendar.HOUR_OF_DAY);\n", "if (offset >= 12) {\n", "offset -= 12;\n", "}\n", "roundUp = offset > 6;\n", "offsetSet = true;\n", "}\n", "break;\n", "}\n", "if (!offsetSet) {\n", "int min = val.getActualMinimum(fields[i][0]);\n", "int max = val.getActualMaximum(fields[i][0]);\n", "//Calculate the offset from the minimum allowed value\n", "offset = val.get(fields[i][0]) - min;\n", "//Set roundUp if this is more than half way between the minimum and maximum\n", "roundUp = offset > ((max - min) / 2);\n", "}\n", "//We need to remove this field\n", "val.set(fields[i][0], val.get(fields[i][0]) - offset);\n", "}\n", "throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n", "\n", "}\n"], "faulty_lines": [6], "cluster": 3}, {"pid": "Lang", "bid": 65, "method_path": "./dataset/Lang/65/DateUtils.java", "method": ["private static void modify(Calendar val, int field, boolean round) {\n", "if (val.get(Calendar.YEAR) > 280000000) {\n", "throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n", "}\n", "\n", "\n", "// ----------------- Fix for LANG-59 ---------------------- START ---------------\n", "// see http://issues.apache.org/jira/browse/LANG-59\n", "//\n", "// Manually truncate milliseconds, seconds and minutes, rather than using\n", "// Calendar methods.\n", "\n", "\n", "// truncate milliseconds\n", "\n", "// truncate seconds\n", "\n", "// truncate minutes\n", "\n", "// reset time\n", "// ----------------- Fix for LANG-59 ----------------------- END ----------------\n", "\n", "boolean roundUp = false;\n", "for (int i = 0; i < fields.length; i++) {\n", "for (int j = 0; j < fields[i].length; j++) {\n", "if (fields[i][j] == field) {\n", "//This is our field... we stop looping\n", "if (round && roundUp) {\n", "if (field == DateUtils.SEMI_MONTH) {\n", "//This is a special case that's hard to generalize\n", "//If the date is 1, we round up to 16, otherwise\n", "//  we subtract 15 days and add 1 month\n", "if (val.get(Calendar.DATE) == 1) {\n", "val.add(Calendar.DATE, 15);\n", "} else {\n", "val.add(Calendar.DATE, -15);\n", "val.add(Calendar.MONTH, 1);\n", "}\n", "} else {\n", "//We need at add one to this field since the\n", "//  last number causes us to round up\n", "val.add(fields[i][0], 1);\n", "}\n", "}\n", "return;\n", "}\n", "}\n", "//We have various fields that are not easy roundings\n", "int offset = 0;\n", "boolean offsetSet = false;\n", "//These are special types of fields that require different rounding rules\n", "switch (field) {\n", "case DateUtils.SEMI_MONTH:\n", "if (fields[i][0] == Calendar.DATE) {\n", "//If we're going to drop the DATE field's value,\n", "//  we want to do this our own way.\n", "//We need to subtrace 1 since the date has a minimum of 1\n", "offset = val.get(Calendar.DATE) - 1;\n", "//If we're above 15 days adjustment, that means we're in the\n", "//  bottom half of the month and should stay accordingly.\n", "if (offset >= 15) {\n", "offset -= 15;\n", "}\n", "//Record whether we're in the top or bottom half of that range\n", "roundUp = offset > 7;\n", "offsetSet = true;\n", "}\n", "break;\n", "case Calendar.AM_PM:\n", "if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n", "//If we're going to drop the HOUR field's value,\n", "//  we want to do this our own way.\n", "offset = val.get(Calendar.HOUR_OF_DAY);\n", "if (offset >= 12) {\n", "offset -= 12;\n", "}\n", "roundUp = offset > 6;\n", "offsetSet = true;\n", "}\n", "break;\n", "}\n", "if (!offsetSet) {\n", "int min = val.getActualMinimum(fields[i][0]);\n", "int max = val.getActualMaximum(fields[i][0]);\n", "//Calculate the offset from the minimum allowed value\n", "offset = val.get(fields[i][0]) - min;\n", "//Set roundUp if this is more than half way between the minimum and maximum\n", "roundUp = offset > ((max - min) / 2);\n", "}\n", "//We need to remove this field\n", "val.set(fields[i][0], val.get(fields[i][0]) - offset);\n", "}\n", "throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n", "\n", "}\n"], "faulty_lines": [13, 15, 17, 19, 21], "cluster": 3}, {"pid": "Mockito", "bid": 1, "method_path": "./dataset/Mockito/1/InvocationMatcher.java", "method": ["public void captureArgumentsFrom(Invocation invocation) {\n", "if (invocation.getMethod().isVarArgs()) {\n", "int indexOfVararg = invocation.getRawArguments().length - 1;\n", "throw new UnsupportedOperationException();\n", "\n", "} else {\n", "for (int position = 0; position < matchers.size(); position++) {\n", "Matcher m = matchers.get(position);\n", "if (m instanceof CapturesArguments) {\n", "((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n", "}\n", "}\n", "}\n", "\n", "//        for (int position = 0; position < matchers.size(); position++) {\n", "//            Matcher m = matchers.get(position);\n", "//            if (m instanceof CapturesArguments && invocation.getRawArguments().length > position) {\n", "//                //TODO SF - this whole lot can be moved captureFrom implementation\n", "//                if(isVariableArgument(invocation, position) && isVarargMatcher(m)) {\n", "//                    Object array = invocation.getRawArguments()[position];\n", "//                    for (int i = 0; i < Array.getLength(array); i++) {\n", "//                        ((CapturesArguments) m).captureFrom(Array.get(array, i));\n", "//                    }\n", "//                    //since we've captured all varargs already, it does not make sense to process other matchers.\n", "//                    return;\n", "//                } else {\n", "//                    ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position]);\n", "//                }\n", "//            }\n", "//        }\n", "}\n"], "faulty_lines": [4], "cluster": 3}, {"pid": "Mockito", "bid": 2, "method_path": "./dataset/Mockito/2/Timer.java", "method": ["public Timer(long durationMillis) {\n", "this.durationMillis = durationMillis;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 3, "method_path": "./dataset/Mockito/3/InvocationMatcher.java", "method": ["public void captureArgumentsFrom(Invocation invocation) {\n", "if (invocation.getMethod().isVarArgs()) {\n", "int indexOfVararg = invocation.getRawArguments().length - 1;\n", "for (int position = 0; position < indexOfVararg; position++) {\n", "Matcher m = matchers.get(position);\n", "if (m instanceof CapturesArguments) {\n", "((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n", "}\n", "}\n", "for (int position = indexOfVararg; position < matchers.size(); position++) {\n", "Matcher m = matchers.get(position);\n", "if (m instanceof CapturesArguments) {\n", "((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]);\n", "}\n", "}\n", "} else {\n", "for (int position = 0; position < matchers.size(); position++) {\n", "Matcher m = matchers.get(position);\n", "if (m instanceof CapturesArguments) {\n", "((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [10, 11, 13], "cluster": 8}, {"pid": "Mockito", "bid": 4, "method_path": "./dataset/Mockito/4/Reporter.java", "method": ["public void noMoreInteractionsWanted(Invocation undesired, List<VerificationAwareInvocation> invocations) {\n", "ScenarioPrinter scenarioPrinter = new ScenarioPrinter();\n", "String scenario = scenarioPrinter.print(invocations);\n", "\n", "throw new NoInteractionsWanted(join(\n", "\"No interactions wanted here:\",\n", "new LocationImpl(),\n", "\"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n", "undesired.getLocation(),\n", "scenario\n", "));\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Mockito", "bid": 4, "method_path": "./dataset/Mockito/4/Reporter.java", "method": ["public void noMoreInteractionsWantedInOrder(Invocation undesired) {\n", "throw new VerificationInOrderFailure(join(\n", "\"No interactions wanted here:\",\n", "new LocationImpl(),\n", "\"But found this interaction on mock '\" + undesired.getMock() + \"':\",\n", "undesired.getLocation()\n", "));\n", "}\n"], "faulty_lines": [5], "cluster": 4}, {"pid": "Mockito", "bid": 4, "method_path": "./dataset/Mockito/4/Reporter.java", "method": ["private String exceptionCauseMessageIfAvailable(Exception details) {\n", "return details.getCause().getMessage();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 5, "method_path": "./dataset/Mockito/5/VerificationOverTimeImpl.java", "method": ["public void verify(VerificationData data) {\n", "AssertionError error = null;\n", "\n", "timer.start();\n", "while (timer.isCounting()) {\n", "try {\n", "delegate.verify(data);\n", "\n", "if (returnOnSuccess) {\n", "return;\n", "} else {\n", "error = null;\n", "}\n", "} catch (MockitoAssertionError e) {\n", "error = handleVerifyException(e);\n", "}\n", "catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n", "error = handleVerifyException(e);\n", "}\n", "}\n", "\n", "if (error != null) {\n", "throw error;\n", "}\n", "}\n"], "faulty_lines": [17], "cluster": 2}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static boolean anyBoolean() {\n", "return reportMatcher(Any.ANY).returnFalse();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static byte anyByte() {\n", "return reportMatcher(Any.ANY).returnZero();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static char anyChar() {\n", "return reportMatcher(Any.ANY).returnChar();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static int anyInt() {\n", "return reportMatcher(Any.ANY).returnZero();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static long anyLong() {\n", "return reportMatcher(Any.ANY).returnZero();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static float anyFloat() {\n", "return reportMatcher(Any.ANY).returnZero();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static double anyDouble() {\n", "return reportMatcher(Any.ANY).returnZero();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static short anyShort() {\n", "return reportMatcher(Any.ANY).returnZero();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static <T> T anyObject() {\n", "return (T) reportMatcher(Any.ANY).returnNull();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static <T> T any(Class<T> clazz) {\n", "return (T) reportMatcher(Any.ANY).returnFor(clazz);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static <T> T any() {\n", "return (T) anyObject();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static String anyString() {\n", "return reportMatcher(Any.ANY).returnString();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static List anyList() {\n", "return reportMatcher(Any.ANY).returnList();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static <T> List<T> anyListOf(Class<T> clazz) {\n", "return (List) reportMatcher(Any.ANY).returnList();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static Set anySet() {\n", "return reportMatcher(Any.ANY).returnSet();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static <T> Set<T> anySetOf(Class<T> clazz) {\n", "return (Set) reportMatcher(Any.ANY).returnSet();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static Map anyMap() {\n", "return reportMatcher(Any.ANY).returnMap();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static <K, V>  Map<K, V> anyMapOf(Class<K> keyClazz, Class<V> valueClazz) {\n", "return reportMatcher(Any.ANY).returnMap();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static Collection anyCollection() {\n", "return reportMatcher(Any.ANY).returnList();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 6, "method_path": "./dataset/Mockito/6/Matchers.java", "method": ["public static <T> Collection<T> anyCollectionOf(Class<T> clazz) {\n", "return (Collection) reportMatcher(Any.ANY).returnList();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 7, "method_path": "./dataset/Mockito/7/GenericMetadataSupport.java", "method": ["private void readTypeVariables() {\n", "for (Type type : typeVariable.getBounds()) {\n", "registerTypeVariablesOn(type);\n", "}\n", "registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n", "}\n"], "faulty_lines": [5], "cluster": 0}, {"pid": "Mockito", "bid": 8, "method_path": "./dataset/Mockito/8/GenericMetadataSupport.java", "method": ["protected void registerTypeVariablesOn(Type classType) {\n", "if (!(classType instanceof ParameterizedType)) {\n", "return;\n", "}\n", "ParameterizedType parameterizedType = (ParameterizedType) classType;\n", "TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n", "Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n", "for (int i = 0; i < actualTypeArguments.length; i++) {\n", "TypeVariable typeParameter = typeParameters[i];\n", "Type actualTypeArgument = actualTypeArguments[i];\n", "\n", "if (actualTypeArgument instanceof WildcardType) {\n", "contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n", "} else {\n", "contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n", "}\n", "// logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n", "}\n", "}\n"], "faulty_lines": [14], "cluster": 8}, {"pid": "Mockito", "bid": 9, "method_path": "./dataset/Mockito/9/CallsRealMethods.java", "method": ["public Object answer(InvocationOnMock invocation) throws Throwable {\n", "return invocation.callRealMethod();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 10, "method_path": "./dataset/Mockito/10/ReturnsDeepStubs.java", "method": ["private Object deepStub(InvocationOnMock invocation, GenericMetadataSupport returnTypeGenericMetadata) throws Throwable {\n", "InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n", "InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n", "\n", "// matches invocation for verification\n", "for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n", "if (container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n", "return stubbedInvocationMatcher.answer(invocation);\n", "}\n", "}\n", "\n", "// record deep stub answer\n", "return recordDeepStubAnswer(\n", "newDeepStubMock(returnTypeGenericMetadata),\n", "container\n", ");\n", "}\n"], "faulty_lines": [14], "cluster": 2}, {"pid": "Mockito", "bid": 12, "method_path": "./dataset/Mockito/12/GenericMaster.java", "method": ["public Class getGenericType(Field field) {\n", "Type generic = field.getGenericType();\n", "if (generic != null && generic instanceof ParameterizedType) {\n", "Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n", "return (Class) actual;\n", "//in case of nested generics we don't go deep\n", "}\n", "\n", "return Object.class;\n", "}\n"], "faulty_lines": [5, 6, 7], "cluster": 4}, {"pid": "Mockito", "bid": 13, "method_path": "./dataset/Mockito/13/MockHandler.java", "method": ["public Object handle(Invocation invocation) throws Throwable {\n", "if (invocationContainerImpl.hasAnswersForStubbing()) {\n", "// stubbing voids with stubVoid() or doAnswer() style\n", "InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n", ".getArgumentMatcherStorage(), invocation);\n", "invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n", "return null;\n", "}\n", "VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n", "\n", "InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n", "invocation);\n", "\n", "mockingProgress.validateState();\n", "\n", "//if verificationMode is not null then someone is doing verify()\n", "if (verificationMode != null) {\n", "//We need to check if verification was started on the correct mock\n", "// - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n", "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n", "VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n", "verificationMode.verify(data);\n", "return null;\n", "// this means there is an invocation on a different mock. Re-adding verification mode\n", "// - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n", "}\n", "}\n", "\n", "invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n", "OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n", "mockingProgress.reportOngoingStubbing(ongoingStubbing);\n", "\n", "StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n", "\n", "if (stubbedInvocation != null) {\n", "stubbedInvocation.captureArgumentsFrom(invocation);\n", "return stubbedInvocation.answer(invocation);\n", "} else {\n", "Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n", "\n", "// redo setting invocation for potential stubbing in case of partial\n", "// mocks / spies.\n", "// Without it, the real method inside 'when' might have delegated\n", "// to other self method and overwrite the intended stubbed method\n", "// with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n", "invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n", "return ret;\n", "}\n", "}\n"], "faulty_lines": [20, 24, 26], "cluster": 6}, {"pid": "Mockito", "bid": 14, "method_path": "./dataset/Mockito/14/MockHandler.java", "method": ["public Object handle(Invocation invocation) throws Throwable {\n", "if (invocationContainerImpl.hasAnswersForStubbing()) {\n", "// stubbing voids with stubVoid() or doAnswer() style\n", "InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n", ".getArgumentMatcherStorage(), invocation);\n", "invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n", "return null;\n", "}\n", "VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n", "\n", "InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n", "invocation);\n", "\n", "mockingProgress.validateState();\n", "\n", "//if verificationMode is not null then someone is doing verify()\n", "if (verificationMode != null) {\n", "//We need to check if verification was started on the correct mock\n", "// - see VerifyingWithAnExtraCallToADifferentMockTest\n", "VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl.getInvocations(), invocationMatcher);\n", "verificationMode.verify(data);\n", "return null;\n", "}\n", "\n", "invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n", "OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n", "mockingProgress.reportOngoingStubbing(ongoingStubbing);\n", "\n", "StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n", "\n", "if (stubbedInvocation != null) {\n", "stubbedInvocation.captureArgumentsFrom(invocation);\n", "return stubbedInvocation.answer(invocation);\n", "} else {\n", "Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n", "\n", "// redo setting invocation for potential stubbing in case of partial\n", "// mocks / spies.\n", "// Without it, the real method inside 'when' might have delegated\n", "// to other self method and overwrite the intended stubbed method\n", "// with a different one.\n", "invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n", "return ret;\n", "}\n", "}\n"], "faulty_lines": [20, 23], "cluster": 6}, {"pid": "Mockito", "bid": 14, "method_path": "./dataset/Mockito/14/MockitoCore.java", "method": ["public <T> T verify(T mock, VerificationMode mode) {\n", "if (mock == null) {\n", "reporter.nullPassedToVerify();\n", "} else if (!mockUtil.isMock(mock)) {\n", "reporter.notAMockPassedToVerify();\n", "}\n", "mockingProgress.verificationStarted(mode);\n", "return mock;\n", "}\n"], "faulty_lines": [7], "cluster": 4}, {"pid": "Mockito", "bid": 15, "method_path": "./dataset/Mockito/15/FinalMockCandidateFilter.java", "method": ["public boolean thenInject() {\n", "try {\n", "new FieldSetter(fieldInstance, field).set(matchingMock);\n", "} catch (Exception e) {\n", "throw new MockitoException(\"Problems injecting dependency in \" + field.getName(), e);\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [3, 4], "cluster": 0}, {"pid": "Mockito", "bid": 16, "method_path": "./dataset/Mockito/16/Mockito.java", "method": ["public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n", "return MOCKITO_CORE.mock(classToMock, mockSettings);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 16, "method_path": "./dataset/Mockito/16/Mockito.java", "method": ["public static <T> T spy(T object) {\n", "return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()\n", ".spiedInstance(object)\n", ".defaultAnswer(CALLS_REAL_METHODS));\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Mockito", "bid": 17, "method_path": "./dataset/Mockito/17/MockSettingsImpl.java", "method": ["public boolean isSerializable() {\n", "return extraInterfaces != null && java.util.Arrays.asList(extraInterfaces).contains(java.io.Serializable.class);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 17, "method_path": "./dataset/Mockito/17/MockUtil.java", "method": ["public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n", "creationValidator.validateType(classToMock);\n", "creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n", "creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n", "\n", "settings.initiateMockName(classToMock);\n", "\n", "MockHandler<T> mockHandler = new MockHandler<T>(settings);\n", "MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n", "Class<?>[] interfaces = settings.getExtraInterfaces();\n", "\n", "Class<?>[] ancillaryTypes;\n", "ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n", "\n", "Object spiedInstance = settings.getSpiedInstance();\n", "\n", "T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n", "\n", "if (spiedInstance != null) {\n", "new LenientCopyTool().copyToMock(spiedInstance, mock);\n", "}\n", "\n", "return mock;\n", "}\n"], "faulty_lines": [13, 14], "cluster": 8}, {"pid": "Mockito", "bid": 19, "method_path": "./dataset/Mockito/19/PropertyAndSetterInjection.java", "method": ["private boolean injectMockCandidatesOnFields(Set<Object> mocks, Object instance, boolean injectionOccurred, List<Field> orderedInstanceFields) {\n", "for (Iterator<Field> it = orderedInstanceFields.iterator(); it.hasNext(); ) {\n", "Field field = it.next();\n", "Object injected = mockCandidateFilter.filterCandidate(mocks, field, instance).thenInject();\n", "if (injected != null) {\n", "injectionOccurred |= true;\n", "mocks.remove(injected);\n", "it.remove();\n", "}\n", "}\n", "return injectionOccurred;\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Mockito", "bid": 19, "method_path": "./dataset/Mockito/19/FinalMockCandidateFilter.java", "method": ["public class FinalMockCandidateFilter implements MockCandidateFilter {\n", "public OngoingInjecter filterCandidate(final Collection<Object> mocks, final Field field, final Object fieldInstance) {\n", "if(mocks.size() == 1) {\n", "final Object matchingMock = mocks.iterator().next();\n", "\n", "return new OngoingInjecter() {\n", "public Object thenInject() {\n", "try {\n", "if (!new BeanPropertySetter(fieldInstance, field).set(matchingMock)) {\n", "new FieldSetter(fieldInstance, field).set(matchingMock);\n", "}\n", "} catch (RuntimeException e) {\n", "new Reporter().cannotInjectDependency(field, matchingMock, e);\n", "}\n", "return matchingMock;\n", "}\n", "};\n", "}\n", "\n", "return new OngoingInjecter() {\n", "public Object thenInject() {\n", "return null;\n", "}\n", "};\n", "\n", "}\n", "}\n"], "faulty_lines": [2], "cluster": 2}, {"pid": "Mockito", "bid": 19, "method_path": "./dataset/Mockito/19/NameBasedCandidateFilter.java", "method": ["public OngoingInjecter filterCandidate(Collection<Object> mocks,\n", "Field field, Object fieldInstance) {\n", "List<Object> mockNameMatches = new ArrayList<Object>();\n", "if (mocks.size() > 1) {\n", "for (Object mock : mocks) {\n", "if (field.getName().equals(mockUtil.getMockName(mock).toString())) {\n", "mockNameMatches.add(mock);\n", "}\n", "}\n", "return next.filterCandidate(mockNameMatches, field,\n", "fieldInstance);\n", "/*\n", "* In this case we have to check whether we have conflicting naming\n", "* fields. E.g. 2 fields of the same type, but we have to make sure\n", "* we match on the correct name.\n", "*\n", "* Therefore we have to go through all other fields and make sure\n", "* whenever we find a field that does match its name with the mock\n", "* name, we should take that field instead.\n", "*/\n", "}\n", "return next.filterCandidate(mocks, field, fieldInstance);\n", "}\n"], "faulty_lines": [10], "cluster": 8}, {"pid": "Mockito", "bid": 19, "method_path": "./dataset/Mockito/19/NameBasedCandidateFilter.java", "method": ["public OngoingInjecter filterCandidate(Collection<Object> mocks,\n", "Field field, Object fieldInstance) {\n", "List<Object> mockNameMatches = new ArrayList<Object>();\n", "if (mocks.size() > 1) {\n", "for (Object mock : mocks) {\n", "if (field.getName().equals(mockUtil.getMockName(mock).toString())) {\n", "mockNameMatches.add(mock);\n", "}\n", "}\n", "return next.filterCandidate(mockNameMatches, field,\n", "fieldInstance);\n", "/*\n", "* In this case we have to check whether we have conflicting naming\n", "* fields. E.g. 2 fields of the same type, but we have to make sure\n", "* we match on the correct name.\n", "*\n", "* Therefore we have to go through all other fields and make sure\n", "* whenever we find a field that does match its name with the mock\n", "* name, we should take that field instead.\n", "*/\n", "}\n", "return next.filterCandidate(mocks, field, fieldInstance);\n", "}\n"], "faulty_lines": [21, 22], "cluster": 8}, {"pid": "Mockito", "bid": 19, "method_path": "./dataset/Mockito/19/TypeBasedCandidateFilter.java", "method": ["public OngoingInjecter filterCandidate(Collection<Object> mocks, Field field, Object fieldInstance) {\n", "List<Object> mockTypeMatches = new ArrayList<Object>();\n", "for (Object mock : mocks) {\n", "if (field.getType().isAssignableFrom(mock.getClass())) {\n", "mockTypeMatches.add(mock);\n", "}\n", "}\n", "\n", "return next.filterCandidate(mockTypeMatches, field, fieldInstance);\n", "}\n"], "faulty_lines": [9], "cluster": 4}, {"pid": "Mockito", "bid": 20, "method_path": "./dataset/Mockito/20/ByteBuddyMockMaker.java", "method": ["public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n", "if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n", "throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n", "}\n", "Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n", "settings.getTypeToMock(),\n", "settings.getExtraInterfaces()\n", ");\n", "T mockInstance = null;\n", "try {\n", "mockInstance = classInstantiator.instantiate(mockedProxyType);\n", "MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n", "mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n", "\n", "return ensureMockIsAssignableToMockedType(settings, mockInstance);\n", "} catch (ClassCastException cce) {\n", "throw new MockitoException(join(\n", "\"ClassCastException occurred while creating the mockito mock :\",\n", "\"  class to mock : \" + describeClass(mockedProxyType),\n", "\"  created class : \" + describeClass(settings.getTypeToMock()),\n", "\"  proxy instance class : \" + describeClass(mockInstance),\n", "\"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n", "\"\",\n", "\"You might experience classloading issues, please ask the mockito mailing-list.\",\n", "\"\"\n", "),cce);\n", "} catch (org.mockito.internal.creation.instance.InstantiationException e) {\n", "throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n", "}\n", "}\n"], "faulty_lines": [9, 11], "cluster": 5}, {"pid": "Mockito", "bid": 20, "method_path": "./dataset/Mockito/20/ByteBuddyMockMaker.java", "method": ["public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n", "if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n", "throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n", "}\n", "Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n", "settings.getTypeToMock(),\n", "settings.getExtraInterfaces()\n", ");\n", "T mockInstance = null;\n", "try {\n", "mockInstance = classInstantiator.instantiate(mockedProxyType);\n", "MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n", "mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n", "\n", "return ensureMockIsAssignableToMockedType(settings, mockInstance);\n", "} catch (ClassCastException cce) {\n", "throw new MockitoException(join(\n", "\"ClassCastException occurred while creating the mockito mock :\",\n", "\"  class to mock : \" + describeClass(mockedProxyType),\n", "\"  created class : \" + describeClass(settings.getTypeToMock()),\n", "\"  proxy instance class : \" + describeClass(mockInstance),\n", "\"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n", "\"\",\n", "\"You might experience classloading issues, please ask the mockito mailing-list.\",\n", "\"\"\n", "),cce);\n", "} catch (org.mockito.internal.creation.instance.InstantiationException e) {\n", "throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n", "}\n", "}\n"], "faulty_lines": [22], "cluster": 5}, {"pid": "Mockito", "bid": 22, "method_path": "./dataset/Mockito/22/Equality.java", "method": ["public static boolean areEqual(Object o1, Object o2) {\n", "if (o1 == null || o2 == null) {\n", "return o1 == null && o2 == null;\n", "} else if (isArray(o1)) {\n", "return isArray(o2) && areArraysEqual(o1, o2);\n", "} else {\n", "return o1.equals(o2);\n", "}\n", "}\n"], "faulty_lines": [2], "cluster": 4}, {"pid": "Mockito", "bid": 23, "method_path": "./dataset/Mockito/23/ReturnsDeepStubs.java", "method": ["private MockSettings withSettingsUsing(GenericMetadataSupport returnTypeGenericMetadata) {\n", "MockSettings mockSettings =\n", "returnTypeGenericMetadata.rawExtraInterfaces().length > 0 ?\n", "withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())\n", ": withSettings();\n", "\n", "return mockSettings\n", ".defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Mockito", "bid": 23, "method_path": "./dataset/Mockito/23/ReturnsDeepStubs.java", "method": ["private Object recordDeepStubMock(final Object mock, InvocationContainerImpl container) throws Throwable {\n", "\n", "container.addAnswer(new Answer<Object>() {\n", "public Object answer(InvocationOnMock invocation) throws Throwable {\n", "return mock;\n", "}\n", "}, false);\n", "\n", "return mock;\n", "}\n"], "faulty_lines": [3], "cluster": 4}, {"pid": "Mockito", "bid": 24, "method_path": "./dataset/Mockito/24/ReturnsEmptyValues.java", "method": ["public Object answer(InvocationOnMock invocation) {\n", "if (methodsGuru.isToString(invocation.getMethod())) {\n", "Object mock = invocation.getMock();\n", "MockName name = mockUtil.getMockName(mock);\n", "if (name.isDefault()) {\n", "return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n", "} else {\n", "return name.toString();\n", "}\n", "} else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n", "//see issue 184.\n", "//mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n", "//Only for compareTo() method by the Comparable interface\n", "return 1;\n", "}\n", "\n", "Class<?> returnType = invocation.getMethod().getReturnType();\n", "return returnValueFor(returnType);\n", "}\n"], "faulty_lines": [14], "cluster": 8}, {"pid": "Mockito", "bid": 25, "method_path": "./dataset/Mockito/25/ReturnsDeepStubs.java", "method": ["private Object getMock(InvocationOnMock invocation) throws Throwable {\n", "InternalMockHandler<Object> handler = new MockUtil().getMockHandler(invocation.getMock());\n", "InvocationContainerImpl container = (InvocationContainerImpl) handler.getInvocationContainer();\n", "\n", "// matches invocation for verification\n", "for (StubbedInvocationMatcher stubbedInvocationMatcher : container.getStubbedInvocations()) {\n", "if(container.getInvocationForStubbing().matches(stubbedInvocationMatcher.getInvocation())) {\n", "return stubbedInvocationMatcher.answer(invocation);\n", "}\n", "}\n", "\n", "// deep stub\n", "return recordDeepStubMock(invocation, container);\n", "}\n"], "faulty_lines": [13], "cluster": 2}, {"pid": "Mockito", "bid": 27, "method_path": "./dataset/Mockito/27/MockUtil.java", "method": ["public <T> void resetMock(T mock) {\n", "MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n", "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n", "MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n", "((Factory) mock).setCallback(0, newFilter);\n", "}\n"], "faulty_lines": [3, 4], "cluster": 4}, {"pid": "Mockito", "bid": 28, "method_path": "./dataset/Mockito/28/DefaultInjectionEngine.java", "method": ["private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n", "for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n", "mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n", "}\n", "}\n"], "faulty_lines": [3], "cluster": 4}, {"pid": "Mockito", "bid": 29, "method_path": "./dataset/Mockito/29/Same.java", "method": ["public void describeTo(Description description) {\n", "description.appendText(\"same(\");\n", "appendQuoting(description);\n", "description.appendText(wanted.toString());\n", "appendQuoting(description);\n", "description.appendText(\")\");\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Mockito", "bid": 30, "method_path": "./dataset/Mockito/30/ReturnsSmartNulls.java", "method": ["public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n", "if (new ObjectMethodsGuru().isToString(method)) {\n", "return \"SmartNull returned by unstubbed \" + formatMethodCall()  + \" method on mock\";\n", "}\n", "\n", "new Reporter().smartNullPointerException(location);\n", "return null;\n", "}\n"], "faulty_lines": [6], "cluster": 4}, {"pid": "Mockito", "bid": 31, "method_path": "./dataset/Mockito/31/ReturnsSmartNulls.java", "method": ["private String formatMethodCall() {\n", "return invocation.getMethod().getName() + \"()\";\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 33, "method_path": "./dataset/Mockito/33/InvocationMatcher.java", "method": ["public boolean hasSameMethod(Invocation candidate) {\n", "//not using method.equals() for 1 good reason:\n", "//sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n", "Method m1 = invocation.getMethod();\n", "Method m2 = candidate.getMethod();\n", "\n", "/* Avoid unnecessary cloning */\n", "return m1.equals(m2);\n", "}\n"], "faulty_lines": [7, 8], "cluster": 4}, {"pid": "Mockito", "bid": 34, "method_path": "./dataset/Mockito/34/InvocationMatcher.java", "method": ["public void captureArgumentsFrom(Invocation i) {\n", "int k = 0;\n", "for (Matcher m : matchers) {\n", "if (m instanceof CapturesArguments) {\n", "((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n", "}\n", "k++;\n", "}\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Mockito", "bid": 35, "method_path": "./dataset/Mockito/35/Matchers.java", "method": ["public static <T> T isA(Class<T> clazz) {\n", "return reportMatcher(new InstanceOf(clazz)).<T>returnNull();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 35, "method_path": "./dataset/Mockito/35/Matchers.java", "method": ["public static <T> T eq(T value) {\n", "return reportMatcher(new Equals(value)).<T>returnNull();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 35, "method_path": "./dataset/Mockito/35/Matchers.java", "method": ["public static <T> T same(T value) {\n", "return reportMatcher(new Same(value)).<T>returnNull();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 36, "method_path": "./dataset/Mockito/36/Invocation.java", "method": ["public Object callRealMethod() throws Throwable {\n", "return realMethod.invoke(mock, rawArguments);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Mockito", "bid": 38, "method_path": "./dataset/Mockito/38/ArgumentMatchingTool.java", "method": ["private boolean toStringEquals(Matcher m, Object arg) {\n", "return StringDescription.toString(m).equals(arg.toString());\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "JacksonCore", "bid": 1, "method_path": "./dataset/JacksonCore/1/NumberInput.java", "method": ["public static BigDecimal parseBigDecimal(String numStr) throws NumberFormatException\n", "{\n", "return new BigDecimal(numStr);\n", "}\n"], "faulty_lines": [3, 4], "cluster": 0}, {"pid": "JacksonCore", "bid": 2, "method_path": "./dataset/JacksonCore/2/UTF8StreamJsonParser.java", "method": ["private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative,\n", "int intPartLength)\n", "throws IOException, JsonParseException\n", "{\n", "// Ok, parse the rest\n", "while (true) {\n", "if (_inputPtr >= _inputEnd && !loadMore()) {\n", "_textBuffer.setCurrentLength(outPtr);\n", "return resetInt(negative, intPartLength);\n", "}\n", "int c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n", "if (c > INT_9 || c < INT_0) {\n", "if (c == '.' || c == 'e' || c == 'E') {\n", "return _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n", "}\n", "break;\n", "}\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "outBuf[outPtr++] = (char) c;\n", "++intPartLength;\n", "}\n", "--_inputPtr; // to push back trailing char (comma etc)\n", "_textBuffer.setCurrentLength(outPtr);\n", "// As per #105, need separating space between root values; check here\n", "\n", "// And there we have it!\n", "return resetInt(negative, intPartLength);\n", "\n", "}\n"], "faulty_lines": [28], "cluster": 1}, {"pid": "JacksonCore", "bid": 2, "method_path": "./dataset/JacksonCore/2/UTF8StreamJsonParser.java", "method": ["private int _skipWSOrEnd() throws IOException\n", "{\n", "final int[] codes = _icWS;\n", "while ((_inputPtr < _inputEnd) || loadMore()) {\n", "final int i = _inputBuffer[_inputPtr++] & 0xFF;\n", "switch (codes[i]) {\n", "case 0: // done!\n", "return i;\n", "case 1: // skip\n", "continue;\n", "case 2: // 2-byte UTF\n", "_skipUtf8_2(i);\n", "break;\n", "case 3: // 3-byte UTF\n", "_skipUtf8_3(i);\n", "break;\n", "case 4: // 4-byte UTF\n", "_skipUtf8_4(i);\n", "break;\n", "case INT_LF:\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "break;\n", "case INT_CR:\n", "_skipCR();\n", "break;\n", "case '/':\n", "_skipComment();\n", "break;\n", "case '#':\n", "if (!_skipYAMLComment()) {\n", "return i;\n", "}\n", "break;\n", "default: // e.g. -1\n", "if (i < 32) {\n", "_throwInvalidSpace(i);\n", "}\n", "_reportInvalidChar(i);\n", "}\n", "}\n", "// We ran out of input...\n", "_handleEOF();\n", "return -1;\n", "}\n"], "faulty_lines": [36, 37, 38], "cluster": 8}, {"pid": "JacksonCore", "bid": 4, "method_path": "./dataset/JacksonCore/4/TextBuffer.java", "method": ["public char[] expandCurrentSegment()\n", "{\n", "final char[] curr = _currentSegment;\n", "// Let's grow by 50% by default\n", "final int len = curr.length;\n", "// but above intended maximum, slow to increase by 25%\n", "int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n", "return (_currentSegment = Arrays.copyOf(curr, newLen));\n", "}\n"], "faulty_lines": [6, 7], "cluster": 4}, {"pid": "JacksonCore", "bid": 5, "method_path": "./dataset/JacksonCore/5/JsonPointer.java", "method": ["private final static int _parseIndex(String str) {\n", "final int len = str.length();\n", "// [Issue#133]: beware of super long indexes; assume we never\n", "// have arrays over 2 billion entries so ints are fine.\n", "if (len == 0 || len > 10) {\n", "return -1;\n", "}\n", "for (int i = 0; i < len; ++i) {\n", "char c = str.charAt(i++);\n", "if (c > '9' || c < '0') {\n", "return -1;\n", "}\n", "}\n", "if (len == 10) {\n", "long l = NumberInput.parseLong(str);\n", "if (l > Integer.MAX_VALUE) {\n", "return -1;\n", "}\n", "}\n", "return NumberInput.parseInt(str);\n", "}\n"], "faulty_lines": [9], "cluster": 2}, {"pid": "JacksonCore", "bid": 6, "method_path": "./dataset/JacksonCore/6/JsonPointer.java", "method": ["private final static int _parseIndex(String str) {\n", "final int len = str.length();\n", "// [core#133]: beware of super long indexes; assume we never\n", "// have arrays over 2 billion entries so ints are fine.\n", "if (len == 0 || len > 10) {\n", "return -1;\n", "}\n", "// [core#176]: no leading zeroes allowed\n", "for (int i = 0; i < len; ++i) {\n", "char c = str.charAt(i);\n", "if (c > '9' || c < '0') {\n", "return -1;\n", "}\n", "}\n", "if (len == 10) {\n", "long l = NumberInput.parseLong(str);\n", "if (l > Integer.MAX_VALUE) {\n", "return -1;\n", "}\n", "}\n", "return NumberInput.parseInt(str);\n", "}\n"], "faulty_lines": [9, 10], "cluster": 2}, {"pid": "JacksonCore", "bid": 7, "method_path": "./dataset/JacksonCore/7/JsonWriteContext.java", "method": ["public int writeValue() {\n", "// Most likely, object:\n", "if (_type == TYPE_OBJECT) {\n", "_gotName = false;\n", "++_index;\n", "return STATUS_OK_AFTER_COLON;\n", "}\n", "\n", "// Ok, array?\n", "if (_type == TYPE_ARRAY) {\n", "int ix = _index;\n", "++_index;\n", "return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n", "}\n", "\n", "// Nope, root context\n", "// No commas within root context, but need space\n", "++_index;\n", "return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n", "}\n"], "faulty_lines": [4], "cluster": 2}, {"pid": "JacksonCore", "bid": 8, "method_path": "./dataset/JacksonCore/8/TextBuffer.java", "method": ["public char[] getTextBuffer()\n", "{\n", "// Are we just using shared input buffer?\n", "if (_inputStart >= 0) return _inputBuffer;\n", "if (_resultArray != null)  return _resultArray;\n", "if (_resultString != null) {\n", "return (_resultArray = _resultString.toCharArray());\n", "}\n", "// Nope; but does it fit in just one segment?\n", "if (!_hasSegments)  return _currentSegment;\n", "// Nope, need to have/create a non-segmented array and return it\n", "return contentsAsArray();\n", "}\n"], "faulty_lines": [10], "cluster": 4}, {"pid": "JacksonCore", "bid": 9, "method_path": "./dataset/JacksonCore/9/ParserMinimalBase.java", "method": ["public String getValueAsString() throws IOException {\n", "if (_currToken == JsonToken.VALUE_STRING) {\n", "return getText();\n", "}\n", "return getValueAsString(null);\n", "}\n"], "faulty_lines": [5], "cluster": 0}, {"pid": "JacksonCore", "bid": 9, "method_path": "./dataset/JacksonCore/9/ParserMinimalBase.java", "method": ["public String getValueAsString(String defaultValue) throws IOException {\n", "if (_currToken == JsonToken.VALUE_STRING) {\n", "return getText();\n", "}\n", "if (_currToken == null || _currToken == JsonToken.VALUE_NULL || !_currToken.isScalarValue()) {\n", "return defaultValue;\n", "}\n", "return getText();\n", "}\n"], "faulty_lines": [5], "cluster": 4}, {"pid": "JacksonCore", "bid": 9, "method_path": "./dataset/JacksonCore/9/ReaderBasedJsonParser.java", "method": ["public final String getValueAsString() throws IOException\n", "{\n", "if (_currToken == JsonToken.VALUE_STRING) {\n", "if (_tokenIncomplete) {\n", "_tokenIncomplete = false;\n", "_finishString(); // only strings can be incomplete\n", "}\n", "return _textBuffer.contentsAsString();\n", "}\n", "return super.getValueAsString(null);\n", "}\n"], "faulty_lines": [10], "cluster": 4}, {"pid": "JacksonCore", "bid": 9, "method_path": "./dataset/JacksonCore/9/ReaderBasedJsonParser.java", "method": ["public final String getValueAsString(String defValue) throws IOException {\n", "if (_currToken == JsonToken.VALUE_STRING) {\n", "if (_tokenIncomplete) {\n", "_tokenIncomplete = false;\n", "_finishString(); // only strings can be incomplete\n", "}\n", "return _textBuffer.contentsAsString();\n", "}\n", "return super.getValueAsString(defValue);\n", "}\n"], "faulty_lines": [9], "cluster": 4}, {"pid": "JacksonCore", "bid": 9, "method_path": "./dataset/JacksonCore/9/UTF8StreamJsonParser.java", "method": ["public String getValueAsString() throws IOException\n", "{\n", "if (_currToken == JsonToken.VALUE_STRING) {\n", "if (_tokenIncomplete) {\n", "_tokenIncomplete = false;\n", "return _finishAndReturnString(); // only strings can be incomplete\n", "}\n", "return _textBuffer.contentsAsString();\n", "}\n", "return super.getValueAsString(null);\n", "}\n"], "faulty_lines": [10], "cluster": 4}, {"pid": "JacksonCore", "bid": 9, "method_path": "./dataset/JacksonCore/9/UTF8StreamJsonParser.java", "method": ["public String getValueAsString(String defValue) throws IOException\n", "{\n", "if (_currToken == JsonToken.VALUE_STRING) {\n", "if (_tokenIncomplete) {\n", "_tokenIncomplete = false;\n", "return _finishAndReturnString(); // only strings can be incomplete\n", "}\n", "return _textBuffer.contentsAsString();\n", "}\n", "return super.getValueAsString(defValue);\n", "}\n"], "faulty_lines": [10], "cluster": 4}, {"pid": "JacksonCore", "bid": 10, "method_path": "./dataset/JacksonCore/10/ByteQuadsCanonicalizer.java", "method": ["private int _findOffsetForAdd(int hash)\n", "{\n", "// first, check the primary:\n", "int offset = _calcOffset(hash);\n", "final int[] hashArea = _hashArea;\n", "if (hashArea[offset+3] == 0) {\n", "//System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\n", "return offset;\n", "}\n", "// then secondary\n", "int offset2 = _secondaryStart + ((offset >> 3) << 2);\n", "if (hashArea[offset2+3] == 0) {\n", "//System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset >> 3), _secondaryStart, (hash & 0x7F));\n", "return offset2;\n", "}\n", "// if not, tertiary?\n", "\n", "offset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\n", "final int bucketSize = (1 << _tertiaryShift);\n", "for (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\n", "if (hashArea[offset2+3] == 0) {\n", "//System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset >> (_tertiaryShift + 2)) << _tertiaryShift), _tertiaryStart, (hash & 0x7F));\n", "return offset2;\n", "}\n", "}\n", "\n", "// and if even tertiary full, append at the end of spill area\n", "offset = _spilloverEnd;\n", "_spilloverEnd += 4;\n", "\n", "//System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash & 0x7F));\n", "\n", "// one caveat: in the unlikely event if spill-over filling up,\n", "// check if that could be considered a DoS attack; handle appropriately\n", "// (NOTE: approximate for now; we could verify details if that becomes necessary)\n", "/* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\n", "*   since \"long names\" area follows. Instead, need to calculate from hash size.\n", "*/\n", "if (_spilloverEnd >= hashArea.length) {\n", "if (_failOnDoS) {\n", "_reportTooManyCollisions();\n", "}\n", "// and if we didn't fail, we'll simply force rehash for next add\n", "// (which, in turn, may double up or nuke contents, depending on size etc)\n", "_needRehash = true;\n", "}\n", "return offset;\n", "}\n"], "faulty_lines": [39], "cluster": 3}, {"pid": "JacksonCore", "bid": 10, "method_path": "./dataset/JacksonCore/10/ByteQuadsCanonicalizer.java", "method": ["public int calcHash(int q1)\n", "{\n", "int hash = q1 ^ _seed;\n", "/* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok\n", "*    except for one specific problem case: numbers. So needed to make sure\n", "*    that all 4 least-significant bits participate in hash. Couple of ways\n", "*    to work it out, but this is the simplest, fast and seems to do ok.\n", "*/\n", "hash += (hash >>> 16); // to xor hi- and low- 16-bits\n", "hash ^= (hash >>> 12);\n", "return hash;\n", "}\n"], "faulty_lines": [10], "cluster": 2}, {"pid": "JacksonCore", "bid": 11, "method_path": "./dataset/JacksonCore/11/ByteQuadsCanonicalizer.java", "method": ["private void _verifySharing()\n", "{\n", "if (_hashShared) {\n", "_hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n", "_names = Arrays.copyOf(_names, _names.length);\n", "_hashShared = false;\n", "// 09-Sep-2015, tatu: As per [jackson-core#216], also need to ensure\n", "//    we rehash as needed, as need-rehash flag is not copied from parent\n", "}\n", "if (_needRehash) {\n", "rehash();\n", "}\n", "}\n"], "faulty_lines": [9], "cluster": 4}, {"pid": "JacksonCore", "bid": 12, "method_path": "./dataset/JacksonCore/12/ReaderBasedJsonParser.java", "method": ["private final void _isNextTokenNameYes(int i) throws IOException\n", "{\n", "_currToken = JsonToken.FIELD_NAME;\n", "\n", "switch (i) {\n", "case '\"':\n", "_tokenIncomplete = true;\n", "_nextToken = JsonToken.VALUE_STRING;\n", "return;\n", "case '[':\n", "_nextToken = JsonToken.START_ARRAY;\n", "return;\n", "case '{':\n", "_nextToken = JsonToken.START_OBJECT;\n", "return;\n", "case 't':\n", "_matchToken(\"true\", 1);\n", "_nextToken = JsonToken.VALUE_TRUE;\n", "return;\n", "case 'f':\n", "_matchToken(\"false\", 1);\n", "_nextToken = JsonToken.VALUE_FALSE;\n", "return;\n", "case 'n':\n", "_matchToken(\"null\", 1);\n", "_nextToken = JsonToken.VALUE_NULL;\n", "return;\n", "case '-':\n", "_nextToken = _parseNegNumber();\n", "return;\n", "case '0':\n", "case '1':\n", "case '2':\n", "case '3':\n", "case '4':\n", "case '5':\n", "case '6':\n", "case '7':\n", "case '8':\n", "case '9':\n", "_nextToken = _parsePosNumber(i);\n", "return;\n", "}\n", "_nextToken = _handleOddValue(i);\n", "}\n", "\n", "protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n", "{\n", "// // // and this is back to standard nextToken()\n", "String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n", "_parsingContext.setCurrentName(name);\n", "_currToken = JsonToken.FIELD_NAME;\n", "i = _skipColon();\n", "if (i == INT_QUOTE) {\n", "_tokenIncomplete = true;\n", "_nextToken = JsonToken.VALUE_STRING;\n", "return nameToMatch.equals(name);\n", "}\n", "// Ok: we must have a value... what is it?\n", "JsonToken t;\n", "switch (i) {\n", "case '-':\n", "t = _parseNegNumber();\n", "break;\n", "case '0':\n", "case '1':\n", "case '2':\n", "case '3':\n", "case '4':\n", "case '5':\n", "case '6':\n", "case '7':\n", "case '8':\n", "case '9':\n", "t = _parsePosNumber(i);\n", "break;\n", "case 'f':\n", "_matchFalse();\n", "t = JsonToken.VALUE_FALSE;\n", "break;\n", "case 'n':\n", "_matchNull();\n", "t = JsonToken.VALUE_NULL;\n", "break;\n", "case 't':\n", "_matchTrue();\n", "t = JsonToken.VALUE_TRUE;\n", "break;\n", "case '[':\n", "t = JsonToken.START_ARRAY;\n", "break;\n", "case '{':\n", "t = JsonToken.START_OBJECT;\n", "break;\n", "default:\n", "t = _handleOddValue(i);\n", "break;\n", "}\n", "_nextToken = t;\n", "return nameToMatch.equals(name);\n", "}\n", "\n", "private final JsonToken _nextTokenNotInObject(int i) throws IOException\n", "{\n", "if (i == INT_QUOTE) {\n", "_tokenIncomplete = true;\n", "return (_currToken = JsonToken.VALUE_STRING);\n", "}\n", "switch (i) {\n", "case '[':\n", "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n", "return (_currToken = JsonToken.START_ARRAY);\n", "case '{':\n", "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n", "return (_currToken = JsonToken.START_OBJECT);\n", "case 't':\n", "_matchToken(\"true\", 1);\n", "return (_currToken = JsonToken.VALUE_TRUE);\n", "case 'f':\n", "_matchToken(\"false\", 1);\n", "return (_currToken = JsonToken.VALUE_FALSE);\n", "case 'n':\n", "_matchToken(\"null\", 1);\n", "return (_currToken = JsonToken.VALUE_NULL);\n", "case '-':\n", "return (_currToken = _parseNegNumber());\n", "/* Should we have separate handling for plus? Although\n", "* it is not allowed per se, it may be erroneously used,\n", "* and could be indicated by a more specific error message.\n", "*/\n", "case '0':\n", "case '1':\n", "case '2':\n", "case '3':\n", "case '4':\n", "case '5':\n", "case '6':\n", "case '7':\n", "case '8':\n", "case '9':\n", "return (_currToken = _parsePosNumber(i));\n", "}\n", "return (_currToken = _handleOddValue(i));\n", "}\n", "\n", "// note: identical to one in UTF8StreamJsonParser\n", "@Override\n", "public final String nextTextValue() throws IOException\n", "{\n", "if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n", "_nameCopied = false;\n", "JsonToken t = _nextToken;\n", "_nextToken = null;\n", "_currToken = t;\n", "if (t == JsonToken.VALUE_STRING) {\n", "if (_tokenIncomplete) {\n", "_tokenIncomplete = false;\n", "_finishString();\n", "}\n", "return _textBuffer.contentsAsString();\n", "}\n", "if (t == JsonToken.START_ARRAY) {\n", "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n", "} else if (t == JsonToken.START_OBJECT) {\n", "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n", "}\n", "return null;\n", "}\n", "// !!! TODO: optimize this case as well\n", "return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n", "}\n", "\n", "// note: identical to one in Utf8StreamParser\n", "@Override\n", "public final int nextIntValue(int defaultValue) throws IOException\n", "{\n", "if (_currToken == JsonToken.FIELD_NAME) {\n", "_nameCopied = false;\n", "JsonToken t = _nextToken;\n", "_nextToken = null;\n", "_currToken = t;\n", "if (t == JsonToken.VALUE_NUMBER_INT) {\n", "return getIntValue();\n", "}\n", "if (t == JsonToken.START_ARRAY) {\n", "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n", "} else if (t == JsonToken.START_OBJECT) {\n", "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n", "}\n", "return defaultValue;\n", "}\n", "// !!! TODO: optimize this case as well\n", "return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n", "}\n", "\n", "// note: identical to one in Utf8StreamParser\n", "@Override\n", "public final long nextLongValue(long defaultValue) throws IOException\n", "{\n", "if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n", "_nameCopied = false;\n", "JsonToken t = _nextToken;\n", "_nextToken = null;\n", "_currToken = t;\n", "if (t == JsonToken.VALUE_NUMBER_INT) {\n", "return getLongValue();\n", "}\n", "if (t == JsonToken.START_ARRAY) {\n", "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n", "} else if (t == JsonToken.START_OBJECT) {\n", "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n", "}\n", "return defaultValue;\n", "}\n", "// !!! TODO: optimize this case as well\n", "return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n", "}\n", "\n", "// note: identical to one in UTF8StreamJsonParser\n", "@Override\n", "public final Boolean nextBooleanValue() throws IOException\n", "{\n", "if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n", "_nameCopied = false;\n", "JsonToken t = _nextToken;\n", "_nextToken = null;\n", "_currToken = t;\n", "if (t == JsonToken.VALUE_TRUE) {\n", "return Boolean.TRUE;\n", "}\n", "if (t == JsonToken.VALUE_FALSE) {\n", "return Boolean.FALSE;\n", "}\n", "if (t == JsonToken.START_ARRAY) {\n", "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n", "} else if (t == JsonToken.START_OBJECT) {\n", "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n", "}\n", "return null;\n", "}\n", "JsonToken t = nextToken();\n", "if (t != null) {\n", "int id = t.id();\n", "if (id == ID_TRUE) return Boolean.TRUE;\n", "if (id == ID_FALSE) return Boolean.FALSE;\n", "}\n", "return null;\n", "}\n", "\n", "/*\n", "/**********************************************************\n", "/* Internal methods, number parsing\n", "/**********************************************************\n", "*/\n", "\n", "/**\n", "* Initial parsing method for number values. It needs to be able\n", "* to parse enough input to be able to determine whether the\n", "* value is to be considered a simple integer value, or a more\n", "* generic decimal value: latter of which needs to be expressed\n", "* as a floating point number. The basic rule is that if the number\n", "* has no fractional or exponential part, it is an integer; otherwise\n", "* a floating point number.\n", "*<p>\n", "* Because much of input has to be processed in any case, no partial\n", "* parsing is done: all input text will be stored for further\n", "* processing. However, actual numeric value conversion will be\n", "* deferred, since it is usually the most complicated and costliest\n", "* part of processing.\n", "*/\n", "protected final JsonToken _parsePosNumber(int ch) throws IOException\n", "{\n", "/* Although we will always be complete with respect to textual\n", "* representation (that is, all characters will be parsed),\n", "* actual conversion to a number is deferred. Thus, need to\n", "* note that no representations are valid yet\n", "*/\n", "int ptr = _inputPtr;\n", "int startPtr = ptr-1; // to include digit already read\n", "final int inputLen = _inputEnd;\n", "\n", "// One special case, leading zero(es):\n", "if (ch == INT_0) {\n", "return _parseNumber2(false, startPtr);\n", "}\n", "\n", "/* First, let's see if the whole number is contained within\n", "* the input buffer unsplit. This should be the common case;\n", "* and to simplify processing, we will just reparse contents\n", "* in the alternative case (number split on buffer boundary)\n", "*/\n", "\n", "int intLen = 1; // already got one\n", "\n", "// First let's get the obligatory integer part:\n", "int_loop:\n", "while (true) {\n", "if (ptr >= inputLen) {\n", "_inputPtr = startPtr;\n", "return _parseNumber2(false, startPtr);\n", "}\n", "ch = (int) _inputBuffer[ptr++];\n", "if (ch < INT_0 || ch > INT_9) {\n", "break int_loop;\n", "}\n", "++intLen;\n", "}\n", "if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n", "_inputPtr = ptr;\n", "return _parseFloat(ch, startPtr, ptr, false, intLen);\n", "}\n", "// Got it all: let's add to text buffer for parsing, access\n", "--ptr; // need to push back following separator\n", "_inputPtr = ptr;\n", "// As per #105, need separating space between root values; check here\n", "if (_parsingContext.inRoot()) {\n", "_verifyRootSpace(ch);\n", "}\n", "int len = ptr-startPtr;\n", "_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n", "return resetInt(false, intLen);\n", "}\n", "\n", "private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n", "throws IOException\n", "{\n", "final int inputLen = _inputEnd;\n", "int fractLen = 0;\n", "\n", "// And then see if we get other parts\n", "if (ch == '.') { // yes, fraction\n", "fract_loop:\n", "while (true) {\n", "if (ptr >= inputLen) {\n", "return _parseNumber2(neg, startPtr);\n", "}\n", "ch = (int) _inputBuffer[ptr++];\n", "if (ch < INT_0 || ch > INT_9) {\n", "break fract_loop;\n", "}\n", "++fractLen;\n", "}\n", "// must be followed by sequence of ints, one minimum\n", "if (fractLen == 0) {\n", "reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n", "}\n", "}\n", "int expLen = 0;\n", "if (ch == 'e' || ch == 'E') { // and/or exponent\n", "if (ptr >= inputLen) {\n", "_inputPtr = startPtr;\n", "return _parseNumber2(neg, startPtr);\n", "}\n", "// Sign indicator?\n", "ch = (int) _inputBuffer[ptr++];\n", "if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n", "if (ptr >= inputLen) {\n", "_inputPtr = startPtr;\n", "return _parseNumber2(neg, startPtr);\n", "}\n", "ch = (int) _inputBuffer[ptr++];\n", "}\n", "while (ch <= INT_9 && ch >= INT_0) {\n", "++expLen;\n", "if (ptr >= inputLen) {\n", "_inputPtr = startPtr;\n", "return _parseNumber2(neg, startPtr);\n", "}\n", "ch = (int) _inputBuffer[ptr++];\n", "}\n", "// must be followed by sequence of ints, one minimum\n", "if (expLen == 0) {\n", "reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n", "}\n", "}\n", "--ptr; // need to push back following separator\n", "_inputPtr = ptr;\n", "// As per #105, need separating space between root values; check here\n", "if (_parsingContext.inRoot()) {\n", "_verifyRootSpace(ch);\n", "}\n", "int len = ptr-startPtr;\n", "_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n", "// And there we have it!\n", "return resetFloat(neg, intLen, fractLen, expLen);\n", "}\n", "\n", "protected final JsonToken _parseNegNumber() throws IOException\n", "{\n", "int ptr = _inputPtr;\n", "int startPtr = ptr-1; // to include sign/digit already read\n", "final int inputLen = _inputEnd;\n", "\n", "if (ptr >= inputLen) {\n", "return _parseNumber2(true, startPtr);\n", "}\n", "int ch = _inputBuffer[ptr++];\n", "// First check: must have a digit to follow minus sign\n", "if (ch > INT_9 || ch < INT_0) {\n", "_inputPtr = ptr;\n", "return _handleInvalidNumberStart(ch, true);\n", "}\n", "// One special case, leading zero(es):\n", "if (ch == INT_0) {\n", "return _parseNumber2(true, startPtr);\n", "}\n", "int intLen = 1; // already got one\n", "\n", "// First let's get the obligatory integer part:\n", "int_loop:\n", "while (true) {\n", "if (ptr >= inputLen) {\n", "return _parseNumber2(true, startPtr);\n", "}\n", "ch = (int) _inputBuffer[ptr++];\n", "if (ch < INT_0 || ch > INT_9) {\n", "break int_loop;\n", "}\n", "++intLen;\n", "}\n", "\n", "if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n", "_inputPtr = ptr;\n", "return _parseFloat(ch, startPtr, ptr, true, intLen);\n", "}\n", "--ptr;\n", "_inputPtr = ptr;\n", "if (_parsingContext.inRoot()) {\n", "_verifyRootSpace(ch);\n", "}\n", "int len = ptr-startPtr;\n", "_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n", "return resetInt(true, intLen);\n", "}\n", "\n", "/**\n", "* Method called to parse a number, when the primary parse\n", "* method has failed to parse it, due to it being split on\n", "* buffer boundary. As a result code is very similar, except\n", "* that it has to explicitly copy contents to the text buffer\n", "* instead of just sharing the main input buffer.\n", "*/\n", "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n", "{\n", "_inputPtr = neg ? (startPtr+1) : startPtr;\n", "char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n", "int outPtr = 0;\n", "\n", "// Need to prepend sign?\n", "if (neg) {\n", "outBuf[outPtr++] = '-';\n", "}\n", "\n", "// This is the place to do leading-zero check(s) too:\n", "int intLen = 0;\n", "char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n", "if (c == '0') {\n", "c = _verifyNoLeadingZeroes();\n", "}\n", "boolean eof = false;\n", "\n", "// Ok, first the obligatory integer part:\n", "int_loop:\n", "while (c >= '0' && c <= '9') {\n", "++intLen;\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "outBuf[outPtr++] = c;\n", "if (_inputPtr >= _inputEnd && !loadMore()) {\n", "// EOF is legal for main level int values\n", "c = CHAR_NULL;\n", "eof = true;\n", "break int_loop;\n", "}\n", "c = _inputBuffer[_inputPtr++];\n", "}\n", "// Also, integer part is not optional\n", "if (intLen == 0) {\n", "return _handleInvalidNumberStart(c, neg);\n", "}\n", "\n", "int fractLen = 0;\n", "// And then see if we get other parts\n", "if (c == '.') { // yes, fraction\n", "outBuf[outPtr++] = c;\n", "\n", "fract_loop:\n", "while (true) {\n", "if (_inputPtr >= _inputEnd && !loadMore()) {\n", "eof = true;\n", "break fract_loop;\n", "}\n", "c = _inputBuffer[_inputPtr++];\n", "if (c < INT_0 || c > INT_9) {\n", "break fract_loop;\n", "}\n", "++fractLen;\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "outBuf[outPtr++] = c;\n", "}\n", "// must be followed by sequence of ints, one minimum\n", "if (fractLen == 0) {\n", "reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n", "}\n", "}\n", "\n", "int expLen = 0;\n", "if (c == 'e' || c == 'E') { // exponent?\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "outBuf[outPtr++] = c;\n", "// Not optional, can require that we get one more char\n", "c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n", ": getNextChar(\"expected a digit for number exponent\");\n", "// Sign indicator?\n", "if (c == '-' || c == '+') {\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "outBuf[outPtr++] = c;\n", "// Likewise, non optional:\n", "c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n", ": getNextChar(\"expected a digit for number exponent\");\n", "}\n", "\n", "exp_loop:\n", "while (c <= INT_9 && c >= INT_0) {\n", "++expLen;\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "outBuf[outPtr++] = c;\n", "if (_inputPtr >= _inputEnd && !loadMore()) {\n", "eof = true;\n", "break exp_loop;\n", "}\n", "c = _inputBuffer[_inputPtr++];\n", "}\n", "// must be followed by sequence of ints, one minimum\n", "if (expLen == 0) {\n", "reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n", "}\n", "}\n", "\n", "// Ok; unless we hit end-of-input, need to push last char read back\n", "if (!eof) {\n", "--_inputPtr;\n", "if (_parsingContext.inRoot()) {\n", "_verifyRootSpace(c);\n", "}\n", "}\n", "_textBuffer.setCurrentLength(outPtr);\n", "// And there we have it!\n", "return reset(neg, intLen, fractLen, expLen);\n", "}\n", "\n", "/**\n", "* Method called when we have seen one zero, and want to ensure\n", "* it is not followed by another\n", "*/\n", "private final char _verifyNoLeadingZeroes() throws IOException\n", "{\n", "// Fast case first:\n", "if (_inputPtr < _inputEnd) {\n", "char ch = _inputBuffer[_inputPtr];\n", "// if not followed by a number (probably '.'); return zero as is, to be included\n", "if (ch < '0' || ch > '9') {\n", "return '0';\n", "}\n", "}\n", "// and offline the less common case\n", "return _verifyNLZ2();\n", "}\n", "\n", "private char _verifyNLZ2() throws IOException\n", "{\n", "if (_inputPtr >= _inputEnd && !loadMore()) {\n", "return '0';\n", "}\n", "char ch = _inputBuffer[_inputPtr];\n", "if (ch < '0' || ch > '9') {\n", "return '0';\n", "}\n", "if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n", "reportInvalidNumber(\"Leading zeroes not allowed\");\n", "}\n", "// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n", "++_inputPtr; // Leading zero to be skipped\n", "if (ch == INT_0) {\n", "while (_inputPtr < _inputEnd || loadMore()) {\n", "ch = _inputBuffer[_inputPtr];\n", "if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n", "return '0';\n", "}\n", "++_inputPtr; // skip previous zero\n", "if (ch != '0') { // followed by other number; return\n", "break;\n", "}\n", "}\n", "}\n", "return ch;\n", "}\n", "\n", "/**\n", "* Method called if expected numeric value (due to leading sign) does not\n", "* look like a number\n", "*/\n", "protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n", "{\n", "if (ch == 'I') {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) { _reportInvalidEOFInValue(); }\n", "}\n", "ch = _inputBuffer[_inputPtr++];\n", "if (ch == 'N') {\n", "String match = negative ? \"-INF\" :\"+INF\";\n", "_matchToken(match, 3);\n", "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n", "return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n", "}\n", "_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n", "} else if (ch == 'n') {\n", "String match = negative ? \"-Infinity\" :\"+Infinity\";\n", "_matchToken(match, 3);\n", "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n", "return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n", "}\n", "_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n", "}\n", "}\n", "reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n", "return null;\n", "}\n", "\n", "/**\n", "* Method called to ensure that a root-value is followed by a space\n", "* token.\n", "*<p>\n", "* NOTE: caller MUST ensure there is at least one character available;\n", "* and that input pointer is AT given char (not past)\n", "*/\n", "private final void _verifyRootSpace(int ch) throws IOException\n", "{\n", "// caller had pushed it back, before calling; reset\n", "++_inputPtr;\n", "switch (ch) {\n", "case ' ':\n", "case '\\t':\n", "return;\n", "case '\\r':\n", "_skipCR();\n", "return;\n", "case '\\n':\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "return;\n", "}\n", "_reportMissingRootWS(ch);\n", "}\n", "\n", "/*\n", "/**********************************************************\n", "/* Internal methods, secondary parsing\n", "/**********************************************************\n", "*/\n", "\n", "protected final String _parseName() throws IOException\n", "{\n", "// First: let's try to see if we have a simple name: one that does\n", "// not cross input buffer boundary, and does not contain escape sequences.\n", "int ptr = _inputPtr;\n", "int hash = _hashSeed;\n", "final int[] codes = _icLatin1;\n", "\n", "while (ptr < _inputEnd) {\n", "int ch = _inputBuffer[ptr];\n", "if (ch < codes.length && codes[ch] != 0) {\n", "if (ch == '\"') {\n", "int start = _inputPtr;\n", "_inputPtr = ptr+1; // to skip the quote\n", "return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n", "}\n", "break;\n", "}\n", "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n", "++ptr;\n", "}\n", "int start = _inputPtr;\n", "_inputPtr = ptr;\n", "return _parseName2(start, hash, INT_QUOTE);\n", "}\n", "\n", "private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n", "{\n", "_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n", "\n", "/* Output pointers; calls will also ensure that the buffer is\n", "* not shared and has room for at least one more char.\n", "*/\n", "char[] outBuf = _textBuffer.getCurrentSegment();\n", "int outPtr = _textBuffer.getCurrentSegmentSize();\n", "\n", "while (true) {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) {\n", "_reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n", "}\n", "}\n", "char c = _inputBuffer[_inputPtr++];\n", "int i = (int) c;\n", "if (i <= INT_BACKSLASH) {\n", "if (i == INT_BACKSLASH) {\n", "/* Although chars outside of BMP are to be escaped as\n", "* an UTF-16 surrogate pair, does that affect decoding?\n", "* For now let's assume it does not.\n", "*/\n", "c = _decodeEscaped();\n", "} else if (i <= endChar) {\n", "if (i == endChar) {\n", "break;\n", "}\n", "if (i < INT_SPACE) {\n", "_throwUnquotedSpace(i, \"name\");\n", "}\n", "}\n", "}\n", "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n", "// Ok, let's add char to output:\n", "outBuf[outPtr++] = c;\n", "\n", "// Need more room?\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "}\n", "_textBuffer.setCurrentLength(outPtr);\n", "{\n", "TextBuffer tb = _textBuffer;\n", "char[] buf = tb.getTextBuffer();\n", "int start = tb.getTextOffset();\n", "int len = tb.size();\n", "return _symbols.findSymbol(buf, start, len, hash);\n", "}\n", "}\n", "\n", "/**\n", "* Method called when we see non-white space character other\n", "* than double quote, when expecting a field name.\n", "* In standard mode will just throw an expection; but\n", "* in non-standard modes may be able to parse name.\n", "*/\n", "protected String _handleOddName(int i) throws IOException\n", "{\n", "// [JACKSON-173]: allow single quotes\n", "if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n", "return _parseAposName();\n", "}\n", "// [JACKSON-69]: allow unquoted names if feature enabled:\n", "if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n", "_reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n", "}\n", "final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n", "final int maxCode = codes.length;\n", "\n", "// Also: first char must be a valid name char, but NOT be number\n", "boolean firstOk;\n", "\n", "if (i < maxCode) { // identifier, or a number ([Issue#102])\n", "firstOk = (codes[i] == 0);\n", "} else {\n", "firstOk = Character.isJavaIdentifierPart((char) i);\n", "}\n", "if (!firstOk) {\n", "_reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n", "}\n", "int ptr = _inputPtr;\n", "int hash = _hashSeed;\n", "final int inputLen = _inputEnd;\n", "\n", "if (ptr < inputLen) {\n", "do {\n", "int ch = _inputBuffer[ptr];\n", "if (ch < maxCode) {\n", "if (codes[ch] != 0) {\n", "int start = _inputPtr-1; // -1 to bring back first char\n", "_inputPtr = ptr;\n", "return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n", "}\n", "} else if (!Character.isJavaIdentifierPart((char) ch)) {\n", "int start = _inputPtr-1; // -1 to bring back first char\n", "_inputPtr = ptr;\n", "return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n", "}\n", "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n", "++ptr;\n", "} while (ptr < inputLen);\n", "}\n", "int start = _inputPtr-1;\n", "_inputPtr = ptr;\n", "return _handleOddName2(start, hash, codes);\n", "}\n", "\n", "protected String _parseAposName() throws IOException\n", "{\n", "// Note: mostly copy of_parseFieldName\n", "int ptr = _inputPtr;\n", "int hash = _hashSeed;\n", "final int inputLen = _inputEnd;\n", "\n", "if (ptr < inputLen) {\n", "final int[] codes = _icLatin1;\n", "final int maxCode = codes.length;\n", "\n", "do {\n", "int ch = _inputBuffer[ptr];\n", "if (ch == '\\'') {\n", "int start = _inputPtr;\n", "_inputPtr = ptr+1; // to skip the quote\n", "return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n", "}\n", "if (ch < maxCode && codes[ch] != 0) {\n", "break;\n", "}\n", "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n", "++ptr;\n", "} while (ptr < inputLen);\n", "}\n", "\n", "int start = _inputPtr;\n", "_inputPtr = ptr;\n", "\n", "return _parseName2(start, hash, '\\'');\n", "}\n", "\n", "/**\n", "* Method for handling cases where first non-space character\n", "* of an expected value token is not legal for standard JSON content.\n", "*/\n", "protected JsonToken _handleOddValue(int i) throws IOException\n", "{\n", "// Most likely an error, unless we are to allow single-quote-strings\n", "switch (i) {\n", "case '\\'':\n", "/* [JACKSON-173]: allow single quotes. Unlike with regular\n", "* Strings, we'll eagerly parse contents; this so that there's\n", "* no need to store information on quote char used.\n", "*\n", "* Also, no separation to fast/slow parsing; we'll just do\n", "* one regular (~= slowish) parsing, to keep code simple\n", "*/\n", "if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n", "return _handleApos();\n", "}\n", "break;\n", "case 'N':\n", "_matchToken(\"NaN\", 1);\n", "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n", "return resetAsNaN(\"NaN\", Double.NaN);\n", "}\n", "_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n", "break;\n", "case 'I':\n", "_matchToken(\"Infinity\", 1);\n", "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n", "return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n", "}\n", "_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n", "break;\n", "case '+': // note: '-' is taken as number\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) {\n", "_reportInvalidEOFInValue();\n", "}\n", "}\n", "return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n", "}\n", "// [Issue#77] Try to decode most likely token\n", "if (Character.isJavaIdentifierStart(i)) {\n", "_reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n", "}\n", "// but if it doesn't look like a token:\n", "_reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n", "return null;\n", "}\n", "\n", "protected JsonToken _handleApos() throws IOException\n", "{\n", "char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n", "int outPtr = _textBuffer.getCurrentSegmentSize();\n", "\n", "while (true) {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) {\n", "_reportInvalidEOF(\": was expecting closing quote for a string value\");\n", "}\n", "}\n", "char c = _inputBuffer[_inputPtr++];\n", "int i = (int) c;\n", "if (i <= '\\\\') {\n", "if (i == '\\\\') {\n", "/* Although chars outside of BMP are to be escaped as\n", "* an UTF-16 surrogate pair, does that affect decoding?\n", "* For now let's assume it does not.\n", "*/\n", "c = _decodeEscaped();\n", "} else if (i <= '\\'') {\n", "if (i == '\\'') {\n", "break;\n", "}\n", "if (i < INT_SPACE) {\n", "_throwUnquotedSpace(i, \"string value\");\n", "}\n", "}\n", "}\n", "// Need more room?\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "// Ok, let's add char to output:\n", "outBuf[outPtr++] = c;\n", "}\n", "_textBuffer.setCurrentLength(outPtr);\n", "return JsonToken.VALUE_STRING;\n", "}\n", "\n", "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n", "{\n", "_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n", "char[] outBuf = _textBuffer.getCurrentSegment();\n", "int outPtr = _textBuffer.getCurrentSegmentSize();\n", "final int maxCode = codes.length;\n", "\n", "while (true) {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) { // acceptable for now (will error out later)\n", "break;\n", "}\n", "}\n", "char c = _inputBuffer[_inputPtr];\n", "int i = (int) c;\n", "if (i <= maxCode) {\n", "if (codes[i] != 0) {\n", "break;\n", "}\n", "} else if (!Character.isJavaIdentifierPart(c)) {\n", "break;\n", "}\n", "++_inputPtr;\n", "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n", "// Ok, let's add char to output:\n", "outBuf[outPtr++] = c;\n", "\n", "// Need more room?\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "}\n", "_textBuffer.setCurrentLength(outPtr);\n", "{\n", "TextBuffer tb = _textBuffer;\n", "char[] buf = tb.getTextBuffer();\n", "int start = tb.getTextOffset();\n", "int len = tb.size();\n", "\n", "return _symbols.findSymbol(buf, start, len, hash);\n", "}\n", "}\n", "\n", "@Override\n", "protected final void _finishString() throws IOException\n", "{\n", "/* First: let's try to see if we have simple String value: one\n", "* that does not cross input buffer boundary, and does not\n", "* contain escape sequences.\n", "*/\n", "int ptr = _inputPtr;\n", "final int inputLen = _inputEnd;\n", "\n", "if (ptr < inputLen) {\n", "final int[] codes = _icLatin1;\n", "final int maxCode = codes.length;\n", "\n", "do {\n", "int ch = _inputBuffer[ptr];\n", "if (ch < maxCode && codes[ch] != 0) {\n", "if (ch == '\"') {\n", "_textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n", "_inputPtr = ptr+1;\n", "// Yes, we got it all\n", "return;\n", "}\n", "break;\n", "}\n", "++ptr;\n", "} while (ptr < inputLen);\n", "}\n", "\n", "/* Either ran out of input, or bumped into an escape\n", "* sequence...\n", "*/\n", "_textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n", "_inputPtr = ptr;\n", "_finishString2();\n", "}\n", "\n", "protected void _finishString2() throws IOException\n", "{\n", "char[] outBuf = _textBuffer.getCurrentSegment();\n", "int outPtr = _textBuffer.getCurrentSegmentSize();\n", "final int[] codes = _icLatin1;\n", "final int maxCode = codes.length;\n", "\n", "while (true) {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) {\n", "_reportInvalidEOF(\": was expecting closing quote for a string value\");\n", "}\n", "}\n", "char c = _inputBuffer[_inputPtr++];\n", "int i = (int) c;\n", "if (i < maxCode && codes[i] != 0) {\n", "if (i == INT_QUOTE) {\n", "break;\n", "} else if (i == INT_BACKSLASH) {\n", "/* Although chars outside of BMP are to be escaped as\n", "* an UTF-16 surrogate pair, does that affect decoding?\n", "* For now let's assume it does not.\n", "*/\n", "c = _decodeEscaped();\n", "} else if (i < INT_SPACE) {\n", "_throwUnquotedSpace(i, \"string value\");\n", "} // anything else?\n", "}\n", "// Need more room?\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "// Ok, let's add char to output:\n", "outBuf[outPtr++] = c;\n", "}\n", "_textBuffer.setCurrentLength(outPtr);\n", "}\n", "\n", "/**\n", "* Method called to skim through rest of unparsed String value,\n", "* if it is not needed. This can be done bit faster if contents\n", "* need not be stored for future access.\n", "*/\n", "protected final void _skipString() throws IOException\n", "{\n", "_tokenIncomplete = false;\n", "\n", "int inPtr = _inputPtr;\n", "int inLen = _inputEnd;\n", "char[] inBuf = _inputBuffer;\n", "\n", "while (true) {\n", "if (inPtr >= inLen) {\n", "_inputPtr = inPtr;\n", "if (!loadMore()) {\n", "_reportInvalidEOF(\": was expecting closing quote for a string value\");\n", "}\n", "inPtr = _inputPtr;\n", "inLen = _inputEnd;\n", "}\n", "char c = inBuf[inPtr++];\n", "int i = (int) c;\n", "if (i <= INT_BACKSLASH) {\n", "if (i == INT_BACKSLASH) {\n", "/* Although chars outside of BMP are to be escaped as\n", "* an UTF-16 surrogate pair, does that affect decoding?\n", "* For now let's assume it does not.\n", "*/\n", "_inputPtr = inPtr;\n", "c = _decodeEscaped();\n", "inPtr = _inputPtr;\n", "inLen = _inputEnd;\n", "} else if (i <= INT_QUOTE) {\n", "if (i == INT_QUOTE) {\n", "_inputPtr = inPtr;\n", "break;\n", "}\n", "if (i < INT_SPACE) {\n", "_inputPtr = inPtr;\n", "_throwUnquotedSpace(i, \"string value\");\n", "}\n", "}\n", "}\n", "}\n", "}\n", "\n", "/*\n", "/**********************************************************\n", "/* Internal methods, other parsing\n", "/**********************************************************\n", "*/\n", "\n", "/**\n", "* We actually need to check the character value here\n", "* (to see if we have \\n following \\r).\n", "*/\n", "protected final void _skipCR() throws IOException {\n", "if (_inputPtr < _inputEnd || loadMore()) {\n", "if (_inputBuffer[_inputPtr] == '\\n') {\n", "++_inputPtr;\n", "}\n", "}\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "}\n", "\n", "private final int _skipColon() throws IOException\n", "{\n", "if ((_inputPtr + 4) >= _inputEnd) {\n", "return _skipColon2(false);\n", "}\n", "char c = _inputBuffer[_inputPtr];\n", "if (c == ':') { // common case, no leading space\n", "int i = _inputBuffer[++_inputPtr];\n", "if (i > INT_SPACE) { // nor trailing\n", "if (i == INT_SLASH || i == INT_HASH) {\n", "return _skipColon2(true);\n", "}\n", "++_inputPtr;\n", "return i;\n", "}\n", "if (i == INT_SPACE || i == INT_TAB) {\n", "i = (int) _inputBuffer[++_inputPtr];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH || i == INT_HASH) {\n", "return _skipColon2(true);\n", "}\n", "++_inputPtr;\n", "return i;\n", "}\n", "}\n", "return _skipColon2(true); // true -> skipped colon\n", "}\n", "if (c == ' ' || c == '\\t') {\n", "c = _inputBuffer[++_inputPtr];\n", "}\n", "if (c == ':') {\n", "int i = _inputBuffer[++_inputPtr];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH || i == INT_HASH) {\n", "return _skipColon2(true);\n", "}\n", "++_inputPtr;\n", "return i;\n", "}\n", "if (i == INT_SPACE || i == INT_TAB) {\n", "i = (int) _inputBuffer[++_inputPtr];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH || i == INT_HASH) {\n", "return _skipColon2(true);\n", "}\n", "++_inputPtr;\n", "return i;\n", "}\n", "}\n", "return _skipColon2(true);\n", "}\n", "return _skipColon2(false);\n", "}\n", "\n", "private final int _skipColon2(boolean gotColon) throws IOException\n", "{\n", "while (true) {\n", "if (_inputPtr >= _inputEnd) {\n", "loadMoreGuaranteed();\n", "}\n", "int i = (int) _inputBuffer[_inputPtr++];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH) {\n", "_skipComment();\n", "continue;\n", "}\n", "if (i == INT_HASH) {\n", "if (_skipYAMLComment()) {\n", "continue;\n", "}\n", "}\n", "if (gotColon) {\n", "return i;\n", "}\n", "if (i != INT_COLON) {\n", "if (i < INT_SPACE) {\n", "_throwInvalidSpace(i);\n", "}\n", "_reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n", "}\n", "gotColon = true;\n", "continue;\n", "}\n", "if (i < INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "}\n", "}\n", "\n", "// Variant called when we know there's at least 4 more bytes available\n", "private final int _skipColonFast(int ptr) throws IOException\n", "{\n", "int i = (int) _inputBuffer[ptr++];\n", "if (i == INT_COLON) { // common case, no leading space\n", "i = _inputBuffer[ptr++];\n", "if (i > INT_SPACE) { // nor trailing\n", "if (i != INT_SLASH && i != INT_HASH) {\n", "_inputPtr = ptr;\n", "return i;\n", "}\n", "} else if (i == INT_SPACE || i == INT_TAB) {\n", "i = (int) _inputBuffer[ptr++];\n", "if (i > INT_SPACE) {\n", "if (i != INT_SLASH && i != INT_HASH) {\n", "_inputPtr = ptr;\n", "return i;\n", "}\n", "}\n", "}\n", "_inputPtr = ptr-1;\n", "return _skipColon2(true); // true -> skipped colon\n", "}\n", "if (i == INT_SPACE || i == INT_TAB) {\n", "i = _inputBuffer[ptr++];\n", "}\n", "boolean gotColon = (i == INT_COLON);\n", "if (gotColon) {\n", "i = _inputBuffer[ptr++];\n", "if (i > INT_SPACE) {\n", "if (i != INT_SLASH && i != INT_HASH) {\n", "_inputPtr = ptr;\n", "return i;\n", "}\n", "} else if (i == INT_SPACE || i == INT_TAB) {\n", "i = (int) _inputBuffer[ptr++];\n", "if (i > INT_SPACE) {\n", "if (i != INT_SLASH && i != INT_HASH) {\n", "_inputPtr = ptr;\n", "return i;\n", "}\n", "}\n", "}\n", "}\n", "_inputPtr = ptr-1;\n", "return _skipColon2(gotColon);\n", "}\n", "\n", "// Primary loop: no reloading, comment handling\n", "private final int _skipComma(int i) throws IOException\n", "{\n", "if (i != INT_COMMA) {\n", "_reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n", "}\n", "while (_inputPtr < _inputEnd) {\n", "i = (int) _inputBuffer[_inputPtr++];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH || i == INT_HASH) {\n", "--_inputPtr;\n", "return _skipAfterComma2();\n", "}\n", "return i;\n", "}\n", "if (i < INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "}\n", "return _skipAfterComma2();\n", "}\n", "\n", "private final int _skipAfterComma2() throws IOException\n", "{\n", "while (_inputPtr < _inputEnd || loadMore()) {\n", "int i = (int) _inputBuffer[_inputPtr++];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH) {\n", "_skipComment();\n", "continue;\n", "}\n", "if (i == INT_HASH) {\n", "if (_skipYAMLComment()) {\n", "continue;\n", "}\n", "}\n", "return i;\n", "}\n", "if (i < INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "}\n", "throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n", "}\n", "\n", "private final int _skipWSOrEnd() throws IOException\n", "{\n", "// Let's handle first character separately since it is likely that\n", "// it is either non-whitespace; or we have longer run of white space\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) {\n", "return _eofAsNextChar();\n", "}\n", "}\n", "int i = _inputBuffer[_inputPtr++];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH || i == INT_HASH) {\n", "--_inputPtr;\n", "return _skipWSOrEnd2();\n", "}\n", "return i;\n", "}\n", "if (i != INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "\n", "while (_inputPtr < _inputEnd) {\n", "i = (int) _inputBuffer[_inputPtr++];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH || i == INT_HASH) {\n", "--_inputPtr;\n", "return _skipWSOrEnd2();\n", "}\n", "return i;\n", "}\n", "if (i != INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "}\n", "return _skipWSOrEnd2();\n", "}\n", "\n", "private int _skipWSOrEnd2() throws IOException\n", "{\n", "while (true) {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) { // We ran out of input...\n", "return _eofAsNextChar();\n", "}\n", "}\n", "int i = (int) _inputBuffer[_inputPtr++];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH) {\n", "_skipComment();\n", "continue;\n", "}\n", "if (i == INT_HASH) {\n", "if (_skipYAMLComment()) {\n", "continue;\n", "}\n", "}\n", "return i;\n", "} else if (i != INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "}\n", "}\n", "\n", "private void _skipComment() throws IOException\n", "{\n", "if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n", "_reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n", "}\n", "// First: check which comment (if either) it is:\n", "if (_inputPtr >= _inputEnd && !loadMore()) {\n", "_reportInvalidEOF(\" in a comment\");\n", "}\n", "char c = _inputBuffer[_inputPtr++];\n", "if (c == '/') {\n", "_skipLine();\n", "} else if (c == '*') {\n", "_skipCComment();\n", "} else {\n", "_reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n", "}\n", "}\n", "\n", "private void _skipCComment() throws IOException\n", "{\n", "// Ok: need the matching '*/'\n", "while ((_inputPtr < _inputEnd) || loadMore()) {\n", "int i = (int) _inputBuffer[_inputPtr++];\n", "if (i <= '*') {\n", "if (i == '*') { // end?\n", "if ((_inputPtr >= _inputEnd) && !loadMore()) {\n", "break;\n", "}\n", "if (_inputBuffer[_inputPtr] == INT_SLASH) {\n", "++_inputPtr;\n", "return;\n", "}\n", "continue;\n", "}\n", "if (i < INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "}\n", "}\n", "_reportInvalidEOF(\" in a comment\");\n", "}\n", "\n", "private boolean _skipYAMLComment() throws IOException\n", "{\n", "if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n", "return false;\n", "}\n", "_skipLine();\n", "return true;\n", "}\n", "\n", "private void _skipLine() throws IOException\n", "{\n", "// Ok: need to find EOF or linefeed\n", "while ((_inputPtr < _inputEnd) || loadMore()) {\n", "int i = (int) _inputBuffer[_inputPtr++];\n", "if (i < INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "break;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "break;\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "}\n", "}\n", "\n", "@Override\n", "protected char _decodeEscaped() throws IOException\n", "{\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) {\n", "_reportInvalidEOF(\" in character escape sequence\");\n", "}\n", "}\n", "char c = _inputBuffer[_inputPtr++];\n", "\n", "switch ((int) c) {\n", "// First, ones that are mapped\n", "case 'b':\n", "return '\\b';\n", "case 't':\n", "return '\\t';\n", "case 'n':\n", "return '\\n';\n", "case 'f':\n", "return '\\f';\n", "case 'r':\n", "return '\\r';\n", "\n", "// And these are to be returned as they are\n", "case '\"':\n", "case '/':\n", "case '\\\\':\n", "return c;\n", "\n", "case 'u': // and finally hex-escaped\n", "break;\n", "\n", "default:\n", "return _handleUnrecognizedCharacterEscape(c);\n", "}\n", "\n", "// Ok, a hex escape. Need 4 characters\n", "int value = 0;\n", "for (int i = 0; i < 4; ++i) {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) {\n", "_reportInvalidEOF(\" in character escape sequence\");\n", "}\n", "}\n", "int ch = (int) _inputBuffer[_inputPtr++];\n", "int digit = CharTypes.charToHex(ch);\n", "if (digit < 0) {\n", "_reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n", "}\n", "value = (value << 4) | digit;\n", "}\n", "return (char) value;\n", "}\n", "\n", "private final void _matchTrue() throws IOException {\n", "int ptr = _inputPtr;\n", "if ((ptr + 3) < _inputEnd) {\n", "final char[] b = _inputBuffer;\n", "if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n", "char c = b[++ptr];\n", "if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n", "_inputPtr = ptr;\n", "return;\n", "}\n", "}\n", "}\n", "// buffer boundary, or problem, offline\n", "_matchToken(\"true\", 1);\n", "}\n", "\n", "private final void _matchFalse() throws IOException {\n", "int ptr = _inputPtr;\n", "if ((ptr + 4) < _inputEnd) {\n", "final char[] b = _inputBuffer;\n", "if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n", "char c = b[++ptr];\n", "if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n", "_inputPtr = ptr;\n", "return;\n", "}\n", "}\n", "}\n", "// buffer boundary, or problem, offline\n", "_matchToken(\"false\", 1);\n", "}\n", "\n", "private final void _matchNull() throws IOException {\n", "int ptr = _inputPtr;\n", "if ((ptr + 3) < _inputEnd) {\n", "final char[] b = _inputBuffer;\n", "if (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\n", "char c = b[++ptr];\n", "if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n", "_inputPtr = ptr;\n", "return;\n", "}\n", "}\n", "}\n", "// buffer boundary, or problem, offline\n", "_matchToken(\"null\", 1);\n", "}\n"], "faulty_lines": [4], "cluster": 6}, {"pid": "JacksonCore", "bid": 12, "method_path": "./dataset/JacksonCore/12/ReaderBasedJsonParser.java", "method": ["protected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n", "{\n", "// // // and this is back to standard nextToken()\n", "String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n", "_parsingContext.setCurrentName(name);\n", "_currToken = JsonToken.FIELD_NAME;\n", "i = _skipColon();\n", "if (i == INT_QUOTE) {\n", "_tokenIncomplete = true;\n", "_nextToken = JsonToken.VALUE_STRING;\n", "return nameToMatch.equals(name);\n", "}\n", "// Ok: we must have a value... what is it?\n", "JsonToken t;\n", "switch (i) {\n", "case '-':\n", "t = _parseNegNumber();\n", "break;\n", "case '0':\n", "case '1':\n", "case '2':\n", "case '3':\n", "case '4':\n", "case '5':\n", "case '6':\n", "case '7':\n", "case '8':\n", "case '9':\n", "t = _parsePosNumber(i);\n", "break;\n", "case 'f':\n", "_matchFalse();\n", "t = JsonToken.VALUE_FALSE;\n", "break;\n", "case 'n':\n", "_matchNull();\n", "t = JsonToken.VALUE_NULL;\n", "break;\n", "case 't':\n", "_matchTrue();\n", "t = JsonToken.VALUE_TRUE;\n", "break;\n", "case '[':\n", "t = JsonToken.START_ARRAY;\n", "break;\n", "case '{':\n", "t = JsonToken.START_OBJECT;\n", "break;\n", "default:\n", "t = _handleOddValue(i);\n", "break;\n", "}\n", "_nextToken = t;\n", "return nameToMatch.equals(name);\n", "}\n", "\n", "private final JsonToken _nextTokenNotInObject(int i) throws IOException\n", "{\n", "if (i == INT_QUOTE) {\n", "_tokenIncomplete = true;\n", "return (_currToken = JsonToken.VALUE_STRING);\n", "}\n", "switch (i) {\n", "case '[':\n", "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n", "return (_currToken = JsonToken.START_ARRAY);\n", "case '{':\n", "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n", "return (_currToken = JsonToken.START_OBJECT);\n", "case 't':\n", "_matchToken(\"true\", 1);\n", "return (_currToken = JsonToken.VALUE_TRUE);\n", "case 'f':\n", "_matchToken(\"false\", 1);\n", "return (_currToken = JsonToken.VALUE_FALSE);\n", "case 'n':\n", "_matchToken(\"null\", 1);\n", "return (_currToken = JsonToken.VALUE_NULL);\n", "case '-':\n", "return (_currToken = _parseNegNumber());\n", "/* Should we have separate handling for plus? Although\n", "* it is not allowed per se, it may be erroneously used,\n", "* and could be indicated by a more specific error message.\n", "*/\n", "case '0':\n", "case '1':\n", "case '2':\n", "case '3':\n", "case '4':\n", "case '5':\n", "case '6':\n", "case '7':\n", "case '8':\n", "case '9':\n", "return (_currToken = _parsePosNumber(i));\n", "}\n", "return (_currToken = _handleOddValue(i));\n", "}\n", "\n", "// note: identical to one in UTF8StreamJsonParser\n", "@Override\n", "public final String nextTextValue() throws IOException\n", "{\n", "if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n", "_nameCopied = false;\n", "JsonToken t = _nextToken;\n", "_nextToken = null;\n", "_currToken = t;\n", "if (t == JsonToken.VALUE_STRING) {\n", "if (_tokenIncomplete) {\n", "_tokenIncomplete = false;\n", "_finishString();\n", "}\n", "return _textBuffer.contentsAsString();\n", "}\n", "if (t == JsonToken.START_ARRAY) {\n", "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n", "} else if (t == JsonToken.START_OBJECT) {\n", "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n", "}\n", "return null;\n", "}\n", "// !!! TODO: optimize this case as well\n", "return (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n", "}\n", "\n", "// note: identical to one in Utf8StreamParser\n", "@Override\n", "public final int nextIntValue(int defaultValue) throws IOException\n", "{\n", "if (_currToken == JsonToken.FIELD_NAME) {\n", "_nameCopied = false;\n", "JsonToken t = _nextToken;\n", "_nextToken = null;\n", "_currToken = t;\n", "if (t == JsonToken.VALUE_NUMBER_INT) {\n", "return getIntValue();\n", "}\n", "if (t == JsonToken.START_ARRAY) {\n", "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n", "} else if (t == JsonToken.START_OBJECT) {\n", "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n", "}\n", "return defaultValue;\n", "}\n", "// !!! TODO: optimize this case as well\n", "return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n", "}\n", "\n", "// note: identical to one in Utf8StreamParser\n", "@Override\n", "public final long nextLongValue(long defaultValue) throws IOException\n", "{\n", "if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n", "_nameCopied = false;\n", "JsonToken t = _nextToken;\n", "_nextToken = null;\n", "_currToken = t;\n", "if (t == JsonToken.VALUE_NUMBER_INT) {\n", "return getLongValue();\n", "}\n", "if (t == JsonToken.START_ARRAY) {\n", "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n", "} else if (t == JsonToken.START_OBJECT) {\n", "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n", "}\n", "return defaultValue;\n", "}\n", "// !!! TODO: optimize this case as well\n", "return (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n", "}\n", "\n", "// note: identical to one in UTF8StreamJsonParser\n", "@Override\n", "public final Boolean nextBooleanValue() throws IOException\n", "{\n", "if (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n", "_nameCopied = false;\n", "JsonToken t = _nextToken;\n", "_nextToken = null;\n", "_currToken = t;\n", "if (t == JsonToken.VALUE_TRUE) {\n", "return Boolean.TRUE;\n", "}\n", "if (t == JsonToken.VALUE_FALSE) {\n", "return Boolean.FALSE;\n", "}\n", "if (t == JsonToken.START_ARRAY) {\n", "_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n", "} else if (t == JsonToken.START_OBJECT) {\n", "_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n", "}\n", "return null;\n", "}\n", "JsonToken t = nextToken();\n", "if (t != null) {\n", "int id = t.id();\n", "if (id == ID_TRUE) return Boolean.TRUE;\n", "if (id == ID_FALSE) return Boolean.FALSE;\n", "}\n", "return null;\n", "}\n", "\n", "/*\n", "/**********************************************************\n", "/* Internal methods, number parsing\n", "/**********************************************************\n", "*/\n", "\n", "/**\n", "* Initial parsing method for number values. It needs to be able\n", "* to parse enough input to be able to determine whether the\n", "* value is to be considered a simple integer value, or a more\n", "* generic decimal value: latter of which needs to be expressed\n", "* as a floating point number. The basic rule is that if the number\n", "* has no fractional or exponential part, it is an integer; otherwise\n", "* a floating point number.\n", "*<p>\n", "* Because much of input has to be processed in any case, no partial\n", "* parsing is done: all input text will be stored for further\n", "* processing. However, actual numeric value conversion will be\n", "* deferred, since it is usually the most complicated and costliest\n", "* part of processing.\n", "*/\n", "protected final JsonToken _parsePosNumber(int ch) throws IOException\n", "{\n", "/* Although we will always be complete with respect to textual\n", "* representation (that is, all characters will be parsed),\n", "* actual conversion to a number is deferred. Thus, need to\n", "* note that no representations are valid yet\n", "*/\n", "int ptr = _inputPtr;\n", "int startPtr = ptr-1; // to include digit already read\n", "final int inputLen = _inputEnd;\n", "\n", "// One special case, leading zero(es):\n", "if (ch == INT_0) {\n", "return _parseNumber2(false, startPtr);\n", "}\n", "\n", "/* First, let's see if the whole number is contained within\n", "* the input buffer unsplit. This should be the common case;\n", "* and to simplify processing, we will just reparse contents\n", "* in the alternative case (number split on buffer boundary)\n", "*/\n", "\n", "int intLen = 1; // already got one\n", "\n", "// First let's get the obligatory integer part:\n", "int_loop:\n", "while (true) {\n", "if (ptr >= inputLen) {\n", "_inputPtr = startPtr;\n", "return _parseNumber2(false, startPtr);\n", "}\n", "ch = (int) _inputBuffer[ptr++];\n", "if (ch < INT_0 || ch > INT_9) {\n", "break int_loop;\n", "}\n", "++intLen;\n", "}\n", "if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n", "_inputPtr = ptr;\n", "return _parseFloat(ch, startPtr, ptr, false, intLen);\n", "}\n", "// Got it all: let's add to text buffer for parsing, access\n", "--ptr; // need to push back following separator\n", "_inputPtr = ptr;\n", "// As per #105, need separating space between root values; check here\n", "if (_parsingContext.inRoot()) {\n", "_verifyRootSpace(ch);\n", "}\n", "int len = ptr-startPtr;\n", "_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n", "return resetInt(false, intLen);\n", "}\n", "\n", "private final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\n", "throws IOException\n", "{\n", "final int inputLen = _inputEnd;\n", "int fractLen = 0;\n", "\n", "// And then see if we get other parts\n", "if (ch == '.') { // yes, fraction\n", "fract_loop:\n", "while (true) {\n", "if (ptr >= inputLen) {\n", "return _parseNumber2(neg, startPtr);\n", "}\n", "ch = (int) _inputBuffer[ptr++];\n", "if (ch < INT_0 || ch > INT_9) {\n", "break fract_loop;\n", "}\n", "++fractLen;\n", "}\n", "// must be followed by sequence of ints, one minimum\n", "if (fractLen == 0) {\n", "reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n", "}\n", "}\n", "int expLen = 0;\n", "if (ch == 'e' || ch == 'E') { // and/or exponent\n", "if (ptr >= inputLen) {\n", "_inputPtr = startPtr;\n", "return _parseNumber2(neg, startPtr);\n", "}\n", "// Sign indicator?\n", "ch = (int) _inputBuffer[ptr++];\n", "if (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\n", "if (ptr >= inputLen) {\n", "_inputPtr = startPtr;\n", "return _parseNumber2(neg, startPtr);\n", "}\n", "ch = (int) _inputBuffer[ptr++];\n", "}\n", "while (ch <= INT_9 && ch >= INT_0) {\n", "++expLen;\n", "if (ptr >= inputLen) {\n", "_inputPtr = startPtr;\n", "return _parseNumber2(neg, startPtr);\n", "}\n", "ch = (int) _inputBuffer[ptr++];\n", "}\n", "// must be followed by sequence of ints, one minimum\n", "if (expLen == 0) {\n", "reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n", "}\n", "}\n", "--ptr; // need to push back following separator\n", "_inputPtr = ptr;\n", "// As per #105, need separating space between root values; check here\n", "if (_parsingContext.inRoot()) {\n", "_verifyRootSpace(ch);\n", "}\n", "int len = ptr-startPtr;\n", "_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n", "// And there we have it!\n", "return resetFloat(neg, intLen, fractLen, expLen);\n", "}\n", "\n", "protected final JsonToken _parseNegNumber() throws IOException\n", "{\n", "int ptr = _inputPtr;\n", "int startPtr = ptr-1; // to include sign/digit already read\n", "final int inputLen = _inputEnd;\n", "\n", "if (ptr >= inputLen) {\n", "return _parseNumber2(true, startPtr);\n", "}\n", "int ch = _inputBuffer[ptr++];\n", "// First check: must have a digit to follow minus sign\n", "if (ch > INT_9 || ch < INT_0) {\n", "_inputPtr = ptr;\n", "return _handleInvalidNumberStart(ch, true);\n", "}\n", "// One special case, leading zero(es):\n", "if (ch == INT_0) {\n", "return _parseNumber2(true, startPtr);\n", "}\n", "int intLen = 1; // already got one\n", "\n", "// First let's get the obligatory integer part:\n", "int_loop:\n", "while (true) {\n", "if (ptr >= inputLen) {\n", "return _parseNumber2(true, startPtr);\n", "}\n", "ch = (int) _inputBuffer[ptr++];\n", "if (ch < INT_0 || ch > INT_9) {\n", "break int_loop;\n", "}\n", "++intLen;\n", "}\n", "\n", "if (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n", "_inputPtr = ptr;\n", "return _parseFloat(ch, startPtr, ptr, true, intLen);\n", "}\n", "--ptr;\n", "_inputPtr = ptr;\n", "if (_parsingContext.inRoot()) {\n", "_verifyRootSpace(ch);\n", "}\n", "int len = ptr-startPtr;\n", "_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n", "return resetInt(true, intLen);\n", "}\n", "\n", "/**\n", "* Method called to parse a number, when the primary parse\n", "* method has failed to parse it, due to it being split on\n", "* buffer boundary. As a result code is very similar, except\n", "* that it has to explicitly copy contents to the text buffer\n", "* instead of just sharing the main input buffer.\n", "*/\n", "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n", "{\n", "_inputPtr = neg ? (startPtr+1) : startPtr;\n", "char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n", "int outPtr = 0;\n", "\n", "// Need to prepend sign?\n", "if (neg) {\n", "outBuf[outPtr++] = '-';\n", "}\n", "\n", "// This is the place to do leading-zero check(s) too:\n", "int intLen = 0;\n", "char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n", "if (c == '0') {\n", "c = _verifyNoLeadingZeroes();\n", "}\n", "boolean eof = false;\n", "\n", "// Ok, first the obligatory integer part:\n", "int_loop:\n", "while (c >= '0' && c <= '9') {\n", "++intLen;\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "outBuf[outPtr++] = c;\n", "if (_inputPtr >= _inputEnd && !loadMore()) {\n", "// EOF is legal for main level int values\n", "c = CHAR_NULL;\n", "eof = true;\n", "break int_loop;\n", "}\n", "c = _inputBuffer[_inputPtr++];\n", "}\n", "// Also, integer part is not optional\n", "if (intLen == 0) {\n", "return _handleInvalidNumberStart(c, neg);\n", "}\n", "\n", "int fractLen = 0;\n", "// And then see if we get other parts\n", "if (c == '.') { // yes, fraction\n", "outBuf[outPtr++] = c;\n", "\n", "fract_loop:\n", "while (true) {\n", "if (_inputPtr >= _inputEnd && !loadMore()) {\n", "eof = true;\n", "break fract_loop;\n", "}\n", "c = _inputBuffer[_inputPtr++];\n", "if (c < INT_0 || c > INT_9) {\n", "break fract_loop;\n", "}\n", "++fractLen;\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "outBuf[outPtr++] = c;\n", "}\n", "// must be followed by sequence of ints, one minimum\n", "if (fractLen == 0) {\n", "reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n", "}\n", "}\n", "\n", "int expLen = 0;\n", "if (c == 'e' || c == 'E') { // exponent?\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "outBuf[outPtr++] = c;\n", "// Not optional, can require that we get one more char\n", "c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n", ": getNextChar(\"expected a digit for number exponent\");\n", "// Sign indicator?\n", "if (c == '-' || c == '+') {\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "outBuf[outPtr++] = c;\n", "// Likewise, non optional:\n", "c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n", ": getNextChar(\"expected a digit for number exponent\");\n", "}\n", "\n", "exp_loop:\n", "while (c <= INT_9 && c >= INT_0) {\n", "++expLen;\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "outBuf[outPtr++] = c;\n", "if (_inputPtr >= _inputEnd && !loadMore()) {\n", "eof = true;\n", "break exp_loop;\n", "}\n", "c = _inputBuffer[_inputPtr++];\n", "}\n", "// must be followed by sequence of ints, one minimum\n", "if (expLen == 0) {\n", "reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n", "}\n", "}\n", "\n", "// Ok; unless we hit end-of-input, need to push last char read back\n", "if (!eof) {\n", "--_inputPtr;\n", "if (_parsingContext.inRoot()) {\n", "_verifyRootSpace(c);\n", "}\n", "}\n", "_textBuffer.setCurrentLength(outPtr);\n", "// And there we have it!\n", "return reset(neg, intLen, fractLen, expLen);\n", "}\n", "\n", "/**\n", "* Method called when we have seen one zero, and want to ensure\n", "* it is not followed by another\n", "*/\n", "private final char _verifyNoLeadingZeroes() throws IOException\n", "{\n", "// Fast case first:\n", "if (_inputPtr < _inputEnd) {\n", "char ch = _inputBuffer[_inputPtr];\n", "// if not followed by a number (probably '.'); return zero as is, to be included\n", "if (ch < '0' || ch > '9') {\n", "return '0';\n", "}\n", "}\n", "// and offline the less common case\n", "return _verifyNLZ2();\n", "}\n", "\n", "private char _verifyNLZ2() throws IOException\n", "{\n", "if (_inputPtr >= _inputEnd && !loadMore()) {\n", "return '0';\n", "}\n", "char ch = _inputBuffer[_inputPtr];\n", "if (ch < '0' || ch > '9') {\n", "return '0';\n", "}\n", "if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\n", "reportInvalidNumber(\"Leading zeroes not allowed\");\n", "}\n", "// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n", "++_inputPtr; // Leading zero to be skipped\n", "if (ch == INT_0) {\n", "while (_inputPtr < _inputEnd || loadMore()) {\n", "ch = _inputBuffer[_inputPtr];\n", "if (ch < '0' || ch > '9') { // followed by non-number; retain one zero\n", "return '0';\n", "}\n", "++_inputPtr; // skip previous zero\n", "if (ch != '0') { // followed by other number; return\n", "break;\n", "}\n", "}\n", "}\n", "return ch;\n", "}\n", "\n", "/**\n", "* Method called if expected numeric value (due to leading sign) does not\n", "* look like a number\n", "*/\n", "protected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n", "{\n", "if (ch == 'I') {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) { _reportInvalidEOFInValue(); }\n", "}\n", "ch = _inputBuffer[_inputPtr++];\n", "if (ch == 'N') {\n", "String match = negative ? \"-INF\" :\"+INF\";\n", "_matchToken(match, 3);\n", "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n", "return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n", "}\n", "_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n", "} else if (ch == 'n') {\n", "String match = negative ? \"-Infinity\" :\"+Infinity\";\n", "_matchToken(match, 3);\n", "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n", "return resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n", "}\n", "_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n", "}\n", "}\n", "reportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\n", "return null;\n", "}\n", "\n", "/**\n", "* Method called to ensure that a root-value is followed by a space\n", "* token.\n", "*<p>\n", "* NOTE: caller MUST ensure there is at least one character available;\n", "* and that input pointer is AT given char (not past)\n", "*/\n", "private final void _verifyRootSpace(int ch) throws IOException\n", "{\n", "// caller had pushed it back, before calling; reset\n", "++_inputPtr;\n", "switch (ch) {\n", "case ' ':\n", "case '\\t':\n", "return;\n", "case '\\r':\n", "_skipCR();\n", "return;\n", "case '\\n':\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "return;\n", "}\n", "_reportMissingRootWS(ch);\n", "}\n", "\n", "/*\n", "/**********************************************************\n", "/* Internal methods, secondary parsing\n", "/**********************************************************\n", "*/\n", "\n", "protected final String _parseName() throws IOException\n", "{\n", "// First: let's try to see if we have a simple name: one that does\n", "// not cross input buffer boundary, and does not contain escape sequences.\n", "int ptr = _inputPtr;\n", "int hash = _hashSeed;\n", "final int[] codes = _icLatin1;\n", "\n", "while (ptr < _inputEnd) {\n", "int ch = _inputBuffer[ptr];\n", "if (ch < codes.length && codes[ch] != 0) {\n", "if (ch == '\"') {\n", "int start = _inputPtr;\n", "_inputPtr = ptr+1; // to skip the quote\n", "return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n", "}\n", "break;\n", "}\n", "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n", "++ptr;\n", "}\n", "int start = _inputPtr;\n", "_inputPtr = ptr;\n", "return _parseName2(start, hash, INT_QUOTE);\n", "}\n", "\n", "private String _parseName2(int startPtr, int hash, int endChar) throws IOException\n", "{\n", "_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n", "\n", "/* Output pointers; calls will also ensure that the buffer is\n", "* not shared and has room for at least one more char.\n", "*/\n", "char[] outBuf = _textBuffer.getCurrentSegment();\n", "int outPtr = _textBuffer.getCurrentSegmentSize();\n", "\n", "while (true) {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) {\n", "_reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n", "}\n", "}\n", "char c = _inputBuffer[_inputPtr++];\n", "int i = (int) c;\n", "if (i <= INT_BACKSLASH) {\n", "if (i == INT_BACKSLASH) {\n", "/* Although chars outside of BMP are to be escaped as\n", "* an UTF-16 surrogate pair, does that affect decoding?\n", "* For now let's assume it does not.\n", "*/\n", "c = _decodeEscaped();\n", "} else if (i <= endChar) {\n", "if (i == endChar) {\n", "break;\n", "}\n", "if (i < INT_SPACE) {\n", "_throwUnquotedSpace(i, \"name\");\n", "}\n", "}\n", "}\n", "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n", "// Ok, let's add char to output:\n", "outBuf[outPtr++] = c;\n", "\n", "// Need more room?\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "}\n", "_textBuffer.setCurrentLength(outPtr);\n", "{\n", "TextBuffer tb = _textBuffer;\n", "char[] buf = tb.getTextBuffer();\n", "int start = tb.getTextOffset();\n", "int len = tb.size();\n", "return _symbols.findSymbol(buf, start, len, hash);\n", "}\n", "}\n", "\n", "/**\n", "* Method called when we see non-white space character other\n", "* than double quote, when expecting a field name.\n", "* In standard mode will just throw an expection; but\n", "* in non-standard modes may be able to parse name.\n", "*/\n", "protected String _handleOddName(int i) throws IOException\n", "{\n", "// [JACKSON-173]: allow single quotes\n", "if (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n", "return _parseAposName();\n", "}\n", "// [JACKSON-69]: allow unquoted names if feature enabled:\n", "if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n", "_reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n", "}\n", "final int[] codes = CharTypes.getInputCodeLatin1JsNames();\n", "final int maxCode = codes.length;\n", "\n", "// Also: first char must be a valid name char, but NOT be number\n", "boolean firstOk;\n", "\n", "if (i < maxCode) { // identifier, or a number ([Issue#102])\n", "firstOk = (codes[i] == 0);\n", "} else {\n", "firstOk = Character.isJavaIdentifierPart((char) i);\n", "}\n", "if (!firstOk) {\n", "_reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n", "}\n", "int ptr = _inputPtr;\n", "int hash = _hashSeed;\n", "final int inputLen = _inputEnd;\n", "\n", "if (ptr < inputLen) {\n", "do {\n", "int ch = _inputBuffer[ptr];\n", "if (ch < maxCode) {\n", "if (codes[ch] != 0) {\n", "int start = _inputPtr-1; // -1 to bring back first char\n", "_inputPtr = ptr;\n", "return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n", "}\n", "} else if (!Character.isJavaIdentifierPart((char) ch)) {\n", "int start = _inputPtr-1; // -1 to bring back first char\n", "_inputPtr = ptr;\n", "return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n", "}\n", "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n", "++ptr;\n", "} while (ptr < inputLen);\n", "}\n", "int start = _inputPtr-1;\n", "_inputPtr = ptr;\n", "return _handleOddName2(start, hash, codes);\n", "}\n", "\n", "protected String _parseAposName() throws IOException\n", "{\n", "// Note: mostly copy of_parseFieldName\n", "int ptr = _inputPtr;\n", "int hash = _hashSeed;\n", "final int inputLen = _inputEnd;\n", "\n", "if (ptr < inputLen) {\n", "final int[] codes = _icLatin1;\n", "final int maxCode = codes.length;\n", "\n", "do {\n", "int ch = _inputBuffer[ptr];\n", "if (ch == '\\'') {\n", "int start = _inputPtr;\n", "_inputPtr = ptr+1; // to skip the quote\n", "return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n", "}\n", "if (ch < maxCode && codes[ch] != 0) {\n", "break;\n", "}\n", "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n", "++ptr;\n", "} while (ptr < inputLen);\n", "}\n", "\n", "int start = _inputPtr;\n", "_inputPtr = ptr;\n", "\n", "return _parseName2(start, hash, '\\'');\n", "}\n", "\n", "/**\n", "* Method for handling cases where first non-space character\n", "* of an expected value token is not legal for standard JSON content.\n", "*/\n", "protected JsonToken _handleOddValue(int i) throws IOException\n", "{\n", "// Most likely an error, unless we are to allow single-quote-strings\n", "switch (i) {\n", "case '\\'':\n", "/* [JACKSON-173]: allow single quotes. Unlike with regular\n", "* Strings, we'll eagerly parse contents; this so that there's\n", "* no need to store information on quote char used.\n", "*\n", "* Also, no separation to fast/slow parsing; we'll just do\n", "* one regular (~= slowish) parsing, to keep code simple\n", "*/\n", "if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\n", "return _handleApos();\n", "}\n", "break;\n", "case 'N':\n", "_matchToken(\"NaN\", 1);\n", "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n", "return resetAsNaN(\"NaN\", Double.NaN);\n", "}\n", "_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n", "break;\n", "case 'I':\n", "_matchToken(\"Infinity\", 1);\n", "if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\n", "return resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n", "}\n", "_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n", "break;\n", "case '+': // note: '-' is taken as number\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) {\n", "_reportInvalidEOFInValue();\n", "}\n", "}\n", "return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n", "}\n", "// [Issue#77] Try to decode most likely token\n", "if (Character.isJavaIdentifierStart(i)) {\n", "_reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n", "}\n", "// but if it doesn't look like a token:\n", "_reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\n", "return null;\n", "}\n", "\n", "protected JsonToken _handleApos() throws IOException\n", "{\n", "char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n", "int outPtr = _textBuffer.getCurrentSegmentSize();\n", "\n", "while (true) {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) {\n", "_reportInvalidEOF(\": was expecting closing quote for a string value\");\n", "}\n", "}\n", "char c = _inputBuffer[_inputPtr++];\n", "int i = (int) c;\n", "if (i <= '\\\\') {\n", "if (i == '\\\\') {\n", "/* Although chars outside of BMP are to be escaped as\n", "* an UTF-16 surrogate pair, does that affect decoding?\n", "* For now let's assume it does not.\n", "*/\n", "c = _decodeEscaped();\n", "} else if (i <= '\\'') {\n", "if (i == '\\'') {\n", "break;\n", "}\n", "if (i < INT_SPACE) {\n", "_throwUnquotedSpace(i, \"string value\");\n", "}\n", "}\n", "}\n", "// Need more room?\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "// Ok, let's add char to output:\n", "outBuf[outPtr++] = c;\n", "}\n", "_textBuffer.setCurrentLength(outPtr);\n", "return JsonToken.VALUE_STRING;\n", "}\n", "\n", "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n", "{\n", "_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n", "char[] outBuf = _textBuffer.getCurrentSegment();\n", "int outPtr = _textBuffer.getCurrentSegmentSize();\n", "final int maxCode = codes.length;\n", "\n", "while (true) {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) { // acceptable for now (will error out later)\n", "break;\n", "}\n", "}\n", "char c = _inputBuffer[_inputPtr];\n", "int i = (int) c;\n", "if (i <= maxCode) {\n", "if (codes[i] != 0) {\n", "break;\n", "}\n", "} else if (!Character.isJavaIdentifierPart(c)) {\n", "break;\n", "}\n", "++_inputPtr;\n", "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n", "// Ok, let's add char to output:\n", "outBuf[outPtr++] = c;\n", "\n", "// Need more room?\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "}\n", "_textBuffer.setCurrentLength(outPtr);\n", "{\n", "TextBuffer tb = _textBuffer;\n", "char[] buf = tb.getTextBuffer();\n", "int start = tb.getTextOffset();\n", "int len = tb.size();\n", "\n", "return _symbols.findSymbol(buf, start, len, hash);\n", "}\n", "}\n", "\n", "@Override\n", "protected final void _finishString() throws IOException\n", "{\n", "/* First: let's try to see if we have simple String value: one\n", "* that does not cross input buffer boundary, and does not\n", "* contain escape sequences.\n", "*/\n", "int ptr = _inputPtr;\n", "final int inputLen = _inputEnd;\n", "\n", "if (ptr < inputLen) {\n", "final int[] codes = _icLatin1;\n", "final int maxCode = codes.length;\n", "\n", "do {\n", "int ch = _inputBuffer[ptr];\n", "if (ch < maxCode && codes[ch] != 0) {\n", "if (ch == '\"') {\n", "_textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n", "_inputPtr = ptr+1;\n", "// Yes, we got it all\n", "return;\n", "}\n", "break;\n", "}\n", "++ptr;\n", "} while (ptr < inputLen);\n", "}\n", "\n", "/* Either ran out of input, or bumped into an escape\n", "* sequence...\n", "*/\n", "_textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n", "_inputPtr = ptr;\n", "_finishString2();\n", "}\n", "\n", "protected void _finishString2() throws IOException\n", "{\n", "char[] outBuf = _textBuffer.getCurrentSegment();\n", "int outPtr = _textBuffer.getCurrentSegmentSize();\n", "final int[] codes = _icLatin1;\n", "final int maxCode = codes.length;\n", "\n", "while (true) {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) {\n", "_reportInvalidEOF(\": was expecting closing quote for a string value\");\n", "}\n", "}\n", "char c = _inputBuffer[_inputPtr++];\n", "int i = (int) c;\n", "if (i < maxCode && codes[i] != 0) {\n", "if (i == INT_QUOTE) {\n", "break;\n", "} else if (i == INT_BACKSLASH) {\n", "/* Although chars outside of BMP are to be escaped as\n", "* an UTF-16 surrogate pair, does that affect decoding?\n", "* For now let's assume it does not.\n", "*/\n", "c = _decodeEscaped();\n", "} else if (i < INT_SPACE) {\n", "_throwUnquotedSpace(i, \"string value\");\n", "} // anything else?\n", "}\n", "// Need more room?\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "// Ok, let's add char to output:\n", "outBuf[outPtr++] = c;\n", "}\n", "_textBuffer.setCurrentLength(outPtr);\n", "}\n", "\n", "/**\n", "* Method called to skim through rest of unparsed String value,\n", "* if it is not needed. This can be done bit faster if contents\n", "* need not be stored for future access.\n", "*/\n", "protected final void _skipString() throws IOException\n", "{\n", "_tokenIncomplete = false;\n", "\n", "int inPtr = _inputPtr;\n", "int inLen = _inputEnd;\n", "char[] inBuf = _inputBuffer;\n", "\n", "while (true) {\n", "if (inPtr >= inLen) {\n", "_inputPtr = inPtr;\n", "if (!loadMore()) {\n", "_reportInvalidEOF(\": was expecting closing quote for a string value\");\n", "}\n", "inPtr = _inputPtr;\n", "inLen = _inputEnd;\n", "}\n", "char c = inBuf[inPtr++];\n", "int i = (int) c;\n", "if (i <= INT_BACKSLASH) {\n", "if (i == INT_BACKSLASH) {\n", "/* Although chars outside of BMP are to be escaped as\n", "* an UTF-16 surrogate pair, does that affect decoding?\n", "* For now let's assume it does not.\n", "*/\n", "_inputPtr = inPtr;\n", "c = _decodeEscaped();\n", "inPtr = _inputPtr;\n", "inLen = _inputEnd;\n", "} else if (i <= INT_QUOTE) {\n", "if (i == INT_QUOTE) {\n", "_inputPtr = inPtr;\n", "break;\n", "}\n", "if (i < INT_SPACE) {\n", "_inputPtr = inPtr;\n", "_throwUnquotedSpace(i, \"string value\");\n", "}\n", "}\n", "}\n", "}\n", "}\n", "\n", "/*\n", "/**********************************************************\n", "/* Internal methods, other parsing\n", "/**********************************************************\n", "*/\n", "\n", "/**\n", "* We actually need to check the character value here\n", "* (to see if we have \\n following \\r).\n", "*/\n", "protected final void _skipCR() throws IOException {\n", "if (_inputPtr < _inputEnd || loadMore()) {\n", "if (_inputBuffer[_inputPtr] == '\\n') {\n", "++_inputPtr;\n", "}\n", "}\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "}\n", "\n", "private final int _skipColon() throws IOException\n", "{\n", "if ((_inputPtr + 4) >= _inputEnd) {\n", "return _skipColon2(false);\n", "}\n", "char c = _inputBuffer[_inputPtr];\n", "if (c == ':') { // common case, no leading space\n", "int i = _inputBuffer[++_inputPtr];\n", "if (i > INT_SPACE) { // nor trailing\n", "if (i == INT_SLASH || i == INT_HASH) {\n", "return _skipColon2(true);\n", "}\n", "++_inputPtr;\n", "return i;\n", "}\n", "if (i == INT_SPACE || i == INT_TAB) {\n", "i = (int) _inputBuffer[++_inputPtr];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH || i == INT_HASH) {\n", "return _skipColon2(true);\n", "}\n", "++_inputPtr;\n", "return i;\n", "}\n", "}\n", "return _skipColon2(true); // true -> skipped colon\n", "}\n", "if (c == ' ' || c == '\\t') {\n", "c = _inputBuffer[++_inputPtr];\n", "}\n", "if (c == ':') {\n", "int i = _inputBuffer[++_inputPtr];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH || i == INT_HASH) {\n", "return _skipColon2(true);\n", "}\n", "++_inputPtr;\n", "return i;\n", "}\n", "if (i == INT_SPACE || i == INT_TAB) {\n", "i = (int) _inputBuffer[++_inputPtr];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH || i == INT_HASH) {\n", "return _skipColon2(true);\n", "}\n", "++_inputPtr;\n", "return i;\n", "}\n", "}\n", "return _skipColon2(true);\n", "}\n", "return _skipColon2(false);\n", "}\n", "\n", "private final int _skipColon2(boolean gotColon) throws IOException\n", "{\n", "while (true) {\n", "if (_inputPtr >= _inputEnd) {\n", "loadMoreGuaranteed();\n", "}\n", "int i = (int) _inputBuffer[_inputPtr++];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH) {\n", "_skipComment();\n", "continue;\n", "}\n", "if (i == INT_HASH) {\n", "if (_skipYAMLComment()) {\n", "continue;\n", "}\n", "}\n", "if (gotColon) {\n", "return i;\n", "}\n", "if (i != INT_COLON) {\n", "if (i < INT_SPACE) {\n", "_throwInvalidSpace(i);\n", "}\n", "_reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n", "}\n", "gotColon = true;\n", "continue;\n", "}\n", "if (i < INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "}\n", "}\n", "\n", "// Variant called when we know there's at least 4 more bytes available\n", "private final int _skipColonFast(int ptr) throws IOException\n", "{\n", "int i = (int) _inputBuffer[ptr++];\n", "if (i == INT_COLON) { // common case, no leading space\n", "i = _inputBuffer[ptr++];\n", "if (i > INT_SPACE) { // nor trailing\n", "if (i != INT_SLASH && i != INT_HASH) {\n", "_inputPtr = ptr;\n", "return i;\n", "}\n", "} else if (i == INT_SPACE || i == INT_TAB) {\n", "i = (int) _inputBuffer[ptr++];\n", "if (i > INT_SPACE) {\n", "if (i != INT_SLASH && i != INT_HASH) {\n", "_inputPtr = ptr;\n", "return i;\n", "}\n", "}\n", "}\n", "_inputPtr = ptr-1;\n", "return _skipColon2(true); // true -> skipped colon\n", "}\n", "if (i == INT_SPACE || i == INT_TAB) {\n", "i = _inputBuffer[ptr++];\n", "}\n", "boolean gotColon = (i == INT_COLON);\n", "if (gotColon) {\n", "i = _inputBuffer[ptr++];\n", "if (i > INT_SPACE) {\n", "if (i != INT_SLASH && i != INT_HASH) {\n", "_inputPtr = ptr;\n", "return i;\n", "}\n", "} else if (i == INT_SPACE || i == INT_TAB) {\n", "i = (int) _inputBuffer[ptr++];\n", "if (i > INT_SPACE) {\n", "if (i != INT_SLASH && i != INT_HASH) {\n", "_inputPtr = ptr;\n", "return i;\n", "}\n", "}\n", "}\n", "}\n", "_inputPtr = ptr-1;\n", "return _skipColon2(gotColon);\n", "}\n", "\n", "// Primary loop: no reloading, comment handling\n", "private final int _skipComma(int i) throws IOException\n", "{\n", "if (i != INT_COMMA) {\n", "_reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n", "}\n", "while (_inputPtr < _inputEnd) {\n", "i = (int) _inputBuffer[_inputPtr++];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH || i == INT_HASH) {\n", "--_inputPtr;\n", "return _skipAfterComma2();\n", "}\n", "return i;\n", "}\n", "if (i < INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "}\n", "return _skipAfterComma2();\n", "}\n", "\n", "private final int _skipAfterComma2() throws IOException\n", "{\n", "while (_inputPtr < _inputEnd || loadMore()) {\n", "int i = (int) _inputBuffer[_inputPtr++];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH) {\n", "_skipComment();\n", "continue;\n", "}\n", "if (i == INT_HASH) {\n", "if (_skipYAMLComment()) {\n", "continue;\n", "}\n", "}\n", "return i;\n", "}\n", "if (i < INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "}\n", "throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n", "}\n", "\n", "private final int _skipWSOrEnd() throws IOException\n", "{\n", "// Let's handle first character separately since it is likely that\n", "// it is either non-whitespace; or we have longer run of white space\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) {\n", "return _eofAsNextChar();\n", "}\n", "}\n", "int i = _inputBuffer[_inputPtr++];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH || i == INT_HASH) {\n", "--_inputPtr;\n", "return _skipWSOrEnd2();\n", "}\n", "return i;\n", "}\n", "if (i != INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "\n", "while (_inputPtr < _inputEnd) {\n", "i = (int) _inputBuffer[_inputPtr++];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH || i == INT_HASH) {\n", "--_inputPtr;\n", "return _skipWSOrEnd2();\n", "}\n", "return i;\n", "}\n", "if (i != INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "}\n", "return _skipWSOrEnd2();\n", "}\n", "\n", "private int _skipWSOrEnd2() throws IOException\n", "{\n", "while (true) {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) { // We ran out of input...\n", "return _eofAsNextChar();\n", "}\n", "}\n", "int i = (int) _inputBuffer[_inputPtr++];\n", "if (i > INT_SPACE) {\n", "if (i == INT_SLASH) {\n", "_skipComment();\n", "continue;\n", "}\n", "if (i == INT_HASH) {\n", "if (_skipYAMLComment()) {\n", "continue;\n", "}\n", "}\n", "return i;\n", "} else if (i != INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "}\n", "}\n", "\n", "private void _skipComment() throws IOException\n", "{\n", "if (!isEnabled(Feature.ALLOW_COMMENTS)) {\n", "_reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n", "}\n", "// First: check which comment (if either) it is:\n", "if (_inputPtr >= _inputEnd && !loadMore()) {\n", "_reportInvalidEOF(\" in a comment\");\n", "}\n", "char c = _inputBuffer[_inputPtr++];\n", "if (c == '/') {\n", "_skipLine();\n", "} else if (c == '*') {\n", "_skipCComment();\n", "} else {\n", "_reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n", "}\n", "}\n", "\n", "private void _skipCComment() throws IOException\n", "{\n", "// Ok: need the matching '*/'\n", "while ((_inputPtr < _inputEnd) || loadMore()) {\n", "int i = (int) _inputBuffer[_inputPtr++];\n", "if (i <= '*') {\n", "if (i == '*') { // end?\n", "if ((_inputPtr >= _inputEnd) && !loadMore()) {\n", "break;\n", "}\n", "if (_inputBuffer[_inputPtr] == INT_SLASH) {\n", "++_inputPtr;\n", "return;\n", "}\n", "continue;\n", "}\n", "if (i < INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "}\n", "}\n", "_reportInvalidEOF(\" in a comment\");\n", "}\n", "\n", "private boolean _skipYAMLComment() throws IOException\n", "{\n", "if (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\n", "return false;\n", "}\n", "_skipLine();\n", "return true;\n", "}\n", "\n", "private void _skipLine() throws IOException\n", "{\n", "// Ok: need to find EOF or linefeed\n", "while ((_inputPtr < _inputEnd) || loadMore()) {\n", "int i = (int) _inputBuffer[_inputPtr++];\n", "if (i < INT_SPACE) {\n", "if (i == INT_LF) {\n", "++_currInputRow;\n", "_currInputRowStart = _inputPtr;\n", "break;\n", "} else if (i == INT_CR) {\n", "_skipCR();\n", "break;\n", "} else if (i != INT_TAB) {\n", "_throwInvalidSpace(i);\n", "}\n", "}\n", "}\n", "}\n", "\n", "@Override\n", "protected char _decodeEscaped() throws IOException\n", "{\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) {\n", "_reportInvalidEOF(\" in character escape sequence\");\n", "}\n", "}\n", "char c = _inputBuffer[_inputPtr++];\n", "\n", "switch ((int) c) {\n", "// First, ones that are mapped\n", "case 'b':\n", "return '\\b';\n", "case 't':\n", "return '\\t';\n", "case 'n':\n", "return '\\n';\n", "case 'f':\n", "return '\\f';\n", "case 'r':\n", "return '\\r';\n", "\n", "// And these are to be returned as they are\n", "case '\"':\n", "case '/':\n", "case '\\\\':\n", "return c;\n", "\n", "case 'u': // and finally hex-escaped\n", "break;\n", "\n", "default:\n", "return _handleUnrecognizedCharacterEscape(c);\n", "}\n", "\n", "// Ok, a hex escape. Need 4 characters\n", "int value = 0;\n", "for (int i = 0; i < 4; ++i) {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!loadMore()) {\n", "_reportInvalidEOF(\" in character escape sequence\");\n", "}\n", "}\n", "int ch = (int) _inputBuffer[_inputPtr++];\n", "int digit = CharTypes.charToHex(ch);\n", "if (digit < 0) {\n", "_reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n", "}\n", "value = (value << 4) | digit;\n", "}\n", "return (char) value;\n", "}\n", "\n", "private final void _matchTrue() throws IOException {\n", "int ptr = _inputPtr;\n", "if ((ptr + 3) < _inputEnd) {\n", "final char[] b = _inputBuffer;\n", "if (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\n", "char c = b[++ptr];\n", "if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n", "_inputPtr = ptr;\n", "return;\n", "}\n", "}\n", "}\n", "// buffer boundary, or problem, offline\n", "_matchToken(\"true\", 1);\n", "}\n", "\n", "private final void _matchFalse() throws IOException {\n", "int ptr = _inputPtr;\n", "if ((ptr + 4) < _inputEnd) {\n", "final char[] b = _inputBuffer;\n", "if (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\n", "char c = b[++ptr];\n", "if (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n", "_inputPtr = ptr;\n", "return;\n", "}\n", "}\n", "}\n", "// buffer boundary, or problem, offline\n", "_matchToken(\"false\", 1);\n", "}\n"], "faulty_lines": [8], "cluster": 6}, {"pid": "JacksonCore", "bid": 12, "method_path": "./dataset/JacksonCore/12/ReaderBasedJsonParser.java", "method": ["public JsonLocation getTokenLocation()\n", "{\n", "final Object src = _ioContext.getSourceReference();\n", "return new JsonLocation(src,\n", "-1L, getTokenCharacterOffset(),\n", "getTokenLineNr(),\n", "getTokenColumnNr());\n", "}\n"], "faulty_lines": [4, 5, 6], "cluster": 0}, {"pid": "JacksonCore", "bid": 12, "method_path": "./dataset/JacksonCore/12/UTF8StreamJsonParser.java", "method": ["public JsonLocation getTokenLocation()\n", "{\n", "final Object src = _ioContext.getSourceReference();\n", "if (_currToken == JsonToken.FIELD_NAME) {\n", "return new JsonLocation(src,\n", "_nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n", "}\n", "return new JsonLocation(src,\n", "getTokenCharacterOffset(), -1L, getTokenLineNr(),\n", "getTokenColumnNr());\n", "}\n"], "faulty_lines": [9], "cluster": 4}, {"pid": "JacksonCore", "bid": 16, "method_path": "./dataset/JacksonCore/16/JsonParserSequence.java", "method": ["protected JsonParserSequence(JsonParser[] parsers)\n", "{\n", "super(parsers[0]);\n", "_parsers = parsers;\n", "_nextParser = 1;\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "JacksonCore", "bid": 17, "method_path": "./dataset/JacksonCore/17/UTF8JsonGenerator.java", "method": ["public void writeRaw(String text, int offset, int len) throws IOException\n", "{\n", "final char[] buf = _charBuffer;\n", "\n", "// minor optimization: see if we can just get and copy\n", "\n", "// If not, need segmented approach. For speed, let's also use input buffer\n", "// size that is guaranteed to fit in output buffer; each char can expand to\n", "// at most 3 bytes, so at most 1/3 of buffer size.\n", "\n", "while (len > 0) {\n", "int len2 = Math.min(buf.length, len);\n", "text.getChars(offset, offset+len2, buf, 0);\n", "writeRaw(buf, 0, len2);\n", "// If this is NOT the last segment and if the last character looks like\n", "// split surrogate second half, drop it\n", "offset += len2;\n", "len -= len2;\n", "}\n", "}\n"], "faulty_lines": [6, 10, 12, 14, 17], "cluster": 2}, {"pid": "JacksonCore", "bid": 18, "method_path": "./dataset/JacksonCore/18/GeneratorBase.java", "method": ["protected String _asString(BigDecimal value) throws IOException {\n", "// 24-Aug-2016, tatu: [core#315] prevent possible DoS vector\n", "return value.toString();\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "JacksonCore", "bid": 18, "method_path": "./dataset/JacksonCore/18/UTF8JsonGenerator.java", "method": ["public void writeNumber(BigDecimal value) throws IOException\n", "{\n", "// Don't really know max length for big decimal, no point checking\n", "_verifyValueWrite(WRITE_NUMBER);\n", "if (value == null) {\n", "_writeNull();\n", "} else  if (_cfgNumbersAsStrings) {\n", "String raw = Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features) ? value.toPlainString() : value.toString();\n", "_writeQuotedRaw(raw);\n", "} else if (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features)) {\n", "writeRaw(value.toPlainString());\n", "} else {\n", "writeRaw(_asString(value));\n", "}\n", "}\n"], "faulty_lines": [8, 9, 10, 11], "cluster": 2}, {"pid": "JacksonCore", "bid": 18, "method_path": "./dataset/JacksonCore/18/WriterBasedJsonGenerator.java", "method": ["public void writeNumber(BigDecimal value) throws IOException\n", "{\n", "// Don't really know max length for big decimal, no point checking\n", "_verifyValueWrite(WRITE_NUMBER);\n", "if (value == null) {\n", "_writeNull();\n", "} else  if (_cfgNumbersAsStrings) {\n", "String raw = isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN) ? value.toPlainString() : value.toString();\n", "_writeQuotedRaw(raw);\n", "} else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n", "writeRaw(value.toPlainString());\n", "} else {\n", "writeRaw(_asString(value));\n", "}\n", "}\n"], "faulty_lines": [8, 9, 10, 11], "cluster": 2}, {"pid": "JacksonCore", "bid": 20, "method_path": "./dataset/JacksonCore/20/JsonGenerator.java", "method": ["public void writeEmbeddedObject(Object object) throws IOException {\n", "// 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n", "throw new JsonGenerationException(\"No native support for writing embedded objects\",\n", "this);\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "JacksonCore", "bid": 23, "method_path": "./dataset/JacksonCore/23/DefaultPrettyPrinter.java", "method": ["public DefaultPrettyPrinter createInstance() {\n", "return new DefaultPrettyPrinter(this);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "JacksonCore", "bid": 24, "method_path": "./dataset/JacksonCore/24/ParserBase.java", "method": ["protected void _reportTooLongIntegral(int expType, String rawNum) throws IOException\n", "{\n", "final String numDesc = _longIntegerDesc(rawNum);\n", "_reportError(\"Numeric value (%s) out of range of %s\", numDesc,\n", "(expType == NR_LONG) ? \"long\" : \"int\");\n", "}\n"], "faulty_lines": [3, 4, 5], "cluster": 4}, {"pid": "JacksonCore", "bid": 24, "method_path": "./dataset/JacksonCore/24/ParserBase.java", "method": ["protected void convertNumberToInt() throws IOException\n", "{\n", "// First, converting from long ought to be easy\n", "if ((_numTypesValid & NR_LONG) != 0) {\n", "// Let's verify it's lossless conversion by simple roundtrip\n", "int result = (int) _numberLong;\n", "if (((long) result) != _numberLong) {\n", "_reportError(\"Numeric value (\"+getText()+\") out of range of int\");\n", "}\n", "_numberInt = result;\n", "} else if ((_numTypesValid & NR_BIGINT) != 0) {\n", "if (BI_MIN_INT.compareTo(_numberBigInt) > 0\n", "|| BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n", "reportOverflowInt();\n", "}\n", "_numberInt = _numberBigInt.intValue();\n", "} else if ((_numTypesValid & NR_DOUBLE) != 0) {\n", "// Need to check boundaries\n", "if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n", "reportOverflowInt();\n", "}\n", "_numberInt = (int) _numberDouble;\n", "} else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n", "if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0\n", "|| BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n", "reportOverflowInt();\n", "}\n", "_numberInt = _numberBigDecimal.intValue();\n", "} else {\n", "_throwInternal();\n", "}\n", "_numTypesValid |= NR_INT;\n", "}\n"], "faulty_lines": [8], "cluster": 1}, {"pid": "JacksonCore", "bid": 25, "method_path": "./dataset/JacksonCore/25/ReaderBasedJsonParser.java", "method": ["private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n", "{\n", "_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n", "char[] outBuf = _textBuffer.getCurrentSegment();\n", "int outPtr = _textBuffer.getCurrentSegmentSize();\n", "final int maxCode = codes.length;\n", "\n", "while (true) {\n", "if (_inputPtr >= _inputEnd) {\n", "if (!_loadMore()) { // acceptable for now (will error out later)\n", "break;\n", "}\n", "}\n", "char c = _inputBuffer[_inputPtr];\n", "int i = (int) c;\n", "if (i <= maxCode) {\n", "if (codes[i] != 0) {\n", "break;\n", "}\n", "} else if (!Character.isJavaIdentifierPart(c)) {\n", "break;\n", "}\n", "++_inputPtr;\n", "hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n", "// Ok, let's add char to output:\n", "outBuf[outPtr++] = c;\n", "\n", "// Need more room?\n", "if (outPtr >= outBuf.length) {\n", "outBuf = _textBuffer.finishCurrentSegment();\n", "outPtr = 0;\n", "}\n", "}\n", "_textBuffer.setCurrentLength(outPtr);\n", "{\n", "TextBuffer tb = _textBuffer;\n", "char[] buf = tb.getTextBuffer();\n", "int start = tb.getTextOffset();\n", "int len = tb.size();\n", "\n", "return _symbols.findSymbol(buf, start, len, hash);\n", "}\n", "}\n"], "faulty_lines": [16], "cluster": 5}, {"pid": "JacksonCore", "bid": 26, "method_path": "./dataset/JacksonCore/26/NonBlockingJsonParser.java", "method": ["public void feedInput(byte[] buf, int start, int end) throws IOException\n", "{\n", "// Must not have remaining input\n", "if (_inputPtr < _inputEnd) {\n", "_reportError(\"Still have %d undecoded bytes, should not call 'feedInput'\", _inputEnd - _inputPtr);\n", "}\n", "if (end < start) {\n", "_reportError(\"Input end (%d) may not be before start (%d)\", end, start);\n", "}\n", "// and shouldn't have been marked as end-of-input\n", "if (_endOfInput) {\n", "_reportError(\"Already closed, can not feed more input\");\n", "}\n", "// Time to update pointers first\n", "_currInputProcessed += _origBufferLen;\n", "\n", "// Also need to adjust row start, to work as if it extended into the past wrt new buffer\n", "_currInputRowStart = start - (_inputEnd - _currInputRowStart);\n", "\n", "// And then update buffer settings\n", "_inputBuffer = buf;\n", "_inputPtr = start;\n", "_inputEnd = end;\n", "_origBufferLen = end - start;\n", "}\n"], "faulty_lines": [21], "cluster": 8}, {"pid": "Math", "bid": 1, "method_path": "./dataset/Math/1/BigFraction.java", "method": ["boolean stop = false;\n", "do {\n", "++n;\n", "final double r1 = 1.0 / (r0 - a0);\n", "final long a1 = (long) FastMath.floor(r1);\n", "p2 = (a1 * p1) + p0;\n", "q2 = (a1 * q1) + q0;\n", "if ((p2 > overflow) || (q2 > overflow)) {\n", "// in maxDenominator mode, if the last fraction was very close to the actual value\n", "// q2 may overflow in the next iteration; in this case return the last one.\n", "throw new FractionConversionException(value, p2, q2);\n", "}\n", "\n", "final double convergent = (double) p2 / (double) q2;\n", "if ((n < maxIterations) &&\n", "(FastMath.abs(convergent - value) > epsilon) &&\n", "(q2 < maxDenominator)) {\n", "p0 = p1;\n", "p1 = p2;\n", "q0 = q1;\n", "q1 = q2;\n", "a0 = a1;\n", "r0 = r1;\n", "} else {\n", "stop = true;\n", "}\n", "} while (!stop);\n"], "faulty_lines": [11], "cluster": 8}, {"pid": "Math", "bid": 1, "method_path": "./dataset/Math/1/Fraction.java", "method": ["boolean stop = false;\n", "do {\n", "++n;\n", "double r1 = 1.0 / (r0 - a0);\n", "long a1 = (long)FastMath.floor(r1);\n", "p2 = (a1 * p1) + p0;\n", "q2 = (a1 * q1) + q0;\n", "\n", "if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n", "// in maxDenominator mode, if the last fraction was very close to the actual value\n", "// q2 may overflow in the next iteration; in this case return the last one.\n", "throw new FractionConversionException(value, p2, q2);\n", "}\n", "\n", "double convergent = (double)p2 / (double)q2;\n", "if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n", "p0 = p1;\n", "p1 = p2;\n", "q0 = q1;\n", "q1 = q2;\n", "a0 = a1;\n", "r0 = r1;\n", "} else {\n", "stop = true;\n", "}\n", "} while (!stop);\n"], "faulty_lines": [12], "cluster": 8}, {"pid": "Math", "bid": 2, "method_path": "./dataset/Math/2/HypergeometricDistribution.java", "method": ["public double getNumericalMean() {\n", "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Math", "bid": 3, "method_path": "./dataset/Math/3/MathArrays.java", "method": ["public static double linearCombination(final double[] a, final double[] b)\n", "throws DimensionMismatchException {\n", "final int len = a.length;\n", "if (len != b.length) {\n", "throw new DimensionMismatchException(len, b.length);\n", "}\n", "\n", "// Revert to scalar multiplication.\n", "\n", "final double[] prodHigh = new double[len];\n", "double prodLowSum = 0;\n", "\n", "for (int i = 0; i < len; i++) {\n", "final double ai = a[i];\n", "final double ca = SPLIT_FACTOR * ai;\n", "final double aHigh = ca - (ca - ai);\n", "final double aLow = ai - aHigh;\n", "\n", "final double bi = b[i];\n", "final double cb = SPLIT_FACTOR * bi;\n", "final double bHigh = cb - (cb - bi);\n", "final double bLow = bi - bHigh;\n", "prodHigh[i] = ai * bi;\n", "final double prodLow = aLow * bLow - (((prodHigh[i] -\n", "aHigh * bHigh) -\n", "aLow * bHigh) -\n", "aHigh * bLow);\n", "prodLowSum += prodLow;\n", "}\n", "\n", "\n", "final double prodHighCur = prodHigh[0];\n", "double prodHighNext = prodHigh[1];\n", "double sHighPrev = prodHighCur + prodHighNext;\n", "double sPrime = sHighPrev - prodHighNext;\n", "double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n", "\n", "final int lenMinusOne = len - 1;\n", "for (int i = 1; i < lenMinusOne; i++) {\n", "prodHighNext = prodHigh[i + 1];\n", "final double sHighCur = sHighPrev + prodHighNext;\n", "sPrime = sHighCur - prodHighNext;\n", "sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n", "sHighPrev = sHighCur;\n", "}\n", "\n", "double result = sHighPrev + (prodLowSum + sLowSum);\n", "\n", "if (Double.isNaN(result)) {\n", "// either we have split infinite numbers or some coefficients were NaNs,\n", "// just rely on the naive implementation and let IEEE754 handle this\n", "result = 0;\n", "for (int i = 0; i < len; ++i) {\n", "result += a[i] * b[i];\n", "}\n", "}\n", "\n", "return result;\n", "}\n"], "faulty_lines": [8, 9], "cluster": 9}, {"pid": "Math", "bid": 4, "method_path": "./dataset/Math/4/SubLine.java", "method": ["public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n", "\n", "// retrieve the underlying lines\n", "Line line1 = (Line) getHyperplane();\n", "Line line2 = (Line) subLine.getHyperplane();\n", "\n", "// compute the intersection on infinite line\n", "Vector2D v2D = line1.intersection(line2);\n", "\n", "// check location of point with respect to first sub-line\n", "Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n", "\n", "// check location of point with respect to second sub-line\n", "Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n", "\n", "if (includeEndPoints) {\n", "return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n", "} else {\n", "return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n", "}\n", "\n", "}\n"], "faulty_lines": [5], "cluster": 8}, {"pid": "Math", "bid": 4, "method_path": "./dataset/Math/4/SubLine.java", "method": ["public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n", "\n", "// retrieve the underlying lines\n", "Line line1 = (Line) getHyperplane();\n", "Line line2 = (Line) subLine.getHyperplane();\n", "\n", "// compute the intersection on infinite line\n", "Vector2D v2D = line1.intersection(line2);\n", "\n", "// check location of point with respect to first sub-line\n", "Location loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n", "\n", "// check location of point with respect to second sub-line\n", "Location loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n", "\n", "if (includeEndPoints) {\n", "return ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n", "} else {\n", "return ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n", "}\n", "\n", "}\n"], "faulty_lines": [9], "cluster": 8}, {"pid": "Math", "bid": 5, "method_path": "./dataset/Math/5/Complex.java", "method": ["public Complex reciprocal() {\n", "if (isNaN) {\n", "return NaN;\n", "}\n", "\n", "if (real == 0.0 && imaginary == 0.0) {\n", "return NaN;\n", "}\n", "\n", "if (isInfinite) {\n", "return ZERO;\n", "}\n", "\n", "if (FastMath.abs(real) < FastMath.abs(imaginary)) {\n", "double q = real / imaginary;\n", "double scale = 1. / (real * q + imaginary);\n", "return createComplex(scale * q, -scale);\n", "} else {\n", "double q = imaginary / real;\n", "double scale = 1. / (imaginary * q + real);\n", "return createComplex(scale, -scale * q);\n", "}\n", "}\n"], "faulty_lines": [7], "cluster": 2}, {"pid": "Math", "bid": 6, "method_path": "./dataset/Math/6/BaseOptimizer.java", "method": ["protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n", "this.checker = checker;\n", "\n", "evaluations = new Incrementor(0, new MaxEvalCallback());\n", "iterations = new Incrementor(0, new MaxIterCallback());\n", "}\n"], "faulty_lines": [5], "cluster": 0}, {"pid": "Math", "bid": 6, "method_path": "./dataset/Math/6/NonLinearConjugateGradientOptimizer.java", "method": ["protected PointValuePair doOptimize() {\n", "final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n", "final double[] point = getStartPoint();\n", "final GoalType goal = getGoalType();\n", "final int n = point.length;\n", "double[] r = computeObjectiveGradient(point);\n", "if (goal == GoalType.MINIMIZE) {\n", "for (int i = 0; i < n; i++) {\n", "r[i] = -r[i];\n", "}\n", "}\n", "\n", "// Initial search direction.\n", "double[] steepestDescent = preconditioner.precondition(point, r);\n", "double[] searchDirection = steepestDescent.clone();\n", "\n", "double delta = 0;\n", "for (int i = 0; i < n; ++i) {\n", "delta += r[i] * searchDirection[i];\n", "}\n", "\n", "PointValuePair current = null;\n", "int iter = 0;\n", "int maxEval = getMaxEvaluations();\n", "while (true) {\n", "++iter;\n", "\n", "final double objective = computeObjectiveValue(point);\n", "PointValuePair previous = current;\n", "current = new PointValuePair(point, objective);\n", "if (previous != null) {\n", "if (checker.converged(iter, previous, current)) {\n", "// We have found an optimum.\n", "return current;\n", "}\n", "}\n", "\n", "// Find the optimal step in the search direction.\n", "final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\n", "final double uB = findUpperBound(lsf, 0, initialStep);\n", "// XXX Last parameters is set to a value close to zero in order to\n", "// work around the divergence problem in the \"testCircleFitting\"\n", "// unit test (see MATH-439).\n", "final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\n", "maxEval -= solver.getEvaluations(); // Subtract used up evaluations.\n", "\n", "// Validate new point.\n", "for (int i = 0; i < point.length; ++i) {\n", "point[i] += step * searchDirection[i];\n", "}\n", "\n", "r = computeObjectiveGradient(point);\n", "if (goal == GoalType.MINIMIZE) {\n", "for (int i = 0; i < n; ++i) {\n", "r[i] = -r[i];\n", "}\n", "}\n", "\n", "// Compute beta.\n", "final double deltaOld = delta;\n", "final double[] newSteepestDescent = preconditioner.precondition(point, r);\n", "delta = 0;\n", "for (int i = 0; i < n; ++i) {\n", "delta += r[i] * newSteepestDescent[i];\n", "}\n", "\n", "final double beta;\n", "switch (updateFormula) {\n", "case FLETCHER_REEVES:\n", "beta = delta / deltaOld;\n", "break;\n", "case POLAK_RIBIERE:\n", "double deltaMid = 0;\n", "for (int i = 0; i < r.length; ++i) {\n", "deltaMid += r[i] * steepestDescent[i];\n", "}\n", "beta = (delta - deltaMid) / deltaOld;\n", "break;\n", "default:\n", "// Should never happen.\n", "throw new MathInternalError();\n", "}\n", "steepestDescent = newSteepestDescent;\n", "\n", "// Compute conjugate search direction.\n", "if (iter % n == 0 ||\n", "beta < 0) {\n", "// Break conjugation: reset search direction.\n", "searchDirection = steepestDescent.clone();\n", "} else {\n", "// Compute new conjugate search direction.\n", "for (int i = 0; i < n; ++i) {\n", "searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [23, 26, 32], "cluster": 9}, {"pid": "Math", "bid": 6, "method_path": "./dataset/Math/6/NonLinearConjugateGradientOptimizer.java", "method": ["protected PointValuePair doOptimize() {\n", "final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n", "final double[] point = getStartPoint();\n", "final GoalType goal = getGoalType();\n", "final int n = point.length;\n", "double[] r = computeObjectiveGradient(point);\n", "if (goal == GoalType.MINIMIZE) {\n", "for (int i = 0; i < n; i++) {\n", "r[i] = -r[i];\n", "}\n", "}\n", "\n", "// Initial search direction.\n", "double[] steepestDescent = preconditioner.precondition(point, r);\n", "double[] searchDirection = steepestDescent.clone();\n", "\n", "double delta = 0;\n", "for (int i = 0; i < n; ++i) {\n", "delta += r[i] * searchDirection[i];\n", "}\n", "\n", "PointValuePair current = null;\n", "int iter = 0;\n", "int maxEval = getMaxEvaluations();\n", "while (true) {\n", "++iter;\n", "\n", "final double objective = computeObjectiveValue(point);\n", "PointValuePair previous = current;\n", "current = new PointValuePair(point, objective);\n", "if (previous != null) {\n", "if (checker.converged(iter, previous, current)) {\n", "// We have found an optimum.\n", "return current;\n", "}\n", "}\n", "\n", "// Find the optimal step in the search direction.\n", "final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\n", "final double uB = findUpperBound(lsf, 0, initialStep);\n", "// XXX Last parameters is set to a value close to zero in order to\n", "// work around the divergence problem in the \"testCircleFitting\"\n", "// unit test (see MATH-439).\n", "final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\n", "maxEval -= solver.getEvaluations(); // Subtract used up evaluations.\n", "\n", "// Validate new point.\n", "for (int i = 0; i < point.length; ++i) {\n", "point[i] += step * searchDirection[i];\n", "}\n", "\n", "r = computeObjectiveGradient(point);\n", "if (goal == GoalType.MINIMIZE) {\n", "for (int i = 0; i < n; ++i) {\n", "r[i] = -r[i];\n", "}\n", "}\n", "\n", "// Compute beta.\n", "final double deltaOld = delta;\n", "final double[] newSteepestDescent = preconditioner.precondition(point, r);\n", "delta = 0;\n", "for (int i = 0; i < n; ++i) {\n", "delta += r[i] * newSteepestDescent[i];\n", "}\n", "\n", "final double beta;\n", "switch (updateFormula) {\n", "case FLETCHER_REEVES:\n", "beta = delta / deltaOld;\n", "break;\n", "case POLAK_RIBIERE:\n", "double deltaMid = 0;\n", "for (int i = 0; i < r.length; ++i) {\n", "deltaMid += r[i] * steepestDescent[i];\n", "}\n", "beta = (delta - deltaMid) / deltaOld;\n", "break;\n", "default:\n", "// Should never happen.\n", "throw new MathInternalError();\n", "}\n", "steepestDescent = newSteepestDescent;\n", "\n", "// Compute conjugate search direction.\n", "if (iter % n == 0 ||\n", "beta < 0) {\n", "// Break conjugation: reset search direction.\n", "searchDirection = steepestDescent.clone();\n", "} else {\n", "// Compute new conjugate search direction.\n", "for (int i = 0; i < n; ++i) {\n", "searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [86], "cluster": 9}, {"pid": "Math", "bid": 6, "method_path": "./dataset/Math/6/CMAESOptimizer.java", "method": ["protected PointValuePair doOptimize() {\n", "// -------------------- Initialization --------------------------------\n", "isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n", "final FitnessFunction fitfun = new FitnessFunction();\n", "final double[] guess = getStartPoint();\n", "// number of objective variables/problem dimension\n", "dimension = guess.length;\n", "initializeCMA(guess);\n", "iterations = 0;\n", "double bestValue = fitfun.value(guess);\n", "push(fitnessHistory, bestValue);\n", "PointValuePair optimum\n", "= new PointValuePair(getStartPoint(),\n", "isMinimize ? bestValue : -bestValue);\n", "PointValuePair lastResult = null;\n", "\n", "// -------------------- Generation Loop --------------------------------\n", "\n", "generationLoop:\n", "for (iterations = 1; iterations <= maxIterations; iterations++) {\n", "\n", "// Generate and evaluate lambda offspring\n", "final RealMatrix arz = randn1(dimension, lambda);\n", "final RealMatrix arx = zeros(dimension, lambda);\n", "final double[] fitness = new double[lambda];\n", "// generate random offspring\n", "for (int k = 0; k < lambda; k++) {\n", "RealMatrix arxk = null;\n", "for (int i = 0; i < checkFeasableCount + 1; i++) {\n", "if (diagonalOnly <= 0) {\n", "arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n", ".scalarMultiply(sigma)); // m + sig * Normal(0,C)\n", "} else {\n", "arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n", ".scalarMultiply(sigma));\n", "}\n", "if (i >= checkFeasableCount ||\n", "fitfun.isFeasible(arxk.getColumn(0))) {\n", "break;\n", "}\n", "// regenerate random arguments for row\n", "arz.setColumn(k, randn(dimension));\n", "}\n", "copyColumn(arxk, 0, arx, k);\n", "try {\n", "fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n", "} catch (TooManyEvaluationsException e) {\n", "break generationLoop;\n", "}\n", "}\n", "// Sort by fitness and compute weighted mean into xmean\n", "final int[] arindex = sortedIndices(fitness);\n", "// Calculate new xmean, this is selection and recombination\n", "final RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n", "final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n", "xmean = bestArx.multiply(weights);\n", "final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n", "final RealMatrix zmean = bestArz.multiply(weights);\n", "final boolean hsig = updateEvolutionPaths(zmean, xold);\n", "if (diagonalOnly <= 0) {\n", "updateCovariance(hsig, bestArx, arz, arindex, xold);\n", "} else {\n", "updateCovarianceDiagonalOnly(hsig, bestArz);\n", "}\n", "// Adapt step size sigma - Eq. (5)\n", "sigma *= Math.exp(Math.min(1, (normps/chiN - 1) * cs / damps));\n", "final double bestFitness = fitness[arindex[0]];\n", "final double worstFitness = fitness[arindex[arindex.length - 1]];\n", "if (bestValue > bestFitness) {\n", "bestValue = bestFitness;\n", "lastResult = optimum;\n", "optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)),\n", "isMinimize ? bestFitness : -bestFitness);\n", "if (getConvergenceChecker() != null &&\n", "lastResult != null) {\n", "if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n", "break generationLoop;\n", "}\n", "}\n", "}\n", "// handle termination criteria\n", "// Break, if fitness is good enough\n", "if (stopFitness != 0) { // only if stopFitness is defined\n", "if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n", "break generationLoop;\n", "}\n", "}\n", "final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n", "final double[] pcCol = pc.getColumn(0);\n", "for (int i = 0; i < dimension; i++) {\n", "if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\n", "break;\n", "}\n", "if (i >= dimension - 1) {\n", "break generationLoop;\n", "}\n", "}\n", "for (int i = 0; i < dimension; i++) {\n", "if (sigma * sqrtDiagC[i] > stopTolUpX) {\n", "break generationLoop;\n", "}\n", "}\n", "final double historyBest = min(fitnessHistory);\n", "final double historyWorst = max(fitnessHistory);\n", "if (iterations > 2 &&\n", "Math.max(historyWorst, worstFitness) -\n", "Math.min(historyBest, bestFitness) < stopTolFun) {\n", "break generationLoop;\n", "}\n", "if (iterations > fitnessHistory.length &&\n", "historyWorst - historyBest < stopTolHistFun) {\n", "break generationLoop;\n", "}\n", "// condition number of the covariance matrix exceeds 1e14\n", "if (max(diagD) / min(diagD) > 1e7) {\n", "break generationLoop;\n", "}\n", "// user defined termination\n", "if (getConvergenceChecker() != null) {\n", "final PointValuePair current\n", "= new PointValuePair(bestArx.getColumn(0),\n", "isMinimize ? bestFitness : -bestFitness);\n", "if (lastResult != null &&\n", "getConvergenceChecker().converged(iterations, current, lastResult)) {\n", "break generationLoop;\n", "}\n", "lastResult = current;\n", "}\n", "// Adjust step size in case of equal function values (flat fitness)\n", "if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n", "sigma = sigma * Math.exp(0.2 + cs / damps);\n", "}\n", "if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n", "Math.min(historyBest, bestFitness) == 0) {\n", "sigma = sigma * Math.exp(0.2 + cs / damps);\n", "}\n", "// store best in history\n", "push(fitnessHistory,bestFitness);\n", "fitfun.setValueRange(worstFitness-bestFitness);\n", "if (generateStatistics) {\n", "statisticsSigmaHistory.add(sigma);\n", "statisticsFitnessHistory.add(bestFitness);\n", "statisticsMeanHistory.add(xmean.transpose());\n", "statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n", "}\n", "}\n", "return optimum;\n", "}\n"], "faulty_lines": [21], "cluster": 9}, {"pid": "Math", "bid": 6, "method_path": "./dataset/Math/6/PowellOptimizer.java", "method": ["protected PointValuePair doOptimize() {\n", "checkParameters();\n", "\n", "final GoalType goal = getGoalType();\n", "final double[] guess = getStartPoint();\n", "final int n = guess.length;\n", "\n", "final double[][] direc = new double[n][n];\n", "for (int i = 0; i < n; i++) {\n", "direc[i][i] = 1;\n", "}\n", "\n", "final ConvergenceChecker<PointValuePair> checker\n", "= getConvergenceChecker();\n", "\n", "double[] x = guess;\n", "double fVal = computeObjectiveValue(x);\n", "double[] x1 = x.clone();\n", "int iter = 0;\n", "while (true) {\n", "++iter;\n", "\n", "double fX = fVal;\n", "double fX2 = 0;\n", "double delta = 0;\n", "int bigInd = 0;\n", "double alphaMin = 0;\n", "\n", "for (int i = 0; i < n; i++) {\n", "final double[] d = MathArrays.copyOf(direc[i]);\n", "\n", "fX2 = fVal;\n", "\n", "final UnivariatePointValuePair optimum = line.search(x, d);\n", "fVal = optimum.getValue();\n", "alphaMin = optimum.getPoint();\n", "final double[][] result = newPointAndDirection(x, d, alphaMin);\n", "x = result[0];\n", "\n", "if ((fX2 - fVal) > delta) {\n", "delta = fX2 - fVal;\n", "bigInd = i;\n", "}\n", "}\n", "\n", "// Default convergence check.\n", "boolean stop = 2 * (fX - fVal) <=\n", "(relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) +\n", "absoluteThreshold);\n", "\n", "final PointValuePair previous = new PointValuePair(x1, fX);\n", "final PointValuePair current = new PointValuePair(x, fVal);\n", "if (!stop) { // User-defined stopping criteria.\n", "if (checker != null) {\n", "stop = checker.converged(iter, previous, current);\n", "}\n", "}\n", "if (stop) {\n", "if (goal == GoalType.MINIMIZE) {\n", "return (fVal < fX) ? current : previous;\n", "} else {\n", "return (fVal > fX) ? current : previous;\n", "}\n", "}\n", "\n", "final double[] d = new double[n];\n", "final double[] x2 = new double[n];\n", "for (int i = 0; i < n; i++) {\n", "d[i] = x[i] - x1[i];\n", "x2[i] = 2 * x[i] - x1[i];\n", "}\n", "\n", "x1 = x.clone();\n", "fX2 = computeObjectiveValue(x2);\n", "\n", "if (fX > fX2) {\n", "double t = 2 * (fX + fX2 - 2 * fVal);\n", "double temp = fX - fVal - delta;\n", "t *= temp * temp;\n", "temp = fX - fX2;\n", "t -= delta * temp * temp;\n", "\n", "if (t < 0.0) {\n", "final UnivariatePointValuePair optimum = line.search(x, d);\n", "fVal = optimum.getValue();\n", "alphaMin = optimum.getPoint();\n", "final double[][] result = newPointAndDirection(x, d, alphaMin);\n", "x = result[0];\n", "\n", "final int lastInd = n - 1;\n", "direc[bigInd] = direc[lastInd];\n", "direc[lastInd] = result[1];\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [19, 21], "cluster": 9}, {"pid": "Math", "bid": 6, "method_path": "./dataset/Math/6/GaussNewtonOptimizer.java", "method": ["public PointVectorValuePair doOptimize() {\n", "checkParameters();\n", "\n", "final ConvergenceChecker<PointVectorValuePair> checker\n", "= getConvergenceChecker();\n", "\n", "// Computation will be useless without a checker (see \"for-loop\").\n", "if (checker == null) {\n", "throw new NullArgumentException();\n", "}\n", "\n", "final double[] targetValues = getTarget();\n", "final int nR = targetValues.length; // Number of observed data.\n", "\n", "final RealMatrix weightMatrix = getWeight();\n", "// Diagonal of the weight matrix.\n", "final double[] residualsWeights = new double[nR];\n", "for (int i = 0; i < nR; i++) {\n", "residualsWeights[i] = weightMatrix.getEntry(i, i);\n", "}\n", "\n", "final double[] currentPoint = getStartPoint();\n", "final int nC = currentPoint.length;\n", "\n", "// iterate until convergence is reached\n", "PointVectorValuePair current = null;\n", "int iter = 0;\n", "for (boolean converged = false; !converged;) {\n", "++iter;\n", "\n", "// evaluate the objective function and its jacobian\n", "PointVectorValuePair previous = current;\n", "// Value of the objective function at \"currentPoint\".\n", "final double[] currentObjective = computeObjectiveValue(currentPoint);\n", "final double[] currentResiduals = computeResiduals(currentObjective);\n", "final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n", "current = new PointVectorValuePair(currentPoint, currentObjective);\n", "\n", "// build the linear problem\n", "final double[]   b = new double[nC];\n", "final double[][] a = new double[nC][nC];\n", "for (int i = 0; i < nR; ++i) {\n", "\n", "final double[] grad   = weightedJacobian.getRow(i);\n", "final double weight   = residualsWeights[i];\n", "final double residual = currentResiduals[i];\n", "\n", "// compute the normal equation\n", "final double wr = weight * residual;\n", "for (int j = 0; j < nC; ++j) {\n", "b[j] += wr * grad[j];\n", "}\n", "\n", "// build the contribution matrix for measurement i\n", "for (int k = 0; k < nC; ++k) {\n", "double[] ak = a[k];\n", "double wgk = weight * grad[k];\n", "for (int l = 0; l < nC; ++l) {\n", "ak[l] += wgk * grad[l];\n", "}\n", "}\n", "}\n", "\n", "try {\n", "// solve the linearized least squares problem\n", "RealMatrix mA = new BlockRealMatrix(a);\n", "DecompositionSolver solver = useLU ?\n", "new LUDecomposition(mA).getSolver() :\n", "new QRDecomposition(mA).getSolver();\n", "final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n", "// update the estimated parameters\n", "for (int i = 0; i < nC; ++i) {\n", "currentPoint[i] += dX[i];\n", "}\n", "} catch (SingularMatrixException e) {\n", "throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n", "}\n", "\n", "// Check convergence.\n", "if (previous != null) {\n", "converged = checker.converged(iter, previous, current);\n", "if (converged) {\n", "setCost(computeCost(currentResiduals));\n", "return current;\n", "}\n", "}\n", "}\n", "// Must never happen.\n", "throw new MathInternalError();\n", "}\n"], "faulty_lines": [27, 29], "cluster": 9}, {"pid": "Math", "bid": 6, "method_path": "./dataset/Math/6/GaussNewtonOptimizer.java", "method": ["public PointVectorValuePair doOptimize() {\n", "checkParameters();\n", "\n", "final ConvergenceChecker<PointVectorValuePair> checker\n", "= getConvergenceChecker();\n", "\n", "// Computation will be useless without a checker (see \"for-loop\").\n", "if (checker == null) {\n", "throw new NullArgumentException();\n", "}\n", "\n", "final double[] targetValues = getTarget();\n", "final int nR = targetValues.length; // Number of observed data.\n", "\n", "final RealMatrix weightMatrix = getWeight();\n", "// Diagonal of the weight matrix.\n", "final double[] residualsWeights = new double[nR];\n", "for (int i = 0; i < nR; i++) {\n", "residualsWeights[i] = weightMatrix.getEntry(i, i);\n", "}\n", "\n", "final double[] currentPoint = getStartPoint();\n", "final int nC = currentPoint.length;\n", "\n", "// iterate until convergence is reached\n", "PointVectorValuePair current = null;\n", "int iter = 0;\n", "for (boolean converged = false; !converged;) {\n", "++iter;\n", "\n", "// evaluate the objective function and its jacobian\n", "PointVectorValuePair previous = current;\n", "// Value of the objective function at \"currentPoint\".\n", "final double[] currentObjective = computeObjectiveValue(currentPoint);\n", "final double[] currentResiduals = computeResiduals(currentObjective);\n", "final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n", "current = new PointVectorValuePair(currentPoint, currentObjective);\n", "\n", "// build the linear problem\n", "final double[]   b = new double[nC];\n", "final double[][] a = new double[nC][nC];\n", "for (int i = 0; i < nR; ++i) {\n", "\n", "final double[] grad   = weightedJacobian.getRow(i);\n", "final double weight   = residualsWeights[i];\n", "final double residual = currentResiduals[i];\n", "\n", "// compute the normal equation\n", "final double wr = weight * residual;\n", "for (int j = 0; j < nC; ++j) {\n", "b[j] += wr * grad[j];\n", "}\n", "\n", "// build the contribution matrix for measurement i\n", "for (int k = 0; k < nC; ++k) {\n", "double[] ak = a[k];\n", "double wgk = weight * grad[k];\n", "for (int l = 0; l < nC; ++l) {\n", "ak[l] += wgk * grad[l];\n", "}\n", "}\n", "}\n", "\n", "try {\n", "// solve the linearized least squares problem\n", "RealMatrix mA = new BlockRealMatrix(a);\n", "DecompositionSolver solver = useLU ?\n", "new LUDecomposition(mA).getSolver() :\n", "new QRDecomposition(mA).getSolver();\n", "final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n", "// update the estimated parameters\n", "for (int i = 0; i < nC; ++i) {\n", "currentPoint[i] += dX[i];\n", "}\n", "} catch (SingularMatrixException e) {\n", "throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n", "}\n", "\n", "// Check convergence.\n", "if (previous != null) {\n", "converged = checker.converged(iter, previous, current);\n", "if (converged) {\n", "setCost(computeCost(currentResiduals));\n", "return current;\n", "}\n", "}\n", "}\n", "// Must never happen.\n", "throw new MathInternalError();\n", "}\n"], "faulty_lines": [81], "cluster": 9}, {"pid": "Math", "bid": 6, "method_path": "./dataset/Math/6/LevenbergMarquardtOptimizer.java", "method": ["protected PointVectorValuePair doOptimize() {\n", "checkParameters();\n", "\n", "final int nR = getTarget().length; // Number of observed data.\n", "final double[] currentPoint = getStartPoint();\n", "final int nC = currentPoint.length; // Number of parameters.\n", "\n", "// arrays shared with the other private methods\n", "solvedCols  = FastMath.min(nR, nC);\n", "diagR       = new double[nC];\n", "jacNorm     = new double[nC];\n", "beta        = new double[nC];\n", "permutation = new int[nC];\n", "lmDir       = new double[nC];\n", "\n", "// local point\n", "double   delta   = 0;\n", "double   xNorm   = 0;\n", "double[] diag    = new double[nC];\n", "double[] oldX    = new double[nC];\n", "double[] oldRes  = new double[nR];\n", "double[] oldObj  = new double[nR];\n", "double[] qtf     = new double[nR];\n", "double[] work1   = new double[nC];\n", "double[] work2   = new double[nC];\n", "double[] work3   = new double[nC];\n", "\n", "final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n", "\n", "// Evaluate the function at the starting point and calculate its norm.\n", "double[] currentObjective = computeObjectiveValue(currentPoint);\n", "double[] currentResiduals = computeResiduals(currentObjective);\n", "PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\n", "double currentCost = computeCost(currentResiduals);\n", "\n", "// Outer loop.\n", "lmPar = 0;\n", "boolean firstIteration = true;\n", "int iter = 0;\n", "final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n", "while (true) {\n", "++iter;\n", "final PointVectorValuePair previous = current;\n", "\n", "// QR decomposition of the jacobian matrix\n", "qrDecomposition(computeWeightedJacobian(currentPoint));\n", "\n", "weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n", "for (int i = 0; i < nR; i++) {\n", "qtf[i] = weightedResidual[i];\n", "}\n", "\n", "// compute Qt.res\n", "qTy(qtf);\n", "\n", "// now we don't need Q anymore,\n", "// so let jacobian contain the R matrix with its diagonal elements\n", "for (int k = 0; k < solvedCols; ++k) {\n", "int pk = permutation[k];\n", "weightedJacobian[k][pk] = diagR[pk];\n", "}\n", "\n", "if (firstIteration) {\n", "// scale the point according to the norms of the columns\n", "// of the initial jacobian\n", "xNorm = 0;\n", "for (int k = 0; k < nC; ++k) {\n", "double dk = jacNorm[k];\n", "if (dk == 0) {\n", "dk = 1.0;\n", "}\n", "double xk = dk * currentPoint[k];\n", "xNorm  += xk * xk;\n", "diag[k] = dk;\n", "}\n", "xNorm = FastMath.sqrt(xNorm);\n", "\n", "// initialize the step bound delta\n", "delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n", "}\n", "\n", "// check orthogonality between function vector and jacobian columns\n", "double maxCosine = 0;\n", "if (currentCost != 0) {\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int    pj = permutation[j];\n", "double s  = jacNorm[pj];\n", "if (s != 0) {\n", "double sum = 0;\n", "for (int i = 0; i <= j; ++i) {\n", "sum += weightedJacobian[i][pj] * qtf[i];\n", "}\n", "maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n", "}\n", "}\n", "}\n", "if (maxCosine <= orthoTolerance) {\n", "// Convergence has been reached.\n", "setCost(currentCost);\n", "return current;\n", "}\n", "\n", "// rescale if necessary\n", "for (int j = 0; j < nC; ++j) {\n", "diag[j] = FastMath.max(diag[j], jacNorm[j]);\n", "}\n", "\n", "// Inner loop.\n", "for (double ratio = 0; ratio < 1.0e-4;) {\n", "\n", "// save the state\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "oldX[pj] = currentPoint[pj];\n", "}\n", "final double previousCost = currentCost;\n", "double[] tmpVec = weightedResidual;\n", "weightedResidual = oldRes;\n", "oldRes    = tmpVec;\n", "tmpVec    = currentObjective;\n", "currentObjective = oldObj;\n", "oldObj    = tmpVec;\n", "\n", "// determine the Levenberg-Marquardt parameter\n", "determineLMParameter(qtf, delta, diag, work1, work2, work3);\n", "\n", "// compute the new point and the norm of the evolution direction\n", "double lmNorm = 0;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "lmDir[pj] = -lmDir[pj];\n", "currentPoint[pj] = oldX[pj] + lmDir[pj];\n", "double s = diag[pj] * lmDir[pj];\n", "lmNorm  += s * s;\n", "}\n", "lmNorm = FastMath.sqrt(lmNorm);\n", "// on the first iteration, adjust the initial step bound.\n", "if (firstIteration) {\n", "delta = FastMath.min(delta, lmNorm);\n", "}\n", "\n", "// Evaluate the function at x + p and calculate its norm.\n", "currentObjective = computeObjectiveValue(currentPoint);\n", "currentResiduals = computeResiduals(currentObjective);\n", "current = new PointVectorValuePair(currentPoint, currentObjective);\n", "currentCost = computeCost(currentResiduals);\n", "\n", "// compute the scaled actual reduction\n", "double actRed = -1.0;\n", "if (0.1 * currentCost < previousCost) {\n", "double r = currentCost / previousCost;\n", "actRed = 1.0 - r * r;\n", "}\n", "\n", "// compute the scaled predicted reduction\n", "// and the scaled directional derivative\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "double dirJ = lmDir[pj];\n", "work1[j] = 0;\n", "for (int i = 0; i <= j; ++i) {\n", "work1[i] += weightedJacobian[i][pj] * dirJ;\n", "}\n", "}\n", "double coeff1 = 0;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "coeff1 += work1[j] * work1[j];\n", "}\n", "double pc2 = previousCost * previousCost;\n", "coeff1 = coeff1 / pc2;\n", "double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n", "double preRed = coeff1 + 2 * coeff2;\n", "double dirDer = -(coeff1 + coeff2);\n", "\n", "// ratio of the actual to the predicted reduction\n", "ratio = (preRed == 0) ? 0 : (actRed / preRed);\n", "\n", "// update the step bound\n", "if (ratio <= 0.25) {\n", "double tmp =\n", "(actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n", "if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\n", "tmp = 0.1;\n", "}\n", "delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n", "lmPar /= tmp;\n", "} else if ((lmPar == 0) || (ratio >= 0.75)) {\n", "delta = 2 * lmNorm;\n", "lmPar *= 0.5;\n", "}\n", "\n", "// test for successful iteration.\n", "if (ratio >= 1.0e-4) {\n", "// successful iteration, update the norm\n", "firstIteration = false;\n", "xNorm = 0;\n", "for (int k = 0; k < nC; ++k) {\n", "double xK = diag[k] * currentPoint[k];\n", "xNorm += xK * xK;\n", "}\n", "xNorm = FastMath.sqrt(xNorm);\n", "\n", "// tests for convergence.\n", "if (checker != null) {\n", "// we use the vectorial convergence checker\n", "if (checker.converged(iter, previous, current)) {\n", "setCost(currentCost);\n", "return current;\n", "}\n", "}\n", "} else {\n", "// failed iteration, reset the previous values\n", "currentCost = previousCost;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "currentPoint[pj] = oldX[pj];\n", "}\n", "tmpVec    = weightedResidual;\n", "weightedResidual = oldRes;\n", "oldRes    = tmpVec;\n", "tmpVec    = currentObjective;\n", "currentObjective = oldObj;\n", "oldObj    = tmpVec;\n", "// Reset \"current\" to previous values.\n", "current = new PointVectorValuePair(currentPoint, currentObjective);\n", "}\n", "\n", "// Default convergence criteria.\n", "if ((FastMath.abs(actRed) <= costRelativeTolerance &&\n", "preRed <= costRelativeTolerance &&\n", "ratio <= 2.0) ||\n", "delta <= parRelativeTolerance * xNorm) {\n", "setCost(currentCost);\n", "return current;\n", "}\n", "\n", "// tests for termination and stringent tolerances\n", "// (2.2204e-16 is the machine epsilon for IEEE754)\n", "if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n", "throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n", "costRelativeTolerance);\n", "} else if (delta <= 2.2204e-16 * xNorm) {\n", "throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n", "parRelativeTolerance);\n", "} else if (maxCosine <= 2.2204e-16)  {\n", "throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n", "orthoTolerance);\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [39, 42], "cluster": 9}, {"pid": "Math", "bid": 8, "method_path": "./dataset/Math/8/DiscreteDistribution.java", "method": ["public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n", "if (sampleSize <= 0) {\n", "throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n", "sampleSize);\n", "}\n", "\n", "final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n", "\n", "for (int i = 0; i < sampleSize; i++) {\n", "out[i] = sample();\n", "}\n", "\n", "return out;\n", "\n", "}\n"], "faulty_lines": [1, 7], "cluster": 4}, {"pid": "Math", "bid": 9, "method_path": "./dataset/Math/9/Line.java", "method": ["public Line revert() {\n", "final Line reverted = new Line(zero, zero.subtract(direction));\n", "return reverted;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Math", "bid": 10, "method_path": "./dataset/Math/10/DSCompiler.java", "method": ["public void atan2(final double[] y, final int yOffset,\n", "final double[] x, final int xOffset,\n", "final double[] result, final int resultOffset) {\n", "\n", "// compute r = sqrt(x^2+y^2)\n", "double[] tmp1 = new double[getSize()];\n", "multiply(x, xOffset, x, xOffset, tmp1, 0);      // x^2\n", "double[] tmp2 = new double[getSize()];\n", "multiply(y, yOffset, y, yOffset, tmp2, 0);      // y^2\n", "add(tmp1, 0, tmp2, 0, tmp2, 0);                 // x^2 + y^2\n", "rootN(tmp2, 0, 2, tmp1, 0);                     // r = sqrt(x^2 + y^2)\n", "\n", "if (x[xOffset] >= 0) {\n", "\n", "// compute atan2(y, x) = 2 atan(y / (r + x))\n", "add(tmp1, 0, x, xOffset, tmp2, 0);          // r + x\n", "divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r + x)\n", "atan(tmp1, 0, tmp2, 0);                     // atan(y / (r + x))\n", "for (int i = 0; i < tmp2.length; ++i) {\n", "result[resultOffset + i] = 2 * tmp2[i]; // 2 * atan(y / (r + x))\n", "}\n", "\n", "} else {\n", "\n", "// compute atan2(y, x) = +/- pi - 2 atan(y / (r - x))\n", "subtract(tmp1, 0, x, xOffset, tmp2, 0);     // r - x\n", "divide(y, yOffset, tmp2, 0, tmp1, 0);       // y /(r - x)\n", "atan(tmp1, 0, tmp2, 0);                     // atan(y / (r - x))\n", "result[resultOffset] =\n", "((tmp2[0] <= 0) ? -FastMath.PI : FastMath.PI) - 2 * tmp2[0]; // +/-pi - 2 * atan(y / (r - x))\n", "for (int i = 1; i < tmp2.length; ++i) {\n", "result[resultOffset + i] = -2 * tmp2[i]; // +/-pi - 2 * atan(y / (r - x))\n", "}\n", "\n", "}\n", "\n", "// fix value to take special cases (+0/+0, +0/-0, -0/+0, -0/-0, +/-infinity) correctly\n", "\n", "}\n"], "faulty_lines": [38], "cluster": 9}, {"pid": "Math", "bid": 11, "method_path": "./dataset/Math/11/MultivariateNormalDistribution.java", "method": ["public double density(final double[] vals) throws DimensionMismatchException {\n", "final int dim = getDimension();\n", "if (vals.length != dim) {\n", "throw new DimensionMismatchException(vals.length, dim);\n", "}\n", "\n", "return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n", "FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n", "getExponentTerm(vals);\n", "}\n"], "faulty_lines": [7], "cluster": 4}, {"pid": "Math", "bid": 13, "method_path": "./dataset/Math/13/AbstractLeastSquaresOptimizer.java", "method": ["private RealMatrix squareRoot(RealMatrix m) {\n", "final EigenDecomposition dec = new EigenDecomposition(m);\n", "return dec.getSquareRoot();\n", "}\n"], "faulty_lines": [2, 4], "cluster": 0}, {"pid": "Math", "bid": 14, "method_path": "./dataset/Math/14/Weight.java", "method": ["public Weight(double[] weight) {\n", "final int dim = weight.length;\n", "weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n", "for (int i = 0; i < dim; i++) {\n", "weightMatrix.setEntry(i, i, weight[i]);\n", "}\n", "}\n"], "faulty_lines": [3, 4, 5, 6], "cluster": 4}, {"pid": "Math", "bid": 14, "method_path": "./dataset/Math/14/AbstractLeastSquaresOptimizer.java", "method": ["private RealMatrix squareRoot(RealMatrix m) {\n", "final EigenDecomposition dec = new EigenDecomposition(m);\n", "return dec.getSquareRoot();\n", "}\n"], "faulty_lines": [2, 4], "cluster": 0}, {"pid": "Math", "bid": 15, "method_path": "./dataset/Math/15/FastMath.java", "method": ["public static double pow(double x, double y) {\n", "final double lns[] = new double[2];\n", "\n", "if (y == 0.0) {\n", "return 1.0;\n", "}\n", "\n", "if (x != x) { // X is NaN\n", "return x;\n", "}\n", "\n", "\n", "if (x == 0) {\n", "long bits = Double.doubleToLongBits(x);\n", "if ((bits & 0x8000000000000000L) != 0) {\n", "// -zero\n", "long yi = (long) y;\n", "\n", "if (y < 0 && y == yi && (yi & 1) == 1) {\n", "return Double.NEGATIVE_INFINITY;\n", "}\n", "\n", "if (y > 0 && y == yi && (yi & 1) == 1) {\n", "return -0.0;\n", "}\n", "}\n", "\n", "if (y < 0) {\n", "return Double.POSITIVE_INFINITY;\n", "}\n", "if (y > 0) {\n", "return 0.0;\n", "}\n", "\n", "return Double.NaN;\n", "}\n", "\n", "if (x == Double.POSITIVE_INFINITY) {\n", "if (y != y) { // y is NaN\n", "return y;\n", "}\n", "if (y < 0.0) {\n", "return 0.0;\n", "} else {\n", "return Double.POSITIVE_INFINITY;\n", "}\n", "}\n", "\n", "if (y == Double.POSITIVE_INFINITY) {\n", "if (x * x == 1.0) {\n", "return Double.NaN;\n", "}\n", "\n", "if (x * x > 1.0) {\n", "return Double.POSITIVE_INFINITY;\n", "} else {\n", "return 0.0;\n", "}\n", "}\n", "\n", "if (x == Double.NEGATIVE_INFINITY) {\n", "if (y != y) { // y is NaN\n", "return y;\n", "}\n", "\n", "if (y < 0) {\n", "long yi = (long) y;\n", "if (y == yi && (yi & 1) == 1) {\n", "return -0.0;\n", "}\n", "\n", "return 0.0;\n", "}\n", "\n", "if (y > 0)  {\n", "long yi = (long) y;\n", "if (y == yi && (yi & 1) == 1) {\n", "return Double.NEGATIVE_INFINITY;\n", "}\n", "\n", "return Double.POSITIVE_INFINITY;\n", "}\n", "}\n", "\n", "if (y == Double.NEGATIVE_INFINITY) {\n", "\n", "if (x * x == 1.0) {\n", "return Double.NaN;\n", "}\n", "\n", "if (x * x < 1.0) {\n", "return Double.POSITIVE_INFINITY;\n", "} else {\n", "return 0.0;\n", "}\n", "}\n", "\n", "/* Handle special case x<0 */\n", "if (x < 0) {\n", "// y is an even integer in this case\n", "if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n", "return pow(-x, y);\n", "}\n", "\n", "if (y == (long) y) {\n", "// If y is an integer\n", "return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n", "} else {\n", "return Double.NaN;\n", "}\n", "}\n", "\n", "/* Split y into ya and yb such that y = ya+yb */\n", "double ya;\n", "double yb;\n", "if (y < 8e298 && y > -8e298) {\n", "double tmp1 = y * HEX_40000000;\n", "ya = y + tmp1 - tmp1;\n", "yb = y - ya;\n", "} else {\n", "double tmp1 = y * 9.31322574615478515625E-10;\n", "double tmp2 = tmp1 * 9.31322574615478515625E-10;\n", "ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n", "yb = y - ya;\n", "}\n", "\n", "/* Compute ln(x) */\n", "final double lores = log(x, lns);\n", "if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n", "return lores;\n", "}\n", "\n", "double lna = lns[0];\n", "double lnb = lns[1];\n", "\n", "/* resplit lns */\n", "double tmp1 = lna * HEX_40000000;\n", "double tmp2 = lna + tmp1 - tmp1;\n", "lnb += lna - tmp2;\n", "lna = tmp2;\n", "\n", "// y*ln(x) = (aa+ab)\n", "final double aa = lna * ya;\n", "final double ab = lna * yb + lnb * ya + lnb * yb;\n", "\n", "lna = aa+ab;\n", "lnb = -(lna - aa - ab);\n", "\n", "double z = 1.0 / 120.0;\n", "z = z * lnb + (1.0 / 24.0);\n", "z = z * lnb + (1.0 / 6.0);\n", "z = z * lnb + 0.5;\n", "z = z * lnb + 1.0;\n", "z = z * lnb;\n", "\n", "final double result = exp(lna, z, null);\n", "//result = result + result * z;\n", "return result;\n", "}\n"], "faulty_lines": [101], "cluster": 9}, {"pid": "Math", "bid": 16, "method_path": "./dataset/Math/16/FastMath.java", "method": ["public class FastMath {\n", "/** StrictMath.log(Double.MAX_VALUE): {@value} */\n", "\n", "/** Archimede's constant PI, ratio of circle circumference to diameter. */\n", "public static final double PI = 105414357.0 / 33554432.0 + 1.984187159361080883e-9;\n", "\n", "/** Napier's constant e, base of the natural logarithm. */\n", "public static final double E = 2850325.0 / 1048576.0 + 8.254840070411028747e-8;\n", "\n", "/** Index of exp(0) in the array of integer exponentials. */\n", "static final int EXP_INT_TABLE_MAX_INDEX = 750;\n", "/** Length of the array of integer exponentials. */\n", "static final int EXP_INT_TABLE_LEN = EXP_INT_TABLE_MAX_INDEX * 2;\n", "/** Logarithm table length. */\n", "static final int LN_MANT_LEN = 1024;\n", "/** Exponential fractions table length. */\n", "static final int EXP_FRAC_TABLE_LEN = 1025; // 0, 1/1024, ... 1024/1024\n", "\n", "/** Indicator for tables initialization.\n", "* <p>\n", "* This compile-time constant should be set to true only if one explicitly\n", "* wants to compute the tables at class loading time instead of using the\n", "* already computed ones provided as literal arrays below.\n", "* </p>\n", "*/\n", "private static final boolean RECOMPUTE_TABLES_AT_RUNTIME = false;\n", "\n", "/** log(2) (high bits). */\n", "private static final double LN_2_A = 0.693147063255310059;\n", "\n", "/** log(2) (low bits). */\n", "private static final double LN_2_B = 1.17304635250823482e-7;\n", "\n", "/** Coefficients for log, when input 0.99 < x < 1.01. */\n", "private static final double LN_QUICK_COEF[][] = {\n", "{1.0, 5.669184079525E-24},\n", "{-0.25, -0.25},\n", "{0.3333333134651184, 1.986821492305628E-8},\n", "{-0.25, -6.663542893624021E-14},\n", "{0.19999998807907104, 1.1921056801463227E-8},\n", "{-0.1666666567325592, -7.800414592973399E-9},\n", "{0.1428571343421936, 5.650007086920087E-9},\n", "{-0.12502530217170715, -7.44321345601866E-11},\n", "{0.11113807559013367, 9.219544613762692E-9},\n", "};\n", "\n", "/** Coefficients for log in the range of 1.0 < x < 1.0 + 2^-10. */\n", "private static final double LN_HI_PREC_COEF[][] = {\n", "{1.0, -6.032174644509064E-23},\n", "{-0.25, -0.25},\n", "{0.3333333134651184, 1.9868161777724352E-8},\n", "{-0.2499999701976776, -2.957007209750105E-8},\n", "{0.19999954104423523, 1.5830993332061267E-10},\n", "{-0.16624879837036133, -2.6033824355191673E-8}\n", "};\n", "\n", "/** Sine, Cosine, Tangent tables are for 0, 1/8, 2/8, ... 13/8 = PI/2 approx. */\n", "private static final int SINE_TABLE_LEN = 14;\n", "\n", "/** Sine table (high bits). */\n", "private static final double SINE_TABLE_A[] =\n", "{\n", "+0.0d,\n", "+0.1246747374534607d,\n", "+0.24740394949913025d,\n", "+0.366272509098053d,\n", "+0.4794255495071411d,\n", "+0.5850973129272461d,\n", "+0.6816387176513672d,\n", "+0.7675435543060303d,\n", "+0.8414709568023682d,\n", "+0.902267575263977d,\n", "+0.9489846229553223d,\n", "+0.9808930158615112d,\n", "+0.9974949359893799d,\n", "+0.9985313415527344d,\n", "};\n", "\n", "/** Sine table (low bits). */\n", "private static final double SINE_TABLE_B[] =\n", "{\n", "+0.0d,\n", "-4.068233003401932E-9d,\n", "+9.755392680573412E-9d,\n", "+1.9987994582857286E-8d,\n", "-1.0902938113007961E-8d,\n", "-3.9986783938944604E-8d,\n", "+4.23719669792332E-8d,\n", "-5.207000323380292E-8d,\n", "+2.800552834259E-8d,\n", "+1.883511811213715E-8d,\n", "-3.5997360512765566E-9d,\n", "+4.116164446561962E-8d,\n", "+5.0614674548127384E-8d,\n", "-1.0129027912496858E-9d,\n", "};\n", "\n", "/** Cosine table (high bits). */\n", "private static final double COSINE_TABLE_A[] =\n", "{\n", "+1.0d,\n", "+0.9921976327896118d,\n", "+0.9689123630523682d,\n", "+0.9305076599121094d,\n", "+0.8775825500488281d,\n", "+0.8109631538391113d,\n", "+0.7316888570785522d,\n", "+0.6409968137741089d,\n", "+0.5403022766113281d,\n", "+0.4311765432357788d,\n", "+0.3153223395347595d,\n", "+0.19454771280288696d,\n", "+0.07073719799518585d,\n", "-0.05417713522911072d,\n", "};\n", "\n", "/** Cosine table (low bits). */\n", "private static final double COSINE_TABLE_B[] =\n", "{\n", "+0.0d,\n", "+3.4439717236742845E-8d,\n", "+5.865827662008209E-8d,\n", "-3.7999795083850525E-8d,\n", "+1.184154459111628E-8d,\n", "-3.43338934259355E-8d,\n", "+1.1795268640216787E-8d,\n", "+4.438921624363781E-8d,\n", "+2.925681159240093E-8d,\n", "-2.6437112632041807E-8d,\n", "+2.2860509143963117E-8d,\n", "-4.813899778443457E-9d,\n", "+3.6725170580355583E-9d,\n", "+2.0217439756338078E-10d,\n", "};\n", "\n", "\n", "/** Tangent table, used by atan() (high bits). */\n", "private static final double TANGENT_TABLE_A[] =\n", "{\n", "+0.0d,\n", "+0.1256551444530487d,\n", "+0.25534194707870483d,\n", "+0.3936265707015991d,\n", "+0.5463024377822876d,\n", "+0.7214844226837158d,\n", "+0.9315965175628662d,\n", "+1.1974215507507324d,\n", "+1.5574076175689697d,\n", "+2.092571258544922d,\n", "+3.0095696449279785d,\n", "+5.041914939880371d,\n", "+14.101419448852539d,\n", "-18.430862426757812d,\n", "};\n", "\n", "/** Tangent table, used by atan() (low bits). */\n", "private static final double TANGENT_TABLE_B[] =\n", "{\n", "+0.0d,\n", "-7.877917738262007E-9d,\n", "-2.5857668567479893E-8d,\n", "+5.2240336371356666E-9d,\n", "+5.206150291559893E-8d,\n", "+1.8307188599677033E-8d,\n", "-5.7618793749770706E-8d,\n", "+7.848361555046424E-8d,\n", "+1.0708593250394448E-7d,\n", "+1.7827257129423813E-8d,\n", "+2.893485277253286E-8d,\n", "+3.1660099222737955E-7d,\n", "+4.983191803254889E-7d,\n", "-3.356118100840571E-7d,\n", "};\n", "\n", "/** Bits of 1/(2*pi), need for reducePayneHanek(). */\n", "private static final long RECIP_2PI[] = new long[] {\n", "(0x28be60dbL << 32) | 0x9391054aL,\n", "(0x7f09d5f4L << 32) | 0x7d4d3770L,\n", "(0x36d8a566L << 32) | 0x4f10e410L,\n", "(0x7f9458eaL << 32) | 0xf7aef158L,\n", "(0x6dc91b8eL << 32) | 0x909374b8L,\n", "(0x01924bbaL << 32) | 0x82746487L,\n", "(0x3f877ac7L << 32) | 0x2c4a69cfL,\n", "(0xba208d7dL << 32) | 0x4baed121L,\n", "(0x3a671c09L << 32) | 0xad17df90L,\n", "(0x4e64758eL << 32) | 0x60d4ce7dL,\n", "(0x272117e2L << 32) | 0xef7e4a0eL,\n", "(0xc7fe25ffL << 32) | 0xf7816603L,\n", "(0xfbcbc462L << 32) | 0xd6829b47L,\n", "(0xdb4d9fb3L << 32) | 0xc9f2c26dL,\n", "(0xd3d18fd9L << 32) | 0xa797fa8bL,\n", "(0x5d49eeb1L << 32) | 0xfaf97c5eL,\n", "(0xcf41ce7dL << 32) | 0xe294a4baL,\n", "0x9afed7ecL << 32  };\n", "\n", "/** Bits of pi/4, need for reducePayneHanek(). */\n", "private static final long PI_O_4_BITS[] = new long[] {\n", "(0xc90fdaa2L << 32) | 0x2168c234L,\n", "(0xc4c6628bL << 32) | 0x80dc1cd1L };\n", "\n", "/** Eighths.\n", "* This is used by sinQ, because its faster to do a table lookup than\n", "* a multiply in this time-critical routine\n", "*/\n", "private static final double EIGHTHS[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625};\n", "\n", "/** Table of 2^((n+2)/3) */\n", "private static final double CBRTTWO[] = { 0.6299605249474366,\n", "0.7937005259840998,\n", "1.0,\n", "1.2599210498948732,\n", "1.5874010519681994 };\n", "\n", "/*\n", "*  There are 52 bits in the mantissa of a double.\n", "*  For additional precision, the code splits double numbers into two parts,\n", "*  by clearing the low order 30 bits if possible, and then performs the arithmetic\n", "*  on each half separately.\n", "*/\n", "\n", "/**\n", "* 0x40000000 - used to split a double into two parts, both with the low order bits cleared.\n", "* Equivalent to 2^30.\n", "*/\n", "private static final long HEX_40000000 = 0x40000000L; // 1073741824L\n", "\n", "/** Mask used to clear low order 30 bits */\n", "private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L;\n", "\n", "/** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */\n", "private static final double TWO_POWER_52 = 4503599627370496.0;\n", "\n", "/** Constant: {@value}. */\n", "private static final double F_1_3 = 1d / 3d;\n", "/** Constant: {@value}. */\n", "private static final double F_1_5 = 1d / 5d;\n", "/** Constant: {@value}. */\n", "private static final double F_1_7 = 1d / 7d;\n", "/** Constant: {@value}. */\n", "private static final double F_1_9 = 1d / 9d;\n", "/** Constant: {@value}. */\n", "private static final double F_1_11 = 1d / 11d;\n", "/** Constant: {@value}. */\n", "private static final double F_1_13 = 1d / 13d;\n", "/** Constant: {@value}. */\n", "private static final double F_1_15 = 1d / 15d;\n", "/** Constant: {@value}. */\n", "private static final double F_1_17 = 1d / 17d;\n", "/** Constant: {@value}. */\n", "private static final double F_3_4 = 3d / 4d;\n", "/** Constant: {@value}. */\n", "private static final double F_15_16 = 15d / 16d;\n", "/** Constant: {@value}. */\n", "private static final double F_13_14 = 13d / 14d;\n", "/** Constant: {@value}. */\n", "private static final double F_11_12 = 11d / 12d;\n", "/** Constant: {@value}. */\n", "private static final double F_9_10 = 9d / 10d;\n", "/** Constant: {@value}. */\n", "private static final double F_7_8 = 7d / 8d;\n", "/** Constant: {@value}. */\n", "private static final double F_5_6 = 5d / 6d;\n", "/** Constant: {@value}. */\n", "private static final double F_1_2 = 1d / 2d;\n", "/** Constant: {@value}. */\n", "private static final double F_1_4 = 1d / 4d;\n", "\n", "/**\n", "* Private Constructor\n", "*/\n", "private FastMath() {}\n", "\n", "// Generic helper methods\n", "\n", "/**\n", "* Get the high order bits from the mantissa.\n", "* Equivalent to adding and subtracting HEX_40000 but also works for very large numbers\n", "*\n", "* @param d the value to split\n", "* @return the high order part of the mantissa\n", "*/\n", "private static double doubleHighPart(double d) {\n", "if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){\n", "return d; // These are un-normalised - don't try to convert\n", "}\n", "long xl = Double.doubleToLongBits(d);\n", "xl = xl & MASK_30BITS; // Drop low order bits\n", "return Double.longBitsToDouble(xl);\n", "}\n", "\n", "/** Compute the square root of a number.\n", "* <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n", "* @param a number on which evaluation is done\n", "* @return square root of a\n", "*/\n", "public static double sqrt(final double a) {\n", "return Math.sqrt(a);\n", "}\n", "\n", "/** Compute the hyperbolic cosine of a number.\n", "* @param x number on which evaluation is done\n", "* @return hyperbolic cosine of x\n", "*/\n", "public static double cosh(double x) {\n", "if (x != x) {\n", "return x;\n", "}\n", "\n", "// cosh[z] = (exp(z) + exp(-z))/2\n", "\n", "// for numbers with magnitude 20 or so,\n", "// exp(-z) can be ignored in comparison with exp(z)\n", "\n", "if (x > 20) {\n", "// Avoid overflow (MATH-905).\n", "return 0.5 * exp(x);\n", "}\n", "if (x < -20) {\n", "// Avoid overflow (MATH-905).\n", "return 0.5 * exp(-x);\n", "}\n", "\n", "final double hiPrec[] = new double[2];\n", "if (x < 0.0) {\n", "x = -x;\n", "}\n", "exp(x, 0.0, hiPrec);\n", "\n", "double ya = hiPrec[0] + hiPrec[1];\n", "double yb = -(ya - hiPrec[0] - hiPrec[1]);\n", "\n", "double temp = ya * HEX_40000000;\n", "double yaa = ya + temp - temp;\n", "double yab = ya - yaa;\n", "\n", "// recip = 1/y\n", "double recip = 1.0/ya;\n", "temp = recip * HEX_40000000;\n", "double recipa = recip + temp - temp;\n", "double recipb = recip - recipa;\n", "\n", "// Correct for rounding in division\n", "recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n", "// Account for yb\n", "recipb += -yb * recip * recip;\n", "\n", "// y = y + 1/y\n", "temp = ya + recipa;\n", "yb += -(temp - ya - recipa);\n", "ya = temp;\n", "temp = ya + recipb;\n", "yb += -(temp - ya - recipb);\n", "ya = temp;\n", "\n", "double result = ya + yb;\n", "result *= 0.5;\n", "return result;\n", "}\n", "\n", "/** Compute the hyperbolic sine of a number.\n", "* @param x number on which evaluation is done\n", "* @return hyperbolic sine of x\n", "*/\n", "public static double sinh(double x) {\n", "boolean negate = false;\n", "if (x != x) {\n", "return x;\n", "}\n", "\n", "// sinh[z] = (exp(z) - exp(-z) / 2\n", "\n", "// for values of z larger than about 20,\n", "// exp(-z) can be ignored in comparison with exp(z)\n", "\n", "if (x > 20) {\n", "// Avoid overflow (MATH-905).\n", "return 0.5 * exp(x);\n", "}\n", "if (x < -20) {\n", "// Avoid overflow (MATH-905).\n", "return -0.5 * exp(-x);\n", "}\n", "\n", "if (x == 0) {\n", "return x;\n", "}\n", "\n", "if (x < 0.0) {\n", "x = -x;\n", "negate = true;\n", "}\n", "\n", "double result;\n", "\n", "if (x > 0.25) {\n", "double hiPrec[] = new double[2];\n", "exp(x, 0.0, hiPrec);\n", "\n", "double ya = hiPrec[0] + hiPrec[1];\n", "double yb = -(ya - hiPrec[0] - hiPrec[1]);\n", "\n", "double temp = ya * HEX_40000000;\n", "double yaa = ya + temp - temp;\n", "double yab = ya - yaa;\n", "\n", "// recip = 1/y\n", "double recip = 1.0/ya;\n", "temp = recip * HEX_40000000;\n", "double recipa = recip + temp - temp;\n", "double recipb = recip - recipa;\n", "\n", "// Correct for rounding in division\n", "recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n", "// Account for yb\n", "recipb += -yb * recip * recip;\n", "\n", "recipa = -recipa;\n", "recipb = -recipb;\n", "\n", "// y = y + 1/y\n", "temp = ya + recipa;\n", "yb += -(temp - ya - recipa);\n", "ya = temp;\n", "temp = ya + recipb;\n", "yb += -(temp - ya - recipb);\n", "ya = temp;\n", "\n", "result = ya + yb;\n", "result *= 0.5;\n", "}\n", "else {\n", "double hiPrec[] = new double[2];\n", "expm1(x, hiPrec);\n", "\n", "double ya = hiPrec[0] + hiPrec[1];\n", "double yb = -(ya - hiPrec[0] - hiPrec[1]);\n", "\n", "/* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n", "double denom = 1.0 + ya;\n", "double denomr = 1.0 / denom;\n", "double denomb = -(denom - 1.0 - ya) + yb;\n", "double ratio = ya * denomr;\n", "double temp = ratio * HEX_40000000;\n", "double ra = ratio + temp - temp;\n", "double rb = ratio - ra;\n", "\n", "temp = denom * HEX_40000000;\n", "double za = denom + temp - temp;\n", "double zb = denom - za;\n", "\n", "rb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n", "\n", "// Adjust for yb\n", "rb += yb*denomr;                        // numerator\n", "rb += -ya * denomb * denomr * denomr;   // denominator\n", "\n", "// y = y - 1/y\n", "temp = ya + ra;\n", "yb += -(temp - ya - ra);\n", "ya = temp;\n", "temp = ya + rb;\n", "yb += -(temp - ya - rb);\n", "ya = temp;\n", "\n", "result = ya + yb;\n", "result *= 0.5;\n", "}\n", "\n", "if (negate) {\n", "result = -result;\n", "}\n", "\n", "return result;\n", "}\n", "\n", "/** Compute the hyperbolic tangent of a number.\n", "* @param x number on which evaluation is done\n", "* @return hyperbolic tangent of x\n", "*/\n", "public static double tanh(double x) {\n", "boolean negate = false;\n", "\n", "if (x != x) {\n", "return x;\n", "}\n", "\n", "// tanh[z] = sinh[z] / cosh[z]\n", "// = (exp(z) - exp(-z)) / (exp(z) + exp(-z))\n", "// = (exp(2x) - 1) / (exp(2x) + 1)\n", "\n", "// for magnitude > 20, sinh[z] == cosh[z] in double precision\n", "\n", "if (x > 20.0) {\n", "return 1.0;\n", "}\n", "\n", "if (x < -20) {\n", "return -1.0;\n", "}\n", "\n", "if (x == 0) {\n", "return x;\n", "}\n", "\n", "if (x < 0.0) {\n", "x = -x;\n", "negate = true;\n", "}\n", "\n", "double result;\n", "if (x >= 0.5) {\n", "double hiPrec[] = new double[2];\n", "// tanh(x) = (exp(2x) - 1) / (exp(2x) + 1)\n", "exp(x*2.0, 0.0, hiPrec);\n", "\n", "double ya = hiPrec[0] + hiPrec[1];\n", "double yb = -(ya - hiPrec[0] - hiPrec[1]);\n", "\n", "/* Numerator */\n", "double na = -1.0 + ya;\n", "double nb = -(na + 1.0 - ya);\n", "double temp = na + yb;\n", "nb += -(temp - na - yb);\n", "na = temp;\n", "\n", "/* Denominator */\n", "double da = 1.0 + ya;\n", "double db = -(da - 1.0 - ya);\n", "temp = da + yb;\n", "db += -(temp - da - yb);\n", "da = temp;\n", "\n", "temp = da * HEX_40000000;\n", "double daa = da + temp - temp;\n", "double dab = da - daa;\n", "\n", "// ratio = na/da\n", "double ratio = na/da;\n", "temp = ratio * HEX_40000000;\n", "double ratioa = ratio + temp - temp;\n", "double ratiob = ratio - ratioa;\n", "\n", "// Correct for rounding in division\n", "ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n", "\n", "// Account for nb\n", "ratiob += nb / da;\n", "// Account for db\n", "ratiob += -db * na / da / da;\n", "\n", "result = ratioa + ratiob;\n", "}\n", "else {\n", "double hiPrec[] = new double[2];\n", "// tanh(x) = expm1(2x) / (expm1(2x) + 2)\n", "expm1(x*2.0, hiPrec);\n", "\n", "double ya = hiPrec[0] + hiPrec[1];\n", "double yb = -(ya - hiPrec[0] - hiPrec[1]);\n", "\n", "/* Numerator */\n", "double na = ya;\n", "double nb = yb;\n", "\n", "/* Denominator */\n", "double da = 2.0 + ya;\n", "double db = -(da - 2.0 - ya);\n", "double temp = da + yb;\n", "db += -(temp - da - yb);\n", "da = temp;\n", "\n", "temp = da * HEX_40000000;\n", "double daa = da + temp - temp;\n", "double dab = da - daa;\n", "\n", "// ratio = na/da\n", "double ratio = na/da;\n", "temp = ratio * HEX_40000000;\n", "double ratioa = ratio + temp - temp;\n", "double ratiob = ratio - ratioa;\n", "\n", "// Correct for rounding in division\n", "ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n", "\n", "// Account for nb\n", "ratiob += nb / da;\n", "// Account for db\n", "ratiob += -db * na / da / da;\n", "\n", "result = ratioa + ratiob;\n", "}\n", "\n", "if (negate) {\n", "result = -result;\n", "}\n", "\n", "return result;\n", "}\n", "\n", "/** Compute the inverse hyperbolic cosine of a number.\n", "* @param a number on which evaluation is done\n", "* @return inverse hyperbolic cosine of a\n", "*/\n", "public static double acosh(final double a) {\n", "return FastMath.log(a + FastMath.sqrt(a * a - 1));\n", "}\n", "\n", "/** Compute the inverse hyperbolic sine of a number.\n", "* @param a number on which evaluation is done\n", "* @return inverse hyperbolic sine of a\n", "*/\n", "public static double asinh(double a) {\n", "boolean negative = false;\n", "if (a < 0) {\n", "negative = true;\n", "a = -a;\n", "}\n", "\n", "double absAsinh;\n", "if (a > 0.167) {\n", "absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n", "} else {\n", "final double a2 = a * a;\n", "if (a > 0.097) {\n", "absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n", "} else if (a > 0.036) {\n", "absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n", "} else if (a > 0.0036) {\n", "absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n", "} else {\n", "absAsinh = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);\n", "}\n", "}\n", "\n", "return negative ? -absAsinh : absAsinh;\n", "}\n", "\n", "/** Compute the inverse hyperbolic tangent of a number.\n", "* @param a number on which evaluation is done\n", "* @return inverse hyperbolic tangent of a\n", "*/\n", "public static double atanh(double a) {\n", "boolean negative = false;\n", "if (a < 0) {\n", "negative = true;\n", "a = -a;\n", "}\n", "\n", "double absAtanh;\n", "if (a > 0.15) {\n", "absAtanh = 0.5 * FastMath.log((1 + a) / (1 - a));\n", "} else {\n", "final double a2 = a * a;\n", "if (a > 0.087) {\n", "absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n", "} else if (a > 0.031) {\n", "absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n", "} else if (a > 0.003) {\n", "absAtanh = a * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n", "} else {\n", "absAtanh = a * (1 + a2 * (F_1_3 + a2 * F_1_5));\n", "}\n", "}\n", "\n", "return negative ? -absAtanh : absAtanh;\n", "}\n", "\n", "/** Compute the signum of a number.\n", "* The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n", "* @param a number on which evaluation is done\n", "* @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n", "*/\n", "public static double signum(final double a) {\n", "return (a < 0.0) ? -1.0 : ((a > 0.0) ? 1.0 : a); // return +0.0/-0.0/NaN depending on a\n", "}\n", "\n", "/** Compute the signum of a number.\n", "* The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n", "* @param a number on which evaluation is done\n", "* @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n", "*/\n", "public static float signum(final float a) {\n", "return (a < 0.0f) ? -1.0f : ((a > 0.0f) ? 1.0f : a); // return +0.0/-0.0/NaN depending on a\n", "}\n", "\n", "/** Compute next number towards positive infinity.\n", "* @param a number to which neighbor should be computed\n", "* @return neighbor of a towards positive infinity\n", "*/\n", "public static double nextUp(final double a) {\n", "return nextAfter(a, Double.POSITIVE_INFINITY);\n", "}\n", "\n", "/** Compute next number towards positive infinity.\n", "* @param a number to which neighbor should be computed\n", "* @return neighbor of a towards positive infinity\n", "*/\n", "public static float nextUp(final float a) {\n", "return nextAfter(a, Float.POSITIVE_INFINITY);\n", "}\n", "\n", "/** Returns a pseudo-random number between 0.0 and 1.0.\n", "* <p><b>Note:</b> this implementation currently delegates to {@link Math#random}\n", "* @return a random number between 0.0 and 1.0\n", "*/\n", "public static double random() {\n", "return Math.random();\n", "}\n", "\n", "/**\n", "* Exponential function.\n", "*\n", "* Computes exp(x), function result is nearly rounded.   It will be correctly\n", "* rounded to the theoretical value for 99.9% of input values, otherwise it will\n", "* have a 1 UPL error.\n", "*\n", "* Method:\n", "*    Lookup intVal = exp(int(x))\n", "*    Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 );\n", "*    Compute z as the exponential of the remaining bits by a polynomial minus one\n", "*    exp(x) = intVal * fracVal * (1 + z)\n", "*\n", "* Accuracy:\n", "*    Calculation is done with 63 bits of precision, so result should be correctly\n", "*    rounded for 99.9% of input values, with less than 1 ULP error otherwise.\n", "*\n", "* @param x   a double\n", "* @return double e<sup>x</sup>\n", "*/\n", "public static double exp(double x) {\n", "return exp(x, 0.0, null);\n", "}\n", "\n", "/**\n", "* Internal helper method for exponential function.\n", "* @param x original argument of the exponential function\n", "* @param extra extra bits of precision on input (To Be Confirmed)\n", "* @param hiPrec extra bits of precision on output (To Be Confirmed)\n", "* @return exp(x)\n", "*/\n", "private static double exp(double x, double extra, double[] hiPrec) {\n", "double intPartA;\n", "double intPartB;\n", "int intVal;\n", "\n", "/* Lookup exp(floor(x)).\n", "* intPartA will have the upper 22 bits, intPartB will have the lower\n", "* 52 bits.\n", "*/\n", "if (x < 0.0) {\n", "intVal = (int) -x;\n", "\n", "if (intVal > 746) {\n", "if (hiPrec != null) {\n", "hiPrec[0] = 0.0;\n", "hiPrec[1] = 0.0;\n", "}\n", "return 0.0;\n", "}\n", "\n", "if (intVal > 709) {\n", "/* This will produce a subnormal output */\n", "final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n", "if (hiPrec != null) {\n", "hiPrec[0] /= 285040095144011776.0;\n", "hiPrec[1] /= 285040095144011776.0;\n", "}\n", "return result;\n", "}\n", "\n", "if (intVal == 709) {\n", "/* exp(1.494140625) is nearly a machine number... */\n", "final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n", "if (hiPrec != null) {\n", "hiPrec[0] /= 4.455505956692756620;\n", "hiPrec[1] /= 4.455505956692756620;\n", "}\n", "return result;\n", "}\n", "\n", "intVal++;\n", "\n", "intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\n", "intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n", "\n", "intVal = -intVal;\n", "} else {\n", "intVal = (int) x;\n", "\n", "if (intVal > 709) {\n", "if (hiPrec != null) {\n", "hiPrec[0] = Double.POSITIVE_INFINITY;\n", "hiPrec[1] = 0.0;\n", "}\n", "return Double.POSITIVE_INFINITY;\n", "}\n", "\n", "intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\n", "intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n", "}\n", "\n", "/* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n", "* x and look up the exp function of it.\n", "* fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n", "*/\n", "final int intFrac = (int) ((x - intVal) * 1024.0);\n", "final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n", "final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n", "\n", "/* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n", "* has a value in the range 0 <= epsilon < 2^-10.\n", "* Do the subtraction from x as the last step to avoid possible loss of percison.\n", "*/\n", "final double epsilon = x - (intVal + intFrac / 1024.0);\n", "\n", "/* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\n", "full double precision (52 bits).  Since z < 2^-10, we will have\n", "62 bits of precision when combined with the contant 1.  This will be\n", "used in the last addition below to get proper rounding. */\n", "\n", "/* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\n", "is less than 0.5 ULP */\n", "double z = 0.04168701738764507;\n", "z = z * epsilon + 0.1666666505023083;\n", "z = z * epsilon + 0.5000000000042687;\n", "z = z * epsilon + 1.0;\n", "z = z * epsilon + -3.940510424527919E-20;\n", "\n", "/* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\n", "expansion.\n", "tempA is exact since intPartA and intPartB only have 22 bits each.\n", "tempB will have 52 bits of precision.\n", "*/\n", "double tempA = intPartA * fracPartA;\n", "double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n", "\n", "/* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\n", "important.  For accuracy add by increasing size.  tempA is exact and\n", "much larger than the others.  If there are extra bits specified from the\n", "pow() function, use them. */\n", "final double tempC = tempB + tempA;\n", "final double result;\n", "if (extra != 0.0) {\n", "result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n", "} else {\n", "result = tempC*z + tempB + tempA;\n", "}\n", "\n", "if (hiPrec != null) {\n", "// If requesting high precision\n", "hiPrec[0] = tempA;\n", "hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n", "}\n", "\n", "return result;\n", "}\n", "\n", "/** Compute exp(x) - 1\n", "* @param x number to compute shifted exponential\n", "* @return exp(x) - 1\n", "*/\n", "public static double expm1(double x) {\n", "return expm1(x, null);\n", "}\n", "\n", "/** Internal helper method for expm1\n", "* @param x number to compute shifted exponential\n", "* @param hiPrecOut receive high precision result for -1.0 < x < 1.0\n", "* @return exp(x) - 1\n", "*/\n", "private static double expm1(double x, double hiPrecOut[]) {\n", "if (x != x || x == 0.0) { // NaN or zero\n", "return x;\n", "}\n", "\n", "if (x <= -1.0 || x >= 1.0) {\n", "// If not between +/- 1.0\n", "//return exp(x) - 1.0;\n", "double hiPrec[] = new double[2];\n", "exp(x, 0.0, hiPrec);\n", "if (x > 0.0) {\n", "return -1.0 + hiPrec[0] + hiPrec[1];\n", "} else {\n", "final double ra = -1.0 + hiPrec[0];\n", "double rb = -(ra + 1.0 - hiPrec[0]);\n", "rb += hiPrec[1];\n", "return ra + rb;\n", "}\n", "}\n", "\n", "double baseA;\n", "double baseB;\n", "double epsilon;\n", "boolean negative = false;\n", "\n", "if (x < 0.0) {\n", "x = -x;\n", "negative = true;\n", "}\n", "\n", "{\n", "int intFrac = (int) (x * 1024.0);\n", "double tempA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;\n", "double tempB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n", "\n", "double temp = tempA + tempB;\n", "tempB = -(temp - tempA - tempB);\n", "tempA = temp;\n", "\n", "temp = tempA * HEX_40000000;\n", "baseA = tempA + temp - temp;\n", "baseB = tempB + (tempA - baseA);\n", "\n", "epsilon = x - intFrac/1024.0;\n", "}\n", "\n", "\n", "/* Compute expm1(epsilon) */\n", "double zb = 0.008336750013465571;\n", "zb = zb * epsilon + 0.041666663879186654;\n", "zb = zb * epsilon + 0.16666666666745392;\n", "zb = zb * epsilon + 0.49999999999999994;\n", "zb = zb * epsilon;\n", "zb = zb * epsilon;\n", "\n", "double za = epsilon;\n", "double temp = za + zb;\n", "zb = -(temp - za - zb);\n", "za = temp;\n", "\n", "temp = za * HEX_40000000;\n", "temp = za + temp - temp;\n", "zb += za - temp;\n", "za = temp;\n", "\n", "/* Combine the parts.   expm1(a+b) = expm1(a) + expm1(b) + expm1(a)*expm1(b) */\n", "double ya = za * baseA;\n", "//double yb = za*baseB + zb*baseA + zb*baseB;\n", "temp = ya + za * baseB;\n", "double yb = -(temp - ya - za * baseB);\n", "ya = temp;\n", "\n", "temp = ya + zb * baseA;\n", "yb += -(temp - ya - zb * baseA);\n", "ya = temp;\n", "\n", "temp = ya + zb * baseB;\n", "yb += -(temp - ya - zb*baseB);\n", "ya = temp;\n", "\n", "//ya = ya + za + baseA;\n", "//yb = yb + zb + baseB;\n", "temp = ya + baseA;\n", "yb += -(temp - baseA - ya);\n", "ya = temp;\n", "\n", "temp = ya + za;\n", "//yb += (ya > za) ? -(temp - ya - za) : -(temp - za - ya);\n", "yb += -(temp - ya - za);\n", "ya = temp;\n", "\n", "temp = ya + baseB;\n", "//yb += (ya > baseB) ? -(temp - ya - baseB) : -(temp - baseB - ya);\n", "yb += -(temp - ya - baseB);\n", "ya = temp;\n", "\n", "temp = ya + zb;\n", "//yb += (ya > zb) ? -(temp - ya - zb) : -(temp - zb - ya);\n", "yb += -(temp - ya - zb);\n", "ya = temp;\n", "\n", "if (negative) {\n", "/* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n", "double denom = 1.0 + ya;\n", "double denomr = 1.0 / denom;\n", "double denomb = -(denom - 1.0 - ya) + yb;\n", "double ratio = ya * denomr;\n", "temp = ratio * HEX_40000000;\n", "final double ra = ratio + temp - temp;\n", "double rb = ratio - ra;\n", "\n", "temp = denom * HEX_40000000;\n", "za = denom + temp - temp;\n", "zb = denom - za;\n", "\n", "rb += (ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n", "\n", "// f(x) = x/1+x\n", "// Compute f'(x)\n", "// Product rule:  d(uv) = du*v + u*dv\n", "// Chain rule:  d(f(g(x)) = f'(g(x))*f(g'(x))\n", "// d(1/x) = -1/(x*x)\n", "// d(1/1+x) = -1/( (1+x)^2) *  1 =  -1/((1+x)*(1+x))\n", "// d(x/1+x) = -x/((1+x)(1+x)) + 1/1+x = 1 / ((1+x)(1+x))\n", "\n", "// Adjust for yb\n", "rb += yb * denomr;                      // numerator\n", "rb += -ya * denomb * denomr * denomr;   // denominator\n", "\n", "// negate\n", "ya = -ra;\n", "yb = -rb;\n", "}\n", "\n", "if (hiPrecOut != null) {\n", "hiPrecOut[0] = ya;\n", "hiPrecOut[1] = yb;\n", "}\n", "\n", "return ya + yb;\n", "}\n", "\n", "/**\n", "* Natural logarithm.\n", "*\n", "* @param x   a double\n", "* @return log(x)\n", "*/\n", "public static double log(final double x) {\n", "return log(x, null);\n", "}\n", "\n", "/**\n", "* Internal helper method for natural logarithm function.\n", "* @param x original argument of the natural logarithm function\n", "* @param hiPrec extra bits of precision on output (To Be Confirmed)\n", "* @return log(x)\n", "*/\n", "private static double log(final double x, final double[] hiPrec) {\n", "if (x==0) { // Handle special case of +0/-0\n", "return Double.NEGATIVE_INFINITY;\n", "}\n", "long bits = Double.doubleToLongBits(x);\n", "\n", "/* Handle special cases of negative input, and NaN */\n", "if ((bits & 0x8000000000000000L) != 0 || x != x) {\n", "if (x != 0.0) {\n", "if (hiPrec != null) {\n", "hiPrec[0] = Double.NaN;\n", "}\n", "\n", "return Double.NaN;\n", "}\n", "}\n", "\n", "/* Handle special cases of Positive infinity. */\n", "if (x == Double.POSITIVE_INFINITY) {\n", "if (hiPrec != null) {\n", "hiPrec[0] = Double.POSITIVE_INFINITY;\n", "}\n", "\n", "return Double.POSITIVE_INFINITY;\n", "}\n", "\n", "/* Extract the exponent */\n", "int exp = (int)(bits >> 52)-1023;\n", "\n", "if ((bits & 0x7ff0000000000000L) == 0) {\n", "// Subnormal!\n", "if (x == 0) {\n", "// Zero\n", "if (hiPrec != null) {\n", "hiPrec[0] = Double.NEGATIVE_INFINITY;\n", "}\n", "\n", "return Double.NEGATIVE_INFINITY;\n", "}\n", "\n", "/* Normalize the subnormal number. */\n", "bits <<= 1;\n", "while ( (bits & 0x0010000000000000L) == 0) {\n", "--exp;\n", "bits <<= 1;\n", "}\n", "}\n", "\n", "\n", "if (exp == -1 || exp == 0) {\n", "if (x < 1.01 && x > 0.99 && hiPrec == null) {\n", "/* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n", "polynomial expansion in higer precision. */\n", "\n", "/* Compute x - 1.0 and split it */\n", "double xa = x - 1.0;\n", "double xb = xa - x + 1.0;\n", "double tmp = xa * HEX_40000000;\n", "double aa = xa + tmp - tmp;\n", "double ab = xa - aa;\n", "xa = aa;\n", "xb = ab;\n", "\n", "final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n", "double ya = lnCoef_last[0];\n", "double yb = lnCoef_last[1];\n", "\n", "for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n", "/* Multiply a = y * x */\n", "aa = ya * xa;\n", "ab = ya * xb + yb * xa + yb * xb;\n", "/* split, so now y = a */\n", "tmp = aa * HEX_40000000;\n", "ya = aa + tmp - tmp;\n", "yb = aa - ya + ab;\n", "\n", "/* Add  a = y + lnQuickCoef */\n", "final double[] lnCoef_i = LN_QUICK_COEF[i];\n", "aa = ya + lnCoef_i[0];\n", "ab = yb + lnCoef_i[1];\n", "/* Split y = a */\n", "tmp = aa * HEX_40000000;\n", "ya = aa + tmp - tmp;\n", "yb = aa - ya + ab;\n", "}\n", "\n", "/* Multiply a = y * x */\n", "aa = ya * xa;\n", "ab = ya * xb + yb * xa + yb * xb;\n", "/* split, so now y = a */\n", "tmp = aa * HEX_40000000;\n", "ya = aa + tmp - tmp;\n", "yb = aa - ya + ab;\n", "\n", "return ya + yb;\n", "}\n", "}\n", "\n", "// lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n", "final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n", "\n", "/*\n", "double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n", "\n", "epsilon -= 1.0;\n", "*/\n", "\n", "// y is the most significant 10 bits of the mantissa\n", "//double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n", "//double epsilon = (x - y) / y;\n", "final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n", "\n", "double lnza = 0.0;\n", "double lnzb = 0.0;\n", "\n", "if (hiPrec != null) {\n", "/* split epsilon -> x */\n", "double tmp = epsilon * HEX_40000000;\n", "double aa = epsilon + tmp - tmp;\n", "double ab = epsilon - aa;\n", "double xa = aa;\n", "double xb = ab;\n", "\n", "/* Need a more accurate epsilon, so adjust the division. */\n", "final double numer = bits & 0x3ffffffffffL;\n", "final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n", "aa = numer - xa*denom - xb * denom;\n", "xb += aa / denom;\n", "\n", "/* Remez polynomial evaluation */\n", "final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\n", "double ya = lnCoef_last[0];\n", "double yb = lnCoef_last[1];\n", "\n", "for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n", "/* Multiply a = y * x */\n", "aa = ya * xa;\n", "ab = ya * xb + yb * xa + yb * xb;\n", "/* split, so now y = a */\n", "tmp = aa * HEX_40000000;\n", "ya = aa + tmp - tmp;\n", "yb = aa - ya + ab;\n", "\n", "/* Add  a = y + lnHiPrecCoef */\n", "final double[] lnCoef_i = LN_HI_PREC_COEF[i];\n", "aa = ya + lnCoef_i[0];\n", "ab = yb + lnCoef_i[1];\n", "/* Split y = a */\n", "tmp = aa * HEX_40000000;\n", "ya = aa + tmp - tmp;\n", "yb = aa - ya + ab;\n", "}\n", "\n", "/* Multiply a = y * x */\n", "aa = ya * xa;\n", "ab = ya * xb + yb * xa + yb * xb;\n", "\n", "/* split, so now lnz = a */\n", "/*\n", "tmp = aa * 1073741824.0;\n", "lnza = aa + tmp - tmp;\n", "lnzb = aa - lnza + ab;\n", "*/\n", "lnza = aa + ab;\n", "lnzb = -(lnza - aa - ab);\n", "} else {\n", "/* High precision not required.  Eval Remez polynomial\n", "using standard double precision */\n", "lnza = -0.16624882440418567;\n", "lnza = lnza * epsilon + 0.19999954120254515;\n", "lnza = lnza * epsilon + -0.2499999997677497;\n", "lnza = lnza * epsilon + 0.3333333333332802;\n", "lnza = lnza * epsilon + -0.5;\n", "lnza = lnza * epsilon + 1.0;\n", "lnza = lnza * epsilon;\n", "}\n", "\n", "/* Relative sizes:\n", "* lnzb     [0, 2.33E-10]\n", "* lnm[1]   [0, 1.17E-7]\n", "* ln2B*exp [0, 1.12E-4]\n", "* lnza      [0, 9.7E-4]\n", "* lnm[0]   [0, 0.692]\n", "* ln2A*exp [0, 709]\n", "*/\n", "\n", "/* Compute the following sum:\n", "* lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n", "*/\n", "\n", "//return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n", "double a = LN_2_A*exp;\n", "double b = 0.0;\n", "double c = a+lnm[0];\n", "double d = -(c-a-lnm[0]);\n", "a = c;\n", "b = b + d;\n", "\n", "c = a + lnza;\n", "d = -(c - a - lnza);\n", "a = c;\n", "b = b + d;\n", "\n", "c = a + LN_2_B*exp;\n", "d = -(c - a - LN_2_B*exp);\n", "a = c;\n", "b = b + d;\n", "\n", "c = a + lnm[1];\n", "d = -(c - a - lnm[1]);\n", "a = c;\n", "b = b + d;\n", "\n", "c = a + lnzb;\n", "d = -(c - a - lnzb);\n", "a = c;\n", "b = b + d;\n", "\n", "if (hiPrec != null) {\n", "hiPrec[0] = a;\n", "hiPrec[1] = b;\n", "}\n", "\n", "return a + b;\n", "}\n", "\n", "/**\n", "* Computes log(1 + x).\n", "*\n", "* @param x Number.\n", "* @return {@code log(1 + x)}.\n", "*/\n", "public static double log1p(final double x) {\n", "if (x == -1) {\n", "return Double.NEGATIVE_INFINITY;\n", "}\n", "\n", "if (x == Double.POSITIVE_INFINITY) {\n", "return Double.POSITIVE_INFINITY;\n", "}\n", "\n", "if (x > 1e-6 ||\n", "x < -1e-6) {\n", "final double xpa = 1 + x;\n", "final double xpb = -(xpa - 1 - x);\n", "\n", "final double[] hiPrec = new double[2];\n", "final double lores = log(xpa, hiPrec);\n", "if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN\n", "return lores;\n", "}\n", "\n", "// Do a taylor series expansion around xpa:\n", "//   f(x+y) = f(x) + f'(x) y + f''(x)/2 y^2\n", "final double fx1 = xpb / xpa;\n", "final double epsilon = 0.5 * fx1 + 1;\n", "return epsilon * fx1 + hiPrec[1] + hiPrec[0];\n", "} else {\n", "// Value is small |x| < 1e6, do a Taylor series centered on 1.\n", "final double y = (x * F_1_3 - F_1_2) * x + 1;\n", "return y * x;\n", "}\n", "}\n", "\n", "/** Compute the base 10 logarithm.\n", "* @param x a number\n", "* @return log10(x)\n", "*/\n", "public static double log10(final double x) {\n", "final double hiPrec[] = new double[2];\n", "\n", "final double lores = log(x, hiPrec);\n", "if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n", "return lores;\n", "}\n", "\n", "final double tmp = hiPrec[0] * HEX_40000000;\n", "final double lna = hiPrec[0] + tmp - tmp;\n", "final double lnb = hiPrec[0] - lna + hiPrec[1];\n", "\n", "final double rln10a = 0.4342944622039795;\n", "final double rln10b = 1.9699272335463627E-8;\n", "\n", "return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\n", "}\n", "\n", "/**\n", "* Computes the <a href=\"http://mathworld.wolfram.com/Logarithm.html\">\n", "* logarithm</a> in a given base.\n", "*\n", "* Returns {@code NaN} if either argument is negative.\n", "* If {@code base} is 0 and {@code x} is positive, 0 is returned.\n", "* If {@code base} is positive and {@code x} is 0,\n", "* {@code Double.NEGATIVE_INFINITY} is returned.\n", "* If both arguments are 0, the result is {@code NaN}.\n", "*\n", "* @param base Base of the logarithm, must be greater than 0.\n", "* @param x Argument, must be greater than 0.\n", "* @return the value of the logarithm, i.e. the number {@code y} such that\n", "* <code>base<sup>y</sup> = x</code>.\n", "* @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0)\n", "*/\n", "public static double log(double base, double x) {\n", "return log(x) / log(base);\n", "}\n", "\n", "/**\n", "* Power function.  Compute x^y.\n", "*\n", "* @param x   a double\n", "* @param y   a double\n", "* @return double\n", "*/\n", "public static double pow(double x, double y) {\n", "final double lns[] = new double[2];\n", "\n", "if (y == 0.0) {\n", "return 1.0;\n", "}\n", "\n", "if (x != x) { // X is NaN\n", "return x;\n", "}\n", "\n", "\n", "if (x == 0) {\n", "long bits = Double.doubleToLongBits(x);\n", "if ((bits & 0x8000000000000000L) != 0) {\n", "// -zero\n", "long yi = (long) y;\n", "\n", "if (y < 0 && y == yi && (yi & 1) == 1) {\n", "return Double.NEGATIVE_INFINITY;\n", "}\n", "\n", "if (y > 0 && y == yi && (yi & 1) == 1) {\n", "return -0.0;\n", "}\n", "}\n", "\n", "if (y < 0) {\n", "return Double.POSITIVE_INFINITY;\n", "}\n", "if (y > 0) {\n", "return 0.0;\n", "}\n", "\n", "return Double.NaN;\n", "}\n", "\n", "if (x == Double.POSITIVE_INFINITY) {\n", "if (y != y) { // y is NaN\n", "return y;\n", "}\n", "if (y < 0.0) {\n", "return 0.0;\n", "} else {\n", "return Double.POSITIVE_INFINITY;\n", "}\n", "}\n", "\n", "if (y == Double.POSITIVE_INFINITY) {\n", "if (x * x == 1.0) {\n", "return Double.NaN;\n", "}\n", "\n", "if (x * x > 1.0) {\n", "return Double.POSITIVE_INFINITY;\n", "} else {\n", "return 0.0;\n", "}\n", "}\n", "\n", "if (x == Double.NEGATIVE_INFINITY) {\n", "if (y != y) { // y is NaN\n", "return y;\n", "}\n", "\n", "if (y < 0) {\n", "long yi = (long) y;\n", "if (y == yi && (yi & 1) == 1) {\n", "return -0.0;\n", "}\n", "\n", "return 0.0;\n", "}\n", "\n", "if (y > 0)  {\n", "long yi = (long) y;\n", "if (y == yi && (yi & 1) == 1) {\n", "return Double.NEGATIVE_INFINITY;\n", "}\n", "\n", "return Double.POSITIVE_INFINITY;\n", "}\n", "}\n", "\n", "if (y == Double.NEGATIVE_INFINITY) {\n", "\n", "if (x * x == 1.0) {\n", "return Double.NaN;\n", "}\n", "\n", "if (x * x < 1.0) {\n", "return Double.POSITIVE_INFINITY;\n", "} else {\n", "return 0.0;\n", "}\n", "}\n", "\n", "/* Handle special case x<0 */\n", "if (x < 0) {\n", "// y is an even integer in this case\n", "if (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\n", "return pow(-x, y);\n", "}\n", "\n", "if (y == (long) y) {\n", "// If y is an integer\n", "return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n", "} else {\n", "return Double.NaN;\n", "}\n", "}\n", "\n", "/* Split y into ya and yb such that y = ya+yb */\n", "double ya;\n", "double yb;\n", "if (y < 8e298 && y > -8e298) {\n", "double tmp1 = y * HEX_40000000;\n", "ya = y + tmp1 - tmp1;\n", "yb = y - ya;\n", "} else {\n", "double tmp1 = y * 9.31322574615478515625E-10;\n", "double tmp2 = tmp1 * 9.31322574615478515625E-10;\n", "ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n", "yb = y - ya;\n", "}\n", "\n", "/* Compute ln(x) */\n", "final double lores = log(x, lns);\n", "if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n", "return lores;\n", "}\n", "\n", "double lna = lns[0];\n", "double lnb = lns[1];\n", "\n", "/* resplit lns */\n", "double tmp1 = lna * HEX_40000000;\n", "double tmp2 = lna + tmp1 - tmp1;\n", "lnb += lna - tmp2;\n", "lna = tmp2;\n", "\n", "// y*ln(x) = (aa+ab)\n", "final double aa = lna * ya;\n", "final double ab = lna * yb + lnb * ya + lnb * yb;\n", "\n", "lna = aa+ab;\n", "lnb = -(lna - aa - ab);\n", "\n", "double z = 1.0 / 120.0;\n", "z = z * lnb + (1.0 / 24.0);\n", "z = z * lnb + (1.0 / 6.0);\n", "z = z * lnb + 0.5;\n", "z = z * lnb + 1.0;\n", "z = z * lnb;\n", "\n", "final double result = exp(lna, z, null);\n", "//result = result + result * z;\n", "return result;\n", "}\n", "\n", "\n", "/**\n", "* Raise a double to an int power.\n", "*\n", "* @param d Number to raise.\n", "* @param e Exponent.\n", "* @return d<sup>e</sup>\n", "*/\n", "public static double pow(double d, int e) {\n", "\n", "if (e == 0) {\n", "return 1.0;\n", "} else if (e < 0) {\n", "e = -e;\n", "d = 1.0 / d;\n", "}\n", "\n", "// split d as two 26 bits numbers\n", "// beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n", "final int splitFactor = 0x8000001;\n", "final double cd       = splitFactor * d;\n", "final double d1High   = cd - (cd - d);\n", "final double d1Low    = d - d1High;\n", "\n", "// prepare result\n", "double resultHigh = 1;\n", "double resultLow  = 0;\n", "\n", "// d^(2p)\n", "double d2p     = d;\n", "double d2pHigh = d1High;\n", "double d2pLow  = d1Low;\n", "\n", "while (e != 0) {\n", "\n", "if ((e & 0x1) != 0) {\n", "// accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm\n", "// beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n", "final double tmpHigh = resultHigh * d2p;\n", "final double cRH     = splitFactor * resultHigh;\n", "final double rHH     = cRH - (cRH - resultHigh);\n", "final double rHL     = resultHigh - rHH;\n", "final double tmpLow  = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);\n", "resultHigh = tmpHigh;\n", "resultLow  = resultLow * d2p + tmpLow;\n", "}\n", "\n", "// accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm\n", "// beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n", "final double tmpHigh = d2pHigh * d2p;\n", "final double cD2pH   = splitFactor * d2pHigh;\n", "final double d2pHH   = cD2pH - (cD2pH - d2pHigh);\n", "final double d2pHL   = d2pHigh - d2pHH;\n", "final double tmpLow  = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);\n", "final double cTmpH   = splitFactor * tmpHigh;\n", "d2pHigh = cTmpH - (cTmpH - tmpHigh);\n", "d2pLow  = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);\n", "d2p     = d2pHigh + d2pLow;\n", "\n", "e = e >> 1;\n", "\n", "}\n", "\n", "return resultHigh + resultLow;\n", "\n", "}\n", "\n", "/**\n", "*  Computes sin(x) - x, where |x| < 1/16.\n", "*  Use a Remez polynomial approximation.\n", "*  @param x a number smaller than 1/16\n", "*  @return sin(x) - x\n", "*/\n", "private static double polySine(final double x)\n", "{\n", "double x2 = x*x;\n", "\n", "double p = 2.7553817452272217E-6;\n", "p = p * x2 + -1.9841269659586505E-4;\n", "p = p * x2 + 0.008333333333329196;\n", "p = p * x2 + -0.16666666666666666;\n", "//p *= x2;\n", "//p *= x;\n", "p = p * x2 * x;\n", "\n", "return p;\n", "}\n", "\n", "/**\n", "*  Computes cos(x) - 1, where |x| < 1/16.\n", "*  Use a Remez polynomial approximation.\n", "*  @param x a number smaller than 1/16\n", "*  @return cos(x) - 1\n", "*/\n", "private static double polyCosine(double x) {\n", "double x2 = x*x;\n", "\n", "double p = 2.479773539153719E-5;\n", "p = p * x2 + -0.0013888888689039883;\n", "p = p * x2 + 0.041666666666621166;\n", "p = p * x2 + -0.49999999999999994;\n", "p *= x2;\n", "\n", "return p;\n", "}\n", "\n", "/**\n", "*  Compute sine over the first quadrant (0 < x < pi/2).\n", "*  Use combination of table lookup and rational polynomial expansion.\n", "*  @param xa number from which sine is requested\n", "*  @param xb extra bits for x (may be 0.0)\n", "*  @return sin(xa + xb)\n", "*/\n", "private static double sinQ(double xa, double xb) {\n", "int idx = (int) ((xa * 8.0) + 0.5);\n", "final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n", "\n", "// Table lookups\n", "final double sintA = SINE_TABLE_A[idx];\n", "final double sintB = SINE_TABLE_B[idx];\n", "final double costA = COSINE_TABLE_A[idx];\n", "final double costB = COSINE_TABLE_B[idx];\n", "\n", "// Polynomial eval of sin(epsilon), cos(epsilon)\n", "double sinEpsA = epsilon;\n", "double sinEpsB = polySine(epsilon);\n", "final double cosEpsA = 1.0;\n", "final double cosEpsB = polyCosine(epsilon);\n", "\n", "// Split epsilon   xa + xb = x\n", "final double temp = sinEpsA * HEX_40000000;\n", "double temp2 = (sinEpsA + temp) - temp;\n", "sinEpsB +=  sinEpsA - temp2;\n", "sinEpsA = temp2;\n", "\n", "/* Compute sin(x) by angle addition formula */\n", "double result;\n", "\n", "/* Compute the following sum:\n", "*\n", "* result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n", "*          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n", "*\n", "* Ranges of elements\n", "*\n", "* xxxtA   0            PI/2\n", "* xxxtB   -1.5e-9      1.5e-9\n", "* sinEpsA -0.0625      0.0625\n", "* sinEpsB -6e-11       6e-11\n", "* cosEpsA  1.0\n", "* cosEpsB  0           -0.0625\n", "*\n", "*/\n", "\n", "//result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n", "//          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n", "\n", "//result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n", "//result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n", "double a = 0;\n", "double b = 0;\n", "\n", "double t = sintA;\n", "double c = a + t;\n", "double d = -(c - a - t);\n", "a = c;\n", "b = b + d;\n", "\n", "t = costA * sinEpsA;\n", "c = a + t;\n", "d = -(c - a - t);\n", "a = c;\n", "b = b + d;\n", "\n", "b = b + sintA * cosEpsB + costA * sinEpsB;\n", "/*\n", "t = sintA*cosEpsB;\n", "c = a + t;\n", "d = -(c - a - t);\n", "a = c;\n", "b = b + d;\n", "\n", "t = costA*sinEpsB;\n", "c = a + t;\n", "d = -(c - a - t);\n", "a = c;\n", "b = b + d;\n", "*/\n", "\n", "b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n", "/*\n", "t = sintB;\n", "c = a + t;\n", "d = -(c - a - t);\n", "a = c;\n", "b = b + d;\n", "\n", "t = costB*sinEpsA;\n", "c = a + t;\n", "d = -(c - a - t);\n", "a = c;\n", "b = b + d;\n", "\n", "t = sintB*cosEpsB;\n", "c = a + t;\n", "d = -(c - a - t);\n", "a = c;\n", "b = b + d;\n", "\n", "t = costB*sinEpsB;\n", "c = a + t;\n", "d = -(c - a - t);\n", "a = c;\n", "b = b + d;\n", "*/\n", "\n", "if (xb != 0.0) {\n", "t = ((costA + costB) * (cosEpsA + cosEpsB) -\n", "(sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\n", "c = a + t;\n", "d = -(c - a - t);\n", "a = c;\n", "b = b + d;\n", "}\n", "\n", "result = a + b;\n", "\n", "return result;\n", "}\n", "\n", "/**\n", "* Compute cosine in the first quadrant by subtracting input from PI/2 and\n", "* then calling sinQ.  This is more accurate as the input approaches PI/2.\n", "*  @param xa number from which cosine is requested\n", "*  @param xb extra bits for x (may be 0.0)\n", "*  @return cos(xa + xb)\n", "*/\n", "private static double cosQ(double xa, double xb) {\n", "final double pi2a = 1.5707963267948966;\n", "final double pi2b = 6.123233995736766E-17;\n", "\n", "final double a = pi2a - xa;\n", "double b = -(a - pi2a + xa);\n", "b += pi2b - xb;\n", "\n", "return sinQ(a, b);\n", "}\n", "\n", "/**\n", "*  Compute tangent (or cotangent) over the first quadrant.   0 < x < pi/2\n", "*  Use combination of table lookup and rational polynomial expansion.\n", "*  @param xa number from which sine is requested\n", "*  @param xb extra bits for x (may be 0.0)\n", "*  @param cotanFlag if true, compute the cotangent instead of the tangent\n", "*  @return tan(xa+xb) (or cotangent, depending on cotanFlag)\n", "*/\n", "private static double tanQ(double xa, double xb, boolean cotanFlag) {\n", "\n", "int idx = (int) ((xa * 8.0) + 0.5);\n", "final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n", "\n", "// Table lookups\n", "final double sintA = SINE_TABLE_A[idx];\n", "final double sintB = SINE_TABLE_B[idx];\n", "final double costA = COSINE_TABLE_A[idx];\n", "final double costB = COSINE_TABLE_B[idx];\n", "\n", "// Polynomial eval of sin(epsilon), cos(epsilon)\n", "double sinEpsA = epsilon;\n", "double sinEpsB = polySine(epsilon);\n", "final double cosEpsA = 1.0;\n", "final double cosEpsB = polyCosine(epsilon);\n", "\n", "// Split epsilon   xa + xb = x\n", "double temp = sinEpsA * HEX_40000000;\n", "double temp2 = (sinEpsA + temp) - temp;\n", "sinEpsB +=  sinEpsA - temp2;\n", "sinEpsA = temp2;\n", "\n", "/* Compute sin(x) by angle addition formula */\n", "\n", "/* Compute the following sum:\n", "*\n", "* result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n", "*          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n", "*\n", "* Ranges of elements\n", "*\n", "* xxxtA   0            PI/2\n", "* xxxtB   -1.5e-9      1.5e-9\n", "* sinEpsA -0.0625      0.0625\n", "* sinEpsB -6e-11       6e-11\n", "* cosEpsA  1.0\n", "* cosEpsB  0           -0.0625\n", "*\n", "*/\n", "\n", "//result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n", "//          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n", "\n", "//result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n", "//result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n", "double a = 0;\n", "double b = 0;\n", "\n", "// Compute sine\n", "double t = sintA;\n", "double c = a + t;\n", "double d = -(c - a - t);\n", "a = c;\n", "b = b + d;\n", "\n", "t = costA*sinEpsA;\n", "c = a + t;\n", "d = -(c - a - t);\n", "a = c;\n", "b = b + d;\n", "\n", "b = b + sintA*cosEpsB + costA*sinEpsB;\n", "b = b + sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n", "\n", "double sina = a + b;\n", "double sinb = -(sina - a - b);\n", "\n", "// Compute cosine\n", "\n", "a = b = c = d = 0.0;\n", "\n", "t = costA*cosEpsA;\n", "c = a + t;\n", "d = -(c - a - t);\n", "a = c;\n", "b = b + d;\n", "\n", "t = -sintA*sinEpsA;\n", "c = a + t;\n", "d = -(c - a - t);\n", "a = c;\n", "b = b + d;\n", "\n", "b = b + costB*cosEpsA + costA*cosEpsB + costB*cosEpsB;\n", "b = b - (sintB*sinEpsA + sintA*sinEpsB + sintB*sinEpsB);\n", "\n", "double cosa = a + b;\n", "double cosb = -(cosa - a - b);\n", "\n", "if (cotanFlag) {\n", "double tmp;\n", "tmp = cosa; cosa = sina; sina = tmp;\n", "tmp = cosb; cosb = sinb; sinb = tmp;\n", "}\n", "\n", "\n", "/* estimate and correct, compute 1.0/(cosa+cosb) */\n", "/*\n", "double est = (sina+sinb)/(cosa+cosb);\n", "double err = (sina - cosa*est) + (sinb - cosb*est);\n", "est += err/(cosa+cosb);\n", "err = (sina - cosa*est) + (sinb - cosb*est);\n", "*/\n", "\n", "// f(x) = 1/x,   f'(x) = -1/x^2\n", "\n", "double est = sina/cosa;\n", "\n", "/* Split the estimate to get more accurate read on division rounding */\n", "temp = est * HEX_40000000;\n", "double esta = (est + temp) - temp;\n", "double estb =  est - esta;\n", "\n", "temp = cosa * HEX_40000000;\n", "double cosaa = (cosa + temp) - temp;\n", "double cosab =  cosa - cosaa;\n", "\n", "//double err = (sina - est*cosa)/cosa;  // Correction for division rounding\n", "double err = (sina - esta*cosaa - esta*cosab - estb*cosaa - estb*cosab)/cosa;  // Correction for division rounding\n", "err += sinb/cosa;                     // Change in est due to sinb\n", "err += -sina * cosb / cosa / cosa;    // Change in est due to cosb\n", "\n", "if (xb != 0.0) {\n", "// tan' = 1 + tan^2      cot' = -(1 + cot^2)\n", "// Approximate impact of xb\n", "double xbadj = xb + est*est*xb;\n", "if (cotanFlag) {\n", "xbadj = -xbadj;\n", "}\n", "\n", "err += xbadj;\n", "}\n", "\n", "return est+err;\n", "}\n", "\n", "/** Reduce the input argument using the Payne and Hanek method.\n", "*  This is good for all inputs 0.0 < x < inf\n", "*  Output is remainder after dividing by PI/2\n", "*  The result array should contain 3 numbers.\n", "*  result[0] is the integer portion, so mod 4 this gives the quadrant.\n", "*  result[1] is the upper bits of the remainder\n", "*  result[2] is the lower bits of the remainder\n", "*\n", "* @param x number to reduce\n", "* @param result placeholder where to put the result\n", "*/\n", "private static void reducePayneHanek(double x, double result[])\n", "{\n", "/* Convert input double to bits */\n", "long inbits = Double.doubleToLongBits(x);\n", "int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n", "\n", "/* Convert to fixed point representation */\n", "inbits &= 0x000fffffffffffffL;\n", "inbits |= 0x0010000000000000L;\n", "\n", "/* Normalize input to be between 0.5 and 1.0 */\n", "exponent++;\n", "inbits <<= 11;\n", "\n", "/* Based on the exponent, get a shifted copy of recip2pi */\n", "long shpi0;\n", "long shpiA;\n", "long shpiB;\n", "int idx = exponent >> 6;\n", "int shift = exponent - (idx << 6);\n", "\n", "if (shift != 0) {\n", "shpi0 = (idx == 0) ? 0 : (RECIP_2PI[idx-1] << shift);\n", "shpi0 |= RECIP_2PI[idx] >>> (64-shift);\n", "shpiA = (RECIP_2PI[idx] << shift) | (RECIP_2PI[idx+1] >>> (64-shift));\n", "shpiB = (RECIP_2PI[idx+1] << shift) | (RECIP_2PI[idx+2] >>> (64-shift));\n", "} else {\n", "shpi0 = (idx == 0) ? 0 : RECIP_2PI[idx-1];\n", "shpiA = RECIP_2PI[idx];\n", "shpiB = RECIP_2PI[idx+1];\n", "}\n", "\n", "/* Multiply input by shpiA */\n", "long a = inbits >>> 32;\n", "long b = inbits & 0xffffffffL;\n", "\n", "long c = shpiA >>> 32;\n", "long d = shpiA & 0xffffffffL;\n", "\n", "long ac = a * c;\n", "long bd = b * d;\n", "long bc = b * c;\n", "long ad = a * d;\n", "\n", "long prodB = bd + (ad << 32);\n", "long prodA = ac + (ad >>> 32);\n", "\n", "boolean bita = (bd & 0x8000000000000000L) != 0;\n", "boolean bitb = (ad & 0x80000000L ) != 0;\n", "boolean bitsum = (prodB & 0x8000000000000000L) != 0;\n", "\n", "/* Carry */\n", "if ( (bita && bitb) ||\n", "((bita || bitb) && !bitsum) ) {\n", "prodA++;\n", "}\n", "\n", "bita = (prodB & 0x8000000000000000L) != 0;\n", "bitb = (bc & 0x80000000L ) != 0;\n", "\n", "prodB = prodB + (bc << 32);\n", "prodA = prodA + (bc >>> 32);\n", "\n", "bitsum = (prodB & 0x8000000000000000L) != 0;\n", "\n", "/* Carry */\n", "if ( (bita && bitb) ||\n", "((bita || bitb) && !bitsum) ) {\n", "prodA++;\n", "}\n", "\n", "/* Multiply input by shpiB */\n", "c = shpiB >>> 32;\n", "d = shpiB & 0xffffffffL;\n", "ac = a * c;\n", "bc = b * c;\n", "ad = a * d;\n", "\n", "/* Collect terms */\n", "ac = ac + ((bc + ad) >>> 32);\n", "\n", "bita = (prodB & 0x8000000000000000L) != 0;\n", "bitb = (ac & 0x8000000000000000L ) != 0;\n", "prodB += ac;\n", "bitsum = (prodB & 0x8000000000000000L) != 0;\n", "/* Carry */\n", "if ( (bita && bitb) ||\n", "((bita || bitb) && !bitsum) ) {\n", "prodA++;\n", "}\n", "\n", "/* Multiply by shpi0 */\n", "c = shpi0 >>> 32;\n", "d = shpi0 & 0xffffffffL;\n", "\n", "bd = b * d;\n", "bc = b * c;\n", "ad = a * d;\n", "\n", "prodA += bd + ((bc + ad) << 32);\n", "\n", "/*\n", "* prodA, prodB now contain the remainder as a fraction of PI.  We want this as a fraction of\n", "* PI/2, so use the following steps:\n", "* 1.) multiply by 4.\n", "* 2.) do a fixed point muliply by PI/4.\n", "* 3.) Convert to floating point.\n", "* 4.) Multiply by 2\n", "*/\n", "\n", "/* This identifies the quadrant */\n", "int intPart = (int)(prodA >>> 62);\n", "\n", "/* Multiply by 4 */\n", "prodA <<= 2;\n", "prodA |= prodB >>> 62;\n", "prodB <<= 2;\n", "\n", "/* Multiply by PI/4 */\n", "a = prodA >>> 32;\n", "b = prodA & 0xffffffffL;\n", "\n", "c = PI_O_4_BITS[0] >>> 32;\n", "d = PI_O_4_BITS[0] & 0xffffffffL;\n", "\n", "ac = a * c;\n", "bd = b * d;\n", "bc = b * c;\n", "ad = a * d;\n", "\n", "long prod2B = bd + (ad << 32);\n", "long prod2A = ac + (ad >>> 32);\n", "\n", "bita = (bd & 0x8000000000000000L) != 0;\n", "bitb = (ad & 0x80000000L ) != 0;\n", "bitsum = (prod2B & 0x8000000000000000L) != 0;\n", "\n", "/* Carry */\n", "if ( (bita && bitb) ||\n", "((bita || bitb) && !bitsum) ) {\n", "prod2A++;\n", "}\n", "\n", "bita = (prod2B & 0x8000000000000000L) != 0;\n", "bitb = (bc & 0x80000000L ) != 0;\n", "\n", "prod2B = prod2B + (bc << 32);\n", "prod2A = prod2A + (bc >>> 32);\n", "\n", "bitsum = (prod2B & 0x8000000000000000L) != 0;\n", "\n", "/* Carry */\n", "if ( (bita && bitb) ||\n", "((bita || bitb) && !bitsum) ) {\n", "prod2A++;\n", "}\n", "\n", "/* Multiply input by pio4bits[1] */\n", "c = PI_O_4_BITS[1] >>> 32;\n", "d = PI_O_4_BITS[1] & 0xffffffffL;\n", "ac = a * c;\n", "bc = b * c;\n", "ad = a * d;\n", "\n", "/* Collect terms */\n", "ac = ac + ((bc + ad) >>> 32);\n", "\n", "bita = (prod2B & 0x8000000000000000L) != 0;\n", "bitb = (ac & 0x8000000000000000L ) != 0;\n", "prod2B += ac;\n", "bitsum = (prod2B & 0x8000000000000000L) != 0;\n", "/* Carry */\n", "if ( (bita && bitb) ||\n", "((bita || bitb) && !bitsum) ) {\n", "prod2A++;\n", "}\n", "\n", "/* Multiply inputB by pio4bits[0] */\n", "a = prodB >>> 32;\n", "b = prodB & 0xffffffffL;\n", "c = PI_O_4_BITS[0] >>> 32;\n", "d = PI_O_4_BITS[0] & 0xffffffffL;\n", "ac = a * c;\n", "bc = b * c;\n", "ad = a * d;\n", "\n", "/* Collect terms */\n", "ac = ac + ((bc + ad) >>> 32);\n", "\n", "bita = (prod2B & 0x8000000000000000L) != 0;\n", "bitb = (ac & 0x8000000000000000L ) != 0;\n", "prod2B += ac;\n", "bitsum = (prod2B & 0x8000000000000000L) != 0;\n", "/* Carry */\n", "if ( (bita && bitb) ||\n", "((bita || bitb) && !bitsum) ) {\n", "prod2A++;\n", "}\n", "\n", "/* Convert to double */\n", "double tmpA = (prod2A >>> 12) / TWO_POWER_52;  // High order 52 bits\n", "double tmpB = (((prod2A & 0xfffL) << 40) + (prod2B >>> 24)) / TWO_POWER_52 / TWO_POWER_52; // Low bits\n", "\n", "double sumA = tmpA + tmpB;\n", "double sumB = -(sumA - tmpA - tmpB);\n", "\n", "/* Multiply by PI/2 and return */\n", "result[0] = intPart;\n", "result[1] = sumA * 2.0;\n", "result[2] = sumB * 2.0;\n", "}\n", "\n", "/**\n", "* Sine function.\n", "*\n", "* @param x Argument.\n", "* @return sin(x)\n", "*/\n", "public static double sin(double x) {\n", "boolean negative = false;\n", "int quadrant = 0;\n", "double xa;\n", "double xb = 0.0;\n", "\n", "/* Take absolute value of the input */\n", "xa = x;\n", "if (x < 0) {\n", "negative = true;\n", "xa = -xa;\n", "}\n", "\n", "/* Check for zero and negative zero */\n", "if (xa == 0.0) {\n", "long bits = Double.doubleToLongBits(x);\n", "if (bits < 0) {\n", "return -0.0;\n", "}\n", "return 0.0;\n", "}\n", "\n", "if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n", "return Double.NaN;\n", "}\n", "\n", "/* Perform any argument reduction */\n", "if (xa > 3294198.0) {\n", "// PI * (2**20)\n", "// Argument too big for CodyWaite reduction.  Must use\n", "// PayneHanek.\n", "double reduceResults[] = new double[3];\n", "reducePayneHanek(xa, reduceResults);\n", "quadrant = ((int) reduceResults[0]) & 3;\n", "xa = reduceResults[1];\n", "xb = reduceResults[2];\n", "} else if (xa > 1.5707963267948966) {\n", "final CodyWaite cw = new CodyWaite(xa, xb);\n", "quadrant = cw.getK() & 3;\n", "xa = cw.getRemA();\n", "xb = cw.getRemB();\n", "}\n", "\n", "if (negative) {\n", "quadrant ^= 2;  // Flip bit 1\n", "}\n", "\n", "switch (quadrant) {\n", "case 0:\n", "return sinQ(xa, xb);\n", "case 1:\n", "return cosQ(xa, xb);\n", "case 2:\n", "return -sinQ(xa, xb);\n", "case 3:\n", "return -cosQ(xa, xb);\n", "default:\n", "return Double.NaN;\n", "}\n", "}\n", "\n", "/**\n", "* Cosine function.\n", "*\n", "* @param x Argument.\n", "* @return cos(x)\n", "*/\n", "public static double cos(double x) {\n", "int quadrant = 0;\n", "\n", "/* Take absolute value of the input */\n", "double xa = x;\n", "if (x < 0) {\n", "xa = -xa;\n", "}\n", "\n", "if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n", "return Double.NaN;\n", "}\n", "\n", "/* Perform any argument reduction */\n", "double xb = 0;\n", "if (xa > 3294198.0) {\n", "// PI * (2**20)\n", "// Argument too big for CodyWaite reduction.  Must use\n", "// PayneHanek.\n", "double reduceResults[] = new double[3];\n", "reducePayneHanek(xa, reduceResults);\n", "quadrant = ((int) reduceResults[0]) & 3;\n", "xa = reduceResults[1];\n", "xb = reduceResults[2];\n", "} else if (xa > 1.5707963267948966) {\n", "final CodyWaite cw = new CodyWaite(xa, xb);\n", "quadrant = cw.getK() & 3;\n", "xa = cw.getRemA();\n", "xb = cw.getRemB();\n", "}\n", "\n", "//if (negative)\n", "//  quadrant = (quadrant + 2) % 4;\n", "\n", "switch (quadrant) {\n", "case 0:\n", "return cosQ(xa, xb);\n", "case 1:\n", "return -sinQ(xa, xb);\n", "case 2:\n", "return -cosQ(xa, xb);\n", "case 3:\n", "return sinQ(xa, xb);\n", "default:\n", "return Double.NaN;\n", "}\n", "}\n", "\n", "/**\n", "* Tangent function.\n", "*\n", "* @param x Argument.\n", "* @return tan(x)\n", "*/\n", "public static double tan(double x) {\n", "boolean negative = false;\n", "int quadrant = 0;\n", "\n", "/* Take absolute value of the input */\n", "double xa = x;\n", "if (x < 0) {\n", "negative = true;\n", "xa = -xa;\n", "}\n", "\n", "/* Check for zero and negative zero */\n", "if (xa == 0.0) {\n", "long bits = Double.doubleToLongBits(x);\n", "if (bits < 0) {\n", "return -0.0;\n", "}\n", "return 0.0;\n", "}\n", "\n", "if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n", "return Double.NaN;\n", "}\n", "\n", "/* Perform any argument reduction */\n", "double xb = 0;\n", "if (xa > 3294198.0) {\n", "// PI * (2**20)\n", "// Argument too big for CodyWaite reduction.  Must use\n", "// PayneHanek.\n", "double reduceResults[] = new double[3];\n", "reducePayneHanek(xa, reduceResults);\n", "quadrant = ((int) reduceResults[0]) & 3;\n", "xa = reduceResults[1];\n", "xb = reduceResults[2];\n", "} else if (xa > 1.5707963267948966) {\n", "final CodyWaite cw = new CodyWaite(xa, xb);\n", "quadrant = cw.getK() & 3;\n", "xa = cw.getRemA();\n", "xb = cw.getRemB();\n", "}\n", "\n", "if (xa > 1.5) {\n", "// Accuracy suffers between 1.5 and PI/2\n", "final double pi2a = 1.5707963267948966;\n", "final double pi2b = 6.123233995736766E-17;\n", "\n", "final double a = pi2a - xa;\n", "double b = -(a - pi2a + xa);\n", "b += pi2b - xb;\n", "\n", "xa = a + b;\n", "xb = -(xa - a - b);\n", "quadrant ^= 1;\n", "negative ^= true;\n", "}\n", "\n", "double result;\n", "if ((quadrant & 1) == 0) {\n", "result = tanQ(xa, xb, false);\n", "} else {\n", "result = -tanQ(xa, xb, true);\n", "}\n", "\n", "if (negative) {\n", "result = -result;\n", "}\n", "\n", "return result;\n", "}\n", "\n", "/**\n", "* Arctangent function\n", "*  @param x a number\n", "*  @return atan(x)\n", "*/\n", "public static double atan(double x) {\n", "return atan(x, 0.0, false);\n", "}\n", "\n", "/** Internal helper function to compute arctangent.\n", "* @param xa number from which arctangent is requested\n", "* @param xb extra bits for x (may be 0.0)\n", "* @param leftPlane if true, result angle must be put in the left half plane\n", "* @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)\n", "*/\n", "private static double atan(double xa, double xb, boolean leftPlane) {\n", "boolean negate = false;\n", "int idx;\n", "\n", "if (xa == 0.0) { // Matches +/- 0.0; return correct sign\n", "return leftPlane ? copySign(Math.PI, xa) : xa;\n", "}\n", "\n", "if (xa < 0) {\n", "// negative\n", "xa = -xa;\n", "xb = -xb;\n", "negate = true;\n", "}\n", "\n", "if (xa > 1.633123935319537E16) { // Very large input\n", "return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);\n", "}\n", "\n", "/* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */\n", "if (xa < 1) {\n", "idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n", "} else {\n", "final double oneOverXa = 1 / xa;\n", "idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);\n", "}\n", "double epsA = xa - TANGENT_TABLE_A[idx];\n", "double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);\n", "epsB += xb - TANGENT_TABLE_B[idx];\n", "\n", "double temp = epsA + epsB;\n", "epsB = -(temp - epsA - epsB);\n", "epsA = temp;\n", "\n", "/* Compute eps = eps / (1.0 + xa*tangent) */\n", "temp = xa * HEX_40000000;\n", "double ya = xa + temp - temp;\n", "double yb = xb + xa - ya;\n", "xa = ya;\n", "xb += yb;\n", "\n", "//if (idx > 8 || idx == 0)\n", "if (idx == 0) {\n", "/* If the slope of the arctan is gentle enough (< 0.45), this approximation will suffice */\n", "//double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);\n", "final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n", "//double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);\n", "ya = epsA * denom;\n", "yb = epsB * denom;\n", "} else {\n", "double temp2 = xa * TANGENT_TABLE_A[idx];\n", "double za = 1d + temp2;\n", "double zb = -(za - 1d - temp2);\n", "temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\n", "temp = za + temp2;\n", "zb += -(temp - za - temp2);\n", "za = temp;\n", "\n", "zb += xb * TANGENT_TABLE_B[idx];\n", "ya = epsA / za;\n", "\n", "temp = ya * HEX_40000000;\n", "final double yaa = (ya + temp) - temp;\n", "final double yab = ya - yaa;\n", "\n", "temp = za * HEX_40000000;\n", "final double zaa = (za + temp) - temp;\n", "final double zab = za - zaa;\n", "\n", "/* Correct for rounding in division */\n", "yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n", "\n", "yb += -epsA * zb / za / za;\n", "yb += epsB / za;\n", "}\n", "\n", "\n", "epsA = ya;\n", "epsB = yb;\n", "\n", "/* Evaluate polynomial */\n", "final double epsA2 = epsA * epsA;\n", "\n", "/*\n", "yb = -0.09001346640161823;\n", "yb = yb * epsA2 + 0.11110718400605211;\n", "yb = yb * epsA2 + -0.1428571349122913;\n", "yb = yb * epsA2 + 0.19999999999273194;\n", "yb = yb * epsA2 + -0.33333333333333093;\n", "yb = yb * epsA2 * epsA;\n", "*/\n", "\n", "yb = 0.07490822288864472;\n", "yb = yb * epsA2 + -0.09088450866185192;\n", "yb = yb * epsA2 + 0.11111095942313305;\n", "yb = yb * epsA2 + -0.1428571423679182;\n", "yb = yb * epsA2 + 0.19999999999923582;\n", "yb = yb * epsA2 + -0.33333333333333287;\n", "yb = yb * epsA2 * epsA;\n", "\n", "\n", "ya = epsA;\n", "\n", "temp = ya + yb;\n", "yb = -(temp - ya - yb);\n", "ya = temp;\n", "\n", "/* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */\n", "yb += epsB / (1d + epsA * epsA);\n", "\n", "//result = yb + eighths[idx] + ya;\n", "double za = EIGHTHS[idx] + ya;\n", "double zb = -(za - EIGHTHS[idx] - ya);\n", "temp = za + yb;\n", "zb += -(temp - za - yb);\n", "za = temp;\n", "\n", "double result = za + zb;\n", "double resultb = -(result - za - zb);\n", "\n", "if (leftPlane) {\n", "// Result is in the left plane\n", "final double pia = 1.5707963267948966 * 2;\n", "final double pib = 6.123233995736766E-17 * 2;\n", "\n", "za = pia - result;\n", "zb = -(za - pia + result);\n", "zb += pib - resultb;\n", "\n", "result = za + zb;\n", "resultb = -(result - za - zb);\n", "}\n", "\n", "\n", "if (negate ^ leftPlane) {\n", "result = -result;\n", "}\n", "\n", "return result;\n", "}\n", "\n", "/**\n", "* Two arguments arctangent function\n", "* @param y ordinate\n", "* @param x abscissa\n", "* @return phase angle of point (x,y) between {@code -PI} and {@code PI}\n", "*/\n", "public static double atan2(double y, double x) {\n", "if (x != x || y != y) {\n", "return Double.NaN;\n", "}\n", "\n", "if (y == 0) {\n", "final double result = x * y;\n", "final double invx = 1d / x;\n", "final double invy = 1d / y;\n", "\n", "if (invx == 0) { // X is infinite\n", "if (x > 0) {\n", "return y; // return +/- 0.0\n", "} else {\n", "return copySign(Math.PI, y);\n", "}\n", "}\n", "\n", "if (x < 0 || invx < 0) {\n", "if (y < 0 || invy < 0) {\n", "return -Math.PI;\n", "} else {\n", "return Math.PI;\n", "}\n", "} else {\n", "return result;\n", "}\n", "}\n", "\n", "// y cannot now be zero\n", "\n", "if (y == Double.POSITIVE_INFINITY) {\n", "if (x == Double.POSITIVE_INFINITY) {\n", "return Math.PI * F_1_4;\n", "}\n", "\n", "if (x == Double.NEGATIVE_INFINITY) {\n", "return Math.PI * F_3_4;\n", "}\n", "\n", "return Math.PI * F_1_2;\n", "}\n", "\n", "if (y == Double.NEGATIVE_INFINITY) {\n", "if (x == Double.POSITIVE_INFINITY) {\n", "return -Math.PI * F_1_4;\n", "}\n", "\n", "if (x == Double.NEGATIVE_INFINITY) {\n", "return -Math.PI * F_3_4;\n", "}\n", "\n", "return -Math.PI * F_1_2;\n", "}\n", "\n", "if (x == Double.POSITIVE_INFINITY) {\n", "if (y > 0 || 1 / y > 0) {\n", "return 0d;\n", "}\n", "\n", "if (y < 0 || 1 / y < 0) {\n", "return -0d;\n", "}\n", "}\n", "\n", "if (x == Double.NEGATIVE_INFINITY)\n", "{\n", "if (y > 0.0 || 1 / y > 0.0) {\n", "return Math.PI;\n", "}\n", "\n", "if (y < 0 || 1 / y < 0) {\n", "return -Math.PI;\n", "}\n", "}\n", "\n", "// Neither y nor x can be infinite or NAN here\n", "\n", "if (x == 0) {\n", "if (y > 0 || 1 / y > 0) {\n", "return Math.PI * F_1_2;\n", "}\n", "\n", "if (y < 0 || 1 / y < 0) {\n", "return -Math.PI * F_1_2;\n", "}\n", "}\n", "\n", "// Compute ratio r = y/x\n", "final double r = y / x;\n", "if (Double.isInfinite(r)) { // bypass calculations that can create NaN\n", "return atan(r, 0, x < 0);\n", "}\n", "\n", "double ra = doubleHighPart(r);\n", "double rb = r - ra;\n", "\n", "// Split x\n", "final double xa = doubleHighPart(x);\n", "final double xb = x - xa;\n", "\n", "rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n", "\n", "final double temp = ra + rb;\n", "rb = -(temp - ra - rb);\n", "ra = temp;\n", "\n", "if (ra == 0) { // Fix up the sign so atan works correctly\n", "ra = copySign(0d, y);\n", "}\n", "\n", "// Call atan\n", "final double result = atan(ra, rb, x < 0);\n", "\n", "return result;\n", "}\n", "\n", "/** Compute the arc sine of a number.\n", "* @param x number on which evaluation is done\n", "* @return arc sine of x\n", "*/\n", "public static double asin(double x) {\n", "if (x != x) {\n", "return Double.NaN;\n", "}\n", "\n", "if (x > 1.0 || x < -1.0) {\n", "return Double.NaN;\n", "}\n", "\n", "if (x == 1.0) {\n", "return Math.PI/2.0;\n", "}\n", "\n", "if (x == -1.0) {\n", "return -Math.PI/2.0;\n", "}\n", "\n", "if (x == 0.0) { // Matches +/- 0.0; return correct sign\n", "return x;\n", "}\n", "\n", "/* Compute asin(x) = atan(x/sqrt(1-x*x)) */\n", "\n", "/* Split x */\n", "double temp = x * HEX_40000000;\n", "final double xa = x + temp - temp;\n", "final double xb = x - xa;\n", "\n", "/* Square it */\n", "double ya = xa*xa;\n", "double yb = xa*xb*2.0 + xb*xb;\n", "\n", "/* Subtract from 1 */\n", "ya = -ya;\n", "yb = -yb;\n", "\n", "double za = 1.0 + ya;\n", "double zb = -(za - 1.0 - ya);\n", "\n", "temp = za + yb;\n", "zb += -(temp - za - yb);\n", "za = temp;\n", "\n", "/* Square root */\n", "double y;\n", "y = sqrt(za);\n", "temp = y * HEX_40000000;\n", "ya = y + temp - temp;\n", "yb = y - ya;\n", "\n", "/* Extend precision of sqrt */\n", "yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n", "\n", "/* Contribution of zb to sqrt */\n", "double dx = zb / (2.0*y);\n", "\n", "// Compute ratio r = x/y\n", "double r = x/y;\n", "temp = r * HEX_40000000;\n", "double ra = r + temp - temp;\n", "double rb = r - ra;\n", "\n", "rb += (x - ra*ya - ra*yb - rb*ya - rb*yb) / y;  // Correct for rounding in division\n", "rb += -x * dx / y / y;  // Add in effect additional bits of sqrt.\n", "\n", "temp = ra + rb;\n", "rb = -(temp - ra - rb);\n", "ra = temp;\n", "\n", "return atan(ra, rb, false);\n", "}\n", "\n", "/** Compute the arc cosine of a number.\n", "* @param x number on which evaluation is done\n", "* @return arc cosine of x\n", "*/\n", "public static double acos(double x) {\n", "if (x != x) {\n", "return Double.NaN;\n", "}\n", "\n", "if (x > 1.0 || x < -1.0) {\n", "return Double.NaN;\n", "}\n", "\n", "if (x == -1.0) {\n", "return Math.PI;\n", "}\n", "\n", "if (x == 1.0) {\n", "return 0.0;\n", "}\n", "\n", "if (x == 0) {\n", "return Math.PI/2.0;\n", "}\n", "\n", "/* Compute acos(x) = atan(sqrt(1-x*x)/x) */\n", "\n", "/* Split x */\n", "double temp = x * HEX_40000000;\n", "final double xa = x + temp - temp;\n", "final double xb = x - xa;\n", "\n", "/* Square it */\n", "double ya = xa*xa;\n", "double yb = xa*xb*2.0 + xb*xb;\n", "\n", "/* Subtract from 1 */\n", "ya = -ya;\n", "yb = -yb;\n", "\n", "double za = 1.0 + ya;\n", "double zb = -(za - 1.0 - ya);\n", "\n", "temp = za + yb;\n", "zb += -(temp - za - yb);\n", "za = temp;\n", "\n", "/* Square root */\n", "double y = sqrt(za);\n", "temp = y * HEX_40000000;\n", "ya = y + temp - temp;\n", "yb = y - ya;\n", "\n", "/* Extend precision of sqrt */\n", "yb += (za - ya*ya - 2*ya*yb - yb*yb) / (2.0*y);\n", "\n", "/* Contribution of zb to sqrt */\n", "yb += zb / (2.0*y);\n", "y = ya+yb;\n", "yb = -(y - ya - yb);\n", "\n", "// Compute ratio r = y/x\n", "double r = y/x;\n", "\n", "// Did r overflow?\n", "if (Double.isInfinite(r)) { // x is effectively zero\n", "return Math.PI/2; // so return the appropriate value\n", "}\n", "\n", "double ra = doubleHighPart(r);\n", "double rb = r - ra;\n", "\n", "rb += (y - ra*xa - ra*xb - rb*xa - rb*xb) / x;  // Correct for rounding in division\n", "rb += yb / x;  // Add in effect additional bits of sqrt.\n", "\n", "temp = ra + rb;\n", "rb = -(temp - ra - rb);\n", "ra = temp;\n", "\n", "return atan(ra, rb, x<0);\n", "}\n", "\n", "/** Compute the cubic root of a number.\n", "* @param x number on which evaluation is done\n", "* @return cubic root of x\n", "*/\n", "public static double cbrt(double x) {\n", "/* Convert input double to bits */\n", "long inbits = Double.doubleToLongBits(x);\n", "int exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n", "boolean subnormal = false;\n", "\n", "if (exponent == -1023) {\n", "if (x == 0) {\n", "return x;\n", "}\n", "\n", "/* Subnormal, so normalize */\n", "subnormal = true;\n", "x *= 1.8014398509481984E16;  // 2^54\n", "inbits = Double.doubleToLongBits(x);\n", "exponent = (int) ((inbits >> 52) & 0x7ff) - 1023;\n", "}\n", "\n", "if (exponent == 1024) {\n", "// Nan or infinity.  Don't care which.\n", "return x;\n", "}\n", "\n", "/* Divide the exponent by 3 */\n", "int exp3 = exponent / 3;\n", "\n", "/* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\n", "double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) |\n", "(long)(((exp3 + 1023) & 0x7ff)) << 52);\n", "\n", "/* This will be a number between 1 and 2 */\n", "final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n", "\n", "/* Estimate the cube root of mant by polynomial */\n", "double est = -0.010714690733195933;\n", "est = est * mant + 0.0875862700108075;\n", "est = est * mant + -0.3058015757857271;\n", "est = est * mant + 0.7249995199969751;\n", "est = est * mant + 0.5039018405998233;\n", "\n", "est *= CBRTTWO[exponent % 3 + 2];\n", "\n", "// est should now be good to about 15 bits of precision.   Do 2 rounds of\n", "// Newton's method to get closer,  this should get us full double precision\n", "// Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n", "final double xs = x / (p2*p2*p2);\n", "est += (xs - est*est*est) / (3*est*est);\n", "est += (xs - est*est*est) / (3*est*est);\n", "\n", "// Do one round of Newton's method in extended precision to get the last bit right.\n", "double temp = est * HEX_40000000;\n", "double ya = est + temp - temp;\n", "double yb = est - ya;\n", "\n", "double za = ya * ya;\n", "double zb = ya * yb * 2.0 + yb * yb;\n", "temp = za * HEX_40000000;\n", "double temp2 = za + temp - temp;\n", "zb += za - temp2;\n", "za = temp2;\n", "\n", "zb = za * yb + ya * zb + zb * yb;\n", "za = za * ya;\n", "\n", "double na = xs - za;\n", "double nb = -(na - xs + za);\n", "nb -= zb;\n", "\n", "est += (na+nb)/(3*est*est);\n", "\n", "/* Scale by a power of two, so this is exact. */\n", "est *= p2;\n", "\n", "if (subnormal) {\n", "est *= 3.814697265625E-6;  // 2^-18\n", "}\n", "\n", "return est;\n", "}\n", "\n", "/**\n", "*  Convert degrees to radians, with error of less than 0.5 ULP\n", "*  @param x angle in degrees\n", "*  @return x converted into radians\n", "*/\n", "public static double toRadians(double x)\n", "{\n", "if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign\n", "return x;\n", "}\n", "\n", "// These are PI/180 split into high and low order bits\n", "final double facta = 0.01745329052209854;\n", "final double factb = 1.997844754509471E-9;\n", "\n", "double xa = doubleHighPart(x);\n", "double xb = x - xa;\n", "\n", "double result = xb * factb + xb * facta + xa * factb + xa * facta;\n", "if (result == 0) {\n", "result = result * x; // ensure correct sign if calculation underflows\n", "}\n", "return result;\n", "}\n", "\n", "/**\n", "*  Convert radians to degrees, with error of less than 0.5 ULP\n", "*  @param x angle in radians\n", "*  @return x converted into degrees\n", "*/\n", "public static double toDegrees(double x)\n", "{\n", "if (Double.isInfinite(x) || x == 0.0) { // Matches +/- 0.0; return correct sign\n", "return x;\n", "}\n", "\n", "// These are 180/PI split into high and low order bits\n", "final double facta = 57.2957763671875;\n", "final double factb = 3.145894820876798E-6;\n", "\n", "double xa = doubleHighPart(x);\n", "double xb = x - xa;\n", "\n", "return xb * factb + xb * facta + xa * factb + xa * facta;\n", "}\n", "\n", "/**\n", "* Absolute value.\n", "* @param x number from which absolute value is requested\n", "* @return abs(x)\n", "*/\n", "public static int abs(final int x) {\n", "return (x < 0) ? -x : x;\n", "}\n", "\n", "/**\n", "* Absolute value.\n", "* @param x number from which absolute value is requested\n", "* @return abs(x)\n", "*/\n", "public static long abs(final long x) {\n", "return (x < 0l) ? -x : x;\n", "}\n", "\n", "/**\n", "* Absolute value.\n", "* @param x number from which absolute value is requested\n", "* @return abs(x)\n", "*/\n", "public static float abs(final float x) {\n", "return (x < 0.0f) ? -x : (x == 0.0f) ? 0.0f : x; // -0.0 => +0.0\n", "}\n", "\n", "/**\n", "* Absolute value.\n", "* @param x number from which absolute value is requested\n", "* @return abs(x)\n", "*/\n", "public static double abs(double x) {\n", "return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n", "}\n", "\n", "/**\n", "* Compute least significant bit (Unit in Last Position) for a number.\n", "* @param x number from which ulp is requested\n", "* @return ulp(x)\n", "*/\n", "public static double ulp(double x) {\n", "if (Double.isInfinite(x)) {\n", "return Double.POSITIVE_INFINITY;\n", "}\n", "return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n", "}\n", "\n", "/**\n", "* Compute least significant bit (Unit in Last Position) for a number.\n", "* @param x number from which ulp is requested\n", "* @return ulp(x)\n", "*/\n", "public static float ulp(float x) {\n", "if (Float.isInfinite(x)) {\n", "return Float.POSITIVE_INFINITY;\n", "}\n", "return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));\n", "}\n", "\n", "/**\n", "* Multiply a double number by a power of 2.\n", "* @param d number to multiply\n", "* @param n power of 2\n", "* @return d &times; 2<sup>n</sup>\n", "*/\n", "public static double scalb(final double d, final int n) {\n", "\n", "// first simple and fast handling when 2^n can be represented using normal numbers\n", "if ((n > -1023) && (n < 1024)) {\n", "return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n", "}\n", "\n", "// handle special cases\n", "if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n", "return d;\n", "}\n", "if (n < -2098) {\n", "return (d > 0) ? 0.0 : -0.0;\n", "}\n", "if (n > 2097) {\n", "return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n", "}\n", "\n", "// decompose d\n", "final long bits = Double.doubleToLongBits(d);\n", "final long sign = bits & 0x8000000000000000L;\n", "int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n", "long mantissa   = bits & 0x000fffffffffffffL;\n", "\n", "// compute scaled exponent\n", "int scaledExponent = exponent + n;\n", "\n", "if (n < 0) {\n", "// we are really in the case n <= -1023\n", "if (scaledExponent > 0) {\n", "// both the input and the result are normal numbers, we only adjust the exponent\n", "return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n", "} else if (scaledExponent > -53) {\n", "// the input is a normal number and the result is a subnormal number\n", "\n", "// recover the hidden mantissa bit\n", "mantissa = mantissa | (1L << 52);\n", "\n", "// scales down complete mantissa, hence losing least significant bits\n", "final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n", "mantissa = mantissa >>> (1 - scaledExponent);\n", "if (mostSignificantLostBit != 0) {\n", "// we need to add 1 bit to round up the result\n", "mantissa++;\n", "}\n", "return Double.longBitsToDouble(sign | mantissa);\n", "\n", "} else {\n", "// no need to compute the mantissa, the number scales down to 0\n", "return (sign == 0L) ? 0.0 : -0.0;\n", "}\n", "} else {\n", "// we are really in the case n >= 1024\n", "if (exponent == 0) {\n", "\n", "// the input number is subnormal, normalize it\n", "while ((mantissa >>> 52) != 1) {\n", "mantissa = mantissa << 1;\n", "--scaledExponent;\n", "}\n", "++scaledExponent;\n", "mantissa = mantissa & 0x000fffffffffffffL;\n", "\n", "if (scaledExponent < 2047) {\n", "return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n", "} else {\n", "return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n", "}\n", "\n", "} else if (scaledExponent < 2047) {\n", "return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n", "} else {\n", "return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n", "}\n", "}\n", "\n", "}\n", "\n", "/**\n", "* Multiply a float number by a power of 2.\n", "* @param f number to multiply\n", "* @param n power of 2\n", "* @return f &times; 2<sup>n</sup>\n", "*/\n", "public static float scalb(final float f, final int n) {\n", "\n", "// first simple and fast handling when 2^n can be represented using normal numbers\n", "if ((n > -127) && (n < 128)) {\n", "return f * Float.intBitsToFloat((n + 127) << 23);\n", "}\n", "\n", "// handle special cases\n", "if (Float.isNaN(f) || Float.isInfinite(f) || (f == 0f)) {\n", "return f;\n", "}\n", "if (n < -277) {\n", "return (f > 0) ? 0.0f : -0.0f;\n", "}\n", "if (n > 276) {\n", "return (f > 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n", "}\n", "\n", "// decompose f\n", "final int bits = Float.floatToIntBits(f);\n", "final int sign = bits & 0x80000000;\n", "int  exponent  = (bits >>> 23) & 0xff;\n", "int mantissa   = bits & 0x007fffff;\n", "\n", "// compute scaled exponent\n", "int scaledExponent = exponent + n;\n", "\n", "if (n < 0) {\n", "// we are really in the case n <= -127\n", "if (scaledExponent > 0) {\n", "// both the input and the result are normal numbers, we only adjust the exponent\n", "return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n", "} else if (scaledExponent > -24) {\n", "// the input is a normal number and the result is a subnormal number\n", "\n", "// recover the hidden mantissa bit\n", "mantissa = mantissa | (1 << 23);\n", "\n", "// scales down complete mantissa, hence losing least significant bits\n", "final int mostSignificantLostBit = mantissa & (1 << (-scaledExponent));\n", "mantissa = mantissa >>> (1 - scaledExponent);\n", "if (mostSignificantLostBit != 0) {\n", "// we need to add 1 bit to round up the result\n", "mantissa++;\n", "}\n", "return Float.intBitsToFloat(sign | mantissa);\n", "\n", "} else {\n", "// no need to compute the mantissa, the number scales down to 0\n", "return (sign == 0) ? 0.0f : -0.0f;\n", "}\n", "} else {\n", "// we are really in the case n >= 128\n", "if (exponent == 0) {\n", "\n", "// the input number is subnormal, normalize it\n", "while ((mantissa >>> 23) != 1) {\n", "mantissa = mantissa << 1;\n", "--scaledExponent;\n", "}\n", "++scaledExponent;\n", "mantissa = mantissa & 0x007fffff;\n", "\n", "if (scaledExponent < 255) {\n", "return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n", "} else {\n", "return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n", "}\n", "\n", "} else if (scaledExponent < 255) {\n", "return Float.intBitsToFloat(sign | (scaledExponent << 23) | mantissa);\n", "} else {\n", "return (sign == 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n", "}\n", "}\n", "\n", "}\n", "\n", "/**\n", "* Get the next machine representable number after a number, moving\n", "* in the direction of another number.\n", "* <p>\n", "* The ordering is as follows (increasing):\n", "* <ul>\n", "* <li>-INFINITY</li>\n", "* <li>-MAX_VALUE</li>\n", "* <li>-MIN_VALUE</li>\n", "* <li>-0.0</li>\n", "* <li>+0.0</li>\n", "* <li>+MIN_VALUE</li>\n", "* <li>+MAX_VALUE</li>\n", "* <li>+INFINITY</li>\n", "* <li></li>\n", "* <p>\n", "* If arguments compare equal, then the second argument is returned.\n", "* <p>\n", "* If {@code direction} is greater than {@code d},\n", "* the smallest machine representable number strictly greater than\n", "* {@code d} is returned; if less, then the largest representable number\n", "* strictly less than {@code d} is returned.</p>\n", "* <p>\n", "* If {@code d} is infinite and direction does not\n", "* bring it back to finite numbers, it is returned unchanged.</p>\n", "*\n", "* @param d base number\n", "* @param direction (the only important thing is whether\n", "* {@code direction} is greater or smaller than {@code d})\n", "* @return the next machine representable number in the specified direction\n", "*/\n", "public static double nextAfter(double d, double direction) {\n", "\n", "// handling of some important special cases\n", "if (Double.isNaN(d) || Double.isNaN(direction)) {\n", "return Double.NaN;\n", "} else if (d == direction) {\n", "return direction;\n", "} else if (Double.isInfinite(d)) {\n", "return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n", "} else if (d == 0) {\n", "return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n", "}\n", "// special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n", "// are handled just as normal numbers\n", "\n", "final long bits = Double.doubleToLongBits(d);\n", "final long sign = bits & 0x8000000000000000L;\n", "if ((direction < d) ^ (sign == 0L)) {\n", "return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));\n", "} else {\n", "return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));\n", "}\n", "\n", "}\n", "\n", "/**\n", "* Get the next machine representable number after a number, moving\n", "* in the direction of another number.\n", "* <p>\n", "* The ordering is as follows (increasing):\n", "* <ul>\n", "* <li>-INFINITY</li>\n", "* <li>-MAX_VALUE</li>\n", "* <li>-MIN_VALUE</li>\n", "* <li>-0.0</li>\n", "* <li>+0.0</li>\n", "* <li>+MIN_VALUE</li>\n", "* <li>+MAX_VALUE</li>\n", "* <li>+INFINITY</li>\n", "* <li></li>\n", "* <p>\n", "* If arguments compare equal, then the second argument is returned.\n", "* <p>\n", "* If {@code direction} is greater than {@code f},\n", "* the smallest machine representable number strictly greater than\n", "* {@code f} is returned; if less, then the largest representable number\n", "* strictly less than {@code f} is returned.</p>\n", "* <p>\n", "* If {@code f} is infinite and direction does not\n", "* bring it back to finite numbers, it is returned unchanged.</p>\n", "*\n", "* @param f base number\n", "* @param direction (the only important thing is whether\n", "* {@code direction} is greater or smaller than {@code f})\n", "* @return the next machine representable number in the specified direction\n", "*/\n", "public static float nextAfter(final float f, final double direction) {\n", "\n", "// handling of some important special cases\n", "if (Double.isNaN(f) || Double.isNaN(direction)) {\n", "return Float.NaN;\n", "} else if (f == direction) {\n", "return (float) direction;\n", "} else if (Float.isInfinite(f)) {\n", "return (f < 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n", "} else if (f == 0f) {\n", "return (direction < 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n", "}\n", "// special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n", "// are handled just as normal numbers\n", "\n", "final int bits = Float.floatToIntBits(f);\n", "final int sign = bits & 0x80000000;\n", "if ((direction < f) ^ (sign == 0)) {\n", "return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) + 1));\n", "} else {\n", "return Float.intBitsToFloat(sign | ((bits & 0x7fffffff) - 1));\n", "}\n", "\n", "}\n", "\n", "/** Get the largest whole number smaller than x.\n", "* @param x number from which floor is requested\n", "* @return a double number f such that f is an integer f <= x < f + 1.0\n", "*/\n", "public static double floor(double x) {\n", "long y;\n", "\n", "if (x != x) { // NaN\n", "return x;\n", "}\n", "\n", "if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n", "return x;\n", "}\n", "\n", "y = (long) x;\n", "if (x < 0 && y != x) {\n", "y--;\n", "}\n", "\n", "if (y == 0) {\n", "return x*y;\n", "}\n", "\n", "return y;\n", "}\n", "\n", "/** Get the smallest whole number larger than x.\n", "* @param x number from which ceil is requested\n", "* @return a double number c such that c is an integer c - 1.0 < x <= c\n", "*/\n", "public static double ceil(double x) {\n", "double y;\n", "\n", "if (x != x) { // NaN\n", "return x;\n", "}\n", "\n", "y = floor(x);\n", "if (y == x) {\n", "return y;\n", "}\n", "\n", "y += 1.0;\n", "\n", "if (y == 0) {\n", "return x*y;\n", "}\n", "\n", "return y;\n", "}\n", "\n", "/** Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.\n", "* @param x number from which nearest whole number is requested\n", "* @return a double number r such that r is an integer r - 0.5 <= x <= r + 0.5\n", "*/\n", "public static double rint(double x) {\n", "double y = floor(x);\n", "double d = x - y;\n", "\n", "if (d > 0.5) {\n", "if (y == -1.0) {\n", "return -0.0; // Preserve sign of operand\n", "}\n", "return y+1.0;\n", "}\n", "if (d < 0.5) {\n", "return y;\n", "}\n", "\n", "/* half way, round to even */\n", "long z = (long) y;\n", "return (z & 1) == 0 ? y : y + 1.0;\n", "}\n", "\n", "/** Get the closest long to x.\n", "* @param x number from which closest long is requested\n", "* @return closest long to x\n", "*/\n", "public static long round(double x) {\n", "return (long) floor(x + 0.5);\n", "}\n", "\n", "/** Get the closest int to x.\n", "* @param x number from which closest int is requested\n", "* @return closest int to x\n", "*/\n", "public static int round(final float x) {\n", "return (int) floor(x + 0.5f);\n", "}\n", "\n", "/** Compute the minimum of two values\n", "* @param a first value\n", "* @param b second value\n", "* @return a if a is lesser or equal to b, b otherwise\n", "*/\n", "public static int min(final int a, final int b) {\n", "return (a <= b) ? a : b;\n", "}\n", "\n", "/** Compute the minimum of two values\n", "* @param a first value\n", "* @param b second value\n", "* @return a if a is lesser or equal to b, b otherwise\n", "*/\n", "public static long min(final long a, final long b) {\n", "return (a <= b) ? a : b;\n", "}\n", "\n", "/** Compute the minimum of two values\n", "* @param a first value\n", "* @param b second value\n", "* @return a if a is lesser or equal to b, b otherwise\n", "*/\n", "public static float min(final float a, final float b) {\n", "if (a > b) {\n", "return b;\n", "}\n", "if (a < b) {\n", "return a;\n", "}\n", "/* if either arg is NaN, return NaN */\n", "if (a != b) {\n", "return Float.NaN;\n", "}\n", "/* min(+0.0,-0.0) == -0.0 */\n", "/* 0x80000000 == Float.floatToRawIntBits(-0.0d) */\n", "int bits = Float.floatToRawIntBits(a);\n", "if (bits == 0x80000000) {\n", "return a;\n", "}\n", "return b;\n", "}\n", "\n", "/** Compute the minimum of two values\n", "* @param a first value\n", "* @param b second value\n", "* @return a if a is lesser or equal to b, b otherwise\n", "*/\n", "public static double min(final double a, final double b) {\n", "if (a > b) {\n", "return b;\n", "}\n", "if (a < b) {\n", "return a;\n", "}\n", "/* if either arg is NaN, return NaN */\n", "if (a != b) {\n", "return Double.NaN;\n", "}\n", "/* min(+0.0,-0.0) == -0.0 */\n", "/* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n", "long bits = Double.doubleToRawLongBits(a);\n", "if (bits == 0x8000000000000000L) {\n", "return a;\n", "}\n", "return b;\n", "}\n", "\n", "/** Compute the maximum of two values\n", "* @param a first value\n", "* @param b second value\n", "* @return b if a is lesser or equal to b, a otherwise\n", "*/\n", "public static int max(final int a, final int b) {\n", "return (a <= b) ? b : a;\n", "}\n", "\n", "/** Compute the maximum of two values\n", "* @param a first value\n", "* @param b second value\n", "* @return b if a is lesser or equal to b, a otherwise\n", "*/\n", "public static long max(final long a, final long b) {\n", "return (a <= b) ? b : a;\n", "}\n", "\n", "/** Compute the maximum of two values\n", "* @param a first value\n", "* @param b second value\n", "* @return b if a is lesser or equal to b, a otherwise\n", "*/\n", "public static float max(final float a, final float b) {\n", "if (a > b) {\n", "return a;\n", "}\n", "if (a < b) {\n", "return b;\n", "}\n", "/* if either arg is NaN, return NaN */\n", "if (a != b) {\n", "return Float.NaN;\n", "}\n", "/* min(+0.0,-0.0) == -0.0 */\n", "/* 0x80000000 == Float.floatToRawIntBits(-0.0d) */\n", "int bits = Float.floatToRawIntBits(a);\n", "if (bits == 0x80000000) {\n", "return b;\n", "}\n", "return a;\n", "}\n", "\n", "/** Compute the maximum of two values\n", "* @param a first value\n", "* @param b second value\n", "* @return b if a is lesser or equal to b, a otherwise\n", "*/\n", "public static double max(final double a, final double b) {\n", "if (a > b) {\n", "return a;\n", "}\n", "if (a < b) {\n", "return b;\n", "}\n", "/* if either arg is NaN, return NaN */\n", "if (a != b) {\n", "return Double.NaN;\n", "}\n", "/* min(+0.0,-0.0) == -0.0 */\n", "/* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n", "long bits = Double.doubleToRawLongBits(a);\n", "if (bits == 0x8000000000000000L) {\n", "return b;\n", "}\n", "return a;\n", "}\n", "\n", "/**\n", "* Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n", "* - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>\n", "* avoiding intermediate overflow or underflow.\n", "*\n", "* <ul>\n", "* <li> If either argument is infinite, then the result is positive infinity.</li>\n", "* <li> else, if either argument is NaN then the result is NaN.</li>\n", "* </ul>\n", "*\n", "* @param x a value\n", "* @param y a value\n", "* @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n", "*/\n", "public static double hypot(final double x, final double y) {\n", "if (Double.isInfinite(x) || Double.isInfinite(y)) {\n", "return Double.POSITIVE_INFINITY;\n", "} else if (Double.isNaN(x) || Double.isNaN(y)) {\n", "return Double.NaN;\n", "} else {\n", "\n", "final int expX = getExponent(x);\n", "final int expY = getExponent(y);\n", "if (expX > expY + 27) {\n", "// y is neglectible with respect to x\n", "return abs(x);\n", "} else if (expY > expX + 27) {\n", "// x is neglectible with respect to y\n", "return abs(y);\n", "} else {\n", "\n", "// find an intermediate scale to avoid both overflow and underflow\n", "final int middleExp = (expX + expY) / 2;\n", "\n", "// scale parameters without losing precision\n", "final double scaledX = scalb(x, -middleExp);\n", "final double scaledY = scalb(y, -middleExp);\n", "\n", "// compute scaled hypotenuse\n", "final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);\n", "\n", "// remove scaling\n", "return scalb(scaledH, middleExp);\n", "\n", "}\n", "\n", "}\n", "}\n", "\n", "/**\n", "* Computes the remainder as prescribed by the IEEE 754 standard.\n", "* The remainder value is mathematically equal to {@code x - y*n}\n", "* where {@code n} is the mathematical integer closest to the exact mathematical value\n", "* of the quotient {@code x/y}.\n", "* If two mathematical integers are equally close to {@code x/y} then\n", "* {@code n} is the integer that is even.\n", "* <p>\n", "* <ul>\n", "* <li>If either operand is NaN, the result is NaN.</li>\n", "* <li>If the result is not NaN, the sign of the result equals the sign of the dividend.</li>\n", "* <li>If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.</li>\n", "* <li>If the dividend is finite and the divisor is an infinity, the result equals the dividend.</li>\n", "* <li>If the dividend is a zero and the divisor is finite, the result equals the dividend.</li>\n", "* </ul>\n", "* <p><b>Note:</b> this implementation currently delegates to {@link StrictMath#IEEEremainder}\n", "* @param dividend the number to be divided\n", "* @param divisor the number by which to divide\n", "* @return the remainder, rounded\n", "*/\n", "public static double IEEEremainder(double dividend, double divisor) {\n", "return StrictMath.IEEEremainder(dividend, divisor); // TODO provide our own implementation\n", "}\n", "\n", "/**\n", "* Returns the first argument with the sign of the second argument.\n", "* A NaN {@code sign} argument is treated as positive.\n", "*\n", "* @param magnitude the value to return\n", "* @param sign the sign for the returned value\n", "* @return the magnitude with the same sign as the {@code sign} argument\n", "*/\n", "public static double copySign(double magnitude, double sign){\n", "long m = Double.doubleToLongBits(magnitude);\n", "long s = Double.doubleToLongBits(sign);\n", "if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK\n", "return magnitude;\n", "}\n", "return -magnitude; // flip sign\n", "}\n", "\n", "/**\n", "* Returns the first argument with the sign of the second argument.\n", "* A NaN {@code sign} argument is treated as positive.\n", "*\n", "* @param magnitude the value to return\n", "* @param sign the sign for the returned value\n", "* @return the magnitude with the same sign as the {@code sign} argument\n", "*/\n", "public static float copySign(float magnitude, float sign){\n", "int m = Float.floatToIntBits(magnitude);\n", "int s = Float.floatToIntBits(sign);\n", "if ((m >= 0 && s >= 0) || (m < 0 && s < 0)) { // Sign is currently OK\n", "return magnitude;\n", "}\n", "return -magnitude; // flip sign\n", "}\n", "\n", "/**\n", "* Return the exponent of a double number, removing the bias.\n", "* <p>\n", "* For double numbers of the form 2<sup>x</sup>, the unbiased\n", "* exponent is exactly x.\n", "* </p>\n", "* @param d number from which exponent is requested\n", "* @return exponent for d in IEEE754 representation, without bias\n", "*/\n", "public static int getExponent(final double d) {\n", "return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023;\n", "}\n", "\n", "/**\n", "* Return the exponent of a float number, removing the bias.\n", "* <p>\n", "* For float numbers of the form 2<sup>x</sup>, the unbiased\n", "* exponent is exactly x.\n", "* </p>\n", "* @param f number from which exponent is requested\n", "* @return exponent for d in IEEE754 representation, without bias\n", "*/\n", "public static int getExponent(final float f) {\n", "return ((Float.floatToIntBits(f) >>> 23) & 0xff) - 127;\n", "}\n", "\n", "/**\n", "* Print out contents of arrays, and check the length.\n", "* <p>used to generate the preset arrays originally.</p>\n", "* @param a unused\n", "*/\n", "public static void main(String[] a) {\n", "PrintStream out = System.out;\n", "FastMathCalc.printarray(out, \"EXP_INT_TABLE_A\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_A);\n", "FastMathCalc.printarray(out, \"EXP_INT_TABLE_B\", EXP_INT_TABLE_LEN, ExpIntTable.EXP_INT_TABLE_B);\n", "FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);\n", "FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);\n", "FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT);\n", "FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A);\n", "FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B);\n", "FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A);\n", "FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B);\n", "FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A);\n", "FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B);\n", "}\n", "\n", "/** Enclose large data table in nested static class so it's only loaded on first access. */\n", "private static class ExpIntTable {\n", "/** Exponential evaluated at integer values,\n", "* exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX].\n", "*/\n", "private static final double[] EXP_INT_TABLE_A;\n", "/** Exponential evaluated at integer values,\n", "* exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX]\n", "*/\n", "private static final double[] EXP_INT_TABLE_B;\n", "\n", "static {\n", "if (RECOMPUTE_TABLES_AT_RUNTIME) {\n", "EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN];\n", "EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN];\n", "\n", "final double tmp[] = new double[2];\n", "final double recip[] = new double[2];\n", "\n", "// Populate expIntTable\n", "for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) {\n", "FastMathCalc.expint(i, tmp);\n", "EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0];\n", "EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1];\n", "\n", "if (i != 0) {\n", "// Negative integer powers\n", "FastMathCalc.splitReciprocal(tmp, recip);\n", "EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];\n", "EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];\n", "}\n", "}\n", "} else {\n", "EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA();\n", "EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB();\n", "}\n", "}\n", "}\n", "\n", "/** Enclose large data table in nested static class so it's only loaded on first access. */\n", "private static class ExpFracTable {\n", "/** Exponential over the range of 0 - 1 in increments of 2^-10\n", "* exp(x/1024) =  expFracTableA[x] + expFracTableB[x].\n", "* 1024 = 2^10\n", "*/\n", "private static final double[] EXP_FRAC_TABLE_A;\n", "/** Exponential over the range of 0 - 1 in increments of 2^-10\n", "* exp(x/1024) =  expFracTableA[x] + expFracTableB[x].\n", "*/\n", "private static final double[] EXP_FRAC_TABLE_B;\n", "\n", "static {\n", "if (RECOMPUTE_TABLES_AT_RUNTIME) {\n", "EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN];\n", "EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN];\n", "\n", "final double tmp[] = new double[2];\n", "\n", "// Populate expFracTable\n", "final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1);\n", "for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) {\n", "FastMathCalc.slowexp(i * factor, tmp);\n", "EXP_FRAC_TABLE_A[i] = tmp[0];\n", "EXP_FRAC_TABLE_B[i] = tmp[1];\n", "}\n", "} else {\n", "EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA();\n", "EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB();\n", "}\n", "}\n", "}\n", "\n", "/** Enclose large data table in nested static class so it's only loaded on first access. */\n", "private static class lnMant {\n", "/** Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. */\n", "private static final double[][] LN_MANT;\n", "\n", "static {\n", "if (RECOMPUTE_TABLES_AT_RUNTIME) {\n", "LN_MANT = new double[FastMath.LN_MANT_LEN][];\n", "\n", "// Populate lnMant table\n", "for (int i = 0; i < LN_MANT.length; i++) {\n", "final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );\n", "LN_MANT[i] = FastMathCalc.slowLog(d);\n", "}\n", "} else {\n", "LN_MANT = FastMathLiteralArrays.loadLnMant();\n", "}\n", "}\n", "}\n", "\n", "/** Enclose the Cody/Waite reduction (used in \"sin\", \"cos\" and \"tan\"). */\n", "private static class CodyWaite {\n", "/** k */\n", "private final int finalK;\n", "/** remA */\n", "private final double finalRemA;\n", "/** remB */\n", "private final double finalRemB;\n", "\n", "/**\n", "* @param xa Argument.\n", "* @param xb Argument.\n", "*/\n", "CodyWaite(double xa,\n", "double xb) {\n", "// Estimate k.\n", "//k = (int)(xa / 1.5707963267948966);\n", "int k = (int)(xa * 0.6366197723675814);\n", "\n", "// Compute remainder.\n", "double remA;\n", "double remB;\n", "while (true) {\n", "double a = -k * 1.570796251296997;\n", "remA = xa + a;\n", "remB = -(remA - xa - a);\n", "\n", "a = -k * 7.549789948768648E-8;\n", "double b = remA;\n", "remA = a + b;\n", "remB += -(remA - b - a);\n", "\n", "a = -k * 6.123233995736766E-17;\n", "b = remA;\n", "remA = a + b;\n", "remB += -(remA - b - a);\n", "\n", "if (remA > 0) {\n", "break;\n", "}\n", "\n", "// Remainder is negative, so decrement k and try again.\n", "// This should only happen if the input is very close\n", "// to an even multiple of pi/2.\n", "--k;\n", "}\n", "\n", "this.finalK = k;\n", "this.finalRemA = remA;\n", "this.finalRemB = remB;\n", "}\n", "\n", "/**\n", "* @return k\n", "*/\n", "int getK() {\n", "return finalK;\n", "}\n", "/**\n", "* @return remA\n", "*/\n", "double getRemA() {\n", "return finalRemA;\n", "}\n", "/**\n", "* @return remB\n", "*/\n", "double getRemB() {\n", "return finalRemB;\n", "}\n", "}\n", "}\n"], "faulty_lines": [3], "cluster": 3}, {"pid": "Math", "bid": 16, "method_path": "./dataset/Math/16/FastMath.java", "method": ["public static double cosh(double x) {\n", "if (x != x) {\n", "return x;\n", "}\n", "\n", "// cosh[z] = (exp(z) + exp(-z))/2\n", "\n", "// for numbers with magnitude 20 or so,\n", "// exp(-z) can be ignored in comparison with exp(z)\n", "\n", "if (x > 20) {\n", "// Avoid overflow (MATH-905).\n", "return 0.5 * exp(x);\n", "}\n", "if (x < -20) {\n", "// Avoid overflow (MATH-905).\n", "return 0.5 * exp(-x);\n", "}\n", "\n", "final double hiPrec[] = new double[2];\n", "if (x < 0.0) {\n", "x = -x;\n", "}\n", "exp(x, 0.0, hiPrec);\n", "\n", "double ya = hiPrec[0] + hiPrec[1];\n", "double yb = -(ya - hiPrec[0] - hiPrec[1]);\n", "\n", "double temp = ya * HEX_40000000;\n", "double yaa = ya + temp - temp;\n", "double yab = ya - yaa;\n", "\n", "// recip = 1/y\n", "double recip = 1.0/ya;\n", "temp = recip * HEX_40000000;\n", "double recipa = recip + temp - temp;\n", "double recipb = recip - recipa;\n", "\n", "// Correct for rounding in division\n", "recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n", "// Account for yb\n", "recipb += -yb * recip * recip;\n", "\n", "// y = y + 1/y\n", "temp = ya + recipa;\n", "yb += -(temp - ya - recipa);\n", "ya = temp;\n", "temp = ya + recipb;\n", "yb += -(temp - ya - recipb);\n", "ya = temp;\n", "\n", "double result = ya + yb;\n", "result *= 0.5;\n", "return result;\n", "}\n"], "faulty_lines": [12, 13, 15, 17, 18], "cluster": 9}, {"pid": "Math", "bid": 17, "method_path": "./dataset/Math/17/Dfp.java", "method": ["public Dfp multiply(final int x) {\n", "return multiplyFast(x);\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Math", "bid": 18, "method_path": "./dataset/Math/18/CMAESOptimizer.java", "method": ["public double[] encode(final double[] x) {\n", "if (boundaries == null) {\n", "return x;\n", "}\n", "double[] res = new double[x.length];\n", "for (int i = 0; i < x.length; i++) {\n", "double diff = boundaries[1][i] - boundaries[0][i];\n", "res[i] = (x[i] - boundaries[0][i]) / diff;\n", "}\n", "return res;\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Math", "bid": 18, "method_path": "./dataset/Math/18/CMAESOptimizer.java", "method": ["public double[] decode(final double[] x) {\n", "if (boundaries == null) {\n", "return x;\n", "}\n", "double[] res = new double[x.length];\n", "for (int i = 0; i < x.length; i++) {\n", "double diff = boundaries[1][i] - boundaries[0][i];\n", "res[i] = diff * x[i] + boundaries[0][i];\n", "}\n", "return res;\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Math", "bid": 18, "method_path": "./dataset/Math/18/CMAESOptimizer.java", "method": ["public boolean isFeasible(final double[] x) {\n", "if (boundaries == null) {\n", "return true;\n", "}\n", "\n", "\n", "for (int i = 0; i < x.length; i++) {\n", "if (x[i] < 0) {\n", "return false;\n", "}\n", "if (x[i] > 1.0) {\n", "return false;\n", "}\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [6, 8, 11], "cluster": 4}, {"pid": "Math", "bid": 19, "method_path": "./dataset/Math/19/CMAESOptimizer.java", "method": ["boolean hasInfiniteBounds = false;\n", "if (hasFiniteBounds) {\n", "for (int i = 0; i < lB.length; i++) {\n", "if (Double.isInfinite(lB[i]) ||\n", "Double.isInfinite(uB[i])) {\n", "hasInfiniteBounds = true;\n", "break;\n", "}\n", "}\n", "\n", "if (hasInfiniteBounds) {\n", "// If there is at least one finite bound, none can be infinite,\n", "// because mixed cases are not supported by the current code.\n", "throw new MathUnsupportedOperationException();\n", "} else {\n", "// Convert API to internal handling of boundaries.\n", "boundaries = new double[2][];\n", "boundaries[0] = lB;\n", "boundaries[1] = uB;\n", "\n", "// Abort early if the normalization will overflow (cf. \"encode\" method).\n", "}\n", "} else {\n", "// Convert API to internal handling of boundaries.\n", "boundaries = null;\n", "}\n"], "faulty_lines": [22], "cluster": 2}, {"pid": "Math", "bid": 20, "method_path": "./dataset/Math/20/CMAESOptimizer.java", "method": ["public double[] repairAndDecode(final double[] x) {\n", "return\n", "decode(x);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Math", "bid": 21, "method_path": "./dataset/Math/21/RectangularCholeskyDecomposition.java", "method": ["public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n", "throws NonPositiveDefiniteMatrixException {\n", "\n", "final int order = matrix.getRowDimension();\n", "final double[][] c = matrix.getData();\n", "final double[][] b = new double[order][order];\n", "\n", "int[] swap  = new int[order];\n", "int[] index = new int[order];\n", "for (int i = 0; i < order; ++i) {\n", "index[i] = i;\n", "}\n", "\n", "int r = 0;\n", "for (boolean loop = true; loop;) {\n", "\n", "// find maximal diagonal element\n", "swap[r] = r;\n", "for (int i = r + 1; i < order; ++i) {\n", "int ii  = index[i];\n", "int isi = index[swap[i]];\n", "if (c[ii][ii] > c[isi][isi]) {\n", "swap[r] = i;\n", "}\n", "}\n", "\n", "\n", "// swap elements\n", "if (swap[r] != r) {\n", "int tmp = index[r];\n", "index[r] = index[swap[r]];\n", "index[swap[r]] = tmp;\n", "}\n", "\n", "// check diagonal element\n", "int ir = index[r];\n", "if (c[ir][ir] < small) {\n", "\n", "if (r == 0) {\n", "throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n", "}\n", "\n", "// check remaining diagonal elements\n", "for (int i = r; i < order; ++i) {\n", "if (c[index[i]][index[i]] < -small) {\n", "// there is at least one sufficiently negative diagonal element,\n", "// the symmetric positive semidefinite matrix is wrong\n", "throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n", "}\n", "}\n", "\n", "// all remaining diagonal elements are close to zero, we consider we have\n", "// found the rank of the symmetric positive semidefinite matrix\n", "++r;\n", "loop = false;\n", "\n", "} else {\n", "\n", "// transform the matrix\n", "final double sqrt = FastMath.sqrt(c[ir][ir]);\n", "b[r][r] = sqrt;\n", "final double inverse  = 1 / sqrt;\n", "for (int i = r + 1; i < order; ++i) {\n", "final int ii = index[i];\n", "final double e = inverse * c[ii][ir];\n", "b[i][r] = e;\n", "c[ii][ii] -= e * e;\n", "for (int j = r + 1; j < i; ++j) {\n", "final int ij = index[j];\n", "final double f = c[ii][ij] - e * b[j][r];\n", "c[ii][ij] = f;\n", "c[ij][ii] = f;\n", "}\n", "}\n", "\n", "// prepare next iteration\n", "loop = ++r < order;\n", "}\n", "}\n", "\n", "// build the root matrix\n", "rank = r;\n", "root = MatrixUtils.createRealMatrix(order, r);\n", "for (int i = 0; i < order; ++i) {\n", "for (int j = 0; j < r; ++j) {\n", "root.setEntry(index[i], j, b[i][j]);\n", "}\n", "}\n", "\n", "}\n"], "faulty_lines": [8], "cluster": 9}, {"pid": "Math", "bid": 21, "method_path": "./dataset/Math/21/RectangularCholeskyDecomposition.java", "method": ["public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n", "throws NonPositiveDefiniteMatrixException {\n", "\n", "final int order = matrix.getRowDimension();\n", "final double[][] c = matrix.getData();\n", "final double[][] b = new double[order][order];\n", "\n", "int[] swap  = new int[order];\n", "int[] index = new int[order];\n", "for (int i = 0; i < order; ++i) {\n", "index[i] = i;\n", "}\n", "\n", "int r = 0;\n", "for (boolean loop = true; loop;) {\n", "\n", "// find maximal diagonal element\n", "swap[r] = r;\n", "for (int i = r + 1; i < order; ++i) {\n", "int ii  = index[i];\n", "int isi = index[swap[i]];\n", "if (c[ii][ii] > c[isi][isi]) {\n", "swap[r] = i;\n", "}\n", "}\n", "\n", "\n", "// swap elements\n", "if (swap[r] != r) {\n", "int tmp = index[r];\n", "index[r] = index[swap[r]];\n", "index[swap[r]] = tmp;\n", "}\n", "\n", "// check diagonal element\n", "int ir = index[r];\n", "if (c[ir][ir] < small) {\n", "\n", "if (r == 0) {\n", "throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n", "}\n", "\n", "// check remaining diagonal elements\n", "for (int i = r; i < order; ++i) {\n", "if (c[index[i]][index[i]] < -small) {\n", "// there is at least one sufficiently negative diagonal element,\n", "// the symmetric positive semidefinite matrix is wrong\n", "throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n", "}\n", "}\n", "\n", "// all remaining diagonal elements are close to zero, we consider we have\n", "// found the rank of the symmetric positive semidefinite matrix\n", "++r;\n", "loop = false;\n", "\n", "} else {\n", "\n", "// transform the matrix\n", "final double sqrt = FastMath.sqrt(c[ir][ir]);\n", "b[r][r] = sqrt;\n", "final double inverse  = 1 / sqrt;\n", "for (int i = r + 1; i < order; ++i) {\n", "final int ii = index[i];\n", "final double e = inverse * c[ii][ir];\n", "b[i][r] = e;\n", "c[ii][ii] -= e * e;\n", "for (int j = r + 1; j < i; ++j) {\n", "final int ij = index[j];\n", "final double f = c[ii][ij] - e * b[j][r];\n", "c[ii][ij] = f;\n", "c[ij][ii] = f;\n", "}\n", "}\n", "\n", "// prepare next iteration\n", "loop = ++r < order;\n", "}\n", "}\n", "\n", "// build the root matrix\n", "rank = r;\n", "root = MatrixUtils.createRealMatrix(order, r);\n", "for (int i = 0; i < order; ++i) {\n", "for (int j = 0; j < r; ++j) {\n", "root.setEntry(index[i], j, b[i][j]);\n", "}\n", "}\n", "\n", "}\n"], "faulty_lines": [18, 21, 22, 23, 29, 30, 31, 32], "cluster": 9}, {"pid": "Math", "bid": 21, "method_path": "./dataset/Math/21/RectangularCholeskyDecomposition.java", "method": ["public RectangularCholeskyDecomposition(RealMatrix matrix, double small)\n", "throws NonPositiveDefiniteMatrixException {\n", "\n", "final int order = matrix.getRowDimension();\n", "final double[][] c = matrix.getData();\n", "final double[][] b = new double[order][order];\n", "\n", "int[] swap  = new int[order];\n", "int[] index = new int[order];\n", "for (int i = 0; i < order; ++i) {\n", "index[i] = i;\n", "}\n", "\n", "int r = 0;\n", "for (boolean loop = true; loop;) {\n", "\n", "// find maximal diagonal element\n", "swap[r] = r;\n", "for (int i = r + 1; i < order; ++i) {\n", "int ii  = index[i];\n", "int isi = index[swap[i]];\n", "if (c[ii][ii] > c[isi][isi]) {\n", "swap[r] = i;\n", "}\n", "}\n", "\n", "\n", "// swap elements\n", "if (swap[r] != r) {\n", "int tmp = index[r];\n", "index[r] = index[swap[r]];\n", "index[swap[r]] = tmp;\n", "}\n", "\n", "// check diagonal element\n", "int ir = index[r];\n", "if (c[ir][ir] < small) {\n", "\n", "if (r == 0) {\n", "throw new NonPositiveDefiniteMatrixException(c[ir][ir], ir, small);\n", "}\n", "\n", "// check remaining diagonal elements\n", "for (int i = r; i < order; ++i) {\n", "if (c[index[i]][index[i]] < -small) {\n", "// there is at least one sufficiently negative diagonal element,\n", "// the symmetric positive semidefinite matrix is wrong\n", "throw new NonPositiveDefiniteMatrixException(c[index[i]][index[i]], i, small);\n", "}\n", "}\n", "\n", "// all remaining diagonal elements are close to zero, we consider we have\n", "// found the rank of the symmetric positive semidefinite matrix\n", "++r;\n", "loop = false;\n", "\n", "} else {\n", "\n", "// transform the matrix\n", "final double sqrt = FastMath.sqrt(c[ir][ir]);\n", "b[r][r] = sqrt;\n", "final double inverse  = 1 / sqrt;\n", "for (int i = r + 1; i < order; ++i) {\n", "final int ii = index[i];\n", "final double e = inverse * c[ii][ir];\n", "b[i][r] = e;\n", "c[ii][ii] -= e * e;\n", "for (int j = r + 1; j < i; ++j) {\n", "final int ij = index[j];\n", "final double f = c[ii][ij] - e * b[j][r];\n", "c[ii][ij] = f;\n", "c[ij][ii] = f;\n", "}\n", "}\n", "\n", "// prepare next iteration\n", "loop = ++r < order;\n", "}\n", "}\n", "\n", "// build the root matrix\n", "rank = r;\n", "root = MatrixUtils.createRealMatrix(order, r);\n", "for (int i = 0; i < order; ++i) {\n", "for (int j = 0; j < r; ++j) {\n", "root.setEntry(index[i], j, b[i][j]);\n", "}\n", "}\n", "\n", "}\n"], "faulty_lines": [63, 67], "cluster": 9}, {"pid": "Math", "bid": 22, "method_path": "./dataset/Math/22/FDistribution.java", "method": ["public boolean isSupportLowerBoundInclusive() {\n", "return true;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Math", "bid": 22, "method_path": "./dataset/Math/22/UniformRealDistribution.java", "method": ["public boolean isSupportUpperBoundInclusive() {\n", "return false;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Math", "bid": 23, "method_path": "./dataset/Math/23/BrentOptimizer.java", "method": ["protected UnivariatePointValuePair doOptimize() {\n", "final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n", "final double lo = getMin();\n", "final double mid = getStartValue();\n", "final double hi = getMax();\n", "\n", "// Optional additional convergence criteria.\n", "final ConvergenceChecker<UnivariatePointValuePair> checker\n", "= getConvergenceChecker();\n", "\n", "double a;\n", "double b;\n", "if (lo < hi) {\n", "a = lo;\n", "b = hi;\n", "} else {\n", "a = hi;\n", "b = lo;\n", "}\n", "\n", "double x = mid;\n", "double v = x;\n", "double w = x;\n", "double d = 0;\n", "double e = 0;\n", "double fx = computeObjectiveValue(x);\n", "if (!isMinim) {\n", "fx = -fx;\n", "}\n", "double fv = fx;\n", "double fw = fx;\n", "\n", "UnivariatePointValuePair previous = null;\n", "UnivariatePointValuePair current\n", "= new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n", "// Best point encountered so far (which is the initial guess).\n", "\n", "int iter = 0;\n", "while (true) {\n", "final double m = 0.5 * (a + b);\n", "final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n", "final double tol2 = 2 * tol1;\n", "\n", "// Default stopping criterion.\n", "final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n", "if (!stop) {\n", "double p = 0;\n", "double q = 0;\n", "double r = 0;\n", "double u = 0;\n", "\n", "if (FastMath.abs(e) > tol1) { // Fit parabola.\n", "r = (x - w) * (fx - fv);\n", "q = (x - v) * (fx - fw);\n", "p = (x - v) * q - (x - w) * r;\n", "q = 2 * (q - r);\n", "\n", "if (q > 0) {\n", "p = -p;\n", "} else {\n", "q = -q;\n", "}\n", "\n", "r = e;\n", "e = d;\n", "\n", "if (p > q * (a - x) &&\n", "p < q * (b - x) &&\n", "FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n", "// Parabolic interpolation step.\n", "d = p / q;\n", "u = x + d;\n", "\n", "// f must not be evaluated too close to a or b.\n", "if (u - a < tol2 || b - u < tol2) {\n", "if (x <= m) {\n", "d = tol1;\n", "} else {\n", "d = -tol1;\n", "}\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "\n", "// Update by at least \"tol1\".\n", "if (FastMath.abs(d) < tol1) {\n", "if (d >= 0) {\n", "u = x + tol1;\n", "} else {\n", "u = x - tol1;\n", "}\n", "} else {\n", "u = x + d;\n", "}\n", "\n", "double fu = computeObjectiveValue(u);\n", "if (!isMinim) {\n", "fu = -fu;\n", "}\n", "\n", "// User-defined convergence checker.\n", "previous = current;\n", "current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n", "\n", "if (checker != null) {\n", "if (checker.converged(iter, previous, current)) {\n", "return best(current, previous, isMinim);\n", "}\n", "}\n", "\n", "// Update a, b, v, w and x.\n", "if (fu <= fx) {\n", "if (u < x) {\n", "b = x;\n", "} else {\n", "a = x;\n", "}\n", "v = w;\n", "fv = fw;\n", "w = x;\n", "fw = fx;\n", "x = u;\n", "fx = fu;\n", "} else {\n", "if (u < x) {\n", "a = u;\n", "} else {\n", "b = u;\n", "}\n", "if (fu <= fw ||\n", "Precision.equals(w, x)) {\n", "v = w;\n", "fv = fw;\n", "w = u;\n", "fw = fu;\n", "} else if (fu <= fv ||\n", "Precision.equals(v, x) ||\n", "Precision.equals(v, w)) {\n", "v = u;\n", "fv = fu;\n", "}\n", "}\n", "} else { // Default termination (Brent's criterion).\n", "return\n", "best(current,\n", "previous,\n", "isMinim);\n", "}\n", "++iter;\n", "}\n", "}\n"], "faulty_lines": [37], "cluster": 9}, {"pid": "Math", "bid": 23, "method_path": "./dataset/Math/23/BrentOptimizer.java", "method": ["protected UnivariatePointValuePair doOptimize() {\n", "final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n", "final double lo = getMin();\n", "final double mid = getStartValue();\n", "final double hi = getMax();\n", "\n", "// Optional additional convergence criteria.\n", "final ConvergenceChecker<UnivariatePointValuePair> checker\n", "= getConvergenceChecker();\n", "\n", "double a;\n", "double b;\n", "if (lo < hi) {\n", "a = lo;\n", "b = hi;\n", "} else {\n", "a = hi;\n", "b = lo;\n", "}\n", "\n", "double x = mid;\n", "double v = x;\n", "double w = x;\n", "double d = 0;\n", "double e = 0;\n", "double fx = computeObjectiveValue(x);\n", "if (!isMinim) {\n", "fx = -fx;\n", "}\n", "double fv = fx;\n", "double fw = fx;\n", "\n", "UnivariatePointValuePair previous = null;\n", "UnivariatePointValuePair current\n", "= new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n", "// Best point encountered so far (which is the initial guess).\n", "\n", "int iter = 0;\n", "while (true) {\n", "final double m = 0.5 * (a + b);\n", "final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n", "final double tol2 = 2 * tol1;\n", "\n", "// Default stopping criterion.\n", "final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n", "if (!stop) {\n", "double p = 0;\n", "double q = 0;\n", "double r = 0;\n", "double u = 0;\n", "\n", "if (FastMath.abs(e) > tol1) { // Fit parabola.\n", "r = (x - w) * (fx - fv);\n", "q = (x - v) * (fx - fw);\n", "p = (x - v) * q - (x - w) * r;\n", "q = 2 * (q - r);\n", "\n", "if (q > 0) {\n", "p = -p;\n", "} else {\n", "q = -q;\n", "}\n", "\n", "r = e;\n", "e = d;\n", "\n", "if (p > q * (a - x) &&\n", "p < q * (b - x) &&\n", "FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n", "// Parabolic interpolation step.\n", "d = p / q;\n", "u = x + d;\n", "\n", "// f must not be evaluated too close to a or b.\n", "if (u - a < tol2 || b - u < tol2) {\n", "if (x <= m) {\n", "d = tol1;\n", "} else {\n", "d = -tol1;\n", "}\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "\n", "// Update by at least \"tol1\".\n", "if (FastMath.abs(d) < tol1) {\n", "if (d >= 0) {\n", "u = x + tol1;\n", "} else {\n", "u = x - tol1;\n", "}\n", "} else {\n", "u = x + d;\n", "}\n", "\n", "double fu = computeObjectiveValue(u);\n", "if (!isMinim) {\n", "fu = -fu;\n", "}\n", "\n", "// User-defined convergence checker.\n", "previous = current;\n", "current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n", "\n", "if (checker != null) {\n", "if (checker.converged(iter, previous, current)) {\n", "return best(current, previous, isMinim);\n", "}\n", "}\n", "\n", "// Update a, b, v, w and x.\n", "if (fu <= fx) {\n", "if (u < x) {\n", "b = x;\n", "} else {\n", "a = x;\n", "}\n", "v = w;\n", "fv = fw;\n", "w = x;\n", "fw = fx;\n", "x = u;\n", "fx = fu;\n", "} else {\n", "if (u < x) {\n", "a = u;\n", "} else {\n", "b = u;\n", "}\n", "if (fu <= fw ||\n", "Precision.equals(w, x)) {\n", "v = w;\n", "fv = fw;\n", "w = u;\n", "fw = fu;\n", "} else if (fu <= fv ||\n", "Precision.equals(v, x) ||\n", "Precision.equals(v, w)) {\n", "v = u;\n", "fv = fu;\n", "}\n", "}\n", "} else { // Default termination (Brent's criterion).\n", "return\n", "best(current,\n", "previous,\n", "isMinim);\n", "}\n", "++iter;\n", "}\n", "}\n"], "faulty_lines": [120, 123], "cluster": 9}, {"pid": "Math", "bid": 23, "method_path": "./dataset/Math/23/BrentOptimizer.java", "method": ["protected UnivariatePointValuePair doOptimize() {\n", "final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n", "final double lo = getMin();\n", "final double mid = getStartValue();\n", "final double hi = getMax();\n", "\n", "// Optional additional convergence criteria.\n", "final ConvergenceChecker<UnivariatePointValuePair> checker\n", "= getConvergenceChecker();\n", "\n", "double a;\n", "double b;\n", "if (lo < hi) {\n", "a = lo;\n", "b = hi;\n", "} else {\n", "a = hi;\n", "b = lo;\n", "}\n", "\n", "double x = mid;\n", "double v = x;\n", "double w = x;\n", "double d = 0;\n", "double e = 0;\n", "double fx = computeObjectiveValue(x);\n", "if (!isMinim) {\n", "fx = -fx;\n", "}\n", "double fv = fx;\n", "double fw = fx;\n", "\n", "UnivariatePointValuePair previous = null;\n", "UnivariatePointValuePair current\n", "= new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n", "// Best point encountered so far (which is the initial guess).\n", "\n", "int iter = 0;\n", "while (true) {\n", "final double m = 0.5 * (a + b);\n", "final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n", "final double tol2 = 2 * tol1;\n", "\n", "// Default stopping criterion.\n", "final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n", "if (!stop) {\n", "double p = 0;\n", "double q = 0;\n", "double r = 0;\n", "double u = 0;\n", "\n", "if (FastMath.abs(e) > tol1) { // Fit parabola.\n", "r = (x - w) * (fx - fv);\n", "q = (x - v) * (fx - fw);\n", "p = (x - v) * q - (x - w) * r;\n", "q = 2 * (q - r);\n", "\n", "if (q > 0) {\n", "p = -p;\n", "} else {\n", "q = -q;\n", "}\n", "\n", "r = e;\n", "e = d;\n", "\n", "if (p > q * (a - x) &&\n", "p < q * (b - x) &&\n", "FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n", "// Parabolic interpolation step.\n", "d = p / q;\n", "u = x + d;\n", "\n", "// f must not be evaluated too close to a or b.\n", "if (u - a < tol2 || b - u < tol2) {\n", "if (x <= m) {\n", "d = tol1;\n", "} else {\n", "d = -tol1;\n", "}\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "\n", "// Update by at least \"tol1\".\n", "if (FastMath.abs(d) < tol1) {\n", "if (d >= 0) {\n", "u = x + tol1;\n", "} else {\n", "u = x - tol1;\n", "}\n", "} else {\n", "u = x + d;\n", "}\n", "\n", "double fu = computeObjectiveValue(u);\n", "if (!isMinim) {\n", "fu = -fu;\n", "}\n", "\n", "// User-defined convergence checker.\n", "previous = current;\n", "current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n", "\n", "if (checker != null) {\n", "if (checker.converged(iter, previous, current)) {\n", "return best(current, previous, isMinim);\n", "}\n", "}\n", "\n", "// Update a, b, v, w and x.\n", "if (fu <= fx) {\n", "if (u < x) {\n", "b = x;\n", "} else {\n", "a = x;\n", "}\n", "v = w;\n", "fv = fw;\n", "w = x;\n", "fw = fx;\n", "x = u;\n", "fx = fu;\n", "} else {\n", "if (u < x) {\n", "a = u;\n", "} else {\n", "b = u;\n", "}\n", "if (fu <= fw ||\n", "Precision.equals(w, x)) {\n", "v = w;\n", "fv = fw;\n", "w = u;\n", "fw = fu;\n", "} else if (fu <= fv ||\n", "Precision.equals(v, x) ||\n", "Precision.equals(v, w)) {\n", "v = u;\n", "fv = fu;\n", "}\n", "}\n", "} else { // Default termination (Brent's criterion).\n", "return\n", "best(current,\n", "previous,\n", "isMinim);\n", "}\n", "++iter;\n", "}\n", "}\n"], "faulty_lines": [160, 163], "cluster": 9}, {"pid": "Math", "bid": 24, "method_path": "./dataset/Math/24/BrentOptimizer.java", "method": ["protected UnivariatePointValuePair doOptimize() {\n", "final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n", "final double lo = getMin();\n", "final double mid = getStartValue();\n", "final double hi = getMax();\n", "\n", "// Optional additional convergence criteria.\n", "final ConvergenceChecker<UnivariatePointValuePair> checker\n", "= getConvergenceChecker();\n", "\n", "double a;\n", "double b;\n", "if (lo < hi) {\n", "a = lo;\n", "b = hi;\n", "} else {\n", "a = hi;\n", "b = lo;\n", "}\n", "\n", "double x = mid;\n", "double v = x;\n", "double w = x;\n", "double d = 0;\n", "double e = 0;\n", "double fx = computeObjectiveValue(x);\n", "if (!isMinim) {\n", "fx = -fx;\n", "}\n", "double fv = fx;\n", "double fw = fx;\n", "\n", "UnivariatePointValuePair previous = null;\n", "UnivariatePointValuePair current\n", "= new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n", "\n", "int iter = 0;\n", "while (true) {\n", "final double m = 0.5 * (a + b);\n", "final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n", "final double tol2 = 2 * tol1;\n", "\n", "// Default stopping criterion.\n", "final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n", "if (!stop) {\n", "double p = 0;\n", "double q = 0;\n", "double r = 0;\n", "double u = 0;\n", "\n", "if (FastMath.abs(e) > tol1) { // Fit parabola.\n", "r = (x - w) * (fx - fv);\n", "q = (x - v) * (fx - fw);\n", "p = (x - v) * q - (x - w) * r;\n", "q = 2 * (q - r);\n", "\n", "if (q > 0) {\n", "p = -p;\n", "} else {\n", "q = -q;\n", "}\n", "\n", "r = e;\n", "e = d;\n", "\n", "if (p > q * (a - x) &&\n", "p < q * (b - x) &&\n", "FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n", "// Parabolic interpolation step.\n", "d = p / q;\n", "u = x + d;\n", "\n", "// f must not be evaluated too close to a or b.\n", "if (u - a < tol2 || b - u < tol2) {\n", "if (x <= m) {\n", "d = tol1;\n", "} else {\n", "d = -tol1;\n", "}\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "\n", "// Update by at least \"tol1\".\n", "if (FastMath.abs(d) < tol1) {\n", "if (d >= 0) {\n", "u = x + tol1;\n", "} else {\n", "u = x - tol1;\n", "}\n", "} else {\n", "u = x + d;\n", "}\n", "\n", "double fu = computeObjectiveValue(u);\n", "if (!isMinim) {\n", "fu = -fu;\n", "}\n", "\n", "// User-defined convergence checker.\n", "previous = current;\n", "current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n", "\n", "if (checker != null) {\n", "if (checker.converged(iter, previous, current)) {\n", "return current;\n", "}\n", "}\n", "\n", "// Update a, b, v, w and x.\n", "if (fu <= fx) {\n", "if (u < x) {\n", "b = x;\n", "} else {\n", "a = x;\n", "}\n", "v = w;\n", "fv = fw;\n", "w = x;\n", "fw = fx;\n", "x = u;\n", "fx = fu;\n", "} else {\n", "if (u < x) {\n", "a = u;\n", "} else {\n", "b = u;\n", "}\n", "if (fu <= fw ||\n", "Precision.equals(w, x)) {\n", "v = w;\n", "fv = fw;\n", "w = u;\n", "fw = fu;\n", "} else if (fu <= fv ||\n", "Precision.equals(v, x) ||\n", "Precision.equals(v, w)) {\n", "v = u;\n", "fv = fu;\n", "}\n", "}\n", "} else { // Default termination (Brent's criterion).\n", "return current;\n", "}\n", "++iter;\n", "}\n", "}\n"], "faulty_lines": [122], "cluster": 9}, {"pid": "Math", "bid": 24, "method_path": "./dataset/Math/24/BrentOptimizer.java", "method": ["protected UnivariatePointValuePair doOptimize() {\n", "final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n", "final double lo = getMin();\n", "final double mid = getStartValue();\n", "final double hi = getMax();\n", "\n", "// Optional additional convergence criteria.\n", "final ConvergenceChecker<UnivariatePointValuePair> checker\n", "= getConvergenceChecker();\n", "\n", "double a;\n", "double b;\n", "if (lo < hi) {\n", "a = lo;\n", "b = hi;\n", "} else {\n", "a = hi;\n", "b = lo;\n", "}\n", "\n", "double x = mid;\n", "double v = x;\n", "double w = x;\n", "double d = 0;\n", "double e = 0;\n", "double fx = computeObjectiveValue(x);\n", "if (!isMinim) {\n", "fx = -fx;\n", "}\n", "double fv = fx;\n", "double fw = fx;\n", "\n", "UnivariatePointValuePair previous = null;\n", "UnivariatePointValuePair current\n", "= new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n", "\n", "int iter = 0;\n", "while (true) {\n", "final double m = 0.5 * (a + b);\n", "final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n", "final double tol2 = 2 * tol1;\n", "\n", "// Default stopping criterion.\n", "final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n", "if (!stop) {\n", "double p = 0;\n", "double q = 0;\n", "double r = 0;\n", "double u = 0;\n", "\n", "if (FastMath.abs(e) > tol1) { // Fit parabola.\n", "r = (x - w) * (fx - fv);\n", "q = (x - v) * (fx - fw);\n", "p = (x - v) * q - (x - w) * r;\n", "q = 2 * (q - r);\n", "\n", "if (q > 0) {\n", "p = -p;\n", "} else {\n", "q = -q;\n", "}\n", "\n", "r = e;\n", "e = d;\n", "\n", "if (p > q * (a - x) &&\n", "p < q * (b - x) &&\n", "FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n", "// Parabolic interpolation step.\n", "d = p / q;\n", "u = x + d;\n", "\n", "// f must not be evaluated too close to a or b.\n", "if (u - a < tol2 || b - u < tol2) {\n", "if (x <= m) {\n", "d = tol1;\n", "} else {\n", "d = -tol1;\n", "}\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "\n", "// Update by at least \"tol1\".\n", "if (FastMath.abs(d) < tol1) {\n", "if (d >= 0) {\n", "u = x + tol1;\n", "} else {\n", "u = x - tol1;\n", "}\n", "} else {\n", "u = x + d;\n", "}\n", "\n", "double fu = computeObjectiveValue(u);\n", "if (!isMinim) {\n", "fu = -fu;\n", "}\n", "\n", "// User-defined convergence checker.\n", "previous = current;\n", "current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n", "\n", "if (checker != null) {\n", "if (checker.converged(iter, previous, current)) {\n", "return current;\n", "}\n", "}\n", "\n", "// Update a, b, v, w and x.\n", "if (fu <= fx) {\n", "if (u < x) {\n", "b = x;\n", "} else {\n", "a = x;\n", "}\n", "v = w;\n", "fv = fw;\n", "w = x;\n", "fw = fx;\n", "x = u;\n", "fx = fu;\n", "} else {\n", "if (u < x) {\n", "a = u;\n", "} else {\n", "b = u;\n", "}\n", "if (fu <= fw ||\n", "Precision.equals(w, x)) {\n", "v = w;\n", "fv = fw;\n", "w = u;\n", "fw = fu;\n", "} else if (fu <= fv ||\n", "Precision.equals(v, x) ||\n", "Precision.equals(v, w)) {\n", "v = u;\n", "fv = fu;\n", "}\n", "}\n", "} else { // Default termination (Brent's criterion).\n", "return current;\n", "}\n", "++iter;\n", "}\n", "}\n"], "faulty_lines": [159], "cluster": 9}, {"pid": "Math", "bid": 25, "method_path": "./dataset/Math/25/HarmonicFitter.java", "method": ["private void guessAOmega() {\n", "// initialize the sums for the linear model between the two integrals\n", "double sx2 = 0;\n", "double sy2 = 0;\n", "double sxy = 0;\n", "double sxz = 0;\n", "double syz = 0;\n", "\n", "double currentX = observations[0].getX();\n", "double currentY = observations[0].getY();\n", "double f2Integral = 0;\n", "double fPrime2Integral = 0;\n", "final double startX = currentX;\n", "for (int i = 1; i < observations.length; ++i) {\n", "// one step forward\n", "final double previousX = currentX;\n", "final double previousY = currentY;\n", "currentX = observations[i].getX();\n", "currentY = observations[i].getY();\n", "\n", "// update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n", "// considering a linear model for f (and therefore constant f')\n", "final double dx = currentX - previousX;\n", "final double dy = currentY - previousY;\n", "final double f2StepIntegral =\n", "dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n", "final double fPrime2StepIntegral = dy * dy / dx;\n", "\n", "final double x = currentX - startX;\n", "f2Integral += f2StepIntegral;\n", "fPrime2Integral += fPrime2StepIntegral;\n", "\n", "sx2 += x * x;\n", "sy2 += f2Integral * f2Integral;\n", "sxy += x * f2Integral;\n", "sxz += x * fPrime2Integral;\n", "syz += f2Integral * fPrime2Integral;\n", "}\n", "\n", "// compute the amplitude and pulsation coefficients\n", "double c1 = sy2 * sxz - sxy * syz;\n", "double c2 = sxy * sxz - sx2 * syz;\n", "double c3 = sx2 * sy2 - sxy * sxy;\n", "if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n", "final int last = observations.length - 1;\n", "// Range of the observations, assuming that the\n", "// observations are sorted.\n", "final double xRange = observations[last].getX() - observations[0].getX();\n", "if (xRange == 0) {\n", "throw new ZeroException();\n", "}\n", "omega = 2 * Math.PI / xRange;\n", "\n", "double yMin = Double.POSITIVE_INFINITY;\n", "double yMax = Double.NEGATIVE_INFINITY;\n", "for (int i = 1; i < observations.length; ++i) {\n", "final double y = observations[i].getY();\n", "if (y < yMin) {\n", "yMin = y;\n", "}\n", "if (y > yMax) {\n", "yMax = y;\n", "}\n", "}\n", "a = 0.5 * (yMax - yMin);\n", "} else {\n", "// In some ill-conditioned cases (cf. MATH-844), the guesser\n", "// procedure cannot produce sensible results.\n", "\n", "a = FastMath.sqrt(c1 / c2);\n", "omega = FastMath.sqrt(c2 / c3);\n", "}\n", "}\n"], "faulty_lines": [67, 69], "cluster": 9}, {"pid": "Math", "bid": 26, "method_path": "./dataset/Math/26/Fraction.java", "method": ["boolean stop = false;\n", "do {\n", "++n;\n", "double r1 = 1.0 / (r0 - a0);\n", "long a1 = (long)FastMath.floor(r1);\n", "p2 = (a1 * p1) + p0;\n", "q2 = (a1 * q1) + q0;\n", "if ((p2 > overflow) || (q2 > overflow)) {\n", "throw new FractionConversionException(value, p2, q2);\n", "}\n", "\n", "double convergent = (double)p2 / (double)q2;\n", "if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n", "p0 = p1;\n", "p1 = p2;\n", "q0 = q1;\n", "q1 = q2;\n", "a0 = a1;\n", "r0 = r1;\n", "} else {\n", "stop = true;\n", "}\n", "} while (!stop);\n"], "faulty_lines": [8], "cluster": 8}, {"pid": "Math", "bid": 27, "method_path": "./dataset/Math/27/Fraction.java", "method": ["public double percentageValue() {\n", "return multiply(100).doubleValue();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Math", "bid": 28, "method_path": "./dataset/Math/28/SimplexSolver.java", "method": ["private Integer getPivotRow(SimplexTableau tableau, final int col) {\n", "// create a list of all the rows that tie for the lowest score in the minimum ratio test\n", "List<Integer> minRatioPositions = new ArrayList<Integer>();\n", "double minRatio = Double.MAX_VALUE;\n", "for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n", "final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n", "final double entry = tableau.getEntry(i, col);\n", "\n", "if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n", "final double ratio = rhs / entry;\n", "// check if the entry is strictly equal to the current min ratio\n", "// do not use a ulp/epsilon check\n", "final int cmp = Double.compare(ratio, minRatio);\n", "if (cmp == 0) {\n", "minRatioPositions.add(i);\n", "} else if (cmp < 0) {\n", "minRatio = ratio;\n", "minRatioPositions = new ArrayList<Integer>();\n", "minRatioPositions.add(i);\n", "}\n", "}\n", "}\n", "\n", "if (minRatioPositions.size() == 0) {\n", "return null;\n", "} else if (minRatioPositions.size() > 1) {\n", "// there's a degeneracy as indicated by a tie in the minimum ratio test\n", "\n", "// 1. check if there's an artificial variable that can be forced out of the basis\n", "for (Integer row : minRatioPositions) {\n", "for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n", "int column = i + tableau.getArtificialVariableOffset();\n", "final double entry = tableau.getEntry(row, column);\n", "if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n", "return row;\n", "}\n", "}\n", "}\n", "\n", "// 2. apply Bland's rule to prevent cycling:\n", "//    take the row for which the corresponding basic variable has the smallest index\n", "//\n", "// see http://www.stanford.edu/class/msande310/blandrule.pdf\n", "// see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n", "//\n", "// Additional heuristic: if we did not get a solution after half of maxIterations\n", "//                       revert to the simple case of just returning the top-most row\n", "// This heuristic is based on empirical data gathered while investigating MATH-828.\n", "Integer minRow = null;\n", "int minIndex = tableau.getWidth();\n", "for (Integer row : minRatioPositions) {\n", "int i = tableau.getNumObjectiveFunctions();\n", "for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n", "if (row == tableau.getBasicRow(i)) {\n", "if (i < minIndex) {\n", "minIndex = i;\n", "minRow = row;\n", "}\n", "}\n", "}\n", "}\n", "return minRow;\n", "}\n", "return minRatioPositions.get(0);\n", "}\n"], "faulty_lines": [30], "cluster": 3}, {"pid": "Math", "bid": 28, "method_path": "./dataset/Math/28/SimplexSolver.java", "method": ["private Integer getPivotRow(SimplexTableau tableau, final int col) {\n", "// create a list of all the rows that tie for the lowest score in the minimum ratio test\n", "List<Integer> minRatioPositions = new ArrayList<Integer>();\n", "double minRatio = Double.MAX_VALUE;\n", "for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n", "final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n", "final double entry = tableau.getEntry(i, col);\n", "\n", "if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n", "final double ratio = rhs / entry;\n", "// check if the entry is strictly equal to the current min ratio\n", "// do not use a ulp/epsilon check\n", "final int cmp = Double.compare(ratio, minRatio);\n", "if (cmp == 0) {\n", "minRatioPositions.add(i);\n", "} else if (cmp < 0) {\n", "minRatio = ratio;\n", "minRatioPositions = new ArrayList<Integer>();\n", "minRatioPositions.add(i);\n", "}\n", "}\n", "}\n", "\n", "if (minRatioPositions.size() == 0) {\n", "return null;\n", "} else if (minRatioPositions.size() > 1) {\n", "// there's a degeneracy as indicated by a tie in the minimum ratio test\n", "\n", "// 1. check if there's an artificial variable that can be forced out of the basis\n", "for (Integer row : minRatioPositions) {\n", "for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n", "int column = i + tableau.getArtificialVariableOffset();\n", "final double entry = tableau.getEntry(row, column);\n", "if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n", "return row;\n", "}\n", "}\n", "}\n", "\n", "// 2. apply Bland's rule to prevent cycling:\n", "//    take the row for which the corresponding basic variable has the smallest index\n", "//\n", "// see http://www.stanford.edu/class/msande310/blandrule.pdf\n", "// see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n", "//\n", "// Additional heuristic: if we did not get a solution after half of maxIterations\n", "//                       revert to the simple case of just returning the top-most row\n", "// This heuristic is based on empirical data gathered while investigating MATH-828.\n", "Integer minRow = null;\n", "int minIndex = tableau.getWidth();\n", "for (Integer row : minRatioPositions) {\n", "int i = tableau.getNumObjectiveFunctions();\n", "for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n", "if (row == tableau.getBasicRow(i)) {\n", "if (i < minIndex) {\n", "minIndex = i;\n", "minRow = row;\n", "}\n", "}\n", "}\n", "}\n", "return minRow;\n", "}\n", "return minRatioPositions.get(0);\n", "}\n"], "faulty_lines": [39], "cluster": 3}, {"pid": "Math", "bid": 28, "method_path": "./dataset/Math/28/SimplexSolver.java", "method": ["private Integer getPivotRow(SimplexTableau tableau, final int col) {\n", "// create a list of all the rows that tie for the lowest score in the minimum ratio test\n", "List<Integer> minRatioPositions = new ArrayList<Integer>();\n", "double minRatio = Double.MAX_VALUE;\n", "for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n", "final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n", "final double entry = tableau.getEntry(i, col);\n", "\n", "if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n", "final double ratio = rhs / entry;\n", "// check if the entry is strictly equal to the current min ratio\n", "// do not use a ulp/epsilon check\n", "final int cmp = Double.compare(ratio, minRatio);\n", "if (cmp == 0) {\n", "minRatioPositions.add(i);\n", "} else if (cmp < 0) {\n", "minRatio = ratio;\n", "minRatioPositions = new ArrayList<Integer>();\n", "minRatioPositions.add(i);\n", "}\n", "}\n", "}\n", "\n", "if (minRatioPositions.size() == 0) {\n", "return null;\n", "} else if (minRatioPositions.size() > 1) {\n", "// there's a degeneracy as indicated by a tie in the minimum ratio test\n", "\n", "// 1. check if there's an artificial variable that can be forced out of the basis\n", "for (Integer row : minRatioPositions) {\n", "for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n", "int column = i + tableau.getArtificialVariableOffset();\n", "final double entry = tableau.getEntry(row, column);\n", "if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n", "return row;\n", "}\n", "}\n", "}\n", "\n", "// 2. apply Bland's rule to prevent cycling:\n", "//    take the row for which the corresponding basic variable has the smallest index\n", "//\n", "// see http://www.stanford.edu/class/msande310/blandrule.pdf\n", "// see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n", "//\n", "// Additional heuristic: if we did not get a solution after half of maxIterations\n", "//                       revert to the simple case of just returning the top-most row\n", "// This heuristic is based on empirical data gathered while investigating MATH-828.\n", "Integer minRow = null;\n", "int minIndex = tableau.getWidth();\n", "for (Integer row : minRatioPositions) {\n", "int i = tableau.getNumObjectiveFunctions();\n", "for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n", "if (row == tableau.getBasicRow(i)) {\n", "if (i < minIndex) {\n", "minIndex = i;\n", "minRow = row;\n", "}\n", "}\n", "}\n", "}\n", "return minRow;\n", "}\n", "return minRatioPositions.get(0);\n", "}\n"], "faulty_lines": [49], "cluster": 3}, {"pid": "Math", "bid": 28, "method_path": "./dataset/Math/28/SimplexSolver.java", "method": ["private Integer getPivotRow(SimplexTableau tableau, final int col) {\n", "// create a list of all the rows that tie for the lowest score in the minimum ratio test\n", "List<Integer> minRatioPositions = new ArrayList<Integer>();\n", "double minRatio = Double.MAX_VALUE;\n", "for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n", "final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n", "final double entry = tableau.getEntry(i, col);\n", "\n", "if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n", "final double ratio = rhs / entry;\n", "// check if the entry is strictly equal to the current min ratio\n", "// do not use a ulp/epsilon check\n", "final int cmp = Double.compare(ratio, minRatio);\n", "if (cmp == 0) {\n", "minRatioPositions.add(i);\n", "} else if (cmp < 0) {\n", "minRatio = ratio;\n", "minRatioPositions = new ArrayList<Integer>();\n", "minRatioPositions.add(i);\n", "}\n", "}\n", "}\n", "\n", "if (minRatioPositions.size() == 0) {\n", "return null;\n", "} else if (minRatioPositions.size() > 1) {\n", "// there's a degeneracy as indicated by a tie in the minimum ratio test\n", "\n", "// 1. check if there's an artificial variable that can be forced out of the basis\n", "for (Integer row : minRatioPositions) {\n", "for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n", "int column = i + tableau.getArtificialVariableOffset();\n", "final double entry = tableau.getEntry(row, column);\n", "if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n", "return row;\n", "}\n", "}\n", "}\n", "\n", "// 2. apply Bland's rule to prevent cycling:\n", "//    take the row for which the corresponding basic variable has the smallest index\n", "//\n", "// see http://www.stanford.edu/class/msande310/blandrule.pdf\n", "// see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n", "//\n", "// Additional heuristic: if we did not get a solution after half of maxIterations\n", "//                       revert to the simple case of just returning the top-most row\n", "// This heuristic is based on empirical data gathered while investigating MATH-828.\n", "Integer minRow = null;\n", "int minIndex = tableau.getWidth();\n", "for (Integer row : minRatioPositions) {\n", "int i = tableau.getNumObjectiveFunctions();\n", "for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n", "if (row == tableau.getBasicRow(i)) {\n", "if (i < minIndex) {\n", "minIndex = i;\n", "minRow = row;\n", "}\n", "}\n", "}\n", "}\n", "return minRow;\n", "}\n", "return minRatioPositions.get(0);\n", "}\n"], "faulty_lines": [63], "cluster": 3}, {"pid": "Math", "bid": 29, "method_path": "./dataset/Math/29/OpenMapRealVector.java", "method": ["public OpenMapRealVector ebeDivide(RealVector v) {\n", "checkVectorDimensions(v.getDimension());\n", "OpenMapRealVector res = new OpenMapRealVector(this);\n", "/*\n", "* MATH-803: it is not sufficient to loop through non zero entries of\n", "* this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n", "* this[i] / v[i] = NaN, and not 0d.\n", "*/\n", "Iterator iter = entries.iterator();\n", "while (iter.hasNext()) {\n", "iter.advance();\n", "res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n", "}\n", "return res;\n", "}\n"], "faulty_lines": [9, 10, 11, 12], "cluster": 2}, {"pid": "Math", "bid": 29, "method_path": "./dataset/Math/29/OpenMapRealVector.java", "method": ["public OpenMapRealVector ebeMultiply(RealVector v) {\n", "checkVectorDimensions(v.getDimension());\n", "OpenMapRealVector res = new OpenMapRealVector(this);\n", "Iterator iter = entries.iterator();\n", "while (iter.hasNext()) {\n", "iter.advance();\n", "res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n", "}\n", "/*\n", "* MATH-803: the above loop assumes that 0d * x  = 0d for any double x,\n", "* which allows to consider only the non-zero entries of this. However,\n", "* this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).\n", "*\n", "* These special cases are handled below.\n", "*/\n", "return res;\n", "}\n"], "faulty_lines": [16], "cluster": 2}, {"pid": "Math", "bid": 30, "method_path": "./dataset/Math/30/MannWhitneyUTest.java", "method": ["private double calculateAsymptoticPValue(final double Umin,\n", "final int n1,\n", "final int n2)\n", "throws ConvergenceException, MaxCountExceededException {\n", "\n", "final int n1n2prod = n1 * n2;\n", "\n", "// http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n", "final double EU = n1n2prod / 2.0;\n", "final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n", "\n", "final double z = (Umin - EU) / FastMath.sqrt(VarU);\n", "\n", "final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n", "\n", "return 2 * standardNormal.cumulativeProbability(z);\n", "}\n"], "faulty_lines": [6], "cluster": 2}, {"pid": "Math", "bid": 31, "method_path": "./dataset/Math/31/ContinuedFraction.java", "method": ["public double evaluate(double x, double epsilon, int maxIterations) {\n", "final double small = 1e-50;\n", "double hPrev = getA(0, x);\n", "\n", "// use the value of small as epsilon criteria for zero checks\n", "if (Precision.equals(hPrev, 0.0, small)) {\n", "hPrev = small;\n", "}\n", "\n", "int n = 1;\n", "double dPrev = 0.0;\n", "double p0 = 1.0;\n", "double q1 = 1.0;\n", "double cPrev = hPrev;\n", "double hN = hPrev;\n", "\n", "while (n < maxIterations) {\n", "final double a = getA(n, x);\n", "final double b = getB(n, x);\n", "\n", "double cN = a * hPrev + b * p0;\n", "double q2 = a * q1 + b * dPrev;\n", "if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n", "double scaleFactor = 1d;\n", "double lastScaleFactor = 1d;\n", "final int maxPower = 5;\n", "final double scale = FastMath.max(a,b);\n", "if (scale <= 0) {  // Can't scale\n", "throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n", "}\n", "for (int i = 0; i < maxPower; i++) {\n", "lastScaleFactor = scaleFactor;\n", "scaleFactor *= scale;\n", "if (a != 0.0 && a > b) {\n", "cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n", "q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n", "} else if (b != 0) {\n", "cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n", "q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n", "}\n", "if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n", "break;\n", "}\n", "}\n", "}\n", "\n", "final double deltaN = cN / q2 / cPrev;\n", "hN = cPrev * deltaN;\n", "\n", "if (Double.isInfinite(hN)) {\n", "throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n", "x);\n", "}\n", "if (Double.isNaN(hN)) {\n", "throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n", "x);\n", "}\n", "\n", "if (FastMath.abs(deltaN - 1.0) < epsilon) {\n", "break;\n", "}\n", "\n", "dPrev = q1;\n", "cPrev = cN / q2;\n", "p0 = hPrev;\n", "hPrev = cN;\n", "q1 = q2;\n", "n++;\n", "}\n", "\n", "if (n >= maxIterations) {\n", "throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n", "maxIterations, x);\n", "}\n", "\n", "return hN;\n", "}\n"], "faulty_lines": [12, 13], "cluster": 9}, {"pid": "Math", "bid": 31, "method_path": "./dataset/Math/31/ContinuedFraction.java", "method": ["public double evaluate(double x, double epsilon, int maxIterations) {\n", "final double small = 1e-50;\n", "double hPrev = getA(0, x);\n", "\n", "// use the value of small as epsilon criteria for zero checks\n", "if (Precision.equals(hPrev, 0.0, small)) {\n", "hPrev = small;\n", "}\n", "\n", "int n = 1;\n", "double dPrev = 0.0;\n", "double p0 = 1.0;\n", "double q1 = 1.0;\n", "double cPrev = hPrev;\n", "double hN = hPrev;\n", "\n", "while (n < maxIterations) {\n", "final double a = getA(n, x);\n", "final double b = getB(n, x);\n", "\n", "double cN = a * hPrev + b * p0;\n", "double q2 = a * q1 + b * dPrev;\n", "if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n", "double scaleFactor = 1d;\n", "double lastScaleFactor = 1d;\n", "final int maxPower = 5;\n", "final double scale = FastMath.max(a,b);\n", "if (scale <= 0) {  // Can't scale\n", "throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n", "}\n", "for (int i = 0; i < maxPower; i++) {\n", "lastScaleFactor = scaleFactor;\n", "scaleFactor *= scale;\n", "if (a != 0.0 && a > b) {\n", "cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n", "q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n", "} else if (b != 0) {\n", "cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n", "q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n", "}\n", "if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n", "break;\n", "}\n", "}\n", "}\n", "\n", "final double deltaN = cN / q2 / cPrev;\n", "hN = cPrev * deltaN;\n", "\n", "if (Double.isInfinite(hN)) {\n", "throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n", "x);\n", "}\n", "if (Double.isNaN(hN)) {\n", "throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n", "x);\n", "}\n", "\n", "if (FastMath.abs(deltaN - 1.0) < epsilon) {\n", "break;\n", "}\n", "\n", "dPrev = q1;\n", "cPrev = cN / q2;\n", "p0 = hPrev;\n", "hPrev = cN;\n", "q1 = q2;\n", "n++;\n", "}\n", "\n", "if (n >= maxIterations) {\n", "throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n", "maxIterations, x);\n", "}\n", "\n", "return hN;\n", "}\n"], "faulty_lines": [21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 47, 48], "cluster": 9}, {"pid": "Math", "bid": 31, "method_path": "./dataset/Math/31/ContinuedFraction.java", "method": ["public double evaluate(double x, double epsilon, int maxIterations) {\n", "final double small = 1e-50;\n", "double hPrev = getA(0, x);\n", "\n", "// use the value of small as epsilon criteria for zero checks\n", "if (Precision.equals(hPrev, 0.0, small)) {\n", "hPrev = small;\n", "}\n", "\n", "int n = 1;\n", "double dPrev = 0.0;\n", "double p0 = 1.0;\n", "double q1 = 1.0;\n", "double cPrev = hPrev;\n", "double hN = hPrev;\n", "\n", "while (n < maxIterations) {\n", "final double a = getA(n, x);\n", "final double b = getB(n, x);\n", "\n", "double cN = a * hPrev + b * p0;\n", "double q2 = a * q1 + b * dPrev;\n", "if (Double.isInfinite(cN) || Double.isInfinite(q2)) {\n", "double scaleFactor = 1d;\n", "double lastScaleFactor = 1d;\n", "final int maxPower = 5;\n", "final double scale = FastMath.max(a,b);\n", "if (scale <= 0) {  // Can't scale\n", "throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n", "}\n", "for (int i = 0; i < maxPower; i++) {\n", "lastScaleFactor = scaleFactor;\n", "scaleFactor *= scale;\n", "if (a != 0.0 && a > b) {\n", "cN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\n", "q2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n", "} else if (b != 0) {\n", "cN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\n", "q2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n", "}\n", "if (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\n", "break;\n", "}\n", "}\n", "}\n", "\n", "final double deltaN = cN / q2 / cPrev;\n", "hN = cPrev * deltaN;\n", "\n", "if (Double.isInfinite(hN)) {\n", "throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n", "x);\n", "}\n", "if (Double.isNaN(hN)) {\n", "throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n", "x);\n", "}\n", "\n", "if (FastMath.abs(deltaN - 1.0) < epsilon) {\n", "break;\n", "}\n", "\n", "dPrev = q1;\n", "cPrev = cN / q2;\n", "p0 = hPrev;\n", "hPrev = cN;\n", "q1 = q2;\n", "n++;\n", "}\n", "\n", "if (n >= maxIterations) {\n", "throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n", "maxIterations, x);\n", "}\n", "\n", "return hN;\n", "}\n"], "faulty_lines": [63, 64, 65, 66, 67], "cluster": 9}, {"pid": "Math", "bid": 32, "method_path": "./dataset/Math/32/PolygonsSet.java", "method": ["protected void computeGeometricalProperties() {\n", "\n", "final Vector2D[][] v = getVertices();\n", "\n", "if (v.length == 0) {\n", "final BSPTree<Euclidean2D> tree = getTree(false);\n", "if ((Boolean) tree.getAttribute()) {\n", "// the instance covers the whole space\n", "setSize(Double.POSITIVE_INFINITY);\n", "setBarycenter(Vector2D.NaN);\n", "} else {\n", "setSize(0);\n", "setBarycenter(new Vector2D(0, 0));\n", "}\n", "} else if (v[0][0] == null) {\n", "// there is at least one open-loop: the polygon is infinite\n", "setSize(Double.POSITIVE_INFINITY);\n", "setBarycenter(Vector2D.NaN);\n", "} else {\n", "// all loops are closed, we compute some integrals around the shape\n", "\n", "double sum  = 0;\n", "double sumX = 0;\n", "double sumY = 0;\n", "\n", "for (Vector2D[] loop : v) {\n", "double x1 = loop[loop.length - 1].getX();\n", "double y1 = loop[loop.length - 1].getY();\n", "for (final Vector2D point : loop) {\n", "final double x0 = x1;\n", "final double y0 = y1;\n", "x1 = point.getX();\n", "y1 = point.getY();\n", "final double factor = x0 * y1 - y0 * x1;\n", "sum  += factor;\n", "sumX += factor * (x0 + x1);\n", "sumY += factor * (y0 + y1);\n", "}\n", "}\n", "\n", "if (sum < 0) {\n", "// the polygon as a finite outside surrounded by an infinite inside\n", "setSize(Double.POSITIVE_INFINITY);\n", "setBarycenter(Vector2D.NaN);\n", "} else {\n", "setSize(sum / 2);\n", "setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n", "}\n", "\n", "}\n", "\n", "}\n"], "faulty_lines": [7], "cluster": 9}, {"pid": "Math", "bid": 33, "method_path": "./dataset/Math/33/SimplexTableau.java", "method": ["protected void dropPhase1Objective() {\n", "if (getNumObjectiveFunctions() == 1) {\n", "return;\n", "}\n", "\n", "List<Integer> columnsToDrop = new ArrayList<Integer>();\n", "columnsToDrop.add(0);\n", "\n", "// positive cost non-artificial variables\n", "for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n", "final double entry = tableau.getEntry(0, i);\n", "if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n", "columnsToDrop.add(i);\n", "}\n", "}\n", "\n", "// non-basic artificial variables\n", "for (int i = 0; i < getNumArtificialVariables(); i++) {\n", "int col = i + getArtificialVariableOffset();\n", "if (getBasicRow(col) == null) {\n", "columnsToDrop.add(col);\n", "}\n", "}\n", "\n", "double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n", "for (int i = 1; i < getHeight(); i++) {\n", "int col = 0;\n", "for (int j = 0; j < getWidth(); j++) {\n", "if (!columnsToDrop.contains(j)) {\n", "matrix[i - 1][col++] = tableau.getEntry(i, j);\n", "}\n", "}\n", "}\n", "\n", "for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n", "columnLabels.remove((int) columnsToDrop.get(i));\n", "}\n", "\n", "this.tableau = new Array2DRowRealMatrix(matrix);\n", "this.numArtificialVariables = 0;\n", "}\n"], "faulty_lines": [12], "cluster": 5}, {"pid": "Math", "bid": 34, "method_path": "./dataset/Math/34/ListPopulation.java", "method": ["public Iterator<Chromosome> iterator() {\n", "return chromosomes.iterator();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Math", "bid": 35, "method_path": "./dataset/Math/35/ElitisticListPopulation.java", "method": ["public ElitisticListPopulation(final List<Chromosome> chromosomes,\n", "final int populationLimit,\n", "final double elitismRate) {\n", "super(chromosomes, populationLimit);\n", "this.elitismRate = elitismRate;\n", "}\n"], "faulty_lines": [5], "cluster": 0}, {"pid": "Math", "bid": 35, "method_path": "./dataset/Math/35/ElitisticListPopulation.java", "method": ["public ElitisticListPopulation(final int populationLimit, final double elitismRate) {\n", "super(populationLimit);\n", "this.elitismRate = elitismRate;\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Math", "bid": 36, "method_path": "./dataset/Math/36/BigFraction.java", "method": ["public double doubleValue() {\n", "double result = numerator.doubleValue() / denominator.doubleValue();\n", "// Numerator and/or denominator must be out of range:\n", "// Calculate how far to shift them to put them in range.\n", "return result;\n", "}\n"], "faulty_lines": [3, 5], "cluster": 0}, {"pid": "Math", "bid": 36, "method_path": "./dataset/Math/36/BigFraction.java", "method": ["public float floatValue() {\n", "float result = numerator.floatValue() / denominator.floatValue();\n", "// Numerator and/or denominator must be out of range:\n", "// Calculate how far to shift them to put them in range.\n", "return result;\n", "}\n"], "faulty_lines": [3, 5], "cluster": 0}, {"pid": "Math", "bid": 37, "method_path": "./dataset/Math/37/Complex.java", "method": ["public Complex tan() {\n", "if (isNaN) {\n", "return NaN;\n", "}\n", "\n", "double real2 = 2.0 * real;\n", "double imaginary2 = 2.0 * imaginary;\n", "double d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\n", "\n", "return createComplex(FastMath.sin(real2) / d,\n", "FastMath.sinh(imaginary2) / d);\n", "}\n"], "faulty_lines": [2, 5], "cluster": 4}, {"pid": "Math", "bid": 37, "method_path": "./dataset/Math/37/Complex.java", "method": ["public Complex tanh() {\n", "if (isNaN) {\n", "return NaN;\n", "}\n", "double real2 = 2.0 * real;\n", "double imaginary2 = 2.0 * imaginary;\n", "double d = FastMath.cosh(real2) + FastMath.cos(imaginary2);\n", "\n", "return createComplex(FastMath.sinh(real2) / d,\n", "FastMath.sin(imaginary2) / d);\n", "}\n"], "faulty_lines": [2, 5], "cluster": 4}, {"pid": "Math", "bid": 38, "method_path": "./dataset/Math/38/BOBYQAOptimizer.java", "method": ["private void prelim(double[] lowerBound,\n", "double[] upperBound) {\n", "printMethod(); // XXX\n", "\n", "final int n = currentBest.getDimension();\n", "final int npt = numberOfInterpolationPoints;\n", "final int ndim = bMatrix.getRowDimension();\n", "\n", "final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n", "final double recip = 1d / rhosq;\n", "final int np = n + 1;\n", "\n", "// Set XBASE to the initial vector of variables, and set the initial\n", "// elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n", "\n", "for (int j = 0; j < n; j++) {\n", "originShift.setEntry(j, currentBest.getEntry(j));\n", "for (int k = 0; k < npt; k++) {\n", "interpolationPoints.setEntry(k, j, ZERO);\n", "}\n", "for (int i = 0; i < ndim; i++) {\n", "bMatrix.setEntry(i, j, ZERO);\n", "}\n", "}\n", "for (int i = 0, max = n * np / 2; i < max; i++) {\n", "modelSecondDerivativesValues.setEntry(i, ZERO);\n", "}\n", "for (int k = 0; k < npt; k++) {\n", "modelSecondDerivativesParameters.setEntry(k, ZERO);\n", "for (int j = 0, max = npt - np; j < max; j++) {\n", "zMatrix.setEntry(k, j, ZERO);\n", "}\n", "}\n", "\n", "// Begin the initialization procedure. NF becomes one more than the number\n", "// of function values so far. The coordinates of the displacement of the\n", "// next initial interpolation point from XBASE are set in XPT(NF+1,.).\n", "\n", "int ipt = 0;\n", "int jpt = 0;\n", "double fbeg = Double.NaN;\n", "do {\n", "final int nfm = getEvaluations();\n", "final int nfx = nfm - n;\n", "final int nfmm = nfm - 1;\n", "final int nfxm = nfx - 1;\n", "double stepa = 0;\n", "double stepb = 0;\n", "if (nfm <= 2 * n) {\n", "if (nfm >= 1 &&\n", "nfm <= n) {\n", "stepa = initialTrustRegionRadius;\n", "if (upperDifference.getEntry(nfmm) == ZERO) {\n", "stepa = -stepa;\n", "throw new PathIsExploredException(); // XXX\n", "}\n", "interpolationPoints.setEntry(nfm, nfmm, stepa);\n", "} else if (nfm > n) {\n", "stepa = interpolationPoints.getEntry(nfx, nfxm);\n", "stepb = -initialTrustRegionRadius;\n", "if (lowerDifference.getEntry(nfxm) == ZERO) {\n", "stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n", "throw new PathIsExploredException(); // XXX\n", "}\n", "if (upperDifference.getEntry(nfxm) == ZERO) {\n", "stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n", "throw new PathIsExploredException(); // XXX\n", "}\n", "interpolationPoints.setEntry(nfm, nfxm, stepb);\n", "}\n", "} else {\n", "final int tmp1 = (nfm - np) / n;\n", "jpt = nfm - tmp1 * n - n;\n", "ipt = jpt + tmp1;\n", "if (ipt > n) {\n", "final int tmp2 = jpt;\n", "jpt = ipt - n;\n", "ipt = tmp2;\n", "throw new PathIsExploredException(); // XXX\n", "}\n", "final int iptMinus1 = ipt;\n", "final int jptMinus1 = jpt;\n", "interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n", "interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n", "}\n", "\n", "// Calculate the next value of F. The least function value so far and\n", "// its index are required.\n", "\n", "for (int j = 0; j < n; j++) {\n", "currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n", "originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n", "upperBound[j]));\n", "if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n", "currentBest.setEntry(j, lowerBound[j]);\n", "}\n", "if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n", "currentBest.setEntry(j, upperBound[j]);\n", "}\n", "}\n", "\n", "final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n", "final double f = isMinimize ? objectiveValue : -objectiveValue;\n", "final int numEval = getEvaluations(); // nfm + 1\n", "fAtInterpolationPoints.setEntry(nfm, f);\n", "\n", "if (numEval == 1) {\n", "fbeg = f;\n", "trustRegionCenterInterpolationPointIndex = 0;\n", "} else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n", "trustRegionCenterInterpolationPointIndex = nfm;\n", "}\n", "\n", "// Set the nonzero initial elements of BMAT and the quadratic model in the\n", "// cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n", "// of the NF-th and (NF-N)-th interpolation points may be switched, in\n", "// order that the function value at the first of them contributes to the\n", "// off-diagonal second derivative terms of the initial quadratic model.\n", "\n", "if (numEval <= 2 * n + 1) {\n", "if (numEval >= 2 &&\n", "numEval <= n + 1) {\n", "gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n", "if (npt < numEval + n) {\n", "final double oneOverStepA = ONE / stepa;\n", "bMatrix.setEntry(0, nfmm, -oneOverStepA);\n", "bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n", "bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n", "throw new PathIsExploredException(); // XXX\n", "}\n", "} else if (numEval >= n + 2) {\n", "final int ih = nfx * (nfx + 1) / 2 - 1;\n", "final double tmp = (f - fbeg) / stepb;\n", "final double diff = stepb - stepa;\n", "modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n", "gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n", "if (stepa * stepb < ZERO) {\n", "if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n", "fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n", "fAtInterpolationPoints.setEntry(nfm - n, f);\n", "if (trustRegionCenterInterpolationPointIndex == nfm) {\n", "trustRegionCenterInterpolationPointIndex = nfm - n;\n", "}\n", "interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n", "interpolationPoints.setEntry(nfm, nfxm, stepa);\n", "}\n", "}\n", "bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n", "bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n", "bMatrix.setEntry(nfm - n, nfxm,\n", "-bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n", "zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n", "zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n", "// zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n", "zMatrix.setEntry(nfm - n, nfxm,\n", "-zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n", "}\n", "\n", "// Set the off-diagonal second derivatives of the Lagrange functions and\n", "// the initial quadratic model.\n", "\n", "} else {\n", "zMatrix.setEntry(0, nfxm, recip);\n", "zMatrix.setEntry(nfm, nfxm, recip);\n", "zMatrix.setEntry(ipt, nfxm, -recip);\n", "zMatrix.setEntry(jpt, nfxm, -recip);\n", "\n", "final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n", "final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n", "modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n", "throw new PathIsExploredException(); // XXX\n", "}\n", "} while (getEvaluations() < npt);\n", "} // prelim\n"], "faulty_lines": [79, 81, 82], "cluster": 9}, {"pid": "Math", "bid": 38, "method_path": "./dataset/Math/38/BOBYQAOptimizer.java", "method": ["private void prelim(double[] lowerBound,\n", "double[] upperBound) {\n", "printMethod(); // XXX\n", "\n", "final int n = currentBest.getDimension();\n", "final int npt = numberOfInterpolationPoints;\n", "final int ndim = bMatrix.getRowDimension();\n", "\n", "final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n", "final double recip = 1d / rhosq;\n", "final int np = n + 1;\n", "\n", "// Set XBASE to the initial vector of variables, and set the initial\n", "// elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n", "\n", "for (int j = 0; j < n; j++) {\n", "originShift.setEntry(j, currentBest.getEntry(j));\n", "for (int k = 0; k < npt; k++) {\n", "interpolationPoints.setEntry(k, j, ZERO);\n", "}\n", "for (int i = 0; i < ndim; i++) {\n", "bMatrix.setEntry(i, j, ZERO);\n", "}\n", "}\n", "for (int i = 0, max = n * np / 2; i < max; i++) {\n", "modelSecondDerivativesValues.setEntry(i, ZERO);\n", "}\n", "for (int k = 0; k < npt; k++) {\n", "modelSecondDerivativesParameters.setEntry(k, ZERO);\n", "for (int j = 0, max = npt - np; j < max; j++) {\n", "zMatrix.setEntry(k, j, ZERO);\n", "}\n", "}\n", "\n", "// Begin the initialization procedure. NF becomes one more than the number\n", "// of function values so far. The coordinates of the displacement of the\n", "// next initial interpolation point from XBASE are set in XPT(NF+1,.).\n", "\n", "int ipt = 0;\n", "int jpt = 0;\n", "double fbeg = Double.NaN;\n", "do {\n", "final int nfm = getEvaluations();\n", "final int nfx = nfm - n;\n", "final int nfmm = nfm - 1;\n", "final int nfxm = nfx - 1;\n", "double stepa = 0;\n", "double stepb = 0;\n", "if (nfm <= 2 * n) {\n", "if (nfm >= 1 &&\n", "nfm <= n) {\n", "stepa = initialTrustRegionRadius;\n", "if (upperDifference.getEntry(nfmm) == ZERO) {\n", "stepa = -stepa;\n", "throw new PathIsExploredException(); // XXX\n", "}\n", "interpolationPoints.setEntry(nfm, nfmm, stepa);\n", "} else if (nfm > n) {\n", "stepa = interpolationPoints.getEntry(nfx, nfxm);\n", "stepb = -initialTrustRegionRadius;\n", "if (lowerDifference.getEntry(nfxm) == ZERO) {\n", "stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n", "throw new PathIsExploredException(); // XXX\n", "}\n", "if (upperDifference.getEntry(nfxm) == ZERO) {\n", "stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n", "throw new PathIsExploredException(); // XXX\n", "}\n", "interpolationPoints.setEntry(nfm, nfxm, stepb);\n", "}\n", "} else {\n", "final int tmp1 = (nfm - np) / n;\n", "jpt = nfm - tmp1 * n - n;\n", "ipt = jpt + tmp1;\n", "if (ipt > n) {\n", "final int tmp2 = jpt;\n", "jpt = ipt - n;\n", "ipt = tmp2;\n", "throw new PathIsExploredException(); // XXX\n", "}\n", "final int iptMinus1 = ipt;\n", "final int jptMinus1 = jpt;\n", "interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n", "interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n", "}\n", "\n", "// Calculate the next value of F. The least function value so far and\n", "// its index are required.\n", "\n", "for (int j = 0; j < n; j++) {\n", "currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n", "originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n", "upperBound[j]));\n", "if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n", "currentBest.setEntry(j, lowerBound[j]);\n", "}\n", "if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n", "currentBest.setEntry(j, upperBound[j]);\n", "}\n", "}\n", "\n", "final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n", "final double f = isMinimize ? objectiveValue : -objectiveValue;\n", "final int numEval = getEvaluations(); // nfm + 1\n", "fAtInterpolationPoints.setEntry(nfm, f);\n", "\n", "if (numEval == 1) {\n", "fbeg = f;\n", "trustRegionCenterInterpolationPointIndex = 0;\n", "} else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n", "trustRegionCenterInterpolationPointIndex = nfm;\n", "}\n", "\n", "// Set the nonzero initial elements of BMAT and the quadratic model in the\n", "// cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n", "// of the NF-th and (NF-N)-th interpolation points may be switched, in\n", "// order that the function value at the first of them contributes to the\n", "// off-diagonal second derivative terms of the initial quadratic model.\n", "\n", "if (numEval <= 2 * n + 1) {\n", "if (numEval >= 2 &&\n", "numEval <= n + 1) {\n", "gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n", "if (npt < numEval + n) {\n", "final double oneOverStepA = ONE / stepa;\n", "bMatrix.setEntry(0, nfmm, -oneOverStepA);\n", "bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n", "bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n", "throw new PathIsExploredException(); // XXX\n", "}\n", "} else if (numEval >= n + 2) {\n", "final int ih = nfx * (nfx + 1) / 2 - 1;\n", "final double tmp = (f - fbeg) / stepb;\n", "final double diff = stepb - stepa;\n", "modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n", "gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n", "if (stepa * stepb < ZERO) {\n", "if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n", "fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n", "fAtInterpolationPoints.setEntry(nfm - n, f);\n", "if (trustRegionCenterInterpolationPointIndex == nfm) {\n", "trustRegionCenterInterpolationPointIndex = nfm - n;\n", "}\n", "interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n", "interpolationPoints.setEntry(nfm, nfxm, stepa);\n", "}\n", "}\n", "bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n", "bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n", "bMatrix.setEntry(nfm - n, nfxm,\n", "-bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n", "zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n", "zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n", "// zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n", "zMatrix.setEntry(nfm - n, nfxm,\n", "-zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n", "}\n", "\n", "// Set the off-diagonal second derivatives of the Lagrange functions and\n", "// the initial quadratic model.\n", "\n", "} else {\n", "zMatrix.setEntry(0, nfxm, recip);\n", "zMatrix.setEntry(nfm, nfxm, recip);\n", "zMatrix.setEntry(ipt, nfxm, -recip);\n", "zMatrix.setEntry(jpt, nfxm, -recip);\n", "\n", "final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n", "final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n", "modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n", "throw new PathIsExploredException(); // XXX\n", "}\n", "} while (getEvaluations() < npt);\n", "} // prelim\n"], "faulty_lines": [171], "cluster": 9}, {"pid": "Math", "bid": 40, "method_path": "./dataset/Math/40/BracketingNthOrderBrentSolver.java", "method": ["protected double doSolve() {\n", "\n", "// prepare arrays with the first points\n", "final double[] x = new double[maximalOrder + 1];\n", "final double[] y = new double[maximalOrder + 1];\n", "x[0] = getMin();\n", "x[1] = getStartValue();\n", "x[2] = getMax();\n", "verifySequence(x[0], x[1], x[2]);\n", "\n", "// evaluate initial guess\n", "y[1] = computeObjectiveValue(x[1]);\n", "if (Precision.equals(y[1], 0.0, 1)) {\n", "// return the initial guess if it is a perfect root.\n", "return x[1];\n", "}\n", "\n", "// evaluate first  endpoint\n", "y[0] = computeObjectiveValue(x[0]);\n", "if (Precision.equals(y[0], 0.0, 1)) {\n", "// return the first endpoint if it is a perfect root.\n", "return x[0];\n", "}\n", "\n", "int nbPoints;\n", "int signChangeIndex;\n", "if (y[0] * y[1] < 0) {\n", "\n", "// reduce interval if it brackets the root\n", "nbPoints        = 2;\n", "signChangeIndex = 1;\n", "\n", "} else {\n", "\n", "// evaluate second endpoint\n", "y[2] = computeObjectiveValue(x[2]);\n", "if (Precision.equals(y[2], 0.0, 1)) {\n", "// return the second endpoint if it is a perfect root.\n", "return x[2];\n", "}\n", "\n", "if (y[1] * y[2] < 0) {\n", "// use all computed point as a start sampling array for solving\n", "nbPoints        = 3;\n", "signChangeIndex = 2;\n", "} else {\n", "throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n", "}\n", "\n", "}\n", "\n", "// prepare a work array for inverse polynomial interpolation\n", "final double[] tmpX = new double[x.length];\n", "\n", "// current tightest bracketing of the root\n", "double xA    = x[signChangeIndex - 1];\n", "double yA    = y[signChangeIndex - 1];\n", "double absYA = FastMath.abs(yA);\n", "int agingA   = 0;\n", "double xB    = x[signChangeIndex];\n", "double yB    = y[signChangeIndex];\n", "double absYB = FastMath.abs(yB);\n", "int agingB   = 0;\n", "\n", "// search loop\n", "while (true) {\n", "\n", "// check convergence of bracketing interval\n", "final double xTol = getAbsoluteAccuracy() +\n", "getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n", "if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n", "switch (allowed) {\n", "case ANY_SIDE :\n", "return absYA < absYB ? xA : xB;\n", "case LEFT_SIDE :\n", "return xA;\n", "case RIGHT_SIDE :\n", "return xB;\n", "case BELOW_SIDE :\n", "return (yA <= 0) ? xA : xB;\n", "case ABOVE_SIDE :\n", "return (yA <  0) ? xB : xA;\n", "default :\n", "// this should never happen\n", "throw new MathInternalError(null);\n", "}\n", "}\n", "\n", "// target for the next evaluation point\n", "double targetY;\n", "if (agingA >= MAXIMAL_AGING) {\n", "// we keep updating the high bracket, try to compensate this\n", "targetY = -REDUCTION_FACTOR * yB;\n", "} else if (agingB >= MAXIMAL_AGING) {\n", "// we keep updating the low bracket, try to compensate this\n", "targetY = -REDUCTION_FACTOR * yA;\n", "} else {\n", "// bracketing is balanced, try to find the root itself\n", "targetY = 0;\n", "}\n", "\n", "// make a few attempts to guess a root,\n", "double nextX;\n", "int start = 0;\n", "int end   = nbPoints;\n", "do {\n", "\n", "// guess a value for current target, using inverse polynomial interpolation\n", "System.arraycopy(x, start, tmpX, start, end - start);\n", "nextX = guessX(targetY, tmpX, y, start, end);\n", "\n", "if (!((nextX > xA) && (nextX < xB))) {\n", "// the guessed root is not strictly inside of the tightest bracketing interval\n", "\n", "// the guessed root is either not strictly inside the interval or it\n", "// is a NaN (which occurs when some sampling points share the same y)\n", "// we try again with a lower interpolation order\n", "if (signChangeIndex - start >= end - signChangeIndex) {\n", "// we have more points before the sign change, drop the lowest point\n", "++start;\n", "} else {\n", "// we have more points after sign change, drop the highest point\n", "--end;\n", "}\n", "\n", "// we need to do one more attempt\n", "nextX = Double.NaN;\n", "\n", "}\n", "\n", "} while (Double.isNaN(nextX) && (end - start > 1));\n", "\n", "if (Double.isNaN(nextX)) {\n", "// fall back to bisection\n", "nextX = xA + 0.5 * (xB - xA);\n", "start = signChangeIndex - 1;\n", "end   = signChangeIndex;\n", "}\n", "\n", "// evaluate the function at the guessed root\n", "final double nextY = computeObjectiveValue(nextX);\n", "if (Precision.equals(nextY, 0.0, 1)) {\n", "// we have found an exact root, since it is not an approximation\n", "// we don't need to bother about the allowed solutions setting\n", "return nextX;\n", "}\n", "\n", "if ((nbPoints > 2) && (end - start != nbPoints)) {\n", "\n", "// we have been forced to ignore some points to keep bracketing,\n", "// they are probably too far from the root, drop them from now on\n", "nbPoints = end - start;\n", "System.arraycopy(x, start, x, 0, nbPoints);\n", "System.arraycopy(y, start, y, 0, nbPoints);\n", "signChangeIndex -= start;\n", "\n", "} else  if (nbPoints == x.length) {\n", "\n", "// we have to drop one point in order to insert the new one\n", "nbPoints--;\n", "\n", "// keep the tightest bracketing interval as centered as possible\n", "if (signChangeIndex >= (x.length + 1) / 2) {\n", "// we drop the lowest point, we have to shift the arrays and the index\n", "System.arraycopy(x, 1, x, 0, nbPoints);\n", "System.arraycopy(y, 1, y, 0, nbPoints);\n", "--signChangeIndex;\n", "}\n", "\n", "}\n", "\n", "// insert the last computed point\n", "//(by construction, we know it lies inside the tightest bracketing interval)\n", "System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n", "x[signChangeIndex] = nextX;\n", "System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n", "y[signChangeIndex] = nextY;\n", "++nbPoints;\n", "\n", "// update the bracketing interval\n", "if (nextY * yA <= 0) {\n", "// the sign change occurs before the inserted point\n", "xB = nextX;\n", "yB = nextY;\n", "absYB = FastMath.abs(yB);\n", "++agingA;\n", "agingB = 0;\n", "} else {\n", "// the sign change occurs after the inserted point\n", "xA = nextX;\n", "yA = nextY;\n", "absYA = FastMath.abs(yA);\n", "agingA = 0;\n", "++agingB;\n", "\n", "// update the sign change index\n", "signChangeIndex++;\n", "\n", "}\n", "\n", "}\n", "\n", "}\n"], "faulty_lines": [93, 96], "cluster": 9}, {"pid": "Math", "bid": 41, "method_path": "./dataset/Math/41/Variance.java", "method": ["public double evaluate(final double[] values, final double[] weights,\n", "final double mean, final int begin, final int length) {\n", "\n", "double var = Double.NaN;\n", "\n", "if (test(values, weights, begin, length)) {\n", "if (length == 1) {\n", "var = 0.0;\n", "} else if (length > 1) {\n", "double accum = 0.0;\n", "double dev = 0.0;\n", "double accum2 = 0.0;\n", "for (int i = begin; i < begin + length; i++) {\n", "dev = values[i] - mean;\n", "accum += weights[i] * (dev * dev);\n", "accum2 += weights[i] * dev;\n", "}\n", "\n", "double sumWts = 0;\n", "for (int i = 0; i < weights.length; i++) {\n", "sumWts += weights[i];\n", "}\n", "\n", "if (isBiasCorrected) {\n", "var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n", "} else {\n", "var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n", "}\n", "}\n", "}\n", "return var;\n", "}\n"], "faulty_lines": [20], "cluster": 8}, {"pid": "Math", "bid": 42, "method_path": "./dataset/Math/42/SimplexTableau.java", "method": ["protected RealPointValuePair getSolution() {\n", "int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n", "Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n", "double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n", "\n", "Set<Integer> basicRows = new HashSet<Integer>();\n", "double[] coefficients = new double[getOriginalNumDecisionVariables()];\n", "for (int i = 0; i < coefficients.length; i++) {\n", "int colIndex = columnLabels.indexOf(\"x\" + i);\n", "if (colIndex < 0) {\n", "coefficients[i] = 0;\n", "continue;\n", "}\n", "Integer basicRow = getBasicRow(colIndex);\n", "// if the basic row is found to be the objective function row\n", "// set the coefficient to 0 -> this case handles unconstrained\n", "// variables that are still part of the objective function\n", "if (basicRows.contains(basicRow)) {\n", "// if multiple variables can take a given value\n", "// then we choose the first and set the rest equal to 0\n", "coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n", "} else {\n", "basicRows.add(basicRow);\n", "coefficients[i] =\n", "(basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n", "(restrictToNonNegative ? 0 : mostNegative);\n", "}\n", "}\n", "return new RealPointValuePair(coefficients, f.getValue(coefficients));\n", "}\n"], "faulty_lines": [15, 18], "cluster": 1}, {"pid": "Math", "bid": 43, "method_path": "./dataset/Math/43/SummaryStatistics.java", "method": ["public void addValue(double value) {\n", "sumImpl.increment(value);\n", "sumsqImpl.increment(value);\n", "minImpl.increment(value);\n", "maxImpl.increment(value);\n", "sumLogImpl.increment(value);\n", "secondMoment.increment(value);\n", "// If mean, variance or geomean have been overridden,\n", "// need to increment these\n", "if (!(meanImpl instanceof Mean)) {\n", "meanImpl.increment(value);\n", "}\n", "if (!(varianceImpl instanceof Variance)) {\n", "varianceImpl.increment(value);\n", "}\n", "if (!(geoMeanImpl instanceof GeometricMean)) {\n", "geoMeanImpl.increment(value);\n", "}\n", "n++;\n", "}\n"], "faulty_lines": [10, 13, 16], "cluster": 2}, {"pid": "Math", "bid": 44, "method_path": "./dataset/Math/44/AbstractIntegrator.java", "method": ["protected double acceptStep(final AbstractStepInterpolator interpolator,\n", "final double[] y, final double[] yDot, final double tEnd)\n", "throws MathIllegalStateException {\n", "\n", "double previousT = interpolator.getGlobalPreviousTime();\n", "final double currentT = interpolator.getGlobalCurrentTime();\n", "resetOccurred = false;\n", "\n", "// initialize the events states if needed\n", "if (! statesInitialized) {\n", "for (EventState state : eventsStates) {\n", "state.reinitializeBegin(interpolator);\n", "}\n", "statesInitialized = true;\n", "}\n", "\n", "// search for next events that may occur during the step\n", "final int orderingSign = interpolator.isForward() ? +1 : -1;\n", "SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n", "\n", "/** {@inheritDoc} */\n", "public int compare(EventState es0, EventState es1) {\n", "return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n", "}\n", "\n", "});\n", "\n", "for (final EventState state : eventsStates) {\n", "if (state.evaluateStep(interpolator)) {\n", "// the event occurs during the current step\n", "occuringEvents.add(state);\n", "}\n", "}\n", "\n", "while (!occuringEvents.isEmpty()) {\n", "\n", "// handle the chronologically first event\n", "final Iterator<EventState> iterator = occuringEvents.iterator();\n", "final EventState currentEvent = iterator.next();\n", "iterator.remove();\n", "\n", "// restrict the interpolator to the first part of the step, up to the event\n", "final double eventT = currentEvent.getEventTime();\n", "interpolator.setSoftPreviousTime(previousT);\n", "interpolator.setSoftCurrentTime(eventT);\n", "\n", "// trigger the event\n", "interpolator.setInterpolatedTime(eventT);\n", "final double[] eventY = interpolator.getInterpolatedState();\n", "currentEvent.stepAccepted(eventT, eventY);\n", "isLastStep = currentEvent.stop();\n", "\n", "// handle the first part of the step, up to the event\n", "for (final StepHandler handler : stepHandlers) {\n", "handler.handleStep(interpolator, isLastStep);\n", "}\n", "\n", "if (isLastStep) {\n", "// the event asked to stop integration\n", "System.arraycopy(eventY, 0, y, 0, y.length);\n", "return eventT;\n", "}\n", "\n", "if (currentEvent.reset(eventT, eventY)) {\n", "// some event handler has triggered changes that\n", "// invalidate the derivatives, we need to recompute them\n", "System.arraycopy(eventY, 0, y, 0, y.length);\n", "computeDerivatives(eventT, y, yDot);\n", "resetOccurred = true;\n", "return eventT;\n", "}\n", "\n", "// prepare handling of the remaining part of the step\n", "previousT = eventT;\n", "interpolator.setSoftPreviousTime(eventT);\n", "interpolator.setSoftCurrentTime(currentT);\n", "\n", "// check if the same event occurs again in the remaining part of the step\n", "if (currentEvent.evaluateStep(interpolator)) {\n", "// the event occurs during the current step\n", "occuringEvents.add(currentEvent);\n", "}\n", "\n", "}\n", "\n", "interpolator.setInterpolatedTime(currentT);\n", "final double[] currentY = interpolator.getInterpolatedState();\n", "for (final EventState state : eventsStates) {\n", "state.stepAccepted(currentT, currentY);\n", "isLastStep = isLastStep || state.stop();\n", "}\n", "isLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n", "\n", "// handle the remaining part of the step, after all events if any\n", "for (StepHandler handler : stepHandlers) {\n", "handler.handleStep(interpolator, isLastStep);\n", "}\n", "\n", "return currentT;\n", "\n", "}\n"], "faulty_lines": [7], "cluster": 3}, {"pid": "Math", "bid": 45, "method_path": "./dataset/Math/45/OpenMapRealMatrix.java", "method": ["public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n", "super(rowDimension, columnDimension);\n", "this.rows = rowDimension;\n", "this.columns = columnDimension;\n", "this.entries = new OpenIntToDoubleHashMap(0.0);\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Math", "bid": 46, "method_path": "./dataset/Math/46/Complex.java", "method": ["public Complex divide(Complex divisor)\n", "throws NullArgumentException {\n", "MathUtils.checkNotNull(divisor);\n", "if (isNaN || divisor.isNaN) {\n", "return NaN;\n", "}\n", "\n", "if (divisor.isZero) {\n", "// return isZero ? NaN : INF; // See MATH-657\n", "return isZero ? NaN : INF;\n", "}\n", "\n", "if (divisor.isInfinite() && !isInfinite()) {\n", "return ZERO;\n", "}\n", "\n", "final double c = divisor.getReal();\n", "final double d = divisor.getImaginary();\n", "\n", "if (FastMath.abs(c) < FastMath.abs(d)) {\n", "double q = c / d;\n", "double denominator = c * q + d;\n", "return createComplex((real * q + imaginary) / denominator,\n", "(imaginary * q - real) / denominator);\n", "} else {\n", "double q = d / c;\n", "double denominator = d * q + c;\n", "return createComplex((imaginary * q + real) / denominator,\n", "(imaginary - real * q) / denominator);\n", "}\n", "}\n"], "faulty_lines": [10], "cluster": 8}, {"pid": "Math", "bid": 46, "method_path": "./dataset/Math/46/Complex.java", "method": ["public Complex divide(double divisor) {\n", "if (isNaN || Double.isNaN(divisor)) {\n", "return NaN;\n", "}\n", "if (divisor == 0d) {\n", "// return isZero ? NaN : INF; // See MATH-657\n", "return isZero ? NaN : INF;\n", "}\n", "if (Double.isInfinite(divisor)) {\n", "return !isInfinite() ? ZERO : NaN;\n", "}\n", "return createComplex(real / divisor,\n", "imaginary  / divisor);\n", "}\n"], "faulty_lines": [7], "cluster": 4}, {"pid": "Math", "bid": 47, "method_path": "./dataset/Math/47/Complex.java", "method": ["public Complex(double real, double imaginary) {\n", "this.real = real;\n", "this.imaginary = imaginary;\n", "\n", "isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n", "isInfinite = !isNaN &&\n", "(Double.isInfinite(real) || Double.isInfinite(imaginary));\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Math", "bid": 47, "method_path": "./dataset/Math/47/Complex.java", "method": ["public Complex divide(Complex divisor)\n", "throws NullArgumentException {\n", "MathUtils.checkNotNull(divisor);\n", "if (isNaN || divisor.isNaN) {\n", "return NaN;\n", "}\n", "\n", "if (divisor.getReal() == 0.0 && divisor.getImaginary() == 0.0) {\n", "return NaN;\n", "}\n", "\n", "if (divisor.isInfinite() && !isInfinite()) {\n", "return ZERO;\n", "}\n", "\n", "final double c = divisor.getReal();\n", "final double d = divisor.getImaginary();\n", "\n", "if (FastMath.abs(c) < FastMath.abs(d)) {\n", "double q = c / d;\n", "double denominator = c * q + d;\n", "return createComplex((real * q + imaginary) / denominator,\n", "(imaginary * q - real) / denominator);\n", "} else {\n", "double q = d / c;\n", "double denominator = d * q + c;\n", "return createComplex((imaginary * q + real) / denominator,\n", "(imaginary - real * q) / denominator);\n", "}\n", "}\n"], "faulty_lines": [8, 9], "cluster": 8}, {"pid": "Math", "bid": 47, "method_path": "./dataset/Math/47/Complex.java", "method": ["public Complex divide(double divisor) {\n", "if (isNaN || Double.isNaN(divisor)) {\n", "return NaN;\n", "}\n", "if (divisor == 0d) {\n", "return NaN;\n", "}\n", "if (Double.isInfinite(divisor)) {\n", "return !isInfinite() ? ZERO : NaN;\n", "}\n", "return createComplex(real / divisor,\n", "imaginary  / divisor);\n", "}\n"], "faulty_lines": [6], "cluster": 4}, {"pid": "Math", "bid": 49, "method_path": "./dataset/Math/49/OpenMapRealVector.java", "method": ["public OpenMapRealVector ebeDivide(RealVector v) {\n", "checkVectorDimensions(v.getDimension());\n", "OpenMapRealVector res = new OpenMapRealVector(this);\n", "Iterator iter = res.entries.iterator();\n", "while (iter.hasNext()) {\n", "iter.advance();\n", "res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n", "}\n", "return res;\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Math", "bid": 49, "method_path": "./dataset/Math/49/OpenMapRealVector.java", "method": ["public OpenMapRealVector ebeDivide(double[] v) {\n", "checkVectorDimensions(v.length);\n", "OpenMapRealVector res = new OpenMapRealVector(this);\n", "Iterator iter = res.entries.iterator();\n", "while (iter.hasNext()) {\n", "iter.advance();\n", "res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n", "}\n", "return res;\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Math", "bid": 49, "method_path": "./dataset/Math/49/OpenMapRealVector.java", "method": ["public OpenMapRealVector ebeMultiply(RealVector v) {\n", "checkVectorDimensions(v.getDimension());\n", "OpenMapRealVector res = new OpenMapRealVector(this);\n", "Iterator iter = res.entries.iterator();\n", "while (iter.hasNext()) {\n", "iter.advance();\n", "res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n", "}\n", "return res;\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Math", "bid": 49, "method_path": "./dataset/Math/49/OpenMapRealVector.java", "method": ["public OpenMapRealVector ebeMultiply(double[] v) {\n", "checkVectorDimensions(v.length);\n", "OpenMapRealVector res = new OpenMapRealVector(this);\n", "Iterator iter = res.entries.iterator();\n", "while (iter.hasNext()) {\n", "iter.advance();\n", "res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n", "}\n", "return res;\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Math", "bid": 52, "method_path": "./dataset/Math/52/Rotation.java", "method": ["public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n", "\n", "// norms computation\n", "double u1u1 = u1.getNormSq();\n", "double u2u2 = u2.getNormSq();\n", "double v1v1 = v1.getNormSq();\n", "double v2v2 = v2.getNormSq();\n", "if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n", "throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n", "}\n", "\n", "// normalize v1 in order to have (v1'|v1') = (u1|u1)\n", "v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n", "\n", "// adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n", "double u1u2   = u1.dotProduct(u2);\n", "double v1v2   = v1.dotProduct(v2);\n", "double coeffU = u1u2 / u1u1;\n", "double coeffV = v1v2 / u1u1;\n", "double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n", "double alpha  = coeffU - beta * coeffV;\n", "v2 = new Vector3D(alpha, v1, beta, v2);\n", "\n", "// preliminary computation\n", "Vector3D uRef  = u1;\n", "Vector3D vRef  = v1;\n", "Vector3D v1Su1 = v1.subtract(u1);\n", "Vector3D v2Su2 = v2.subtract(u2);\n", "Vector3D k     = v1Su1.crossProduct(v2Su2);\n", "Vector3D u3    = u1.crossProduct(u2);\n", "double c       = k.dotProduct(u3);\n", "if (c == 0) {\n", "// the (q1, q2, q3) vector is close to the (u1, u2) plane\n", "// we try other vectors\n", "Vector3D v3 = Vector3D.crossProduct(v1, v2);\n", "Vector3D v3Su3 = v3.subtract(u3);\n", "k = v1Su1.crossProduct(v3Su3);\n", "Vector3D u2Prime = u1.crossProduct(u3);\n", "c = k.dotProduct(u2Prime);\n", "\n", "if (c == 0) {\n", "// the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n", "// it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n", "k = v2Su2.crossProduct(v3Su3);;\n", "c = k.dotProduct(u2.crossProduct(u3));;\n", "\n", "if (c == 0) {\n", "// the (q1, q2, q3) vector is aligned with everything\n", "// this is really the identity rotation\n", "q0 = 1.0;\n", "q1 = 0.0;\n", "q2 = 0.0;\n", "q3 = 0.0;\n", "return;\n", "}\n", "\n", "// we will have to use u2 and v2 to compute the scalar part\n", "uRef = u2;\n", "vRef = v2;\n", "\n", "}\n", "\n", "}\n", "\n", "// compute the vectorial part\n", "c = FastMath.sqrt(c);\n", "double inv = 1.0 / (c + c);\n", "q1 = inv * k.getX();\n", "q2 = inv * k.getY();\n", "q3 = inv * k.getZ();\n", "\n", "// compute the scalar part\n", "k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n", "uRef.getZ() * q1 - uRef.getX() * q3,\n", "uRef.getX() * q2 - uRef.getY() * q1);\n", "q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n", "\n", "}\n"], "faulty_lines": [32], "cluster": 9}, {"pid": "Math", "bid": 52, "method_path": "./dataset/Math/52/Rotation.java", "method": ["public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n", "\n", "// norms computation\n", "double u1u1 = u1.getNormSq();\n", "double u2u2 = u2.getNormSq();\n", "double v1v1 = v1.getNormSq();\n", "double v2v2 = v2.getNormSq();\n", "if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n", "throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n", "}\n", "\n", "// normalize v1 in order to have (v1'|v1') = (u1|u1)\n", "v1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n", "\n", "// adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\n", "double u1u2   = u1.dotProduct(u2);\n", "double v1v2   = v1.dotProduct(v2);\n", "double coeffU = u1u2 / u1u1;\n", "double coeffV = v1v2 / u1u1;\n", "double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n", "double alpha  = coeffU - beta * coeffV;\n", "v2 = new Vector3D(alpha, v1, beta, v2);\n", "\n", "// preliminary computation\n", "Vector3D uRef  = u1;\n", "Vector3D vRef  = v1;\n", "Vector3D v1Su1 = v1.subtract(u1);\n", "Vector3D v2Su2 = v2.subtract(u2);\n", "Vector3D k     = v1Su1.crossProduct(v2Su2);\n", "Vector3D u3    = u1.crossProduct(u2);\n", "double c       = k.dotProduct(u3);\n", "if (c == 0) {\n", "// the (q1, q2, q3) vector is close to the (u1, u2) plane\n", "// we try other vectors\n", "Vector3D v3 = Vector3D.crossProduct(v1, v2);\n", "Vector3D v3Su3 = v3.subtract(u3);\n", "k = v1Su1.crossProduct(v3Su3);\n", "Vector3D u2Prime = u1.crossProduct(u3);\n", "c = k.dotProduct(u2Prime);\n", "\n", "if (c == 0) {\n", "// the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n", "// it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n", "k = v2Su2.crossProduct(v3Su3);;\n", "c = k.dotProduct(u2.crossProduct(u3));;\n", "\n", "if (c == 0) {\n", "// the (q1, q2, q3) vector is aligned with everything\n", "// this is really the identity rotation\n", "q0 = 1.0;\n", "q1 = 0.0;\n", "q2 = 0.0;\n", "q3 = 0.0;\n", "return;\n", "}\n", "\n", "// we will have to use u2 and v2 to compute the scalar part\n", "uRef = u2;\n", "vRef = v2;\n", "\n", "}\n", "\n", "}\n", "\n", "// compute the vectorial part\n", "c = FastMath.sqrt(c);\n", "double inv = 1.0 / (c + c);\n", "q1 = inv * k.getX();\n", "q2 = inv * k.getY();\n", "q3 = inv * k.getZ();\n", "\n", "// compute the scalar part\n", "k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n", "uRef.getZ() * q1 - uRef.getX() * q3,\n", "uRef.getX() * q2 - uRef.getY() * q1);\n", "q0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n", "\n", "}\n"], "faulty_lines": [41, 47], "cluster": 9}, {"pid": "Math", "bid": 53, "method_path": "./dataset/Math/53/Complex.java", "method": ["public Complex add(Complex rhs)\n", "throws NullArgumentException {\n", "MathUtils.checkNotNull(rhs);\n", "return createComplex(real + rhs.getReal(),\n", "imaginary + rhs.getImaginary());\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Math", "bid": 54, "method_path": "./dataset/Math/54/Dfp.java", "method": ["protected Dfp(final DfpField field, double x) {\n", "\n", "// initialize as if 0\n", "mant = new int[field.getRadixDigits()];\n", "sign = 1;\n", "exp = 0;\n", "nans = FINITE;\n", "this.field = field;\n", "\n", "long bits = Double.doubleToLongBits(x);\n", "long mantissa = bits & 0x000fffffffffffffL;\n", "int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n", "\n", "if (exponent == -1023) {\n", "// Zero or sub-normal\n", "if (x == 0) {\n", "// make sure 0 has the right sign\n", "return;\n", "}\n", "\n", "exponent++;\n", "\n", "// Normalize the subnormal number\n", "while ( (mantissa & 0x0010000000000000L) == 0) {\n", "exponent--;\n", "mantissa <<= 1;\n", "}\n", "mantissa &= 0x000fffffffffffffL;\n", "}\n", "\n", "if (exponent == 1024) {\n", "// infinity or NAN\n", "if (x != x) {\n", "sign = (byte) 1;\n", "nans = QNAN;\n", "} else if (x < 0) {\n", "sign = (byte) -1;\n", "nans = INFINITE;\n", "} else {\n", "sign = (byte) 1;\n", "nans = INFINITE;\n", "}\n", "return;\n", "}\n", "\n", "Dfp xdfp = new Dfp(field, mantissa);\n", "xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n", "xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n", "\n", "if ((bits & 0x8000000000000000L) != 0) {\n", "xdfp = xdfp.negate();\n", "}\n", "\n", "System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n", "sign = xdfp.sign;\n", "exp  = xdfp.exp;\n", "nans = xdfp.nans;\n", "\n", "}\n"], "faulty_lines": [18], "cluster": 3}, {"pid": "Math", "bid": 54, "method_path": "./dataset/Math/54/Dfp.java", "method": ["public double toDouble() {\n", "\n", "if (isInfinite()) {\n", "if (lessThan(getZero())) {\n", "return Double.NEGATIVE_INFINITY;\n", "} else {\n", "return Double.POSITIVE_INFINITY;\n", "}\n", "}\n", "\n", "if (isNaN()) {\n", "return Double.NaN;\n", "}\n", "\n", "Dfp y = this;\n", "boolean negate = false;\n", "if (lessThan(getZero())) {\n", "y = negate();\n", "negate = true;\n", "}\n", "\n", "/* Find the exponent, first estimate by integer log10, then adjust.\n", "Should be faster than doing a natural logarithm.  */\n", "int exponent = (int)(y.log10() * 3.32);\n", "if (exponent < 0) {\n", "exponent--;\n", "}\n", "\n", "Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n", "while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n", "tempDfp = tempDfp.multiply(2);\n", "exponent++;\n", "}\n", "exponent--;\n", "\n", "/* We have the exponent, now work on the mantissa */\n", "\n", "y = y.divide(DfpMath.pow(getTwo(), exponent));\n", "if (exponent > -1023) {\n", "y = y.subtract(getOne());\n", "}\n", "\n", "if (exponent < -1074) {\n", "return 0;\n", "}\n", "\n", "if (exponent > 1023) {\n", "return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n", "}\n", "\n", "\n", "y = y.multiply(newInstance(4503599627370496l)).rint();\n", "String str = y.toString();\n", "str = str.substring(0, str.length()-1);\n", "long mantissa = Long.parseLong(str);\n", "\n", "if (mantissa == 4503599627370496L) {\n", "// Handle special case where we round up to next power of two\n", "mantissa = 0;\n", "exponent++;\n", "}\n", "\n", "/* Its going to be subnormal, so make adjustments */\n", "if (exponent <= -1023) {\n", "exponent--;\n", "}\n", "\n", "while (exponent < -1023) {\n", "exponent++;\n", "mantissa >>>= 1;\n", "}\n", "\n", "long bits = mantissa | ((exponent + 1023L) << 52);\n", "double x = Double.longBitsToDouble(bits);\n", "\n", "if (negate) {\n", "x = -x;\n", "}\n", "\n", "return x;\n", "\n", "}\n"], "faulty_lines": [17], "cluster": 3}, {"pid": "Math", "bid": 55, "method_path": "./dataset/Math/55/Vector3D.java", "method": ["public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n", "\n", "\n", "// rescale both vectors without losing precision,\n", "// to ensure their norm are the same order of magnitude\n", "\n", "// we reduce cancellation errors by preconditioning,\n", "// we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n", "// v3 without loss of precision. See Kahan lecture\n", "// \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n", "// available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n", "\n", "// compute rho as an 8 bits approximation of v1.v2 / v2.v2\n", "\n", "\n", "// compute cross product from v3 and v2 instead of v1 and v2\n", "return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n", "\n", "}\n"], "faulty_lines": [3, 6], "cluster": 8}, {"pid": "Math", "bid": 55, "method_path": "./dataset/Math/55/Vector3D.java", "method": ["public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n", "\n", "\n", "// rescale both vectors without losing precision,\n", "// to ensure their norm are the same order of magnitude\n", "\n", "// we reduce cancellation errors by preconditioning,\n", "// we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n", "// v3 without loss of precision. See Kahan lecture\n", "// \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n", "// available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n", "\n", "// compute rho as an 8 bits approximation of v1.v2 / v2.v2\n", "\n", "\n", "// compute cross product from v3 and v2 instead of v1 and v2\n", "return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n", "\n", "}\n"], "faulty_lines": [14, 15, 17], "cluster": 8}, {"pid": "Math", "bid": 56, "method_path": "./dataset/Math/56/MultidimensionalCounter.java", "method": ["public int[] getCounts(int index) {\n", "if (index < 0 ||\n", "index >= totalSize) {\n", "throw new OutOfRangeException(index, 0, totalSize);\n", "}\n", "\n", "final int[] indices = new int[dimension];\n", "\n", "int count = 0;\n", "for (int i = 0; i < last; i++) {\n", "int idx = 0;\n", "final int offset = uniCounterOffset[i];\n", "while (count <= index) {\n", "count += offset;\n", "++idx;\n", "}\n", "--idx;\n", "count -= offset;\n", "indices[i] = idx;\n", "}\n", "\n", "int idx = 1;\n", "while (count < index) {\n", "count += idx;\n", "++idx;\n", "}\n", "--idx;\n", "indices[last] = idx;\n", "\n", "return indices;\n", "}\n"], "faulty_lines": [22, 23, 24, 25, 26, 27, 28], "cluster": 2}, {"pid": "Math", "bid": 57, "method_path": "./dataset/Math/57/KMeansPlusPlusClusterer.java", "method": ["private static <T extends Clusterable<T>> List<Cluster<T>>\n", "chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n", "\n", "final List<T> pointSet = new ArrayList<T>(points);\n", "final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n", "\n", "// Choose one center uniformly at random from among the data points.\n", "final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n", "resultSet.add(new Cluster<T>(firstPoint));\n", "\n", "final double[] dx2 = new double[pointSet.size()];\n", "while (resultSet.size() < k) {\n", "// For each data point x, compute D(x), the distance between x and\n", "// the nearest center that has already been chosen.\n", "int sum = 0;\n", "for (int i = 0; i < pointSet.size(); i++) {\n", "final T p = pointSet.get(i);\n", "final Cluster<T> nearest = getNearestCluster(resultSet, p);\n", "final double d = p.distanceFrom(nearest.getCenter());\n", "sum += d * d;\n", "dx2[i] = sum;\n", "}\n", "\n", "// Add one new data point as a center. Each point x is chosen with\n", "// probability proportional to D(x)2\n", "final double r = random.nextDouble() * sum;\n", "for (int i = 0 ; i < dx2.length; i++) {\n", "if (dx2[i] >= r) {\n", "final T p = pointSet.remove(i);\n", "resultSet.add(new Cluster<T>(p));\n", "break;\n", "}\n", "}\n", "}\n", "\n", "return resultSet;\n", "\n", "}\n"], "faulty_lines": [15], "cluster": 5}, {"pid": "Math", "bid": 58, "method_path": "./dataset/Math/58/GaussianFitter.java", "method": ["public double[] fit() {\n", "final double[] guess = (new ParameterGuesser(getObservations())).guess();\n", "return fit(new Gaussian.Parametric(), guess);\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Math", "bid": 59, "method_path": "./dataset/Math/59/FastMath.java", "method": ["public static float max(final float a, final float b) {\n", "return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Math", "bid": 60, "method_path": "./dataset/Math/60/NormalDistributionImpl.java", "method": ["public double cumulativeProbability(double x) throws MathException {\n", "final double dev = x - mean;\n", "try {\n", "return 0.5 * (1.0 + Erf.erf((dev) /\n", "(standardDeviation * FastMath.sqrt(2.0))));\n", "} catch (MaxIterationsExceededException ex) {\n", "if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n", "return 0;\n", "} else if (x > (mean + 20 * standardDeviation)) {\n", "return 1;\n", "} else {\n", "throw ex;\n", "}\n", "}\n", "}\n"], "faulty_lines": [3, 6, 7, 8, 9, 10, 11, 12, 13, 14], "cluster": 2}, {"pid": "Math", "bid": 61, "method_path": "./dataset/Math/61/PoissonDistributionImpl.java", "method": ["public PoissonDistributionImpl(double p, double epsilon, int maxIterations) {\n", "if (p <= 0) {\n", "throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NOT_POSITIVE_POISSON_MEAN, p);\n", "}\n", "mean = p;\n", "normal = new NormalDistributionImpl(p, FastMath.sqrt(p));\n", "this.epsilon = epsilon;\n", "this.maxIterations = maxIterations;\n", "}\n"], "faulty_lines": [3], "cluster": 4}, {"pid": "Math", "bid": 62, "method_path": "./dataset/Math/62/MultiStartUnivariateRealOptimizer.java", "method": ["public UnivariateRealPointValuePair optimize(final FUNC f,\n", "final GoalType goal,\n", "final double min, final double max)\n", "throws FunctionEvaluationException {\n", "return optimize(f, goal, min, max, 0);\n", "}\n"], "faulty_lines": [5], "cluster": 0}, {"pid": "Math", "bid": 62, "method_path": "./dataset/Math/62/MultiStartUnivariateRealOptimizer.java", "method": ["public UnivariateRealPointValuePair optimize(final FUNC f, final GoalType goal,\n", "final double min, final double max,\n", "final double startValue)\n", "throws FunctionEvaluationException {\n", "optima = new UnivariateRealPointValuePair[starts];\n", "totalEvaluations = 0;\n", "\n", "// Multi-start loop.\n", "for (int i = 0; i < starts; ++i) {\n", "try {\n", "final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n", "final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n", "optima[i] = optimizer.optimize(f, goal, FastMath.min(bound1, bound2), FastMath.max(bound1, bound2));\n", "} catch (FunctionEvaluationException fee) {\n", "optima[i] = null;\n", "} catch (ConvergenceException ce) {\n", "optima[i] = null;\n", "}\n", "\n", "final int usedEvaluations = optimizer.getEvaluations();\n", "optimizer.setMaxEvaluations(optimizer.getMaxEvaluations() - usedEvaluations);\n", "totalEvaluations += usedEvaluations;\n", "}\n", "\n", "sortPairs(goal);\n", "\n", "if (optima[0] == null) {\n", "throw new ConvergenceException(LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n", "starts);\n", "}\n", "\n", "// Return the point with the best objective function value.\n", "return optima[0];\n", "}\n"], "faulty_lines": [11, 12, 13], "cluster": 1}, {"pid": "Math", "bid": 63, "method_path": "./dataset/Math/63/MathUtils.java", "method": ["public static boolean equals(double x, double y) {\n", "return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Math", "bid": 64, "method_path": "./dataset/Math/64/LevenbergMarquardtOptimizer.java", "method": ["protected VectorialPointValuePair doOptimize()\n", "throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n", "\n", "// arrays shared with the other private methods\n", "solvedCols  = Math.min(rows, cols);\n", "diagR       = new double[cols];\n", "jacNorm     = new double[cols];\n", "beta        = new double[cols];\n", "permutation = new int[cols];\n", "lmDir       = new double[cols];\n", "\n", "// local point\n", "double   delta   = 0;\n", "double   xNorm   = 0;\n", "double[] diag    = new double[cols];\n", "double[] oldX    = new double[cols];\n", "double[] oldRes  = new double[rows];\n", "double[] work1   = new double[cols];\n", "double[] work2   = new double[cols];\n", "double[] work3   = new double[cols];\n", "\n", "// evaluate the function at the starting point and calculate its norm\n", "updateResidualsAndCost();\n", "\n", "// outer loop\n", "lmPar = 0;\n", "boolean firstIteration = true;\n", "VectorialPointValuePair current = new VectorialPointValuePair(point, objective);\n", "while (true) {\n", "incrementIterationsCounter();\n", "\n", "// compute the Q.R. decomposition of the jacobian matrix\n", "VectorialPointValuePair previous = current;\n", "updateJacobian();\n", "qrDecomposition();\n", "\n", "// compute Qt.res\n", "qTy(residuals);\n", "// now we don't need Q anymore,\n", "// so let jacobian contain the R matrix with its diagonal elements\n", "for (int k = 0; k < solvedCols; ++k) {\n", "int pk = permutation[k];\n", "jacobian[k][pk] = diagR[pk];\n", "}\n", "\n", "if (firstIteration) {\n", "\n", "// scale the point according to the norms of the columns\n", "// of the initial jacobian\n", "xNorm = 0;\n", "for (int k = 0; k < cols; ++k) {\n", "double dk = jacNorm[k];\n", "if (dk == 0) {\n", "dk = 1.0;\n", "}\n", "double xk = dk * point[k];\n", "xNorm  += xk * xk;\n", "diag[k] = dk;\n", "}\n", "xNorm = Math.sqrt(xNorm);\n", "\n", "// initialize the step bound delta\n", "delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n", "\n", "}\n", "\n", "// check orthogonality between function vector and jacobian columns\n", "double maxCosine = 0;\n", "if (cost != 0) {\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int    pj = permutation[j];\n", "double s  = jacNorm[pj];\n", "if (s != 0) {\n", "double sum = 0;\n", "for (int i = 0; i <= j; ++i) {\n", "sum += jacobian[i][pj] * residuals[i];\n", "}\n", "maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n", "}\n", "}\n", "}\n", "if (maxCosine <= orthoTolerance) {\n", "// convergence has been reached\n", "return current;\n", "}\n", "\n", "// rescale if necessary\n", "for (int j = 0; j < cols; ++j) {\n", "diag[j] = Math.max(diag[j], jacNorm[j]);\n", "}\n", "\n", "// inner loop\n", "for (double ratio = 0; ratio < 1.0e-4;) {\n", "\n", "// save the state\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "oldX[pj] = point[pj];\n", "}\n", "double previousCost = cost;\n", "double[] tmpVec = residuals;\n", "residuals = oldRes;\n", "oldRes    = tmpVec;\n", "\n", "// determine the Levenberg-Marquardt parameter\n", "determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n", "\n", "// compute the new point and the norm of the evolution direction\n", "double lmNorm = 0;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "lmDir[pj] = -lmDir[pj];\n", "point[pj] = oldX[pj] + lmDir[pj];\n", "double s = diag[pj] * lmDir[pj];\n", "lmNorm  += s * s;\n", "}\n", "lmNorm = Math.sqrt(lmNorm);\n", "// on the first iteration, adjust the initial step bound.\n", "if (firstIteration) {\n", "delta = Math.min(delta, lmNorm);\n", "}\n", "\n", "// evaluate the function at x + p and calculate its norm\n", "updateResidualsAndCost();\n", "current = new VectorialPointValuePair(point, objective);\n", "\n", "// compute the scaled actual reduction\n", "double actRed = -1.0;\n", "if (0.1 * cost < previousCost) {\n", "double r = cost / previousCost;\n", "actRed = 1.0 - r * r;\n", "}\n", "\n", "// compute the scaled predicted reduction\n", "// and the scaled directional derivative\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "double dirJ = lmDir[pj];\n", "work1[j] = 0;\n", "for (int i = 0; i <= j; ++i) {\n", "work1[i] += jacobian[i][pj] * dirJ;\n", "}\n", "}\n", "double coeff1 = 0;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "coeff1 += work1[j] * work1[j];\n", "}\n", "double pc2 = previousCost * previousCost;\n", "coeff1 = coeff1 / pc2;\n", "double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n", "double preRed = coeff1 + 2 * coeff2;\n", "double dirDer = -(coeff1 + coeff2);\n", "\n", "// ratio of the actual to the predicted reduction\n", "ratio = (preRed == 0) ? 0 : (actRed / preRed);\n", "\n", "// update the step bound\n", "if (ratio <= 0.25) {\n", "double tmp =\n", "(actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n", "if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n", "tmp = 0.1;\n", "}\n", "delta = tmp * Math.min(delta, 10.0 * lmNorm);\n", "lmPar /= tmp;\n", "} else if ((lmPar == 0) || (ratio >= 0.75)) {\n", "delta = 2 * lmNorm;\n", "lmPar *= 0.5;\n", "}\n", "\n", "// test for successful iteration.\n", "if (ratio >= 1.0e-4) {\n", "// successful iteration, update the norm\n", "firstIteration = false;\n", "xNorm = 0;\n", "for (int k = 0; k < cols; ++k) {\n", "double xK = diag[k] * point[k];\n", "xNorm    += xK * xK;\n", "}\n", "xNorm = Math.sqrt(xNorm);\n", "\n", "// tests for convergence.\n", "// we use the vectorial convergence checker\n", "} else {\n", "// failed iteration, reset the previous values\n", "cost = previousCost;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "point[pj] = oldX[pj];\n", "}\n", "tmpVec    = residuals;\n", "residuals = oldRes;\n", "oldRes    = tmpVec;\n", "}\n", "if (checker==null) {\n", "if (((Math.abs(actRed) <= costRelativeTolerance) &&\n", "(preRed <= costRelativeTolerance) &&\n", "(ratio <= 2.0)) ||\n", "(delta <= parRelativeTolerance * xNorm)) {\n", "return current;\n", "}\n", "} else {\n", "if (checker.converged(getIterations(), previous, current)) {\n", "return current;\n", "}\n", "}\n", "// tests for termination and stringent tolerances\n", "// (2.2204e-16 is the machine epsilon for IEEE754)\n", "if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n", "throw new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n", "costRelativeTolerance);\n", "} else if (delta <= 2.2204e-16 * xNorm) {\n", "throw new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n", "parRelativeTolerance);\n", "} else if (maxCosine <= 2.2204e-16)  {\n", "throw new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n", "orthoTolerance);\n", "}\n", "\n", "}\n", "\n", "}\n", "\n", "}\n"], "faulty_lines": [18], "cluster": 9}, {"pid": "Math", "bid": 65, "method_path": "./dataset/Math/65/AbstractLeastSquaresOptimizer.java", "method": ["public double getRMS() {\n", "double criterion = 0;\n", "for (int i = 0; i < rows; ++i) {\n", "final double residual = residuals[i];\n", "criterion += residual * residual * residualsWeights[i];\n", "}\n", "return Math.sqrt(criterion / rows);\n", "}\n"], "faulty_lines": [2, 3, 4, 5, 6, 7], "cluster": 0}, {"pid": "Math", "bid": 65, "method_path": "./dataset/Math/65/AbstractLeastSquaresOptimizer.java", "method": ["public double getChiSquare() {\n", "double chiSquare = 0;\n", "for (int i = 0; i < rows; ++i) {\n", "final double residual = residuals[i];\n", "chiSquare += residual * residual / residualsWeights[i];\n", "}\n", "return chiSquare;\n", "}\n"], "faulty_lines": [5], "cluster": 0}, {"pid": "Math", "bid": 66, "method_path": "./dataset/Math/66/BrentOptimizer.java", "method": ["public BrentOptimizer() {\n", "setMaxEvaluations(Integer.MAX_VALUE);\n", "setMaximalIterationCount(100);\n", "setAbsoluteAccuracy(1E-10);\n", "setRelativeAccuracy(1.0e-14);\n", "}\n"], "faulty_lines": [2, 4, 5], "cluster": 0}, {"pid": "Math", "bid": 66, "method_path": "./dataset/Math/66/BrentOptimizer.java", "method": ["private double localMin(boolean isMinim,\n", "UnivariateRealFunction f,\n", "GoalType goalType,\n", "double lo, double mid, double hi,\n", "double eps, double t)\n", "throws MaxIterationsExceededException, FunctionEvaluationException {\n", "if (eps <= 0) {\n", "throw new NotStrictlyPositiveException(eps);\n", "}\n", "if (t <= 0) {\n", "throw new NotStrictlyPositiveException(t);\n", "}\n", "double a, b;\n", "if (lo < hi) {\n", "a = lo;\n", "b = hi;\n", "} else {\n", "a = hi;\n", "b = lo;\n", "}\n", "\n", "double x = mid;\n", "double v = x;\n", "double w = x;\n", "double d = 0;\n", "double e = 0;\n", "double fx = computeObjectiveValue(f, x);\n", "if (goalType == GoalType.MAXIMIZE) {\n", "fx = -fx;\n", "}\n", "double fv = fx;\n", "double fw = fx;\n", "\n", "int count = 0;\n", "while (count < maximalIterationCount) {\n", "double m = 0.5 * (a + b);\n", "final double tol1 = eps * Math.abs(x) + t;\n", "final double tol2 = 2 * tol1;\n", "\n", "// Check stopping criterion.\n", "if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n", "double p = 0;\n", "double q = 0;\n", "double r = 0;\n", "double u = 0;\n", "\n", "if (Math.abs(e) > tol1) { // Fit parabola.\n", "r = (x - w) * (fx - fv);\n", "q = (x - v) * (fx - fw);\n", "p = (x - v) * q - (x - w) * r;\n", "q = 2 * (q - r);\n", "\n", "if (q > 0) {\n", "p = -p;\n", "} else {\n", "q = -q;\n", "}\n", "\n", "r = e;\n", "e = d;\n", "\n", "if (p > q * (a - x)\n", "&& p < q * (b - x)\n", "&& Math.abs(p) < Math.abs(0.5 * q * r)) {\n", "// Parabolic interpolation step.\n", "d = p / q;\n", "u = x + d;\n", "\n", "// f must not be evaluated too close to a or b.\n", "if (u - a < tol2\n", "|| b - u < tol2) {\n", "if (x <= m) {\n", "d = tol1;\n", "} else {\n", "d = -tol1;\n", "}\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "\n", "// Update by at least \"tol1\".\n", "if (Math.abs(d) < tol1) {\n", "if (d >= 0) {\n", "u = x + tol1;\n", "} else {\n", "u = x - tol1;\n", "}\n", "} else {\n", "u = x + d;\n", "}\n", "\n", "double fu = computeObjectiveValue(f, u);\n", "if (goalType == GoalType.MAXIMIZE) {\n", "fu = -fu;\n", "}\n", "\n", "// Update a, b, v, w and x.\n", "if (fu <= fx) {\n", "if (u < x) {\n", "b = x;\n", "} else {\n", "a = x;\n", "}\n", "v = w;\n", "fv = fw;\n", "w = x;\n", "fw = fx;\n", "x = u;\n", "fx = fu;\n", "} else {\n", "if (u < x) {\n", "a = u;\n", "} else {\n", "b = u;\n", "}\n", "if (fu <= fw\n", "|| w == x) {\n", "v = w;\n", "fv = fw;\n", "w = u;\n", "fw = fu;\n", "} else if (fu <= fv\n", "|| v == x\n", "|| v == w) {\n", "v = u;\n", "fv = fu;\n", "}\n", "}\n", "} else { // termination\n", "setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n", "return x;\n", "}\n", "++count;\n", "}\n", "throw new MaxIterationsExceededException(maximalIterationCount);\n", "}\n"], "faulty_lines": [27, 28, 34, 35], "cluster": 9}, {"pid": "Math", "bid": 66, "method_path": "./dataset/Math/66/BrentOptimizer.java", "method": ["private double localMin(boolean isMinim,\n", "UnivariateRealFunction f,\n", "GoalType goalType,\n", "double lo, double mid, double hi,\n", "double eps, double t)\n", "throws MaxIterationsExceededException, FunctionEvaluationException {\n", "if (eps <= 0) {\n", "throw new NotStrictlyPositiveException(eps);\n", "}\n", "if (t <= 0) {\n", "throw new NotStrictlyPositiveException(t);\n", "}\n", "double a, b;\n", "if (lo < hi) {\n", "a = lo;\n", "b = hi;\n", "} else {\n", "a = hi;\n", "b = lo;\n", "}\n", "\n", "double x = mid;\n", "double v = x;\n", "double w = x;\n", "double d = 0;\n", "double e = 0;\n", "double fx = computeObjectiveValue(f, x);\n", "if (goalType == GoalType.MAXIMIZE) {\n", "fx = -fx;\n", "}\n", "double fv = fx;\n", "double fw = fx;\n", "\n", "int count = 0;\n", "while (count < maximalIterationCount) {\n", "double m = 0.5 * (a + b);\n", "final double tol1 = eps * Math.abs(x) + t;\n", "final double tol2 = 2 * tol1;\n", "\n", "// Check stopping criterion.\n", "if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n", "double p = 0;\n", "double q = 0;\n", "double r = 0;\n", "double u = 0;\n", "\n", "if (Math.abs(e) > tol1) { // Fit parabola.\n", "r = (x - w) * (fx - fv);\n", "q = (x - v) * (fx - fw);\n", "p = (x - v) * q - (x - w) * r;\n", "q = 2 * (q - r);\n", "\n", "if (q > 0) {\n", "p = -p;\n", "} else {\n", "q = -q;\n", "}\n", "\n", "r = e;\n", "e = d;\n", "\n", "if (p > q * (a - x)\n", "&& p < q * (b - x)\n", "&& Math.abs(p) < Math.abs(0.5 * q * r)) {\n", "// Parabolic interpolation step.\n", "d = p / q;\n", "u = x + d;\n", "\n", "// f must not be evaluated too close to a or b.\n", "if (u - a < tol2\n", "|| b - u < tol2) {\n", "if (x <= m) {\n", "d = tol1;\n", "} else {\n", "d = -tol1;\n", "}\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "\n", "// Update by at least \"tol1\".\n", "if (Math.abs(d) < tol1) {\n", "if (d >= 0) {\n", "u = x + tol1;\n", "} else {\n", "u = x - tol1;\n", "}\n", "} else {\n", "u = x + d;\n", "}\n", "\n", "double fu = computeObjectiveValue(f, u);\n", "if (goalType == GoalType.MAXIMIZE) {\n", "fu = -fu;\n", "}\n", "\n", "// Update a, b, v, w and x.\n", "if (fu <= fx) {\n", "if (u < x) {\n", "b = x;\n", "} else {\n", "a = x;\n", "}\n", "v = w;\n", "fv = fw;\n", "w = x;\n", "fw = fx;\n", "x = u;\n", "fx = fu;\n", "} else {\n", "if (u < x) {\n", "a = u;\n", "} else {\n", "b = u;\n", "}\n", "if (fu <= fw\n", "|| w == x) {\n", "v = w;\n", "fv = fw;\n", "w = u;\n", "fw = fu;\n", "} else if (fu <= fv\n", "|| v == x\n", "|| v == w) {\n", "v = u;\n", "fv = fu;\n", "}\n", "}\n", "} else { // termination\n", "setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n", "return x;\n", "}\n", "++count;\n", "}\n", "throw new MaxIterationsExceededException(maximalIterationCount);\n", "}\n"], "faulty_lines": [108, 109], "cluster": 9}, {"pid": "Math", "bid": 66, "method_path": "./dataset/Math/66/BrentOptimizer.java", "method": ["private double localMin(boolean isMinim,\n", "UnivariateRealFunction f,\n", "GoalType goalType,\n", "double lo, double mid, double hi,\n", "double eps, double t)\n", "throws MaxIterationsExceededException, FunctionEvaluationException {\n", "if (eps <= 0) {\n", "throw new NotStrictlyPositiveException(eps);\n", "}\n", "if (t <= 0) {\n", "throw new NotStrictlyPositiveException(t);\n", "}\n", "double a, b;\n", "if (lo < hi) {\n", "a = lo;\n", "b = hi;\n", "} else {\n", "a = hi;\n", "b = lo;\n", "}\n", "\n", "double x = mid;\n", "double v = x;\n", "double w = x;\n", "double d = 0;\n", "double e = 0;\n", "double fx = computeObjectiveValue(f, x);\n", "if (goalType == GoalType.MAXIMIZE) {\n", "fx = -fx;\n", "}\n", "double fv = fx;\n", "double fw = fx;\n", "\n", "int count = 0;\n", "while (count < maximalIterationCount) {\n", "double m = 0.5 * (a + b);\n", "final double tol1 = eps * Math.abs(x) + t;\n", "final double tol2 = 2 * tol1;\n", "\n", "// Check stopping criterion.\n", "if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n", "double p = 0;\n", "double q = 0;\n", "double r = 0;\n", "double u = 0;\n", "\n", "if (Math.abs(e) > tol1) { // Fit parabola.\n", "r = (x - w) * (fx - fv);\n", "q = (x - v) * (fx - fw);\n", "p = (x - v) * q - (x - w) * r;\n", "q = 2 * (q - r);\n", "\n", "if (q > 0) {\n", "p = -p;\n", "} else {\n", "q = -q;\n", "}\n", "\n", "r = e;\n", "e = d;\n", "\n", "if (p > q * (a - x)\n", "&& p < q * (b - x)\n", "&& Math.abs(p) < Math.abs(0.5 * q * r)) {\n", "// Parabolic interpolation step.\n", "d = p / q;\n", "u = x + d;\n", "\n", "// f must not be evaluated too close to a or b.\n", "if (u - a < tol2\n", "|| b - u < tol2) {\n", "if (x <= m) {\n", "d = tol1;\n", "} else {\n", "d = -tol1;\n", "}\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "} else {\n", "// Golden section step.\n", "if (x < m) {\n", "e = b - x;\n", "} else {\n", "e = a - x;\n", "}\n", "d = GOLDEN_SECTION * e;\n", "}\n", "\n", "// Update by at least \"tol1\".\n", "if (Math.abs(d) < tol1) {\n", "if (d >= 0) {\n", "u = x + tol1;\n", "} else {\n", "u = x - tol1;\n", "}\n", "} else {\n", "u = x + d;\n", "}\n", "\n", "double fu = computeObjectiveValue(f, u);\n", "if (goalType == GoalType.MAXIMIZE) {\n", "fu = -fu;\n", "}\n", "\n", "// Update a, b, v, w and x.\n", "if (fu <= fx) {\n", "if (u < x) {\n", "b = x;\n", "} else {\n", "a = x;\n", "}\n", "v = w;\n", "fv = fw;\n", "w = x;\n", "fw = fx;\n", "x = u;\n", "fx = fu;\n", "} else {\n", "if (u < x) {\n", "a = u;\n", "} else {\n", "b = u;\n", "}\n", "if (fu <= fw\n", "|| w == x) {\n", "v = w;\n", "fv = fw;\n", "w = u;\n", "fw = fu;\n", "} else if (fu <= fv\n", "|| v == x\n", "|| v == w) {\n", "v = u;\n", "fv = fu;\n", "}\n", "}\n", "} else { // termination\n", "setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n", "return x;\n", "}\n", "++count;\n", "}\n", "throw new MaxIterationsExceededException(maximalIterationCount);\n", "}\n"], "faulty_lines": [146, 149, 151], "cluster": 9}, {"pid": "Math", "bid": 68, "method_path": "./dataset/Math/68/LevenbergMarquardtOptimizer.java", "method": ["public LevenbergMarquardtOptimizer() {\n", "\n", "// set up the superclass with a default  max cost evaluations setting\n", "setMaxIterations(1000);\n", "\n", "// default values for the tuning parameters\n", "setInitialStepBoundFactor(100.0);\n", "setCostRelativeTolerance(1.0e-10);\n", "setParRelativeTolerance(1.0e-10);\n", "setOrthoTolerance(1.0e-10);\n", "\n", "}\n"], "faulty_lines": [7], "cluster": 4}, {"pid": "Math", "bid": 68, "method_path": "./dataset/Math/68/LevenbergMarquardtOptimizer.java", "method": ["protected VectorialPointValuePair doOptimize()\n", "throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n", "\n", "// arrays shared with the other private methods\n", "solvedCols  = Math.min(rows, cols);\n", "diagR       = new double[cols];\n", "jacNorm     = new double[cols];\n", "beta        = new double[cols];\n", "permutation = new int[cols];\n", "lmDir       = new double[cols];\n", "\n", "// local point\n", "double   delta   = 0;\n", "double   xNorm   = 0;\n", "double[] diag    = new double[cols];\n", "double[] oldX    = new double[cols];\n", "double[] oldRes  = new double[rows];\n", "double[] work1   = new double[cols];\n", "double[] work2   = new double[cols];\n", "double[] work3   = new double[cols];\n", "\n", "// evaluate the function at the starting point and calculate its norm\n", "updateResidualsAndCost();\n", "\n", "// outer loop\n", "lmPar = 0;\n", "boolean firstIteration = true;\n", "while (true) {\n", "\n", "incrementIterationsCounter();\n", "\n", "// compute the Q.R. decomposition of the jacobian matrix\n", "updateJacobian();\n", "qrDecomposition();\n", "\n", "// compute Qt.res\n", "qTy(residuals);\n", "\n", "// now we don't need Q anymore,\n", "// so let jacobian contain the R matrix with its diagonal elements\n", "for (int k = 0; k < solvedCols; ++k) {\n", "int pk = permutation[k];\n", "jacobian[k][pk] = diagR[pk];\n", "}\n", "\n", "if (firstIteration) {\n", "\n", "// scale the point according to the norms of the columns\n", "// of the initial jacobian\n", "xNorm = 0;\n", "for (int k = 0; k < cols; ++k) {\n", "double dk = jacNorm[k];\n", "if (dk == 0) {\n", "dk = 1.0;\n", "}\n", "double xk = dk * point[k];\n", "xNorm  += xk * xk;\n", "diag[k] = dk;\n", "}\n", "xNorm = Math.sqrt(xNorm);\n", "\n", "// initialize the step bound delta\n", "delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n", "\n", "}\n", "\n", "// check orthogonality between function vector and jacobian columns\n", "double maxCosine = 0;\n", "if (cost != 0) {\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int    pj = permutation[j];\n", "double s  = jacNorm[pj];\n", "if (s != 0) {\n", "double sum = 0;\n", "for (int i = 0; i <= j; ++i) {\n", "sum += jacobian[i][pj] * residuals[i];\n", "}\n", "maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n", "}\n", "}\n", "}\n", "if (maxCosine <= orthoTolerance) {\n", "// convergence has been reached\n", "return new VectorialPointValuePair(point, objective);\n", "}\n", "\n", "// rescale if necessary\n", "for (int j = 0; j < cols; ++j) {\n", "diag[j] = Math.max(diag[j], jacNorm[j]);\n", "}\n", "\n", "// inner loop\n", "for (double ratio = 0; ratio < 1.0e-4;) {\n", "\n", "// save the state\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "oldX[pj] = point[pj];\n", "}\n", "double previousCost = cost;\n", "double[] tmpVec = residuals;\n", "residuals = oldRes;\n", "oldRes    = tmpVec;\n", "\n", "// determine the Levenberg-Marquardt parameter\n", "determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n", "\n", "// compute the new point and the norm of the evolution direction\n", "double lmNorm = 0;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "lmDir[pj] = -lmDir[pj];\n", "point[pj] = oldX[pj] + lmDir[pj];\n", "double s = diag[pj] * lmDir[pj];\n", "lmNorm  += s * s;\n", "}\n", "lmNorm = Math.sqrt(lmNorm);\n", "\n", "// on the first iteration, adjust the initial step bound.\n", "if (firstIteration) {\n", "delta = Math.min(delta, lmNorm);\n", "}\n", "\n", "// evaluate the function at x + p and calculate its norm\n", "updateResidualsAndCost();\n", "\n", "// compute the scaled actual reduction\n", "double actRed = -1.0;\n", "if (0.1 * cost < previousCost) {\n", "double r = cost / previousCost;\n", "actRed = 1.0 - r * r;\n", "}\n", "\n", "// compute the scaled predicted reduction\n", "// and the scaled directional derivative\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "double dirJ = lmDir[pj];\n", "work1[j] = 0;\n", "for (int i = 0; i <= j; ++i) {\n", "work1[i] += jacobian[i][pj] * dirJ;\n", "}\n", "}\n", "double coeff1 = 0;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "coeff1 += work1[j] * work1[j];\n", "}\n", "double pc2 = previousCost * previousCost;\n", "coeff1 = coeff1 / pc2;\n", "double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n", "double preRed = coeff1 + 2 * coeff2;\n", "double dirDer = -(coeff1 + coeff2);\n", "\n", "// ratio of the actual to the predicted reduction\n", "ratio = (preRed == 0) ? 0 : (actRed / preRed);\n", "\n", "// update the step bound\n", "if (ratio <= 0.25) {\n", "double tmp =\n", "(actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n", "if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n", "tmp = 0.1;\n", "}\n", "delta = tmp * Math.min(delta, 10.0 * lmNorm);\n", "lmPar /= tmp;\n", "} else if ((lmPar == 0) || (ratio >= 0.75)) {\n", "delta = 2 * lmNorm;\n", "lmPar *= 0.5;\n", "}\n", "\n", "// test for successful iteration.\n", "if (ratio >= 1.0e-4) {\n", "// successful iteration, update the norm\n", "firstIteration = false;\n", "xNorm = 0;\n", "for (int k = 0; k < cols; ++k) {\n", "double xK = diag[k] * point[k];\n", "xNorm    += xK * xK;\n", "}\n", "xNorm = Math.sqrt(xNorm);\n", "} else {\n", "// failed iteration, reset the previous values\n", "cost = previousCost;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "point[pj] = oldX[pj];\n", "}\n", "tmpVec    = residuals;\n", "residuals = oldRes;\n", "oldRes    = tmpVec;\n", "}\n", "\n", "// tests for convergence.\n", "// we use the vectorial convergence checker\n", "// we use the Levenberg-Marquardt specific convergence parameters\n", "if (((Math.abs(actRed) <= costRelativeTolerance) &&\n", "(preRed <= costRelativeTolerance) &&\n", "(ratio <= 2.0)) ||\n", "(delta <= parRelativeTolerance * xNorm)) {\n", "return new VectorialPointValuePair(point, objective);\n", "}\n", "\n", "// tests for termination and stringent tolerances\n", "// (2.2204e-16 is the machine epsilon for IEEE754)\n", "if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n", "throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" +\n", "\" no further reduction in the\" +\n", "\" sum of squares is possible\",\n", "costRelativeTolerance);\n", "} else if (delta <= 2.2204e-16 * xNorm) {\n", "throw new OptimizationException(\"parameters relative tolerance is too small\" +\n", "\" ({0}), no further improvement in\" +\n", "\" the approximate solution is possible\",\n", "parRelativeTolerance);\n", "} else if (maxCosine <= 2.2204e-16)  {\n", "throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" +\n", "\" solution is orthogonal to the jacobian\",\n", "orthoTolerance);\n", "}\n", "\n", "}\n", "\n", "}\n", "\n", "}\n"], "faulty_lines": [28, 33], "cluster": 9}, {"pid": "Math", "bid": 68, "method_path": "./dataset/Math/68/LevenbergMarquardtOptimizer.java", "method": ["boolean firstIteration = true;\n", "while (true) {\n", "\n", "incrementIterationsCounter();\n", "\n", "// compute the Q.R. decomposition of the jacobian matrix\n", "updateJacobian();\n", "qrDecomposition();\n", "\n", "// compute Qt.res\n", "qTy(residuals);\n", "\n", "// now we don't need Q anymore,\n", "// so let jacobian contain the R matrix with its diagonal elements\n", "for (int k = 0; k < solvedCols; ++k) {\n", "int pk = permutation[k];\n", "jacobian[k][pk] = diagR[pk];\n", "}\n", "\n", "if (firstIteration) {\n", "\n", "// scale the point according to the norms of the columns\n", "// of the initial jacobian\n", "xNorm = 0;\n", "for (int k = 0; k < cols; ++k) {\n", "double dk = jacNorm[k];\n", "if (dk == 0) {\n", "dk = 1.0;\n", "}\n", "double xk = dk * point[k];\n", "xNorm  += xk * xk;\n", "diag[k] = dk;\n", "}\n", "xNorm = Math.sqrt(xNorm);\n", "\n", "// initialize the step bound delta\n", "delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n", "\n", "}\n", "\n", "// check orthogonality between function vector and jacobian columns\n", "double maxCosine = 0;\n", "if (cost != 0) {\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int    pj = permutation[j];\n", "double s  = jacNorm[pj];\n", "if (s != 0) {\n", "double sum = 0;\n", "for (int i = 0; i <= j; ++i) {\n", "sum += jacobian[i][pj] * residuals[i];\n", "}\n", "maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n", "}\n", "}\n", "}\n", "if (maxCosine <= orthoTolerance) {\n", "// convergence has been reached\n", "return new VectorialPointValuePair(point, objective);\n", "}\n", "\n", "// rescale if necessary\n", "for (int j = 0; j < cols; ++j) {\n", "diag[j] = Math.max(diag[j], jacNorm[j]);\n", "}\n", "\n", "// inner loop\n", "for (double ratio = 0; ratio < 1.0e-4;) {\n", "\n", "// save the state\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "oldX[pj] = point[pj];\n", "}\n", "double previousCost = cost;\n", "double[] tmpVec = residuals;\n", "residuals = oldRes;\n", "oldRes    = tmpVec;\n", "\n", "// determine the Levenberg-Marquardt parameter\n", "determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n", "\n", "// compute the new point and the norm of the evolution direction\n", "double lmNorm = 0;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "lmDir[pj] = -lmDir[pj];\n", "point[pj] = oldX[pj] + lmDir[pj];\n", "double s = diag[pj] * lmDir[pj];\n", "lmNorm  += s * s;\n", "}\n", "lmNorm = Math.sqrt(lmNorm);\n", "\n", "// on the first iteration, adjust the initial step bound.\n", "if (firstIteration) {\n", "delta = Math.min(delta, lmNorm);\n", "}\n", "\n", "// evaluate the function at x + p and calculate its norm\n", "updateResidualsAndCost();\n", "\n", "// compute the scaled actual reduction\n", "double actRed = -1.0;\n", "if (0.1 * cost < previousCost) {\n", "double r = cost / previousCost;\n", "actRed = 1.0 - r * r;\n", "}\n", "\n", "// compute the scaled predicted reduction\n", "// and the scaled directional derivative\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "double dirJ = lmDir[pj];\n", "work1[j] = 0;\n", "for (int i = 0; i <= j; ++i) {\n", "work1[i] += jacobian[i][pj] * dirJ;\n", "}\n", "}\n", "double coeff1 = 0;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "coeff1 += work1[j] * work1[j];\n", "}\n", "double pc2 = previousCost * previousCost;\n", "coeff1 = coeff1 / pc2;\n", "double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n", "double preRed = coeff1 + 2 * coeff2;\n", "double dirDer = -(coeff1 + coeff2);\n", "\n", "// ratio of the actual to the predicted reduction\n", "ratio = (preRed == 0) ? 0 : (actRed / preRed);\n", "\n", "// update the step bound\n", "if (ratio <= 0.25) {\n", "double tmp =\n", "(actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n", "if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n", "tmp = 0.1;\n", "}\n", "delta = tmp * Math.min(delta, 10.0 * lmNorm);\n", "lmPar /= tmp;\n", "} else if ((lmPar == 0) || (ratio >= 0.75)) {\n", "delta = 2 * lmNorm;\n", "lmPar *= 0.5;\n", "}\n", "\n", "// test for successful iteration.\n", "if (ratio >= 1.0e-4) {\n", "// successful iteration, update the norm\n", "firstIteration = false;\n", "xNorm = 0;\n", "for (int k = 0; k < cols; ++k) {\n", "double xK = diag[k] * point[k];\n", "xNorm    += xK * xK;\n", "}\n", "xNorm = Math.sqrt(xNorm);\n", "} else {\n", "// failed iteration, reset the previous values\n", "cost = previousCost;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "point[pj] = oldX[pj];\n", "}\n", "tmpVec    = residuals;\n", "residuals = oldRes;\n", "oldRes    = tmpVec;\n", "}\n", "\n", "// tests for convergence.\n", "// we use the vectorial convergence checker\n", "// we use the Levenberg-Marquardt specific convergence parameters\n", "if (((Math.abs(actRed) <= costRelativeTolerance) &&\n", "(preRed <= costRelativeTolerance) &&\n", "(ratio <= 2.0)) ||\n", "(delta <= parRelativeTolerance * xNorm)) {\n", "return new VectorialPointValuePair(point, objective);\n", "}\n", "\n", "// tests for termination and stringent tolerances\n", "// (2.2204e-16 is the machine epsilon for IEEE754)\n", "if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n", "throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" +\n", "\" no further reduction in the\" +\n", "\" sum of squares is possible\",\n", "costRelativeTolerance);\n", "} else if (delta <= 2.2204e-16 * xNorm) {\n", "throw new OptimizationException(\"parameters relative tolerance is too small\" +\n", "\" ({0}), no further improvement in\" +\n", "\" the approximate solution is possible\",\n", "parRelativeTolerance);\n", "} else if (maxCosine <= 2.2204e-16)  {\n", "throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" +\n", "\" solution is orthogonal to the jacobian\",\n", "orthoTolerance);\n", "}\n", "\n", "}\n", "\n", "}\n"], "faulty_lines": [58], "cluster": 9}, {"pid": "Math", "bid": 68, "method_path": "./dataset/Math/68/LevenbergMarquardtOptimizer.java", "method": ["boolean firstIteration = true;\n", "while (true) {\n", "\n", "incrementIterationsCounter();\n", "\n", "// compute the Q.R. decomposition of the jacobian matrix\n", "updateJacobian();\n", "qrDecomposition();\n", "\n", "// compute Qt.res\n", "qTy(residuals);\n", "\n", "// now we don't need Q anymore,\n", "// so let jacobian contain the R matrix with its diagonal elements\n", "for (int k = 0; k < solvedCols; ++k) {\n", "int pk = permutation[k];\n", "jacobian[k][pk] = diagR[pk];\n", "}\n", "\n", "if (firstIteration) {\n", "\n", "// scale the point according to the norms of the columns\n", "// of the initial jacobian\n", "xNorm = 0;\n", "for (int k = 0; k < cols; ++k) {\n", "double dk = jacNorm[k];\n", "if (dk == 0) {\n", "dk = 1.0;\n", "}\n", "double xk = dk * point[k];\n", "xNorm  += xk * xk;\n", "diag[k] = dk;\n", "}\n", "xNorm = Math.sqrt(xNorm);\n", "\n", "// initialize the step bound delta\n", "delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n", "\n", "}\n", "\n", "// check orthogonality between function vector and jacobian columns\n", "double maxCosine = 0;\n", "if (cost != 0) {\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int    pj = permutation[j];\n", "double s  = jacNorm[pj];\n", "if (s != 0) {\n", "double sum = 0;\n", "for (int i = 0; i <= j; ++i) {\n", "sum += jacobian[i][pj] * residuals[i];\n", "}\n", "maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n", "}\n", "}\n", "}\n", "if (maxCosine <= orthoTolerance) {\n", "// convergence has been reached\n", "return new VectorialPointValuePair(point, objective);\n", "}\n", "\n", "// rescale if necessary\n", "for (int j = 0; j < cols; ++j) {\n", "diag[j] = Math.max(diag[j], jacNorm[j]);\n", "}\n", "\n", "// inner loop\n", "for (double ratio = 0; ratio < 1.0e-4;) {\n", "\n", "// save the state\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "oldX[pj] = point[pj];\n", "}\n", "double previousCost = cost;\n", "double[] tmpVec = residuals;\n", "residuals = oldRes;\n", "oldRes    = tmpVec;\n", "\n", "// determine the Levenberg-Marquardt parameter\n", "determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n", "\n", "// compute the new point and the norm of the evolution direction\n", "double lmNorm = 0;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "lmDir[pj] = -lmDir[pj];\n", "point[pj] = oldX[pj] + lmDir[pj];\n", "double s = diag[pj] * lmDir[pj];\n", "lmNorm  += s * s;\n", "}\n", "lmNorm = Math.sqrt(lmNorm);\n", "\n", "// on the first iteration, adjust the initial step bound.\n", "if (firstIteration) {\n", "delta = Math.min(delta, lmNorm);\n", "}\n", "\n", "// evaluate the function at x + p and calculate its norm\n", "updateResidualsAndCost();\n", "\n", "// compute the scaled actual reduction\n", "double actRed = -1.0;\n", "if (0.1 * cost < previousCost) {\n", "double r = cost / previousCost;\n", "actRed = 1.0 - r * r;\n", "}\n", "\n", "// compute the scaled predicted reduction\n", "// and the scaled directional derivative\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "double dirJ = lmDir[pj];\n", "work1[j] = 0;\n", "for (int i = 0; i <= j; ++i) {\n", "work1[i] += jacobian[i][pj] * dirJ;\n", "}\n", "}\n", "double coeff1 = 0;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "coeff1 += work1[j] * work1[j];\n", "}\n", "double pc2 = previousCost * previousCost;\n", "coeff1 = coeff1 / pc2;\n", "double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n", "double preRed = coeff1 + 2 * coeff2;\n", "double dirDer = -(coeff1 + coeff2);\n", "\n", "// ratio of the actual to the predicted reduction\n", "ratio = (preRed == 0) ? 0 : (actRed / preRed);\n", "\n", "// update the step bound\n", "if (ratio <= 0.25) {\n", "double tmp =\n", "(actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n", "if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n", "tmp = 0.1;\n", "}\n", "delta = tmp * Math.min(delta, 10.0 * lmNorm);\n", "lmPar /= tmp;\n", "} else if ((lmPar == 0) || (ratio >= 0.75)) {\n", "delta = 2 * lmNorm;\n", "lmPar *= 0.5;\n", "}\n", "\n", "// test for successful iteration.\n", "if (ratio >= 1.0e-4) {\n", "// successful iteration, update the norm\n", "firstIteration = false;\n", "xNorm = 0;\n", "for (int k = 0; k < cols; ++k) {\n", "double xK = diag[k] * point[k];\n", "xNorm    += xK * xK;\n", "}\n", "xNorm = Math.sqrt(xNorm);\n", "} else {\n", "// failed iteration, reset the previous values\n", "cost = previousCost;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "point[pj] = oldX[pj];\n", "}\n", "tmpVec    = residuals;\n", "residuals = oldRes;\n", "oldRes    = tmpVec;\n", "}\n", "\n", "// tests for convergence.\n", "// we use the vectorial convergence checker\n", "// we use the Levenberg-Marquardt specific convergence parameters\n", "if (((Math.abs(actRed) <= costRelativeTolerance) &&\n", "(preRed <= costRelativeTolerance) &&\n", "(ratio <= 2.0)) ||\n", "(delta <= parRelativeTolerance * xNorm)) {\n", "return new VectorialPointValuePair(point, objective);\n", "}\n", "\n", "// tests for termination and stringent tolerances\n", "// (2.2204e-16 is the machine epsilon for IEEE754)\n", "if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n", "throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" +\n", "\" no further reduction in the\" +\n", "\" sum of squares is possible\",\n", "costRelativeTolerance);\n", "} else if (delta <= 2.2204e-16 * xNorm) {\n", "throw new OptimizationException(\"parameters relative tolerance is too small\" +\n", "\" ({0}), no further improvement in\" +\n", "\" the approximate solution is possible\",\n", "parRelativeTolerance);\n", "} else if (maxCosine <= 2.2204e-16)  {\n", "throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" +\n", "\" solution is orthogonal to the jacobian\",\n", "orthoTolerance);\n", "}\n", "\n", "}\n", "\n", "}\n"], "faulty_lines": [100], "cluster": 9}, {"pid": "Math", "bid": 68, "method_path": "./dataset/Math/68/LevenbergMarquardtOptimizer.java", "method": ["boolean firstIteration = true;\n", "while (true) {\n", "\n", "incrementIterationsCounter();\n", "\n", "// compute the Q.R. decomposition of the jacobian matrix\n", "updateJacobian();\n", "qrDecomposition();\n", "\n", "// compute Qt.res\n", "qTy(residuals);\n", "\n", "// now we don't need Q anymore,\n", "// so let jacobian contain the R matrix with its diagonal elements\n", "for (int k = 0; k < solvedCols; ++k) {\n", "int pk = permutation[k];\n", "jacobian[k][pk] = diagR[pk];\n", "}\n", "\n", "if (firstIteration) {\n", "\n", "// scale the point according to the norms of the columns\n", "// of the initial jacobian\n", "xNorm = 0;\n", "for (int k = 0; k < cols; ++k) {\n", "double dk = jacNorm[k];\n", "if (dk == 0) {\n", "dk = 1.0;\n", "}\n", "double xk = dk * point[k];\n", "xNorm  += xk * xk;\n", "diag[k] = dk;\n", "}\n", "xNorm = Math.sqrt(xNorm);\n", "\n", "// initialize the step bound delta\n", "delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n", "\n", "}\n", "\n", "// check orthogonality between function vector and jacobian columns\n", "double maxCosine = 0;\n", "if (cost != 0) {\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int    pj = permutation[j];\n", "double s  = jacNorm[pj];\n", "if (s != 0) {\n", "double sum = 0;\n", "for (int i = 0; i <= j; ++i) {\n", "sum += jacobian[i][pj] * residuals[i];\n", "}\n", "maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n", "}\n", "}\n", "}\n", "if (maxCosine <= orthoTolerance) {\n", "// convergence has been reached\n", "return new VectorialPointValuePair(point, objective);\n", "}\n", "\n", "// rescale if necessary\n", "for (int j = 0; j < cols; ++j) {\n", "diag[j] = Math.max(diag[j], jacNorm[j]);\n", "}\n", "\n", "// inner loop\n", "for (double ratio = 0; ratio < 1.0e-4;) {\n", "\n", "// save the state\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "oldX[pj] = point[pj];\n", "}\n", "double previousCost = cost;\n", "double[] tmpVec = residuals;\n", "residuals = oldRes;\n", "oldRes    = tmpVec;\n", "\n", "// determine the Levenberg-Marquardt parameter\n", "determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n", "\n", "// compute the new point and the norm of the evolution direction\n", "double lmNorm = 0;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "lmDir[pj] = -lmDir[pj];\n", "point[pj] = oldX[pj] + lmDir[pj];\n", "double s = diag[pj] * lmDir[pj];\n", "lmNorm  += s * s;\n", "}\n", "lmNorm = Math.sqrt(lmNorm);\n", "\n", "// on the first iteration, adjust the initial step bound.\n", "if (firstIteration) {\n", "delta = Math.min(delta, lmNorm);\n", "}\n", "\n", "// evaluate the function at x + p and calculate its norm\n", "updateResidualsAndCost();\n", "\n", "// compute the scaled actual reduction\n", "double actRed = -1.0;\n", "if (0.1 * cost < previousCost) {\n", "double r = cost / previousCost;\n", "actRed = 1.0 - r * r;\n", "}\n", "\n", "// compute the scaled predicted reduction\n", "// and the scaled directional derivative\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "double dirJ = lmDir[pj];\n", "work1[j] = 0;\n", "for (int i = 0; i <= j; ++i) {\n", "work1[i] += jacobian[i][pj] * dirJ;\n", "}\n", "}\n", "double coeff1 = 0;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "coeff1 += work1[j] * work1[j];\n", "}\n", "double pc2 = previousCost * previousCost;\n", "coeff1 = coeff1 / pc2;\n", "double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n", "double preRed = coeff1 + 2 * coeff2;\n", "double dirDer = -(coeff1 + coeff2);\n", "\n", "// ratio of the actual to the predicted reduction\n", "ratio = (preRed == 0) ? 0 : (actRed / preRed);\n", "\n", "// update the step bound\n", "if (ratio <= 0.25) {\n", "double tmp =\n", "(actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n", "if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n", "tmp = 0.1;\n", "}\n", "delta = tmp * Math.min(delta, 10.0 * lmNorm);\n", "lmPar /= tmp;\n", "} else if ((lmPar == 0) || (ratio >= 0.75)) {\n", "delta = 2 * lmNorm;\n", "lmPar *= 0.5;\n", "}\n", "\n", "// test for successful iteration.\n", "if (ratio >= 1.0e-4) {\n", "// successful iteration, update the norm\n", "firstIteration = false;\n", "xNorm = 0;\n", "for (int k = 0; k < cols; ++k) {\n", "double xK = diag[k] * point[k];\n", "xNorm    += xK * xK;\n", "}\n", "xNorm = Math.sqrt(xNorm);\n", "} else {\n", "// failed iteration, reset the previous values\n", "cost = previousCost;\n", "for (int j = 0; j < solvedCols; ++j) {\n", "int pj = permutation[j];\n", "point[pj] = oldX[pj];\n", "}\n", "tmpVec    = residuals;\n", "residuals = oldRes;\n", "oldRes    = tmpVec;\n", "}\n", "\n", "// tests for convergence.\n", "// we use the vectorial convergence checker\n", "// we use the Levenberg-Marquardt specific convergence parameters\n", "if (((Math.abs(actRed) <= costRelativeTolerance) &&\n", "(preRed <= costRelativeTolerance) &&\n", "(ratio <= 2.0)) ||\n", "(delta <= parRelativeTolerance * xNorm)) {\n", "return new VectorialPointValuePair(point, objective);\n", "}\n", "\n", "// tests for termination and stringent tolerances\n", "// (2.2204e-16 is the machine epsilon for IEEE754)\n", "if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n", "throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" +\n", "\" no further reduction in the\" +\n", "\" sum of squares is possible\",\n", "costRelativeTolerance);\n", "} else if (delta <= 2.2204e-16 * xNorm) {\n", "throw new OptimizationException(\"parameters relative tolerance is too small\" +\n", "\" ({0}), no further improvement in\" +\n", "\" the approximate solution is possible\",\n", "parRelativeTolerance);\n", "} else if (maxCosine <= 2.2204e-16)  {\n", "throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" +\n", "\" solution is orthogonal to the jacobian\",\n", "orthoTolerance);\n", "}\n", "\n", "}\n", "\n", "}\n"], "faulty_lines": [168, 169, 174, 176], "cluster": 9}, {"pid": "Math", "bid": 69, "method_path": "./dataset/Math/69/PearsonsCorrelation.java", "method": ["public RealMatrix getCorrelationPValues() throws MathException {\n", "TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n", "int nVars = correlationMatrix.getColumnDimension();\n", "double[][] out = new double[nVars][nVars];\n", "for (int i = 0; i < nVars; i++) {\n", "for (int j = 0; j < nVars; j++) {\n", "if (i == j) {\n", "out[i][j] = 0d;\n", "} else {\n", "double r = correlationMatrix.getEntry(i, j);\n", "double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n", "out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n", "}\n", "}\n", "}\n", "return new BlockRealMatrix(out);\n", "}\n"], "faulty_lines": [12], "cluster": 2}, {"pid": "Math", "bid": 70, "method_path": "./dataset/Math/70/BisectionSolver.java", "method": ["public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n", "throws MaxIterationsExceededException, FunctionEvaluationException {\n", "return solve(min, max);\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Math", "bid": 72, "method_path": "./dataset/Math/72/BrentSolver.java", "method": ["public double solve(final UnivariateRealFunction f,\n", "final double min, final double max, final double initial)\n", "throws MaxIterationsExceededException, FunctionEvaluationException {\n", "\n", "clearResult();\n", "verifySequence(min, initial, max);\n", "\n", "// return the initial guess if it is good enough\n", "double yInitial = f.value(initial);\n", "if (Math.abs(yInitial) <= functionValueAccuracy) {\n", "setResult(initial, 0);\n", "return result;\n", "}\n", "\n", "// return the first endpoint if it is good enough\n", "double yMin = f.value(min);\n", "if (Math.abs(yMin) <= functionValueAccuracy) {\n", "setResult(yMin, 0);\n", "return result;\n", "}\n", "\n", "// reduce interval if min and initial bracket the root\n", "if (yInitial * yMin < 0) {\n", "return solve(f, min, yMin, initial, yInitial, min, yMin);\n", "}\n", "\n", "// return the second endpoint if it is good enough\n", "double yMax = f.value(max);\n", "if (Math.abs(yMax) <= functionValueAccuracy) {\n", "setResult(yMax, 0);\n", "return result;\n", "}\n", "\n", "// reduce interval if initial and max bracket the root\n", "if (yInitial * yMax < 0) {\n", "return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n", "}\n", "\n", "if (yMin * yMax > 0) {\n", "throw MathRuntimeException.createIllegalArgumentException(\n", "NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n", "}\n", "\n", "// full Brent algorithm starting with provided initial guess\n", "return solve(f, min, yMin, max, yMax, initial, yInitial);\n", "\n", "}\n"], "faulty_lines": [18], "cluster": 5}, {"pid": "Math", "bid": 72, "method_path": "./dataset/Math/72/BrentSolver.java", "method": ["public double solve(final UnivariateRealFunction f,\n", "final double min, final double max, final double initial)\n", "throws MaxIterationsExceededException, FunctionEvaluationException {\n", "\n", "clearResult();\n", "verifySequence(min, initial, max);\n", "\n", "// return the initial guess if it is good enough\n", "double yInitial = f.value(initial);\n", "if (Math.abs(yInitial) <= functionValueAccuracy) {\n", "setResult(initial, 0);\n", "return result;\n", "}\n", "\n", "// return the first endpoint if it is good enough\n", "double yMin = f.value(min);\n", "if (Math.abs(yMin) <= functionValueAccuracy) {\n", "setResult(yMin, 0);\n", "return result;\n", "}\n", "\n", "// reduce interval if min and initial bracket the root\n", "if (yInitial * yMin < 0) {\n", "return solve(f, min, yMin, initial, yInitial, min, yMin);\n", "}\n", "\n", "// return the second endpoint if it is good enough\n", "double yMax = f.value(max);\n", "if (Math.abs(yMax) <= functionValueAccuracy) {\n", "setResult(yMax, 0);\n", "return result;\n", "}\n", "\n", "// reduce interval if initial and max bracket the root\n", "if (yInitial * yMax < 0) {\n", "return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n", "}\n", "\n", "if (yMin * yMax > 0) {\n", "throw MathRuntimeException.createIllegalArgumentException(\n", "NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n", "}\n", "\n", "// full Brent algorithm starting with provided initial guess\n", "return solve(f, min, yMin, max, yMax, initial, yInitial);\n", "\n", "}\n"], "faulty_lines": [30], "cluster": 5}, {"pid": "Math", "bid": 73, "method_path": "./dataset/Math/73/BrentSolver.java", "method": ["public double solve(final UnivariateRealFunction f,\n", "final double min, final double max, final double initial)\n", "throws MaxIterationsExceededException, FunctionEvaluationException {\n", "\n", "clearResult();\n", "verifySequence(min, initial, max);\n", "\n", "// return the initial guess if it is good enough\n", "double yInitial = f.value(initial);\n", "if (Math.abs(yInitial) <= functionValueAccuracy) {\n", "setResult(initial, 0);\n", "return result;\n", "}\n", "\n", "// return the first endpoint if it is good enough\n", "double yMin = f.value(min);\n", "if (Math.abs(yMin) <= functionValueAccuracy) {\n", "setResult(yMin, 0);\n", "return result;\n", "}\n", "\n", "// reduce interval if min and initial bracket the root\n", "if (yInitial * yMin < 0) {\n", "return solve(f, min, yMin, initial, yInitial, min, yMin);\n", "}\n", "\n", "// return the second endpoint if it is good enough\n", "double yMax = f.value(max);\n", "if (Math.abs(yMax) <= functionValueAccuracy) {\n", "setResult(yMax, 0);\n", "return result;\n", "}\n", "\n", "// reduce interval if initial and max bracket the root\n", "if (yInitial * yMax < 0) {\n", "return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n", "}\n", "\n", "\n", "// full Brent algorithm starting with provided initial guess\n", "return solve(f, min, yMin, max, yMax, initial, yInitial);\n", "\n", "}\n"], "faulty_lines": [39], "cluster": 1}, {"pid": "Math", "bid": 75, "method_path": "./dataset/Math/75/Frequency.java", "method": ["public double getPct(Object v) {\n", "return getCumPct((Comparable<?>) v);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Math", "bid": 76, "method_path": "./dataset/Math/76/SingularValueDecompositionImpl.java", "method": ["public RealMatrix getU()\n", "throws InvalidMatrixException {\n", "\n", "if (cachedU == null) {\n", "\n", "final int p = singularValues.length;\n", "if (m >= n) {\n", "// the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n", "final RealMatrix e =\n", "eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n", "final double[][] eData = e.getData();\n", "final double[][] wData = new double[m][p];\n", "double[] ei1 = eData[0];\n", "for (int i = 0; i < p - 1; ++i) {\n", "// compute W = B.E.S^(-1) where E is the eigenvectors matrix\n", "final double mi = mainBidiagonal[i];\n", "final double[] ei0 = ei1;\n", "final double[] wi  = wData[i];\n", "ei1 = eData[i + 1];\n", "final double si = secondaryBidiagonal[i];\n", "for (int j = 0; j < p; ++j) {\n", "wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n", "}\n", "}\n", "for (int j = 0; j < p; ++j) {\n", "wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n", "}\n", "\n", "for (int i = p; i < m; ++i) {\n", "wData[i] = new double[p];\n", "}\n", "cachedU =\n", "transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n", "} else {\n", "// the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n", "final RealMatrix e =\n", "eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n", "cachedU = transformer.getU().multiply(e);\n", "}\n", "\n", "}\n", "\n", "// return the cached matrix\n", "return cachedU;\n", "\n", "}\n"], "faulty_lines": [10, 14, 19, 24, 26, 28], "cluster": 9}, {"pid": "Math", "bid": 76, "method_path": "./dataset/Math/76/SingularValueDecompositionImpl.java", "method": ["public RealMatrix getV()\n", "throws InvalidMatrixException {\n", "\n", "if (cachedV == null) {\n", "\n", "final int p = singularValues.length;\n", "if (m >= n) {\n", "// the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n", "final RealMatrix e =\n", "eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n", "cachedV = transformer.getV().multiply(e);\n", "} else {\n", "// the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n", "// compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n", "final RealMatrix e =\n", "eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n", "final double[][] eData = e.getData();\n", "final double[][] wData = new double[n][p];\n", "double[] ei1 = eData[0];\n", "for (int i = 0; i < p - 1; ++i) {\n", "final double mi = mainBidiagonal[i];\n", "final double[] ei0 = ei1;\n", "final double[] wi  = wData[i];\n", "ei1 = eData[i + 1];\n", "final double si = secondaryBidiagonal[i];\n", "for (int j = 0; j < p; ++j) {\n", "wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n", "}\n", "}\n", "for (int j = 0; j < p; ++j) {\n", "wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n", "}\n", "for (int i = p; i < n; ++i) {\n", "wData[i] = new double[p];\n", "}\n", "cachedV =\n", "transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n", "}\n", "\n", "}\n", "\n", "// return the cached matrix\n", "return cachedV;\n", "\n", "}\n"], "faulty_lines": [16, 20, 24, 29, 31, 33], "cluster": 9}, {"pid": "Math", "bid": 77, "method_path": "./dataset/Math/77/ArrayRealVector.java", "method": ["public double getLInfNorm() {\n", "double max = 0;\n", "for (double a : data) {\n", "max += Math.max(max, Math.abs(a));\n", "}\n", "return max;\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Math", "bid": 78, "method_path": "./dataset/Math/78/EventState.java", "method": ["public boolean evaluateStep(final StepInterpolator interpolator)\n", "throws DerivativeException, EventException, ConvergenceException {\n", "\n", "try {\n", "\n", "forward = interpolator.isForward();\n", "final double t1 = interpolator.getCurrentTime();\n", "final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n", "final double h  = (t1 - t0) / n;\n", "\n", "double ta = t0;\n", "double ga = g0;\n", "double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n", "for (int i = 0; i < n; ++i) {\n", "\n", "// evaluate handler value at the end of the substep\n", "tb += h;\n", "interpolator.setInterpolatedTime(tb);\n", "final double gb = handler.g(tb, interpolator.getInterpolatedState());\n", "\n", "// check events occurrence\n", "if (g0Positive ^ (gb >= 0)) {\n", "// there is a sign change: an event is expected during this step\n", "\n", "// this is a corner case:\n", "// - there was an event near ta,\n", "// - there is another event between ta and tb\n", "// - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n", "// this implies that the real sign of ga is the same as gb, so we need to slightly\n", "// shift ta to make sure ga and gb get opposite signs and the solver won't complain\n", "// about bracketing\n", "// this should never happen\n", "\n", "// variation direction, with respect to the integration direction\n", "increasing = gb >= ga;\n", "\n", "final UnivariateRealFunction f = new UnivariateRealFunction() {\n", "public double value(final double t) throws FunctionEvaluationException {\n", "try {\n", "interpolator.setInterpolatedTime(t);\n", "return handler.g(t, interpolator.getInterpolatedState());\n", "} catch (DerivativeException e) {\n", "throw new FunctionEvaluationException(e, t);\n", "} catch (EventException e) {\n", "throw new FunctionEvaluationException(e, t);\n", "}\n", "}\n", "};\n", "final BrentSolver solver = new BrentSolver();\n", "solver.setAbsoluteAccuracy(convergence);\n", "solver.setMaximalIterationCount(maxIterationCount);\n", "final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n", "if ((Math.abs(root - ta) <= convergence) &&\n", "(Math.abs(root - previousEventTime) <= convergence)) {\n", "// we have either found nothing or found (again ?) a past event, we simply ignore it\n", "ta = tb;\n", "ga = gb;\n", "} else if (Double.isNaN(previousEventTime) ||\n", "(Math.abs(previousEventTime - root) > convergence)) {\n", "pendingEventTime = root;\n", "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n", "// we were already waiting for this event which was\n", "// found during a previous call for a step that was\n", "// rejected, this step must now be accepted since it\n", "// properly ends exactly at the event occurrence\n", "return false;\n", "}\n", "// either we were not waiting for the event or it has\n", "// moved in such a way the step cannot be accepted\n", "pendingEvent = true;\n", "return true;\n", "}\n", "\n", "} else {\n", "// no sign change: there is no event for now\n", "ta = tb;\n", "ga = gb;\n", "}\n", "\n", "}\n", "\n", "// no event during the whole step\n", "pendingEvent     = false;\n", "pendingEventTime = Double.NaN;\n", "return false;\n", "\n", "} catch (FunctionEvaluationException e) {\n", "final Throwable cause = e.getCause();\n", "if ((cause != null) && (cause instanceof DerivativeException)) {\n", "throw (DerivativeException) cause;\n", "} else if ((cause != null) && (cause instanceof EventException)) {\n", "throw (EventException) cause;\n", "}\n", "throw new EventException(e);\n", "}\n", "\n", "}\n"], "faulty_lines": [25], "cluster": 9}, {"pid": "Math", "bid": 78, "method_path": "./dataset/Math/78/EventState.java", "method": ["public boolean evaluateStep(final StepInterpolator interpolator)\n", "throws DerivativeException, EventException, ConvergenceException {\n", "\n", "try {\n", "\n", "forward = interpolator.isForward();\n", "final double t1 = interpolator.getCurrentTime();\n", "final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n", "final double h  = (t1 - t0) / n;\n", "\n", "double ta = t0;\n", "double ga = g0;\n", "double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n", "for (int i = 0; i < n; ++i) {\n", "\n", "// evaluate handler value at the end of the substep\n", "tb += h;\n", "interpolator.setInterpolatedTime(tb);\n", "final double gb = handler.g(tb, interpolator.getInterpolatedState());\n", "\n", "// check events occurrence\n", "if (g0Positive ^ (gb >= 0)) {\n", "// there is a sign change: an event is expected during this step\n", "\n", "// this is a corner case:\n", "// - there was an event near ta,\n", "// - there is another event between ta and tb\n", "// - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n", "// this implies that the real sign of ga is the same as gb, so we need to slightly\n", "// shift ta to make sure ga and gb get opposite signs and the solver won't complain\n", "// about bracketing\n", "// this should never happen\n", "\n", "// variation direction, with respect to the integration direction\n", "increasing = gb >= ga;\n", "\n", "final UnivariateRealFunction f = new UnivariateRealFunction() {\n", "public double value(final double t) throws FunctionEvaluationException {\n", "try {\n", "interpolator.setInterpolatedTime(t);\n", "return handler.g(t, interpolator.getInterpolatedState());\n", "} catch (DerivativeException e) {\n", "throw new FunctionEvaluationException(e, t);\n", "} catch (EventException e) {\n", "throw new FunctionEvaluationException(e, t);\n", "}\n", "}\n", "};\n", "final BrentSolver solver = new BrentSolver();\n", "solver.setAbsoluteAccuracy(convergence);\n", "solver.setMaximalIterationCount(maxIterationCount);\n", "final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n", "if ((Math.abs(root - ta) <= convergence) &&\n", "(Math.abs(root - previousEventTime) <= convergence)) {\n", "// we have either found nothing or found (again ?) a past event, we simply ignore it\n", "ta = tb;\n", "ga = gb;\n", "} else if (Double.isNaN(previousEventTime) ||\n", "(Math.abs(previousEventTime - root) > convergence)) {\n", "pendingEventTime = root;\n", "if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n", "// we were already waiting for this event which was\n", "// found during a previous call for a step that was\n", "// rejected, this step must now be accepted since it\n", "// properly ends exactly at the event occurrence\n", "return false;\n", "}\n", "// either we were not waiting for the event or it has\n", "// moved in such a way the step cannot be accepted\n", "pendingEvent = true;\n", "return true;\n", "}\n", "\n", "} else {\n", "// no sign change: there is no event for now\n", "ta = tb;\n", "ga = gb;\n", "}\n", "\n", "}\n", "\n", "// no event during the whole step\n", "pendingEvent     = false;\n", "pendingEventTime = Double.NaN;\n", "return false;\n", "\n", "} catch (FunctionEvaluationException e) {\n", "final Throwable cause = e.getCause();\n", "if ((cause != null) && (cause instanceof DerivativeException)) {\n", "throw (DerivativeException) cause;\n", "} else if ((cause != null) && (cause instanceof EventException)) {\n", "throw (EventException) cause;\n", "}\n", "throw new EventException(e);\n", "}\n", "\n", "}\n"], "faulty_lines": [32, 33], "cluster": 9}, {"pid": "Math", "bid": 79, "method_path": "./dataset/Math/79/MathUtils.java", "method": ["public static double distance(int[] p1, int[] p2) {\n", "int sum = 0;\n", "for (int i = 0; i < p1.length; i++) {\n", "final int dp = p1[i] - p2[i];\n", "sum += dp * dp;\n", "}\n", "return Math.sqrt(sum);\n", "}\n"], "faulty_lines": [2, 4], "cluster": 4}, {"pid": "Math", "bid": 80, "method_path": "./dataset/Math/80/EigenDecompositionImpl.java", "method": ["private boolean flipIfWarranted(final int n, final int step) {\n", "if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n", "// flip array\n", "int j = 4 * n - 1;\n", "for (int i = 0; i < j; i += 4) {\n", "for (int k = 0; k < 4; k += step) {\n", "final double tmp = work[i + k];\n", "work[i + k] = work[j - k];\n", "work[j - k] = tmp;\n", "}\n", "j -= 4;\n", "}\n", "return true;\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [4], "cluster": 2}, {"pid": "Math", "bid": 81, "method_path": "./dataset/Math/81/EigenDecompositionImpl.java", "method": ["private void computeGershgorinCircles() {\n", "\n", "final int m     = main.length;\n", "final int lowerStart = 4 * m;\n", "final int upperStart = 5 * m;\n", "lowerSpectra = Double.POSITIVE_INFINITY;\n", "upperSpectra = Double.NEGATIVE_INFINITY;\n", "double eMax = 0;\n", "\n", "double eCurrent = 0;\n", "for (int i = 0; i < m - 1; ++i) {\n", "\n", "final double dCurrent = main[i];\n", "final double ePrevious = eCurrent;\n", "eCurrent = Math.abs(secondary[i]);\n", "eMax = Math.max(eMax, eCurrent);\n", "final double radius = ePrevious + eCurrent;\n", "\n", "final double lower = dCurrent - radius;\n", "work[lowerStart + i] = lower;\n", "lowerSpectra = Math.min(lowerSpectra, lower);\n", "\n", "final double upper = dCurrent + radius;\n", "work[upperStart + i] = upper;\n", "upperSpectra = Math.max(upperSpectra, upper);\n", "\n", "}\n", "\n", "final double dCurrent = main[m - 1];\n", "final double lower = dCurrent - eCurrent;\n", "work[lowerStart + m - 1] = lower;\n", "lowerSpectra = Math.min(lowerSpectra, lower);\n", "final double upper = dCurrent + eCurrent;\n", "work[upperStart + m - 1] = upper;\n", "minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n", "\n", "}\n"], "faulty_lines": [35], "cluster": 1}, {"pid": "Math", "bid": 81, "method_path": "./dataset/Math/81/EigenDecompositionImpl.java", "method": ["private void processGeneralBlock(final int n)\n", "throws InvalidMatrixException {\n", "\n", "// check decomposed matrix data range\n", "double sumOffDiag = 0;\n", "for (int i = 0; i < n - 1; ++i) {\n", "final int fourI = 4 * i;\n", "final double ei = work[fourI + 2];\n", "sumOffDiag += ei;\n", "}\n", "\n", "if (sumOffDiag == 0) {\n", "// matrix is already diagonal\n", "return;\n", "}\n", "\n", "// initial checks for splits (see Parlett & Marques section 3.3)\n", "flipIfWarranted(n, 2);\n", "\n", "// two iterations with Li's test for initial splits\n", "initialSplits(n);\n", "\n", "// initialize parameters used by goodStep\n", "tType = 0;\n", "dMin1 = 0;\n", "dMin2 = 0;\n", "dN    = 0;\n", "dN1   = 0;\n", "dN2   = 0;\n", "tau   = 0;\n", "\n", "// process split segments\n", "int i0 = 0;\n", "int n0 = n;\n", "while (n0 > 0) {\n", "\n", "// retrieve shift that was temporarily stored as a negative off-diagonal element\n", "sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\n", "sigmaLow = 0;\n", "\n", "// find start of a new split segment to process\n", "double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n", "double offDiagMax = 0;\n", "double diagMax    = work[4 * n0 - 4];\n", "double diagMin    = diagMax;\n", "i0 = 0;\n", "for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n", "if (work[i + 2] <= 0) {\n", "i0 = 1 + i / 4;\n", "break;\n", "}\n", "if (diagMin >= 4 * offDiagMax) {\n", "diagMin    = Math.min(diagMin, work[i + 4]);\n", "offDiagMax = Math.max(offDiagMax, work[i + 2]);\n", "}\n", "diagMax    = Math.max(diagMax, work[i] + work[i + 2]);\n", "offDiagMin = Math.min(offDiagMin, work[i + 2]);\n", "}\n", "work[4 * n0 - 2] = offDiagMin;\n", "\n", "// lower bound of Gershgorin disk\n", "dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n", "\n", "pingPong = 0;\n", "int maxIter = 30 * (n0 - i0);\n", "for (int k = 0; i0 < n0; ++k) {\n", "if (k >= maxIter) {\n", "throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n", "}\n", "\n", "// perform one step\n", "n0 = goodStep(i0, n0);\n", "pingPong = 1 - pingPong;\n", "\n", "// check for new splits after \"ping\" steps\n", "// when the last elements of qd array are very small\n", "if ((pingPong == 0) && (n0 - i0 > 3) &&\n", "(work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n", "(work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n", "int split  = i0 - 1;\n", "diagMax    = work[4 * i0];\n", "offDiagMin = work[4 * i0 + 2];\n", "double previousEMin = work[4 * i0 + 3];\n", "for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n", "if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n", "(work[i + 2] <= TOLERANCE_2 * sigma)) {\n", "// insert a split\n", "work[i + 2]  = -sigma;\n", "split        = i / 4;\n", "diagMax      = 0;\n", "offDiagMin   = work[i + 6];\n", "previousEMin = work[i + 7];\n", "} else {\n", "diagMax      = Math.max(diagMax, work[i + 4]);\n", "offDiagMin   = Math.min(offDiagMin, work[i + 2]);\n", "previousEMin = Math.min(previousEMin, work[i + 3]);\n", "}\n", "}\n", "work[4 * n0 - 2] = offDiagMin;\n", "work[4 * n0 - 1] = previousEMin;\n", "i0 = split + 1;\n", "}\n", "}\n", "\n", "}\n", "\n", "}\n"], "faulty_lines": [84, 85], "cluster": 9}, {"pid": "Math", "bid": 81, "method_path": "./dataset/Math/81/EigenDecompositionImpl.java", "method": ["private void computeShiftIncrement(final int start, final int end, final int deflated) {\n", "\n", "final double cnst1 = 0.563;\n", "final double cnst2 = 1.010;\n", "final double cnst3 = 1.05;\n", "\n", "// a negative dMin forces the shift to take that absolute value\n", "// tType records the type of shift.\n", "if (dMin <= 0.0) {\n", "tau = -dMin;\n", "tType = -1;\n", "return;\n", "}\n", "\n", "int nn = 4 * end + pingPong - 1;\n", "switch (deflated) {\n", "\n", "case 0 : // no realEigenvalues deflated.\n", "if (dMin == dN || dMin == dN1) {\n", "\n", "double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n", "double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n", "double a2 = work[nn - 7] + work[nn - 5];\n", "\n", "if (dMin == dN && dMin1 == dN1) {\n", "// cases 2 and 3.\n", "final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n", "final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n", "if (gap1 > 0.0 && gap1 > b1) {\n", "tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n", "tType = -2;\n", "} else {\n", "double s = 0.0;\n", "if (dN > b1) {\n", "s = dN - b1;\n", "}\n", "if (a2 > (b1 + b2)) {\n", "s = Math.min(s, a2 - (b1 + b2));\n", "}\n", "tau   = Math.max(s, 0.333 * dMin);\n", "tType = -3;\n", "}\n", "} else {\n", "// case 4.\n", "tType = -4;\n", "double s = 0.25 * dMin;\n", "double gam;\n", "int np;\n", "if (dMin == dN) {\n", "gam = dN;\n", "a2 = 0.0;\n", "if (work[nn - 5]  >  work[nn - 7]) {\n", "return;\n", "}\n", "b2 = work[nn - 5] / work[nn - 7];\n", "np = nn - 9;\n", "} else {\n", "np = nn - 2 * pingPong;\n", "b2 = work[np - 2];\n", "gam = dN1;\n", "if (work[np - 4]  >  work[np - 2]) {\n", "return;\n", "}\n", "a2 = work[np - 4] / work[np - 2];\n", "if (work[nn - 9]  >  work[nn - 11]) {\n", "return;\n", "}\n", "b2 = work[nn - 9] / work[nn - 11];\n", "np = nn - 13;\n", "}\n", "\n", "// approximate contribution to norm squared from i < nn-1.\n", "a2 = a2 + b2;\n", "for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n", "if(b2 == 0.0) {\n", "break;\n", "}\n", "b1 = b2;\n", "if (work[i4]  >  work[i4 - 2]) {\n", "return;\n", "}\n", "b2 = b2 * (work[i4] / work[i4 - 2]);\n", "a2 = a2 + b2;\n", "if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n", "break;\n", "}\n", "}\n", "a2 = cnst3 * a2;\n", "\n", "// rayleigh quotient residual bound.\n", "if (a2 < cnst1) {\n", "s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n", "}\n", "tau = s;\n", "\n", "}\n", "} else if (dMin == dN2) {\n", "\n", "// case 5.\n", "tType = -5;\n", "double s = 0.25 * dMin;\n", "\n", "// compute contribution to norm squared from i > nn-2.\n", "final int np = nn - 2 * pingPong;\n", "double b1 = work[np - 2];\n", "double b2 = work[np - 6];\n", "final double gam = dN2;\n", "if (work[np - 8] > b2 || work[np - 4] > b1) {\n", "return;\n", "}\n", "double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n", "\n", "// approximate contribution to norm squared from i < nn-2.\n", "if (end - start > 2) {\n", "b2 = work[nn - 13] / work[nn - 15];\n", "a2 = a2 + b2;\n", "for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n", "if (b2 == 0.0) {\n", "break;\n", "}\n", "b1 = b2;\n", "if (work[i4]  >  work[i4 - 2]) {\n", "return;\n", "}\n", "b2 = b2 * (work[i4] / work[i4 - 2]);\n", "a2 = a2 + b2;\n", "if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n", "break;\n", "}\n", "}\n", "a2 = cnst3 * a2;\n", "}\n", "\n", "if (a2 < cnst1) {\n", "tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n", "} else {\n", "tau = s;\n", "}\n", "\n", "} else {\n", "\n", "// case 6, no information to guide us.\n", "if (tType == -6) {\n", "g += 0.333 * (1 - g);\n", "} else if (tType == -18) {\n", "g = 0.25 * 0.333;\n", "} else {\n", "g = 0.25;\n", "}\n", "tau   = g * dMin;\n", "tType = -6;\n", "\n", "}\n", "break;\n", "\n", "case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n", "if (dMin1 == dN1 && dMin2 == dN2) {\n", "\n", "// cases 7 and 8.\n", "tType = -7;\n", "double s = 0.333 * dMin1;\n", "if (work[nn - 5] > work[nn - 7]) {\n", "return;\n", "}\n", "double b1 = work[nn - 5] / work[nn - 7];\n", "double b2 = b1;\n", "if (b2 != 0.0) {\n", "for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n", "final double oldB1 = b1;\n", "if (work[i4] > work[i4 - 2]) {\n", "return;\n", "}\n", "b1 = b1 * (work[i4] / work[i4 - 2]);\n", "b2 = b2 + b1;\n", "if (100 * Math.max(b1, oldB1) < b2) {\n", "break;\n", "}\n", "}\n", "}\n", "b2 = Math.sqrt(cnst3 * b2);\n", "final double a2 = dMin1 / (1 + b2 * b2);\n", "final double gap2 = 0.5 * dMin2 - a2;\n", "if (gap2 > 0.0 && gap2 > b2 * a2) {\n", "tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n", "} else {\n", "tau = Math.max(s, a2 * (1 - cnst2 * b2));\n", "tType = -8;\n", "}\n", "} else {\n", "\n", "// case 9.\n", "tau = 0.25 * dMin1;\n", "if (dMin1 == dN1) {\n", "tau = 0.5 * dMin1;\n", "}\n", "tType = -9;\n", "}\n", "break;\n", "\n", "case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n", "\n", "// cases 10 and 11.\n", "if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n", "tType = -10;\n", "final double s = 0.333 * dMin2;\n", "if (work[nn - 5] > work[nn - 7]) {\n", "return;\n", "}\n", "double b1 = work[nn - 5] / work[nn - 7];\n", "double b2 = b1;\n", "if (b2 != 0.0){\n", "for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n", "if (work[i4] > work[i4 - 2]) {\n", "return;\n", "}\n", "b1 *= work[i4] / work[i4 - 2];\n", "b2 += b1;\n", "if (100 * b1 < b2) {\n", "break;\n", "}\n", "}\n", "}\n", "b2 = Math.sqrt(cnst3 * b2);\n", "final double a2 = dMin2 / (1 + b2 * b2);\n", "final double gap2 = work[nn - 7] + work[nn - 9] -\n", "Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n", "if (gap2 > 0.0 && gap2 > b2 * a2) {\n", "tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n", "} else {\n", "tau = Math.max(s, a2 * (1 - cnst2 * b2));\n", "}\n", "} else {\n", "tau   = 0.25 * dMin2;\n", "tType = -11;\n", "}\n", "break;\n", "\n", "default : // case 12, more than two realEigenvalues deflated. no information.\n", "tau   = 0.0;\n", "tType = -12;\n", "}\n", "\n", "}\n"], "faulty_lines": [114], "cluster": 9}, {"pid": "Math", "bid": 82, "method_path": "./dataset/Math/82/SimplexSolver.java", "method": ["private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n", "double minRatio = Double.MAX_VALUE;\n", "Integer minRatioPos = null;\n", "for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n", "final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n", "final double entry = tableau.getEntry(i, col);\n", "if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n", "final double ratio = rhs / entry;\n", "if (ratio < minRatio) {\n", "minRatio = ratio;\n", "minRatioPos = i;\n", "}\n", "}\n", "}\n", "return minRatioPos;\n", "}\n"], "faulty_lines": [7], "cluster": 2}, {"pid": "Math", "bid": 83, "method_path": "./dataset/Math/83/SimplexTableau.java", "method": ["private Integer getBasicRow(final int col, boolean ignoreObjectiveRows) {\n", "Integer row = null;\n", "int start = getNumObjectiveFunctions();\n", "for (int i = start; i < getHeight(); i++) {\n", "if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n", "row = i;\n", "} else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n", "return null;\n", "}\n", "}\n", "return row;\n", "}\n"], "faulty_lines": [3], "cluster": 4}, {"pid": "Math", "bid": 83, "method_path": "./dataset/Math/83/SimplexTableau.java", "method": ["protected RealPointValuePair getSolution() {\n", "double[] coefficients = new double[getOriginalNumDecisionVariables()];\n", "Integer negativeVarBasicRow = getBasicRow(getNegativeDecisionVariableOffset());\n", "double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n", "Set<Integer> basicRows = new HashSet<Integer>();\n", "for (int i = 0; i < coefficients.length; i++) {\n", "Integer basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n", "if (basicRows.contains(basicRow)) {\n", "// if multiple variables can take a given value\n", "// then we choose the first and set the rest equal to 0\n", "coefficients[i] = 0;\n", "} else {\n", "basicRows.add(basicRow);\n", "coefficients[i] =\n", "(basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n", "(restrictToNonNegative ? 0 : mostNegative);\n", "}\n", "}\n", "return new RealPointValuePair(coefficients, f.getValue(coefficients));\n", "}\n"], "faulty_lines": [3, 7], "cluster": 8}, {"pid": "Math", "bid": 84, "method_path": "./dataset/Math/84/MultiDirectional.java", "method": ["protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n", "throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n", "\n", "while (true) {\n", "\n", "incrementIterationsCounter();\n", "\n", "// save the original vertex\n", "final RealPointValuePair[] original = simplex;\n", "final RealPointValuePair best = original[0];\n", "\n", "// perform a reflection step\n", "final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n", "if (comparator.compare(reflected, best) < 0) {\n", "\n", "// compute the expanded simplex\n", "final RealPointValuePair[] reflectedSimplex = simplex;\n", "final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n", "if (comparator.compare(reflected, expanded) <= 0) {\n", "// accept the reflected simplex\n", "simplex = reflectedSimplex;\n", "}\n", "\n", "return;\n", "\n", "}\n", "\n", "// compute the contracted simplex\n", "final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n", "if (comparator.compare(contracted, best) < 0) {\n", "// accept the contracted simplex\n", "\n", "// check convergence\n", "return;\n", "}\n", "\n", "}\n", "\n", "}\n"], "faulty_lines": [4], "cluster": 8}, {"pid": "Math", "bid": 84, "method_path": "./dataset/Math/84/MultiDirectional.java", "method": ["protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n", "throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n", "\n", "while (true) {\n", "\n", "incrementIterationsCounter();\n", "\n", "// save the original vertex\n", "final RealPointValuePair[] original = simplex;\n", "final RealPointValuePair best = original[0];\n", "\n", "// perform a reflection step\n", "final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n", "if (comparator.compare(reflected, best) < 0) {\n", "\n", "// compute the expanded simplex\n", "final RealPointValuePair[] reflectedSimplex = simplex;\n", "final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n", "if (comparator.compare(reflected, expanded) <= 0) {\n", "// accept the reflected simplex\n", "simplex = reflectedSimplex;\n", "}\n", "\n", "return;\n", "\n", "}\n", "\n", "// compute the contracted simplex\n", "final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n", "if (comparator.compare(contracted, best) < 0) {\n", "// accept the contracted simplex\n", "\n", "// check convergence\n", "return;\n", "}\n", "\n", "}\n", "\n", "}\n"], "faulty_lines": [32, 34], "cluster": 8}, {"pid": "Math", "bid": 85, "method_path": "./dataset/Math/85/UnivariateRealSolverUtils.java", "method": ["public static double[] bracket(UnivariateRealFunction function,\n", "double initial, double lowerBound, double upperBound,\n", "int maximumIterations) throws ConvergenceException,\n", "FunctionEvaluationException {\n", "\n", "if (function == null) {\n", "throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n", "}\n", "if (maximumIterations <= 0)  {\n", "throw MathRuntimeException.createIllegalArgumentException(\n", "\"bad value for maximum iterations number: {0}\", maximumIterations);\n", "}\n", "if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n", "throw MathRuntimeException.createIllegalArgumentException(\n", "\"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n", "lowerBound, initial, upperBound);\n", "}\n", "double a = initial;\n", "double b = initial;\n", "double fa;\n", "double fb;\n", "int numIterations = 0 ;\n", "\n", "do {\n", "a = Math.max(a - 1.0, lowerBound);\n", "b = Math.min(b + 1.0, upperBound);\n", "fa = function.value(a);\n", "\n", "fb = function.value(b);\n", "numIterations++ ;\n", "} while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&\n", "((a > lowerBound) || (b < upperBound)));\n", "\n", "if (fa * fb >= 0.0 ) {\n", "throw new ConvergenceException(\n", "\"number of iterations={0}, maximum iterations={1}, \" +\n", "\"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n", "\"final b value={6}, f(a)={7}, f(b)={8}\",\n", "numIterations, maximumIterations, initial,\n", "lowerBound, upperBound, a, b, fa, fb);\n", "}\n", "\n", "return new double[]{a, b};\n", "}\n"], "faulty_lines": [34], "cluster": 5}, {"pid": "Math", "bid": 86, "method_path": "./dataset/Math/86/CholeskyDecompositionImpl.java", "method": ["public CholeskyDecompositionImpl(final RealMatrix matrix,\n", "final double relativeSymmetryThreshold,\n", "final double absolutePositivityThreshold)\n", "throws NonSquareMatrixException,\n", "NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n", "\n", "if (!matrix.isSquare()) {\n", "throw new NonSquareMatrixException(matrix.getRowDimension(),\n", "matrix.getColumnDimension());\n", "}\n", "\n", "final int order = matrix.getRowDimension();\n", "lTData   = matrix.getData();\n", "cachedL  = null;\n", "cachedLT = null;\n", "\n", "// check the matrix before transformation\n", "for (int i = 0; i < order; ++i) {\n", "\n", "final double[] lI = lTData[i];\n", "\n", "if (lTData[i][i] < absolutePositivityThreshold) {\n", "throw new NotPositiveDefiniteMatrixException();\n", "}\n", "// check off-diagonal elements (and reset them to 0)\n", "for (int j = i + 1; j < order; ++j) {\n", "final double[] lJ = lTData[j];\n", "final double lIJ = lI[j];\n", "final double lJI = lJ[i];\n", "final double maxDelta =\n", "relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n", "if (Math.abs(lIJ - lJI) > maxDelta) {\n", "throw new NotSymmetricMatrixException();\n", "}\n", "lJ[i] = 0;\n", "}\n", "}\n", "\n", "// transform the matrix\n", "for (int i = 0; i < order; ++i) {\n", "\n", "final double[] ltI = lTData[i];\n", "\n", "// check diagonal element\n", "\n", "ltI[i] = Math.sqrt(ltI[i]);\n", "final double inverse = 1.0 / ltI[i];\n", "\n", "for (int q = order - 1; q > i; --q) {\n", "ltI[q] *= inverse;\n", "final double[] ltQ = lTData[q];\n", "for (int p = q; p < order; ++p) {\n", "ltQ[p] -= ltI[q] * ltI[p];\n", "}\n", "}\n", "\n", "}\n", "\n", "}\n"], "faulty_lines": [22, 23, 24], "cluster": 9}, {"pid": "Math", "bid": 86, "method_path": "./dataset/Math/86/CholeskyDecompositionImpl.java", "method": ["public CholeskyDecompositionImpl(final RealMatrix matrix,\n", "final double relativeSymmetryThreshold,\n", "final double absolutePositivityThreshold)\n", "throws NonSquareMatrixException,\n", "NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n", "\n", "if (!matrix.isSquare()) {\n", "throw new NonSquareMatrixException(matrix.getRowDimension(),\n", "matrix.getColumnDimension());\n", "}\n", "\n", "final int order = matrix.getRowDimension();\n", "lTData   = matrix.getData();\n", "cachedL  = null;\n", "cachedLT = null;\n", "\n", "// check the matrix before transformation\n", "for (int i = 0; i < order; ++i) {\n", "\n", "final double[] lI = lTData[i];\n", "\n", "if (lTData[i][i] < absolutePositivityThreshold) {\n", "throw new NotPositiveDefiniteMatrixException();\n", "}\n", "// check off-diagonal elements (and reset them to 0)\n", "for (int j = i + 1; j < order; ++j) {\n", "final double[] lJ = lTData[j];\n", "final double lIJ = lI[j];\n", "final double lJI = lJ[i];\n", "final double maxDelta =\n", "relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n", "if (Math.abs(lIJ - lJI) > maxDelta) {\n", "throw new NotSymmetricMatrixException();\n", "}\n", "lJ[i] = 0;\n", "}\n", "}\n", "\n", "// transform the matrix\n", "for (int i = 0; i < order; ++i) {\n", "\n", "final double[] ltI = lTData[i];\n", "\n", "// check diagonal element\n", "\n", "ltI[i] = Math.sqrt(ltI[i]);\n", "final double inverse = 1.0 / ltI[i];\n", "\n", "for (int q = order - 1; q > i; --q) {\n", "ltI[q] *= inverse;\n", "final double[] ltQ = lTData[q];\n", "for (int p = q; p < order; ++p) {\n", "ltQ[p] -= ltI[q] * ltI[p];\n", "}\n", "}\n", "\n", "}\n", "\n", "}\n"], "faulty_lines": [45], "cluster": 9}, {"pid": "Math", "bid": 87, "method_path": "./dataset/Math/87/SimplexTableau.java", "method": ["private Integer getBasicRow(final int col) {\n", "Integer row = null;\n", "for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n", "if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n", "if (row == null) {\n", "row = i;\n", "} else {\n", "return null;\n", "}\n", "}\n", "}\n", "return row;\n", "}\n"], "faulty_lines": [4, 5, 7, 9], "cluster": 4}, {"pid": "Math", "bid": 88, "method_path": "./dataset/Math/88/SimplexTableau.java", "method": ["protected RealPointValuePair getSolution() {\n", "double[] coefficients = new double[getOriginalNumDecisionVariables()];\n", "Integer basicRow =\n", "getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n", "double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n", "for (int i = 0; i < coefficients.length; i++) {\n", "basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n", "// if multiple variables can take a given value\n", "// then we choose the first and set the rest equal to 0\n", "coefficients[i] =\n", "(basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n", "(restrictToNonNegative ? 0 : mostNegative);\n", "if (basicRow != null) {\n", "for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n", "if (tableau.getEntry(basicRow, j) == 1) {\n", "coefficients[i] = 0;\n", "}\n", "}\n", "}\n", "}\n", "return new RealPointValuePair(coefficients, f.getValue(coefficients));\n", "}\n"], "faulty_lines": [6, 8, 10, 13, 14, 15, 16, 17, 18], "cluster": 8}, {"pid": "Math", "bid": 89, "method_path": "./dataset/Math/89/Frequency.java", "method": ["public void addValue(Object v) {\n", "addValue((Comparable<?>) v);\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Math", "bid": 90, "method_path": "./dataset/Math/90/Frequency.java", "method": ["public void addValue(Object v) {\n", "\n", "/**\n", "* Adds 1 to the frequency count for v.\n", "* <p>\n", "* If other objects have already been added to this Frequency, v must\n", "* be comparable to those that have already been added.\n", "* </p>\n", "*\n", "* @param v the value to add.\n", "* @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n", "*/\n", "Object obj = v;\n", "if (v instanceof Integer) {\n", "obj = Long.valueOf(((Integer) v).longValue());\n", "}\n", "try {\n", "Long count = (Long) freqTable.get(obj);\n", "if (count == null) {\n", "freqTable.put(obj, Long.valueOf(1));\n", "} else {\n", "freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n", "}\n", "} catch (ClassCastException ex) {\n", "//TreeMap will throw ClassCastException if v is not comparable\n", "throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n", "}\n", "}\n"], "faulty_lines": [2], "cluster": 8}, {"pid": "Math", "bid": 90, "method_path": "./dataset/Math/90/Frequency.java", "method": ["public void addValue(Object v) {\n", "\n", "/**\n", "* Adds 1 to the frequency count for v.\n", "* <p>\n", "* If other objects have already been added to this Frequency, v must\n", "* be comparable to those that have already been added.\n", "* </p>\n", "*\n", "* @param v the value to add.\n", "* @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n", "*/\n", "Object obj = v;\n", "if (v instanceof Integer) {\n", "obj = Long.valueOf(((Integer) v).longValue());\n", "}\n", "try {\n", "Long count = (Long) freqTable.get(obj);\n", "if (count == null) {\n", "freqTable.put(obj, Long.valueOf(1));\n", "} else {\n", "freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n", "}\n", "} catch (ClassCastException ex) {\n", "//TreeMap will throw ClassCastException if v is not comparable\n", "throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n", "}\n", "}\n"], "faulty_lines": [13], "cluster": 8}, {"pid": "Math", "bid": 91, "method_path": "./dataset/Math/91/Fraction.java", "method": ["public int compareTo(Fraction object) {\n", "double nOd = doubleValue();\n", "double dOn = object.doubleValue();\n", "return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Math", "bid": 92, "method_path": "./dataset/Math/92/MathUtils.java", "method": ["public static long binomialCoefficient(final int n, final int k) {\n", "if (n < k) {\n", "throw new IllegalArgumentException(\n", "\"must have n >= k for binomial coefficient (n,k)\");\n", "}\n", "if (n < 0) {\n", "throw new IllegalArgumentException(\n", "\"must have n >= 0 for binomial coefficient (n,k)\");\n", "}\n", "if ((n == k) || (k == 0)) {\n", "return 1;\n", "}\n", "if ((k == 1) || (k == n - 1)) {\n", "return n;\n", "}\n", "long result = Math.round(binomialCoefficientDouble(n, k));\n", "if (result == Long.MAX_VALUE) {\n", "throw new ArithmeticException(\n", "\"result too large to represent in a long integer\");\n", "}\n", "// Use symmetry for large k\n", "\n", "// We use the formula\n", "// (n choose k) = n! / (n-k)! / k!\n", "// (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n", "// which could be written\n", "// (n choose k) == (n-1 choose k-1) * n / k\n", "// For n <= 61, the naive implementation cannot overflow.\n", "// For n > 61 but n <= 66, the result cannot overflow,\n", "// but we must take care not to overflow intermediate values.\n", "// We know that (result * i) is divisible by j,\n", "// but (result * i) may overflow, so we split j:\n", "// Filter out the gcd, d, so j/d and i/d are integer.\n", "// result is divisible by (j/d) because (j/d)\n", "// is relative prime to (i/d) and is a divisor of\n", "// result * (i/d).\n", "// For n > 66, a result overflow might occur, so we check\n", "// the multiplication, taking care to not overflow\n", "// unnecessary.\n", "return result;\n", "}\n"], "faulty_lines": [16, 17, 18, 19, 20, 22, 28, 29, 31, 37, 40], "cluster": 9}, {"pid": "Math", "bid": 92, "method_path": "./dataset/Math/92/MathUtils.java", "method": ["public static double binomialCoefficientDouble(final int n, final int k) {\n", "\n", "\n", "return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n", "}\n"], "faulty_lines": [2, 3, 4], "cluster": 0}, {"pid": "Math", "bid": 92, "method_path": "./dataset/Math/92/MathUtils.java", "method": ["public static double binomialCoefficientLog(final int n, final int k) {\n", "if (n < k) {\n", "throw new IllegalArgumentException(\n", "\"must have n >= k for binomial coefficient (n,k)\");\n", "}\n", "if (n < 0) {\n", "throw new IllegalArgumentException(\n", "\"must have n >= 0 for binomial coefficient (n,k)\");\n", "}\n", "if ((n == k) || (k == 0)) {\n", "return 0;\n", "}\n", "if ((k == 1) || (k == n - 1)) {\n", "return Math.log((double) n);\n", "}\n", "\n", "/*\n", "* For values small enough to do exact integer computation,\n", "* return the log of the exact value\n", "*/\n", "\n", "/*\n", "* Return the log of binomialCoefficientDouble for values that will not\n", "* overflow binomialCoefficientDouble\n", "*/\n", "\n", "/*\n", "* Sum logs for values that could overflow\n", "*/\n", "double logSum = 0;\n", "\n", "// n!/k!\n", "for (int i = k + 1; i <= n; i++) {\n", "logSum += Math.log((double)i);\n", "}\n", "\n", "// divide by (n-k)!\n", "for (int i = 2; i <= n - k; i++) {\n", "logSum -= Math.log((double)i);\n", "}\n", "\n", "return logSum;\n", "}\n"], "faulty_lines": [21, 26], "cluster": 8}, {"pid": "Math", "bid": 93, "method_path": "./dataset/Math/93/MathUtils.java", "method": ["public static long factorial(final int n) {\n", "long result = Math.round(factorialDouble(n));\n", "if (result == Long.MAX_VALUE) {\n", "throw new ArithmeticException(\n", "\"factorial value is too large to fit in a long\");\n", "}\n", "return factorials[n];\n", "}\n"], "faulty_lines": [2, 3], "cluster": 4}, {"pid": "Math", "bid": 93, "method_path": "./dataset/Math/93/MathUtils.java", "method": ["public static double factorialDouble(final int n) {\n", "if (n < 0) {\n", "throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n", "}\n", "return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n", "}\n"], "faulty_lines": [5], "cluster": 0}, {"pid": "Math", "bid": 93, "method_path": "./dataset/Math/93/MathUtils.java", "method": ["public static double factorialLog(final int n) {\n", "if (n < 0) {\n", "throw new IllegalArgumentException(\"must have n > 0 for n!\");\n", "}\n", "double logSum = 0;\n", "for (int i = 2; i <= n; i++) {\n", "logSum += Math.log((double)i);\n", "}\n", "return logSum;\n", "}\n"], "faulty_lines": [5], "cluster": 4}, {"pid": "Math", "bid": 94, "method_path": "./dataset/Math/94/MathUtils.java", "method": ["public static int gcd(int u, int v) {\n", "if (u * v == 0) {\n", "return (Math.abs(u) + Math.abs(v));\n", "}\n", "// keep u and v negative, as negative integers range down to\n", "// -2^31, while positive numbers can only be as large as 2^31-1\n", "// (i.e. we can't necessarily negate a negative number without\n", "// overflow)\n", "/* assert u!=0 && v!=0; */\n", "if (u > 0) {\n", "u = -u;\n", "} // make u negative\n", "if (v > 0) {\n", "v = -v;\n", "} // make v negative\n", "// B1. [Find power of 2]\n", "int k = 0;\n", "while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n", "// both even...\n", "u /= 2;\n", "v /= 2;\n", "k++; // cast out twos.\n", "}\n", "if (k == 31) {\n", "throw new ArithmeticException(\"overflow: gcd is 2^31\");\n", "}\n", "// B2. Initialize: u and v have been divided by 2^k and at least\n", "// one is odd.\n", "int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n", "// t negative: u was odd, v may be even (t replaces v)\n", "// t positive: u was even, v is odd (t replaces u)\n", "do {\n", "/* assert u<0 && v<0; */\n", "// B4/B3: cast out twos from t.\n", "while ((t & 1) == 0) { // while t is even..\n", "t /= 2; // cast out twos\n", "}\n", "// B5 [reset max(u,v)]\n", "if (t > 0) {\n", "u = -t;\n", "} else {\n", "v = t;\n", "}\n", "// B6/B3. at this point both u and v should be odd.\n", "t = (v - u) / 2;\n", "// |u| larger: t positive (replace u)\n", "// |v| larger: t negative (replace v)\n", "} while (t != 0);\n", "return -u * (1 << k); // gcd is u*2^k\n", "}\n"], "faulty_lines": [2], "cluster": 9}, {"pid": "Math", "bid": 95, "method_path": "./dataset/Math/95/FDistributionImpl.java", "method": ["protected double getInitialDomain(double p) {\n", "double ret;\n", "double d = getDenominatorDegreesOfFreedom();\n", "// use mean\n", "ret = d / (d - 2.0);\n", "return ret;\n", "}\n"], "faulty_lines": [2, 4, 6], "cluster": 0}, {"pid": "Math", "bid": 97, "method_path": "./dataset/Math/97/BrentSolver.java", "method": ["public double solve(double min, double max) throws MaxIterationsExceededException,\n", "FunctionEvaluationException {\n", "\n", "clearResult();\n", "verifyInterval(min, max);\n", "\n", "double ret = Double.NaN;\n", "\n", "double yMin = f.value(min);\n", "double yMax = f.value(max);\n", "\n", "// Verify bracketing\n", "double sign = yMin * yMax;\n", "if (sign >= 0) {\n", "// check if either value is close to a zero\n", "// neither value is close to zero and min and max do not bracket root.\n", "throw new IllegalArgumentException\n", "(\"Function values at endpoints do not have different signs.\" +\n", "\"  Endpoints: [\" + min + \",\" + max + \"]\" +\n", "\"  Values: [\" + yMin + \",\" + yMax + \"]\");\n", "} else {\n", "// solve using only the first endpoint as initial guess\n", "ret = solve(min, yMin, max, yMax, min, yMin);\n", "// either min or max is a root\n", "}\n", "\n", "return ret;\n", "}\n"], "faulty_lines": [14, 16, 21, 24, 25], "cluster": 8}, {"pid": "Math", "bid": 98, "method_path": "./dataset/Math/98/BigMatrixImpl.java", "method": ["public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n", "if (v.length != this.getColumnDimension()) {\n", "throw new IllegalArgumentException(\"vector has wrong length\");\n", "}\n", "final int nRows = this.getRowDimension();\n", "final int nCols = this.getColumnDimension();\n", "final BigDecimal[] out = new BigDecimal[v.length];\n", "for (int row = 0; row < nRows; row++) {\n", "BigDecimal sum = ZERO;\n", "for (int i = 0; i < nCols; i++) {\n", "sum = sum.add(data[row][i].multiply(v[i]));\n", "}\n", "out[row] = sum;\n", "}\n", "return out;\n", "}\n"], "faulty_lines": [7], "cluster": 2}, {"pid": "Math", "bid": 98, "method_path": "./dataset/Math/98/RealMatrixImpl.java", "method": ["public double[] operate(double[] v) throws IllegalArgumentException {\n", "final int nRows = this.getRowDimension();\n", "final int nCols = this.getColumnDimension();\n", "if (v.length != nCols) {\n", "throw new IllegalArgumentException(\"vector has wrong length\");\n", "}\n", "final double[] out = new double[v.length];\n", "for (int row = 0; row < nRows; row++) {\n", "final double[] dataRow = data[row];\n", "double sum = 0;\n", "for (int i = 0; i < nCols; i++) {\n", "sum += dataRow[i] * v[i];\n", "}\n", "out[row] = sum;\n", "}\n", "return out;\n", "}\n"], "faulty_lines": [7], "cluster": 2}, {"pid": "Math", "bid": 99, "method_path": "./dataset/Math/99/MathUtils.java", "method": ["public static int gcd(final int p, final int q) {\n", "int u = p;\n", "int v = q;\n", "if ((u == 0) || (v == 0)) {\n", "return (Math.abs(u) + Math.abs(v));\n", "}\n", "// keep u and v negative, as negative integers range down to\n", "// -2^31, while positive numbers can only be as large as 2^31-1\n", "// (i.e. we can't necessarily negate a negative number without\n", "// overflow)\n", "/* assert u!=0 && v!=0; */\n", "if (u > 0) {\n", "u = -u;\n", "} // make u negative\n", "if (v > 0) {\n", "v = -v;\n", "} // make v negative\n", "// B1. [Find power of 2]\n", "int k = 0;\n", "while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n", "// both even...\n", "u /= 2;\n", "v /= 2;\n", "k++; // cast out twos.\n", "}\n", "if (k == 31) {\n", "throw MathRuntimeException.createArithmeticException(\n", "\"overflow: gcd({0}, {1}) is 2^31\",\n", "new Object[] { p, q });\n", "}\n", "// B2. Initialize: u and v have been divided by 2^k and at least\n", "// one is odd.\n", "int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n", "// t negative: u was odd, v may be even (t replaces v)\n", "// t positive: u was even, v is odd (t replaces u)\n", "do {\n", "/* assert u<0 && v<0; */\n", "// B4/B3: cast out twos from t.\n", "while ((t & 1) == 0) { // while t is even..\n", "t /= 2; // cast out twos\n", "}\n", "// B5 [reset max(u,v)]\n", "if (t > 0) {\n", "u = -t;\n", "} else {\n", "v = t;\n", "}\n", "// B6/B3. at this point both u and v should be odd.\n", "t = (v - u) / 2;\n", "// |u| larger: t positive (replace u)\n", "// |v| larger: t negative (replace v)\n", "} while (t != 0);\n", "return -u * (1 << k); // gcd is u*2^k\n", "}\n"], "faulty_lines": [5], "cluster": 9}, {"pid": "Math", "bid": 99, "method_path": "./dataset/Math/99/MathUtils.java", "method": ["public static int lcm(int a, int b) {\n", "if (a==0 || b==0){\n", "return 0;\n", "}\n", "int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n", "return lcm;\n", "}\n"], "faulty_lines": [6], "cluster": 0}, {"pid": "Math", "bid": 100, "method_path": "./dataset/Math/100/AbstractEstimator.java", "method": ["public double[][] getCovariances(EstimationProblem problem)\n", "throws EstimationException {\n", "\n", "// set up the jacobian\n", "updateJacobian();\n", "\n", "// compute transpose(J).J, avoiding building big intermediate matrices\n", "final int rows = problem.getMeasurements().length;\n", "final int cols = problem.getAllParameters().length;\n", "final int max  = cols * rows;\n", "double[][] jTj = new double[cols][cols];\n", "for (int i = 0; i < cols; ++i) {\n", "for (int j = i; j < cols; ++j) {\n", "double sum = 0;\n", "for (int k = 0; k < max; k += cols) {\n", "sum += jacobian[k + i] * jacobian[k + j];\n", "}\n", "jTj[i][j] = sum;\n", "jTj[j][i] = sum;\n", "}\n", "}\n", "\n", "try {\n", "// compute the covariances matrix\n", "return new RealMatrixImpl(jTj).inverse().getData();\n", "} catch (InvalidMatrixException ime) {\n", "throw new EstimationException(\"unable to compute covariances: singular problem\",\n", "new Object[0]);\n", "}\n", "\n", "}\n"], "faulty_lines": [9], "cluster": 8}, {"pid": "Math", "bid": 100, "method_path": "./dataset/Math/100/AbstractEstimator.java", "method": ["public double[] guessParametersErrors(EstimationProblem problem)\n", "throws EstimationException {\n", "int m = problem.getMeasurements().length;\n", "int p = problem.getAllParameters().length;\n", "if (m <= p) {\n", "throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\",\n", "new Object[] { new Integer(m), new Integer(p)});\n", "}\n", "double[] errors = new double[problem.getAllParameters().length];\n", "final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n", "double[][] covar = getCovariances(problem);\n", "for (int i = 0; i < errors.length; ++i) {\n", "errors[i] = Math.sqrt(covar[i][i]) * c;\n", "}\n", "return errors;\n", "}\n"], "faulty_lines": [4, 9], "cluster": 2}, {"pid": "Math", "bid": 101, "method_path": "./dataset/Math/101/ComplexFormat.java", "method": ["public Complex parse(String source, ParsePosition pos) {\n", "int initialIndex = pos.getIndex();\n", "\n", "// parse whitespace\n", "parseAndIgnoreWhitespace(source, pos);\n", "\n", "// parse real\n", "Number re = parseNumber(source, getRealFormat(), pos);\n", "if (re == null) {\n", "// invalid real number\n", "// set index back to initial, error index should already be set\n", "// character examined.\n", "pos.setIndex(initialIndex);\n", "return null;\n", "}\n", "\n", "// parse sign\n", "int startIndex = pos.getIndex();\n", "char c = parseNextCharacter(source, pos);\n", "int sign = 0;\n", "switch (c) {\n", "case 0 :\n", "// no sign\n", "// return real only complex number\n", "return new Complex(re.doubleValue(), 0.0);\n", "case '-' :\n", "sign = -1;\n", "break;\n", "case '+' :\n", "sign = 1;\n", "break;\n", "default :\n", "// invalid sign\n", "// set index back to initial, error index should be the last\n", "// character examined.\n", "pos.setIndex(initialIndex);\n", "pos.setErrorIndex(startIndex);\n", "return null;\n", "}\n", "\n", "// parse whitespace\n", "parseAndIgnoreWhitespace(source, pos);\n", "\n", "// parse imaginary\n", "Number im = parseNumber(source, getRealFormat(), pos);\n", "if (im == null) {\n", "// invalid imaginary number\n", "// set index back to initial, error index should already be set\n", "// character examined.\n", "pos.setIndex(initialIndex);\n", "return null;\n", "}\n", "\n", "// parse imaginary character\n", "int n = getImaginaryCharacter().length();\n", "startIndex = pos.getIndex();\n", "int endIndex = startIndex + n;\n", "if (\n", "source.substring(startIndex, endIndex).compareTo(\n", "getImaginaryCharacter()) != 0) {\n", "// set index back to initial, error index should be the start index\n", "// character examined.\n", "pos.setIndex(initialIndex);\n", "pos.setErrorIndex(startIndex);\n", "return null;\n", "}\n", "pos.setIndex(endIndex);\n", "\n", "return new Complex(re.doubleValue(), im.doubleValue() * sign);\n", "}\n"], "faulty_lines": [58], "cluster": 3}, {"pid": "Math", "bid": 102, "method_path": "./dataset/Math/102/ChiSquareTestImpl.java", "method": ["public double chiSquare(double[] expected, long[] observed)\n", "throws IllegalArgumentException {\n", "if ((expected.length < 2) || (expected.length != observed.length)) {\n", "throw new IllegalArgumentException(\n", "\"observed, expected array lengths incorrect\");\n", "}\n", "if (!isPositive(expected) || !isNonNegative(observed)) {\n", "throw new IllegalArgumentException(\n", "\"observed counts must be non-negative and expected counts must be postive\");\n", "}\n", "double sumSq = 0.0d;\n", "double dev = 0.0d;\n", "for (int i = 0; i < observed.length; i++) {\n", "dev = ((double) observed[i] - expected[i]);\n", "sumSq += dev * dev / expected[i];\n", "}\n", "return sumSq;\n", "}\n"], "faulty_lines": [11, 14, 16], "cluster": 2}, {"pid": "Math", "bid": 103, "method_path": "./dataset/Math/103/NormalDistributionImpl.java", "method": ["public double cumulativeProbability(double x) throws MathException {\n", "return 0.5 * (1.0 + Erf.erf((x - mean) /\n", "(standardDeviation * Math.sqrt(2.0))));\n", "}\n"], "faulty_lines": [2, 4], "cluster": 0}, {"pid": "Math", "bid": 105, "method_path": "./dataset/Math/105/SimpleRegression.java", "method": ["public double getSumSquaredErrors() {\n", "return sumYY - sumXY * sumXY / sumXX;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Math", "bid": 106, "method_path": "./dataset/Math/106/ProperFractionFormat.java", "method": ["public Fraction parse(String source, ParsePosition pos) {\n", "// try to parse improper fraction\n", "Fraction ret = super.parse(source, pos);\n", "if (ret != null) {\n", "return ret;\n", "}\n", "\n", "int initialIndex = pos.getIndex();\n", "\n", "// parse whitespace\n", "parseAndIgnoreWhitespace(source, pos);\n", "\n", "// parse whole\n", "Number whole = getWholeFormat().parse(source, pos);\n", "if (whole == null) {\n", "// invalid integer number\n", "// set index back to initial, error index should already be set\n", "// character examined.\n", "pos.setIndex(initialIndex);\n", "return null;\n", "}\n", "\n", "// parse whitespace\n", "parseAndIgnoreWhitespace(source, pos);\n", "\n", "// parse numerator\n", "Number num = getNumeratorFormat().parse(source, pos);\n", "if (num == null) {\n", "// invalid integer number\n", "// set index back to initial, error index should already be set\n", "// character examined.\n", "pos.setIndex(initialIndex);\n", "return null;\n", "}\n", "\n", "// minus signs should be leading, invalid expression\n", "\n", "// parse '/'\n", "int startIndex = pos.getIndex();\n", "char c = parseNextCharacter(source, pos);\n", "switch (c) {\n", "case 0 :\n", "// no '/'\n", "// return num as a fraction\n", "return new Fraction(num.intValue(), 1);\n", "case '/' :\n", "// found '/', continue parsing denominator\n", "break;\n", "default :\n", "// invalid '/'\n", "// set index back to initial, error index should be the last\n", "// character examined.\n", "pos.setIndex(initialIndex);\n", "pos.setErrorIndex(startIndex);\n", "return null;\n", "}\n", "\n", "// parse whitespace\n", "parseAndIgnoreWhitespace(source, pos);\n", "\n", "// parse denominator\n", "Number den = getDenominatorFormat().parse(source, pos);\n", "if (den == null) {\n", "// invalid integer number\n", "// set index back to initial, error index should already be set\n", "// character examined.\n", "pos.setIndex(initialIndex);\n", "return null;\n", "}\n", "\n", "// minus signs must be leading, invalid\n", "\n", "int w = whole.intValue();\n", "int n = num.intValue();\n", "int d = den.intValue();\n", "return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n", "}\n"], "faulty_lines": [36, 37], "cluster": 3}, {"pid": "Math", "bid": 106, "method_path": "./dataset/Math/106/ProperFractionFormat.java", "method": ["public Fraction parse(String source, ParsePosition pos) {\n", "// try to parse improper fraction\n", "Fraction ret = super.parse(source, pos);\n", "if (ret != null) {\n", "return ret;\n", "}\n", "\n", "int initialIndex = pos.getIndex();\n", "\n", "// parse whitespace\n", "parseAndIgnoreWhitespace(source, pos);\n", "\n", "// parse whole\n", "Number whole = getWholeFormat().parse(source, pos);\n", "if (whole == null) {\n", "// invalid integer number\n", "// set index back to initial, error index should already be set\n", "// character examined.\n", "pos.setIndex(initialIndex);\n", "return null;\n", "}\n", "\n", "// parse whitespace\n", "parseAndIgnoreWhitespace(source, pos);\n", "\n", "// parse numerator\n", "Number num = getNumeratorFormat().parse(source, pos);\n", "if (num == null) {\n", "// invalid integer number\n", "// set index back to initial, error index should already be set\n", "// character examined.\n", "pos.setIndex(initialIndex);\n", "return null;\n", "}\n", "\n", "// minus signs should be leading, invalid expression\n", "\n", "// parse '/'\n", "int startIndex = pos.getIndex();\n", "char c = parseNextCharacter(source, pos);\n", "switch (c) {\n", "case 0 :\n", "// no '/'\n", "// return num as a fraction\n", "return new Fraction(num.intValue(), 1);\n", "case '/' :\n", "// found '/', continue parsing denominator\n", "break;\n", "default :\n", "// invalid '/'\n", "// set index back to initial, error index should be the last\n", "// character examined.\n", "pos.setIndex(initialIndex);\n", "pos.setErrorIndex(startIndex);\n", "return null;\n", "}\n", "\n", "// parse whitespace\n", "parseAndIgnoreWhitespace(source, pos);\n", "\n", "// parse denominator\n", "Number den = getDenominatorFormat().parse(source, pos);\n", "if (den == null) {\n", "// invalid integer number\n", "// set index back to initial, error index should already be set\n", "// character examined.\n", "pos.setIndex(initialIndex);\n", "return null;\n", "}\n", "\n", "// minus signs must be leading, invalid\n", "\n", "int w = whole.intValue();\n", "int n = num.intValue();\n", "int d = den.intValue();\n", "return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n", "}\n"], "faulty_lines": [71, 72], "cluster": 3}, {"pid": "Closure", "bid": 1, "method_path": "./dataset/Closure/1/RemoveUnusedVars.java", "method": ["private void removeUnreferencedFunctionArgs(Scope fnScope) {\n", "// Notice that removing unreferenced function args breaks\n", "// Function.prototype.length. In advanced mode, we don't really care\n", "// about this: we consider \"length\" the equivalent of reflecting on\n", "// the function's lexical source.\n", "//\n", "// Rather than create a new option for this, we assume that if the user\n", "// is removing globals, then it's OK to remove unused function args.\n", "//\n", "// See http://code.google.com/p/closure-compiler/issues/detail?id=253\n", "\n", "Node function = fnScope.getRootNode();\n", "\n", "Preconditions.checkState(function.isFunction());\n", "if (NodeUtil.isGetOrSetKey(function.getParent())) {\n", "// The parameters object literal setters can not be removed.\n", "return;\n", "}\n", "\n", "Node argList = getFunctionArgList(function);\n", "boolean modifyCallers = modifyCallSites\n", "&& callSiteOptimizer.canModifyCallers(function);\n", "if (!modifyCallers) {\n", "// Strip unreferenced args off the end of the function declaration.\n", "Node lastArg;\n", "while ((lastArg = argList.getLastChild()) != null) {\n", "Var var = fnScope.getVar(lastArg.getString());\n", "if (!referenced.contains(var)) {\n", "argList.removeChild(lastArg);\n", "compiler.reportCodeChange();\n", "} else {\n", "break;\n", "}\n", "}\n", "} else {\n", "callSiteOptimizer.optimize(fnScope, referenced);\n", "}\n", "}\n"], "faulty_lines": [11], "cluster": 1}, {"pid": "Closure", "bid": 2, "method_path": "./dataset/Closure/2/TypeCheck.java", "method": ["private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n", "String functionName, HashMap<String, ObjectType> properties,\n", "HashMap<String, ObjectType> currentProperties,\n", "ObjectType interfaceType) {\n", "ObjectType implicitProto = interfaceType.getImplicitPrototype();\n", "Set<String> currentPropertyNames;\n", "// This can be the case if interfaceType is proxy to a non-existent\n", "// object (which is a bad type annotation, but shouldn't crash).\n", "currentPropertyNames = implicitProto.getOwnPropertyNames();\n", "for (String name : currentPropertyNames) {\n", "ObjectType oType = properties.get(name);\n", "if (oType != null) {\n", "if (!interfaceType.getPropertyType(name).isEquivalentTo(\n", "oType.getPropertyType(name))) {\n", "compiler.report(\n", "t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n", "functionName, name, oType.toString(),\n", "interfaceType.toString()));\n", "}\n", "}\n", "currentProperties.put(name, interfaceType);\n", "}\n", "for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n", "checkInterfaceConflictProperties(t, n, functionName, properties,\n", "currentProperties, iType);\n", "}\n", "}\n"], "faulty_lines": [7, 9, 10], "cluster": 8}, {"pid": "Closure", "bid": 3, "method_path": "./dataset/Closure/3/FlowSensitiveInlineVariables.java", "method": ["public void enterScope(NodeTraversal t) {\n", "\n", "if (t.inGlobalScope()) {\n", "return; // Don't even brother. All global variables are likely escaped.\n", "}\n", "\n", "if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE <\n", "t.getScope().getVarCount()) {\n", "return;\n", "}\n", "\n", "// Compute the forward reaching definition.\n", "ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n", "// Process the body of the function.\n", "Preconditions.checkState(t.getScopeRoot().isFunction());\n", "cfa.process(null, t.getScopeRoot().getLastChild());\n", "cfg = cfa.getCfg();\n", "reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n", "reachingDef.analyze();\n", "candidates = Lists.newLinkedList();\n", "\n", "// Using the forward reaching definition search to find all the inline\n", "// candidates\n", "new NodeTraversal(compiler, new GatherCandiates()).traverse(\n", "t.getScopeRoot().getLastChild());\n", "\n", "// Compute the backward reaching use. The CFG can be reused.\n", "reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n", "reachingUses.analyze();\n", "for (Candidate c : candidates) {\n", "if (c.canInline()) {\n", "c.inlineVariable();\n", "\n", "// If definition c has dependencies, then inlining it may have\n", "// introduced new dependencies for our other inlining candidates.\n", "//\n", "// MustBeReachingVariableDef uses this dependency graph in its\n", "// analysis, so some of these candidates may no longer be valid.\n", "// We keep track of when the variable dependency graph changed\n", "// so that we can back off appropriately.\n", "if (!c.defMetadata.depends.isEmpty()) {\n", "inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [31], "cluster": 7}, {"pid": "Closure", "bid": 3, "method_path": "./dataset/Closure/3/FlowSensitiveInlineVariables.java", "method": ["public boolean apply(Node input) {\n", "switch (input.getType()) {\n", "case Token.GETELEM:\n", "case Token.GETPROP:\n", "case Token.ARRAYLIT:\n", "case Token.OBJECTLIT:\n", "case Token.REGEXP:\n", "case Token.NEW:\n", "return true;\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [10], "cluster": 4}, {"pid": "Closure", "bid": 6, "method_path": "./dataset/Closure/6/TypeValidator.java", "method": ["boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n", "JSType leftType, Node owner, String propName) {\n", "// The NoType check is a hack to make typedefs work OK.\n", "if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n", "if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n", "registerMismatch(rightType, leftType, null);\n", "} else {\n", "// Do not type-check interface methods, because we expect that\n", "// they will have dummy implementations that do not match the type\n", "// annotations.\n", "JSType ownerType = getJSType(owner);\n", "if (ownerType.isFunctionPrototypeType()) {\n", "FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n", "if (ownerFn.isInterface() &&\n", "rightType.isFunctionType() && leftType.isFunctionType()) {\n", "return true;\n", "}\n", "}\n", "\n", "mismatch(t, n,\n", "\"assignment to property \" + propName + \" of \" +\n", "getReadableJSTypeName(owner, true),\n", "rightType, leftType);\n", "}\n", "return false;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [5, 6, 7], "cluster": 1}, {"pid": "Closure", "bid": 6, "method_path": "./dataset/Closure/6/TypeValidator.java", "method": ["boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n", "JSType leftType, Node owner, String propName) {\n", "// The NoType check is a hack to make typedefs work OK.\n", "if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n", "if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n", "registerMismatch(rightType, leftType, null);\n", "} else {\n", "// Do not type-check interface methods, because we expect that\n", "// they will have dummy implementations that do not match the type\n", "// annotations.\n", "JSType ownerType = getJSType(owner);\n", "if (ownerType.isFunctionPrototypeType()) {\n", "FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n", "if (ownerFn.isInterface() &&\n", "rightType.isFunctionType() && leftType.isFunctionType()) {\n", "return true;\n", "}\n", "}\n", "\n", "mismatch(t, n,\n", "\"assignment to property \" + propName + \" of \" +\n", "getReadableJSTypeName(owner, true),\n", "rightType, leftType);\n", "}\n", "return false;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [24], "cluster": 1}, {"pid": "Closure", "bid": 6, "method_path": "./dataset/Closure/6/TypeValidator.java", "method": ["boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType,\n", "JSType leftType, String msg) {\n", "if (!rightType.canAssignTo(leftType)) {\n", "if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n", "registerMismatch(rightType, leftType, null);\n", "} else {\n", "mismatch(t, n, msg, rightType, leftType);\n", "}\n", "return false;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [4, 5, 6, 8], "cluster": 4}, {"pid": "Closure", "bid": 7, "method_path": "./dataset/Closure/7/ChainableReverseAbstractInterpreter.java", "method": ["public JSType caseObjectType(ObjectType type) {\n", "if (value.equals(\"function\")) {\n", "JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n", "return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n", "// Objects are restricted to \"Function\", subtypes are left\n", "// Only filter out subtypes of \"function\"\n", "}\n", "return matchesExpectation(\"object\") ? type : null;\n", "}\n"], "faulty_lines": [4, 6, 7], "cluster": 4}, {"pid": "Closure", "bid": 9, "method_path": "./dataset/Closure/9/ProcessCommonJSModules.java", "method": ["private String normalizeSourceName(String filename) {\n", "// The DOS command shell will normalize \"/\" to \"\\\", so we have to\n", "// wrestle it back.\n", "\n", "if (filename.indexOf(filenamePrefix) == 0) {\n", "filename = filename.substring(filenamePrefix.length());\n", "}\n", "\n", "return filename;\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Closure", "bid": 9, "method_path": "./dataset/Closure/9/ProcessCommonJSModules.java", "method": ["private void visitScript(NodeTraversal t, Node script) {\n", "Preconditions.checkArgument(scriptNodeCount == 1,\n", "\"ProcessCommonJSModules supports only one invocation per \" +\n", "\"CompilerInput / script node\");\n", "String moduleName = guessCJSModuleName(normalizeSourceName(script.getSourceFileName()));\n", "script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n", ".copyInformationFromForTree(script));\n", "if (reportDependencies) {\n", "CompilerInput ci = t.getInput();\n", "ci.addProvide(moduleName);\n", "JSModule m = new JSModule(moduleName);\n", "m.addAndOverrideModule(ci);\n", "module = m;\n", "}\n", "script.addChildToFront(IR.exprResult(\n", "IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n", "IR.string(moduleName))).copyInformationFromForTree(script));\n", "\n", "emitOptionalModuleExportsOverride(script, moduleName);\n", "\n", "// Rename vars to not conflict in global scope.\n", "NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n", "moduleName));\n", "\n", "compiler.reportCodeChange();\n", "}\n"], "faulty_lines": [5], "cluster": 8}, {"pid": "Closure", "bid": 11, "method_path": "./dataset/Closure/11/TypeCheck.java", "method": ["private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n", "// obj.prop or obj.method()\n", "// Lots of types can appear on the left, a call to a void function can\n", "// never be on the left. getPropertyType will decide what is acceptable\n", "// and what isn't.\n", "Node property = n.getLastChild();\n", "Node objNode = n.getFirstChild();\n", "JSType childType = getJSType(objNode);\n", "\n", "if (childType.isDict()) {\n", "report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n", "} else if (n.getJSType() != null && parent.isAssign()) {\n", "return;\n", "} else if (validator.expectNotNullOrUndefined(t, n, childType,\n", "\"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n", "checkPropertyAccess(childType, property.getString(), t, n);\n", "}\n", "ensureTyped(t, n);\n", "}\n"], "faulty_lines": [12, 13], "cluster": 8}, {"pid": "Closure", "bid": 12, "method_path": "./dataset/Closure/12/MaybeReachingVariableUse.java", "method": ["private boolean hasExceptionHandler(Node cfgNode) {\n", "return false;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Closure", "bid": 13, "method_path": "./dataset/Closure/13/PeepholeOptimizationsPass.java", "method": ["private void traverse(Node node) {\n", "// The goal here is to avoid retraversing\n", "// the entire AST to catch newly created opportunities.\n", "// So we track whether a \"unit of code\" has changed,\n", "// and revisit immediately.\n", "if (!shouldVisit(node)) {\n", "return;\n", "}\n", "\n", "int visits = 0;\n", "do {\n", "Node c = node.getFirstChild();\n", "while(c != null) {\n", "traverse(c);\n", "Node next = c.getNext();\n", "c = next;\n", "}\n", "\n", "visit(node);\n", "visits++;\n", "\n", "Preconditions.checkState(visits < 10000, \"too many interations\");\n", "} while (shouldRetraverse(node));\n", "\n", "exitNode(node);\n", "}\n"], "faulty_lines": [14, 15], "cluster": 2}, {"pid": "Closure", "bid": 14, "method_path": "./dataset/Closure/14/ControlFlowAnalysis.java", "method": ["private static Node computeFollowNode(\n", "Node fromNode, Node node, ControlFlowAnalysis cfa) {\n", "/*\n", "* This is the case where:\n", "*\n", "* 1. Parent is null implies that we are transferring control to the end of\n", "* the script.\n", "*\n", "* 2. Parent is a function implies that we are transferring control back to\n", "* the caller of the function.\n", "*\n", "* 3. If the node is a return statement, we should also transfer control\n", "* back to the caller of the function.\n", "*\n", "* 4. If the node is root then we have reached the end of what we have been\n", "* asked to traverse.\n", "*\n", "* In all cases we should transfer control to a \"symbolic return\" node.\n", "* This will make life easier for DFAs.\n", "*/\n", "Node parent = node.getParent();\n", "if (parent == null || parent.isFunction() ||\n", "(cfa != null && node == cfa.root)) {\n", "return null;\n", "}\n", "\n", "// If we are just before a IF/WHILE/DO/FOR:\n", "switch (parent.getType()) {\n", "// The follow() of any of the path from IF would be what follows IF.\n", "case Token.IF:\n", "return computeFollowNode(fromNode, parent, cfa);\n", "case Token.CASE:\n", "case Token.DEFAULT_CASE:\n", "// After the body of a CASE, the control goes to the body of the next\n", "// case, without having to go to the case condition.\n", "if (parent.getNext() != null) {\n", "if (parent.getNext().isCase()) {\n", "return parent.getNext().getFirstChild().getNext();\n", "} else if (parent.getNext().isDefaultCase()) {\n", "return parent.getNext().getFirstChild();\n", "} else {\n", "Preconditions.checkState(false, \"Not reachable\");\n", "}\n", "} else {\n", "return computeFollowNode(fromNode, parent, cfa);\n", "}\n", "break;\n", "case Token.FOR:\n", "if (NodeUtil.isForIn(parent)) {\n", "return parent;\n", "} else {\n", "return parent.getFirstChild().getNext().getNext();\n", "}\n", "case Token.WHILE:\n", "case Token.DO:\n", "return parent;\n", "case Token.TRY:\n", "// If we are coming out of the TRY block...\n", "if (parent.getFirstChild() == node) {\n", "if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n", "return computeFallThrough(parent.getLastChild());\n", "} else { // and have no FINALLY.\n", "return computeFollowNode(fromNode, parent, cfa);\n", "}\n", "// CATCH block.\n", "} else if (NodeUtil.getCatchBlock(parent) == node){\n", "if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n", "return computeFallThrough(node.getNext());\n", "} else {\n", "return computeFollowNode(fromNode, parent, cfa);\n", "}\n", "// If we are coming out of the FINALLY block...\n", "} else if (parent.getLastChild() == node){\n", "if (cfa != null) {\n", "for (Node finallyNode : cfa.finallyMap.get(parent)) {\n", "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n", "}\n", "}\n", "return computeFollowNode(fromNode, parent, cfa);\n", "}\n", "}\n", "\n", "// Now that we are done with the special cases follow should be its\n", "// immediate sibling, unless its sibling is a function\n", "Node nextSibling = node.getNext();\n", "\n", "// Skip function declarations because control doesn't get pass into it.\n", "while (nextSibling != null && nextSibling.isFunction()) {\n", "nextSibling = nextSibling.getNext();\n", "}\n", "\n", "if (nextSibling != null) {\n", "return computeFallThrough(nextSibling);\n", "} else {\n", "// If there are no more siblings, control is transferred up the AST.\n", "return computeFollowNode(fromNode, parent, cfa);\n", "}\n", "}\n"], "faulty_lines": [76], "cluster": 7}, {"pid": "Closure", "bid": 15, "method_path": "./dataset/Closure/15/FlowSensitiveInlineVariables.java", "method": ["public boolean apply(Node n) {\n", "// When the node is null it means, we reached the implicit return\n", "// where the function returns (possibly without an return statement)\n", "if (n == null) {\n", "return false;\n", "}\n", "\n", "// TODO(user): We only care about calls to functions that\n", "// passes one of the dependent variable to a non-side-effect free\n", "// function.\n", "if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n", "return true;\n", "}\n", "\n", "if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n", "return true;\n", "}\n", "\n", "\n", "for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n", "if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n", "return true;\n", "}\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [19], "cluster": 2}, {"pid": "Closure", "bid": 16, "method_path": "./dataset/Closure/16/ScopedAliases.java", "method": ["private class AliasedTypeNode implements AliasUsage {\n", "private final Node typeReference;\n", "private final String aliasName;\n", "\n", "AliasedTypeNode(Node typeReference,\n", "String aliasName) {\n", "this.typeReference = typeReference;\n", "this.aliasName = aliasName;\n", "}\n", "\n", "@Override\n", "public void applyAlias() {\n", "typeReference.setString(aliasName);\n", "}\n", "}\n"], "faulty_lines": [3, 5, 8, 13], "cluster": 4}, {"pid": "Closure", "bid": 16, "method_path": "./dataset/Closure/16/ScopedAliases.java", "method": ["private void fixTypeNode(Node typeNode) {\n", "if (typeNode.isString()) {\n", "String name = typeNode.getString();\n", "int endIndex = name.indexOf('.');\n", "if (endIndex == -1) {\n", "endIndex = name.length();\n", "}\n", "String baseName = name.substring(0, endIndex);\n", "Var aliasVar = aliases.get(baseName);\n", "if (aliasVar != null) {\n", "Node aliasedNode = aliasVar.getInitialValue();\n", "aliasUsages.add(new AliasedTypeNode(typeNode, aliasedNode.getQualifiedName() + name.substring(endIndex)));\n", "}\n", "}\n", "\n", "for (Node child = typeNode.getFirstChild(); child != null;\n", "child = child.getNext()) {\n", "fixTypeNode(child);\n", "}\n", "}\n"], "faulty_lines": [12], "cluster": 2}, {"pid": "Closure", "bid": 17, "method_path": "./dataset/Closure/17/TypedScopeCreator.java", "method": ["private JSType getDeclaredType(String sourceName, JSDocInfo info,\n", "Node lValue, @Nullable Node rValue) {\n", "if (info != null && info.hasType()) {\n", "return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n", "} else if (rValue != null && rValue.isFunction() &&\n", "shouldUseFunctionLiteralType(\n", "JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {\n", "return rValue.getJSType();\n", "} else if (info != null) {\n", "if (info.hasEnumParameterType()) {\n", "if (rValue != null && rValue.isObjectLit()) {\n", "return rValue.getJSType();\n", "} else {\n", "return createEnumTypeFromNodes(\n", "rValue, lValue.getQualifiedName(), info, lValue);\n", "}\n", "} else if (info.isConstructor() || info.isInterface()) {\n", "return createFunctionTypeFromNodes(\n", "rValue, lValue.getQualifiedName(), info, lValue);\n", "} else {\n", "// Check if this is constant, and if it has a known type.\n", "if (info.isConstant()) {\n", "JSType knownType = null;\n", "if (rValue != null) {\n", "if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n", "// If rValue has a type-cast, we use the type in the type-cast.\n", "// If rValue's type was already computed during scope creation,\n", "// then we can safely use that.\n", "return rValue.getJSType();\n", "} else if (rValue.isOr()) {\n", "// Check for a very specific JS idiom:\n", "// var x = x || TYPE;\n", "// This is used by Closure's base namespace for esoteric\n", "// reasons.\n", "Node firstClause = rValue.getFirstChild();\n", "Node secondClause = firstClause.getNext();\n", "boolean namesMatch = firstClause.isName()\n", "&& lValue.isName()\n", "&& firstClause.getString().equals(lValue.getString());\n", "if (namesMatch && secondClause.getJSType() != null\n", "&& !secondClause.getJSType().isUnknownType()) {\n", "return secondClause.getJSType();\n", "}\n", "}\n", "}\n", "}\n", "}\n", "}\n", "\n", "return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n", "}\n"], "faulty_lines": [25, 27], "cluster": 7}, {"pid": "Closure", "bid": 19, "method_path": "./dataset/Closure/19/ChainableReverseAbstractInterpreter.java", "method": ["protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n", "switch (node.getType()) {\n", "case Token.NAME:\n", "scope.inferSlotType(node.getString(), type);\n", "break;\n", "\n", "case Token.GETPROP:\n", "String qualifiedName = node.getQualifiedName();\n", "Preconditions.checkNotNull(qualifiedName);\n", "\n", "JSType origType = node.getJSType();\n", "origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n", "scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n", "break;\n", "\n", "// \"this\" references aren't currently modeled in the CFG.\n", "\n", "default:\n", "throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n", "node.toStringTree());\n", "}\n", "}\n"], "faulty_lines": [16, 17], "cluster": 2}, {"pid": "Closure", "bid": 20, "method_path": "./dataset/Closure/20/PeepholeSubstituteAlternateSyntax.java", "method": ["private Node tryFoldSimpleFunctionCall(Node n) {\n", "Preconditions.checkState(n.isCall());\n", "Node callTarget = n.getFirstChild();\n", "if (callTarget != null && callTarget.isName() &&\n", "callTarget.getString().equals(\"String\")) {\n", "// Fold String(a) to '' + (a) on immutable literals,\n", "// which allows further optimizations\n", "//\n", "// We can't do this in the general case, because String(a) has\n", "// slightly different semantics than '' + (a). See\n", "// http://code.google.com/p/closure-compiler/issues/detail?id=759\n", "Node value = callTarget.getNext();\n", "if (value != null) {\n", "Node addition = IR.add(\n", "IR.string(\"\").srcref(callTarget),\n", "value.detachFromParent());\n", "n.getParent().replaceChild(n, addition);\n", "reportCodeChange();\n", "return addition;\n", "}\n", "}\n", "return n;\n", "}\n"], "faulty_lines": [13], "cluster": 8}, {"pid": "Closure", "bid": 21, "method_path": "./dataset/Closure/21/CheckSideEffects.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "// VOID nodes appear when there are extra semicolons at the BLOCK level.\n", "// I've been unable to think of any cases where this indicates a bug,\n", "// and apparently some people like keeping these semicolons around,\n", "// so we'll allow it.\n", "if (n.isEmpty() ||\n", "n.isComma()) {\n", "return;\n", "}\n", "\n", "if (parent == null) {\n", "return;\n", "}\n", "\n", "// Do not try to remove a block or an expr result. We already handle\n", "// these cases when we visit the child, and the peephole passes will\n", "// fix up the tree in more clever ways when these are removed.\n", "if (n.isExprResult()) {\n", "return;\n", "}\n", "\n", "// This no-op statement was there so that JSDoc information could\n", "// be attached to the name. This check should not complain about it.\n", "if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n", "return;\n", "}\n", "\n", "boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n", "boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n", "if (parent.getType() == Token.COMMA) {\n", "if (isResultUsed) {\n", "return;\n", "}\n", "if (n == parent.getLastChild()) {\n", "for (Node an : parent.getAncestors()) {\n", "int ancestorType = an.getType();\n", "if (ancestorType == Token.COMMA) continue;\n", "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n", "else break;\n", "}\n", "}\n", "} else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n", "if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n", "return;\n", "}\n", "}\n", "if (\n", "(isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n", "String msg = \"This code lacks side-effects. Is there a bug?\";\n", "if (n.isString()) {\n", "msg = \"Is there a missing '+' on the previous line?\";\n", "} else if (isSimpleOp) {\n", "msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n", "\"' operator is not being used.\";\n", "}\n", "\n", "t.getCompiler().report(\n", "t.makeError(n, level, USELESS_CODE_ERROR, msg));\n", "// TODO(johnlenz): determine if it is necessary to\n", "// try to protect side-effect free statements as well.\n", "if (!NodeUtil.isStatement(n)) {\n", "problemNodes.add(n);\n", "}\n", "}\n", "}\n"], "faulty_lines": [18], "cluster": 7}, {"pid": "Closure", "bid": 22, "method_path": "./dataset/Closure/22/CheckSideEffects.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "// VOID nodes appear when there are extra semicolons at the BLOCK level.\n", "// I've been unable to think of any cases where this indicates a bug,\n", "// and apparently some people like keeping these semicolons around,\n", "// so we'll allow it.\n", "if (n.isEmpty() ||\n", "n.isComma()) {\n", "return;\n", "}\n", "\n", "if (parent == null) {\n", "return;\n", "}\n", "\n", "// Do not try to remove a block or an expr result. We already handle\n", "// these cases when we visit the child, and the peephole passes will\n", "// fix up the tree in more clever ways when these are removed.\n", "if (parent.getType() == Token.COMMA) {\n", "Node gramps = parent.getParent();\n", "if (gramps.isCall() && parent == gramps.getFirstChild()) {\n", "if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n", "return;\n", "}\n", "}\n", "\n", "// This no-op statement was there so that JSDoc information could\n", "// be attached to the name. This check should not complain about it.\n", "if (n == parent.getLastChild()) {\n", "for (Node an : parent.getAncestors()) {\n", "int ancestorType = an.getType();\n", "if (ancestorType == Token.COMMA)\n", "continue;\n", "if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n", "return;\n", "else\n", "break;\n", "}\n", "}\n", "} else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n", "if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n", "n == parent.getFirstChild().getNext().getNext())) {\n", "} else {\n", "return;\n", "}\n", "}\n", "\n", "boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n", "boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n", "if (!isResultUsed &&\n", "(isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n", "if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n", "return;\n", "} else if (n.isExprResult()) {\n", "return;\n", "}\n", "String msg = \"This code lacks side-effects. Is there a bug?\";\n", "if (n.isString()) {\n", "msg = \"Is there a missing '+' on the previous line?\";\n", "} else if (isSimpleOp) {\n", "msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n", "\"' operator is not being used.\";\n", "}\n", "\n", "t.getCompiler().report(\n", "t.makeError(n, level, USELESS_CODE_ERROR, msg));\n", "// TODO(johnlenz): determine if it is necessary to\n", "// try to protect side-effect free statements as well.\n", "if (!NodeUtil.isStatement(n)) {\n", "problemNodes.add(n);\n", "}\n", "}\n", "}\n"], "faulty_lines": [18, 19, 20, 21, 23, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 44, 51, 52, 53, 54, 55], "cluster": 7}, {"pid": "Closure", "bid": 23, "method_path": "./dataset/Closure/23/PeepholeFoldConstants.java", "method": ["private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n", "Node parent = n.getParent();\n", "// If GETPROP/GETELEM is used as assignment target the array literal is\n", "// acting as a temporary we can't fold it here:\n", "//    \"[][0] += 1\"\n", "if (isAssignmentTarget(n)) {\n", "return n;\n", "}\n", "\n", "if (!right.isNumber()) {\n", "// Sometimes people like to use complex expressions to index into\n", "// arrays, or strings to index into array methods.\n", "return n;\n", "}\n", "\n", "double index = right.getDouble();\n", "int intIndex = (int) index;\n", "if (intIndex != index) {\n", "error(INVALID_GETELEM_INDEX_ERROR, right);\n", "return n;\n", "}\n", "\n", "if (intIndex < 0) {\n", "error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n", "return n;\n", "}\n", "\n", "Node current = left.getFirstChild();\n", "Node elem = null;\n", "for (int i = 0; current != null && i < intIndex; i++) {\n", "elem = current;\n", "\n", "current = current.getNext();\n", "}\n", "\n", "if (elem == null) {\n", "error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n", "return n;\n", "}\n", "\n", "if (elem.isEmpty()) {\n", "elem = NodeUtil.newUndefinedNode(elem);\n", "} else {\n", "left.removeChild(elem);\n", "}\n", "\n", "// Replace the entire GETELEM with the value\n", "n.getParent().replaceChild(n, elem);\n", "reportCodeChange();\n", "return elem;\n", "}\n"], "faulty_lines": [30, 32], "cluster": 1}, {"pid": "Closure", "bid": 24, "method_path": "./dataset/Closure/24/ScopedAliases.java", "method": ["private void findAliases(NodeTraversal t) {\n", "Scope scope = t.getScope();\n", "for (Var v : scope.getVarIterable()) {\n", "Node n = v.getNode();\n", "int type = n.getType();\n", "Node parent = n.getParent();\n", "if (parent.isVar()) {\n", "if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n", "String name = n.getString();\n", "Var aliasVar = scope.getVar(name);\n", "aliases.put(name, aliasVar);\n", "\n", "String qualifiedName =\n", "aliasVar.getInitialValue().getQualifiedName();\n", "transformation.addAlias(name, qualifiedName);\n", "// Bleeding functions already get a BAD_PARAMETERS error, so just\n", "// do nothing.\n", "// Parameters of the scope function also get a BAD_PARAMETERS\n", "// error.\n", "} else {\n", "// TODO(robbyw): Support using locals for private variables.\n", "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [7, 8], "cluster": 8}, {"pid": "Closure", "bid": 24, "method_path": "./dataset/Closure/24/ScopedAliases.java", "method": ["private void findAliases(NodeTraversal t) {\n", "Scope scope = t.getScope();\n", "for (Var v : scope.getVarIterable()) {\n", "Node n = v.getNode();\n", "int type = n.getType();\n", "Node parent = n.getParent();\n", "if (parent.isVar()) {\n", "if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n", "String name = n.getString();\n", "Var aliasVar = scope.getVar(name);\n", "aliases.put(name, aliasVar);\n", "\n", "String qualifiedName =\n", "aliasVar.getInitialValue().getQualifiedName();\n", "transformation.addAlias(name, qualifiedName);\n", "// Bleeding functions already get a BAD_PARAMETERS error, so just\n", "// do nothing.\n", "// Parameters of the scope function also get a BAD_PARAMETERS\n", "// error.\n", "} else {\n", "// TODO(robbyw): Support using locals for private variables.\n", "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [16, 18, 24], "cluster": 8}, {"pid": "Closure", "bid": 25, "method_path": "./dataset/Closure/25/TypeInference.java", "method": ["private FlowScope traverseNew(Node n, FlowScope scope) {\n", "\n", "Node constructor = n.getFirstChild();\n", "scope = traverse(constructor, scope);\n", "JSType constructorType = constructor.getJSType();\n", "JSType type = null;\n", "if (constructorType != null) {\n", "constructorType = constructorType.restrictByNotNullOrUndefined();\n", "if (constructorType.isUnknownType()) {\n", "type = getNativeType(UNKNOWN_TYPE);\n", "} else {\n", "FunctionType ct = constructorType.toMaybeFunctionType();\n", "if (ct == null && constructorType instanceof FunctionType) {\n", "// If constructorType is a NoObjectType, then toMaybeFunctionType will\n", "// return null. But NoObjectType implements the FunctionType\n", "// interface, precisely because it can validly construct objects.\n", "ct = (FunctionType) constructorType;\n", "}\n", "if (ct != null && ct.isConstructor()) {\n", "type = ct.getInstanceType();\n", "}\n", "}\n", "}\n", "n.setJSType(type);\n", "for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n", "scope = traverse(arg, scope);\n", "}\n", "return scope;\n", "}\n"], "faulty_lines": [2, 4], "cluster": 8}, {"pid": "Closure", "bid": 25, "method_path": "./dataset/Closure/25/TypeInference.java", "method": ["private FlowScope traverseNew(Node n, FlowScope scope) {\n", "\n", "Node constructor = n.getFirstChild();\n", "scope = traverse(constructor, scope);\n", "JSType constructorType = constructor.getJSType();\n", "JSType type = null;\n", "if (constructorType != null) {\n", "constructorType = constructorType.restrictByNotNullOrUndefined();\n", "if (constructorType.isUnknownType()) {\n", "type = getNativeType(UNKNOWN_TYPE);\n", "} else {\n", "FunctionType ct = constructorType.toMaybeFunctionType();\n", "if (ct == null && constructorType instanceof FunctionType) {\n", "// If constructorType is a NoObjectType, then toMaybeFunctionType will\n", "// return null. But NoObjectType implements the FunctionType\n", "// interface, precisely because it can validly construct objects.\n", "ct = (FunctionType) constructorType;\n", "}\n", "if (ct != null && ct.isConstructor()) {\n", "type = ct.getInstanceType();\n", "}\n", "}\n", "}\n", "n.setJSType(type);\n", "for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n", "scope = traverse(arg, scope);\n", "}\n", "return scope;\n", "}\n"], "faulty_lines": [21, 25, 26, 27], "cluster": 8}, {"pid": "Closure", "bid": 26, "method_path": "./dataset/Closure/26/ProcessCommonJSModules.java", "method": ["private class ProcessCommonJsModulesCallback extends\n", "AbstractPostOrderCallback {\n", "\n", "private int scriptNodeCount = 0;\n", "\n", "@Override\n", "public void visit(NodeTraversal t, Node n, Node parent) {\n", "if (n.isCall() && n.getChildCount() == 2 &&\n", "\"require\".equals(n.getFirstChild().getQualifiedName()) &&\n", "n.getChildAtIndex(1).isString()) {\n", "visitRequireCall(t, n, parent);\n", "}\n", "\n", "if (n.isScript()) {\n", "scriptNodeCount++;\n", "visitScript(t, n);\n", "}\n", "\n", "if (n.isGetProp() &&\n", "\"module.exports\".equals(n.getQualifiedName())) {\n", "visitModuleExports(n);\n", "}\n", "}\n", "\n", "/**\n", "* Visit require calls. Emit corresponding goog.require and rewrite require\n", "* to be a direct reference to name of require module.\n", "*/\n", "private void visitRequireCall(NodeTraversal t, Node require, Node parent) {\n", "String moduleName = toModuleName(require.getChildAtIndex(1).getString(),\n", "normalizeSourceName(t.getSourceName()));\n", "Node moduleRef = IR.name(moduleName).srcref(require);\n", "parent.replaceChild(require, moduleRef);\n", "Node script = getCurrentScriptNode(parent);\n", "if (reportDependencies) {\n", "t.getInput().addRequire(moduleName);\n", "}\n", "// Rewrite require(\"name\").\n", "script.addChildToFront(IR.exprResult(\n", "IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"require\")),\n", "IR.string(moduleName))).copyInformationFromForTree(require));\n", "compiler.reportCodeChange();\n", "}\n", "\n", "/**\n", "* Emit goog.provide and add suffix to all global vars to avoid conflicts\n", "* with other modules.\n", "*/\n", "private void visitScript(NodeTraversal t, Node script) {\n", "Preconditions.checkArgument(scriptNodeCount == 1,\n", "\"ProcessCommonJSModules supports only one invocation per \" +\n", "\"CompilerInput / script node\");\n", "String moduleName = guessCJSModuleName(normalizeSourceName(script\n", ".getSourceFileName()));\n", "script.addChildToFront(IR.var(IR.name(moduleName), IR.objectlit())\n", ".copyInformationFromForTree(script));\n", "if (reportDependencies) {\n", "CompilerInput ci = t.getInput();\n", "ci.addProvide(moduleName);\n", "JSModule m = new JSModule(moduleName);\n", "m.addAndOverrideModule(ci);\n", "module = m;\n", "}\n", "script.addChildToFront(IR.exprResult(\n", "IR.call(IR.getprop(IR.name(\"goog\"), IR.string(\"provide\")),\n", "IR.string(moduleName))).copyInformationFromForTree(script));\n", "\n", "emitOptionalModuleExportsOverride(script, moduleName);\n", "\n", "// Rename vars to not conflict in global scope.\n", "NodeTraversal.traverse(compiler, script, new SuffixVarsCallback(\n", "moduleName));\n", "\n", "compiler.reportCodeChange();\n", "}\n", "\n", "/**\n", "* Emit <code>if (moduleName.module$exports) {\n", "*    moduleName = moduleName.module$export;\n", "* }</code> at end of file.\n", "*/\n", "private void emitOptionalModuleExportsOverride(Node script,\n", "String moduleName) {\n", "\n", "Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n", "IR.string(\"module$exports\"));\n", "script.addChildToBack(IR.ifNode(\n", "moduleExportsProp,\n", "IR.block(IR.exprResult(IR.assign(IR.name(moduleName),\n", "moduleExportsProp.cloneTree())))).copyInformationFromForTree(\n", "script));\n", "}\n", "\n", "/**\n", "* Rewrite module.exports to moduleName.module$exports.\n", "*/\n", "private void visitModuleExports(Node prop) {\n", "String moduleName = guessCJSModuleName(prop.getSourceFileName());\n", "Node module = prop.getChildAtIndex(0);\n", "module.putProp(Node.ORIGINALNAME_PROP, \"module\");\n", "module.setString(moduleName);\n", "Node exports = prop.getChildAtIndex(1);\n", "exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n", "exports.setString(\"module$exports\");\n", "}\n", "\n", "/**\n", "* Returns next script node in parents.\n", "*/\n", "private Node getCurrentScriptNode(Node n) {\n", "while (true) {\n", "if (n.isScript()) {\n", "return n;\n", "}\n", "n = n.getParent();\n", "}\n", "}\n", "}\n"], "faulty_lines": [5], "cluster": 7}, {"pid": "Closure", "bid": 26, "method_path": "./dataset/Closure/26/ProcessCommonJSModules.java", "method": ["private void emitOptionalModuleExportsOverride(Node script,\n", "String moduleName) {\n", "\n", "Node moduleExportsProp = IR.getprop(IR.name(moduleName),\n", "IR.string(\"module$exports\"));\n", "script.addChildToBack(IR.ifNode(\n", "moduleExportsProp,\n", "IR.block(IR.exprResult(IR.assign(IR.name(moduleName),\n", "moduleExportsProp.cloneTree())))).copyInformationFromForTree(\n", "script));\n", "}\n"], "faulty_lines": [3], "cluster": 4}, {"pid": "Closure", "bid": 26, "method_path": "./dataset/Closure/26/ProcessCommonJSModules.java", "method": ["private void visitModuleExports(Node prop) {\n", "String moduleName = guessCJSModuleName(prop.getSourceFileName());\n", "Node module = prop.getChildAtIndex(0);\n", "module.putProp(Node.ORIGINALNAME_PROP, \"module\");\n", "module.setString(moduleName);\n", "Node exports = prop.getChildAtIndex(1);\n", "exports.putProp(Node.ORIGINALNAME_PROP, \"exports\");\n", "exports.setString(\"module$exports\");\n", "}\n"], "faulty_lines": [9], "cluster": 4}, {"pid": "Closure", "bid": 27, "method_path": "./dataset/Closure/27/IR.java", "method": ["public static Node tryFinally(Node tryBody, Node finallyBody) {\n", "Preconditions.checkState(tryBody.isLabelName());\n", "Preconditions.checkState(finallyBody.isLabelName());\n", "Node catchBody = block().copyInformationFrom(tryBody);\n", "return new Node(Token.TRY, tryBody, catchBody, finallyBody);\n", "}\n"], "faulty_lines": [2, 3], "cluster": 4}, {"pid": "Closure", "bid": 27, "method_path": "./dataset/Closure/27/IR.java", "method": ["public static Node tryCatch(Node tryBody, Node catchNode) {\n", "Preconditions.checkState(tryBody.isBlock());\n", "Preconditions.checkState(catchNode.isCatch());\n", "Node catchBody = block(catchNode).copyInformationFrom(catchNode);\n", "return new Node(Token.TRY, tryBody, catchBody);\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Closure", "bid": 29, "method_path": "./dataset/Closure/29/InlineObjectLiterals.java", "method": ["private boolean isInlinableObject(List<Reference> refs) {\n", "boolean ret = false;\n", "for (Reference ref : refs) {\n", "Node name = ref.getNode();\n", "Node parent = ref.getParent();\n", "Node gramps = ref.getGrandparent();\n", "\n", "// Ignore indirect references, like x.y (except x.y(), since\n", "// the function referenced by y might reference 'this').\n", "//\n", "if (parent.isGetProp()) {\n", "Preconditions.checkState(parent.getFirstChild() == name);\n", "// A call target maybe using the object as a 'this' value.\n", "if (gramps.isCall()\n", "&& gramps.getFirstChild() == parent) {\n", "return false;\n", "}\n", "\n", "// NOTE(nicksantos): This pass's object-splitting algorithm has\n", "// a blind spot. It assumes that if a property isn't defined on an\n", "// object, then the value is undefined. This is not true, because\n", "// Object.prototype can have arbitrary properties on it.\n", "//\n", "// We short-circuit this problem by bailing out if we see a reference\n", "// to a property that isn't defined on the object literal. This\n", "// isn't a perfect algorithm, but it should catch most cases.\n", "continue;\n", "}\n", "\n", "// Only rewrite VAR declarations or simple assignment statements\n", "if (!isVarOrAssignExprLhs(name)) {\n", "return false;\n", "}\n", "\n", "Node val = ref.getAssignedValue();\n", "if (val == null) {\n", "// A var with no assignment.\n", "continue;\n", "}\n", "\n", "// We're looking for object literal assignments only.\n", "if (!val.isObjectLit()) {\n", "return false;\n", "}\n", "\n", "// Make sure that the value is not self-refential. IOW,\n", "// disallow things like x = {b: x.a}.\n", "//\n", "// TODO: Only exclude unorderable self-referential\n", "// assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n", "// but x = {a: 1, b: x.a} is.\n", "//\n", "// Also, ES5 getters/setters aren't handled by this pass.\n", "for (Node child = val.getFirstChild(); child != null;\n", "child = child.getNext()) {\n", "if (child.isGetterDef() ||\n", "child.isSetterDef()) {\n", "// ES5 get/set not supported.\n", "return false;\n", "}\n", "\n", "\n", "Node childVal = child.getFirstChild();\n", "// Check if childVal is the parent of any of the passed in\n", "// references, as that is how self-referential assignments\n", "// will happen.\n", "for (Reference t : refs) {\n", "Node refNode = t.getParent();\n", "while (!NodeUtil.isStatementBlock(refNode)) {\n", "if (refNode == childVal) {\n", "// There's a self-referential assignment\n", "return false;\n", "}\n", "refNode = refNode.getParent();\n", "}\n", "}\n", "}\n", "\n", "\n", "// We have found an acceptable object literal assignment. As\n", "// long as there are no other assignments that mess things up,\n", "// we can inline.\n", "ret = true;\n", "}\n", "return ret;\n", "}\n"], "faulty_lines": [3], "cluster": 7}, {"pid": "Closure", "bid": 29, "method_path": "./dataset/Closure/29/InlineObjectLiterals.java", "method": ["boolean ret = false;\n", "for (Reference ref : refs) {\n", "Node name = ref.getNode();\n", "Node parent = ref.getParent();\n", "Node gramps = ref.getGrandparent();\n", "\n", "// Ignore indirect references, like x.y (except x.y(), since\n", "// the function referenced by y might reference 'this').\n", "//\n", "if (parent.isGetProp()) {\n", "Preconditions.checkState(parent.getFirstChild() == name);\n", "// A call target maybe using the object as a 'this' value.\n", "if (gramps.isCall()\n", "&& gramps.getFirstChild() == parent) {\n", "return false;\n", "}\n", "\n", "// NOTE(nicksantos): This pass's object-splitting algorithm has\n", "// a blind spot. It assumes that if a property isn't defined on an\n", "// object, then the value is undefined. This is not true, because\n", "// Object.prototype can have arbitrary properties on it.\n", "//\n", "// We short-circuit this problem by bailing out if we see a reference\n", "// to a property that isn't defined on the object literal. This\n", "// isn't a perfect algorithm, but it should catch most cases.\n", "continue;\n", "}\n", "\n", "// Only rewrite VAR declarations or simple assignment statements\n", "if (!isVarOrAssignExprLhs(name)) {\n", "return false;\n", "}\n", "\n", "Node val = ref.getAssignedValue();\n", "if (val == null) {\n", "// A var with no assignment.\n", "continue;\n", "}\n", "\n", "// We're looking for object literal assignments only.\n", "if (!val.isObjectLit()) {\n", "return false;\n", "}\n", "\n", "// Make sure that the value is not self-refential. IOW,\n", "// disallow things like x = {b: x.a}.\n", "//\n", "// TODO: Only exclude unorderable self-referential\n", "// assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n", "// but x = {a: 1, b: x.a} is.\n", "//\n", "// Also, ES5 getters/setters aren't handled by this pass.\n", "for (Node child = val.getFirstChild(); child != null;\n", "child = child.getNext()) {\n", "if (child.isGetterDef() ||\n", "child.isSetterDef()) {\n", "// ES5 get/set not supported.\n", "return false;\n", "}\n", "\n", "\n", "Node childVal = child.getFirstChild();\n", "// Check if childVal is the parent of any of the passed in\n", "// references, as that is how self-referential assignments\n", "// will happen.\n", "for (Reference t : refs) {\n", "Node refNode = t.getParent();\n", "while (!NodeUtil.isStatementBlock(refNode)) {\n", "if (refNode == childVal) {\n", "// There's a self-referential assignment\n", "return false;\n", "}\n", "refNode = refNode.getParent();\n", "}\n", "}\n", "}\n", "\n", "\n", "// We have found an acceptable object literal assignment. As\n", "// long as there are no other assignments that mess things up,\n", "// we can inline.\n", "ret = true;\n", "}\n"], "faulty_lines": [26], "cluster": 7}, {"pid": "Closure", "bid": 29, "method_path": "./dataset/Closure/29/InlineObjectLiterals.java", "method": ["boolean ret = false;\n", "for (Reference ref : refs) {\n", "Node name = ref.getNode();\n", "Node parent = ref.getParent();\n", "Node gramps = ref.getGrandparent();\n", "\n", "// Ignore indirect references, like x.y (except x.y(), since\n", "// the function referenced by y might reference 'this').\n", "//\n", "if (parent.isGetProp()) {\n", "Preconditions.checkState(parent.getFirstChild() == name);\n", "// A call target maybe using the object as a 'this' value.\n", "if (gramps.isCall()\n", "&& gramps.getFirstChild() == parent) {\n", "return false;\n", "}\n", "\n", "// NOTE(nicksantos): This pass's object-splitting algorithm has\n", "// a blind spot. It assumes that if a property isn't defined on an\n", "// object, then the value is undefined. This is not true, because\n", "// Object.prototype can have arbitrary properties on it.\n", "//\n", "// We short-circuit this problem by bailing out if we see a reference\n", "// to a property that isn't defined on the object literal. This\n", "// isn't a perfect algorithm, but it should catch most cases.\n", "continue;\n", "}\n", "\n", "// Only rewrite VAR declarations or simple assignment statements\n", "if (!isVarOrAssignExprLhs(name)) {\n", "return false;\n", "}\n", "\n", "Node val = ref.getAssignedValue();\n", "if (val == null) {\n", "// A var with no assignment.\n", "continue;\n", "}\n", "\n", "// We're looking for object literal assignments only.\n", "if (!val.isObjectLit()) {\n", "return false;\n", "}\n", "\n", "// Make sure that the value is not self-refential. IOW,\n", "// disallow things like x = {b: x.a}.\n", "//\n", "// TODO: Only exclude unorderable self-referential\n", "// assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n", "// but x = {a: 1, b: x.a} is.\n", "//\n", "// Also, ES5 getters/setters aren't handled by this pass.\n", "for (Node child = val.getFirstChild(); child != null;\n", "child = child.getNext()) {\n", "if (child.isGetterDef() ||\n", "child.isSetterDef()) {\n", "// ES5 get/set not supported.\n", "return false;\n", "}\n", "\n", "\n", "Node childVal = child.getFirstChild();\n", "// Check if childVal is the parent of any of the passed in\n", "// references, as that is how self-referential assignments\n", "// will happen.\n", "for (Reference t : refs) {\n", "Node refNode = t.getParent();\n", "while (!NodeUtil.isStatementBlock(refNode)) {\n", "if (refNode == childVal) {\n", "// There's a self-referential assignment\n", "return false;\n", "}\n", "refNode = refNode.getParent();\n", "}\n", "}\n", "}\n", "\n", "\n", "// We have found an acceptable object literal assignment. As\n", "// long as there are no other assignments that mess things up,\n", "// we can inline.\n", "ret = true;\n", "}\n"], "faulty_lines": [61], "cluster": 7}, {"pid": "Closure", "bid": 30, "method_path": "./dataset/Closure/30/FlowSensitiveInlineVariables.java", "method": ["public void process(Node externs, Node root) {\n", "(new NodeTraversal(compiler, this)).traverse(root);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Closure", "bid": 30, "method_path": "./dataset/Closure/30/MustBeReachingVariableDef.java", "method": ["private static class Definition {\n", "final Node node;\n", "final Set<Var> depends = Sets.newHashSet();\n", "\n", "Definition(Node node) {\n", "this.node = node;\n", "}\n", "\n", "@Override\n", "public boolean equals(Object other) {\n", "if (!(other instanceof Definition)) {\n", "return false;\n", "}\n", "Definition otherDef = (Definition) other;\n", "// If the var has the same definition node we can assume they have the\n", "// same depends set.\n", "return otherDef.node == node;\n", "}\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Closure", "bid": 30, "method_path": "./dataset/Closure/30/MustBeReachingVariableDef.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "if (n.isName() && jsScope.isDeclared(n.getString(), true)) {\n", "Var dep = jsScope.getVar(n.getString());\n", "def.depends.add(dep);\n", "}\n", "}\n"], "faulty_lines": [2, 4, 5], "cluster": 0}, {"pid": "Closure", "bid": 30, "method_path": "./dataset/Closure/30/MustBeReachingVariableDef.java", "method": ["boolean dependsOnOuterScopeVars(String name, Node useNode) {\n", "Preconditions.checkArgument(getCfg().hasNode(useNode));\n", "GraphNode<Node, Branch> n = getCfg().getNode(useNode);\n", "FlowState<MustDef> state = n.getAnnotation();\n", "Definition def = state.getIn().reachingDef.get(jsScope.getVar(name));\n", "\n", "for (Var s : def.depends) {\n", "if (s.scope != jsScope) {\n", "return true;\n", "}\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [6], "cluster": 4}, {"pid": "Closure", "bid": 33, "method_path": "./dataset/Closure/33/PrototypeObjectType.java", "method": ["public void matchConstraint(ObjectType constraintObj) {\n", "// We only want to match contraints on anonymous types.\n", "\n", "// Handle the case where the constraint object is a record type.\n", "//\n", "// param constraintObj {{prop: (number|undefined)}}\n", "// function f(constraintObj) {}\n", "// f({});\n", "//\n", "// We want to modify the object literal to match the constraint, by\n", "// taking any each property on the record and trying to match\n", "// properties on this object.\n", "if (constraintObj.isRecordType()) {\n", "for (String prop : constraintObj.getOwnPropertyNames()) {\n", "JSType propType = constraintObj.getPropertyType(prop);\n", "if (!isPropertyTypeDeclared(prop)) {\n", "JSType typeToInfer = propType;\n", "if (!hasProperty(prop)) {\n", "typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n", ".getLeastSupertype(propType);\n", "}\n", "defineInferredProperty(prop, typeToInfer, null);\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [3], "cluster": 8}, {"pid": "Closure", "bid": 34, "method_path": "./dataset/Closure/34/CodeGenerator.java", "method": ["void add(Node n, Context context) {\n", "if (!cc.continueProcessing()) {\n", "return;\n", "}\n", "\n", "int type = n.getType();\n", "String opstr = NodeUtil.opToStr(type);\n", "int childCount = n.getChildCount();\n", "Node first = n.getFirstChild();\n", "Node last = n.getLastChild();\n", "\n", "// Handle all binary operators\n", "if (opstr != null && first != last) {\n", "Preconditions.checkState(\n", "childCount == 2,\n", "\"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n", "opstr, childCount);\n", "int p = NodeUtil.precedence(type);\n", "\n", "// For right-hand-side of operations, only pass context if it's\n", "// the IN_FOR_INIT_CLAUSE one.\n", "Context rhsContext = getContextForNoInOperator(context);\n", "\n", "// Handle associativity.\n", "// e.g. if the parse tree is a * (b * c),\n", "// we can simply generate a * b * c.\n", "if (last.getType() == type &&\n", "NodeUtil.isAssociative(type)) {\n", "addExpr(first, p, context);\n", "cc.addOp(opstr, true);\n", "addExpr(last, p, rhsContext);\n", "} else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n", "// Assignments are the only right-associative binary operators\n", "addExpr(first, p, context);\n", "cc.addOp(opstr, true);\n", "addExpr(last, p, rhsContext);\n", "} else {\n", "addExpr(first, p, context);\n", "cc.addOp(opstr, true);\n", "addExpr(last, p + 1, rhsContext);\n", "}\n", "return;\n", "}\n", "\n", "cc.startSourceMapping(n);\n", "\n", "switch (type) {\n", "case Token.TRY: {\n", "Preconditions.checkState(first.getNext().isBlock() &&\n", "!first.getNext().hasMoreThanOneChild());\n", "Preconditions.checkState(childCount >= 2 && childCount <= 3);\n", "\n", "add(\"try\");\n", "add(first, Context.PRESERVE_BLOCK);\n", "\n", "// second child contains the catch block, or nothing if there\n", "// isn't a catch block\n", "Node catchblock = first.getNext().getFirstChild();\n", "if (catchblock != null) {\n", "add(catchblock);\n", "}\n", "\n", "if (childCount == 3) {\n", "add(\"finally\");\n", "add(last, Context.PRESERVE_BLOCK);\n", "}\n", "break;\n", "}\n", "\n", "case Token.CATCH:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"catch(\");\n", "add(first);\n", "add(\")\");\n", "add(last, Context.PRESERVE_BLOCK);\n", "break;\n", "\n", "case Token.THROW:\n", "Preconditions.checkState(childCount == 1);\n", "add(\"throw\");\n", "add(first);\n", "\n", "// Must have a ';' after a throw statement, otherwise safari can't\n", "// parse this.\n", "cc.endStatement(true);\n", "break;\n", "\n", "case Token.RETURN:\n", "add(\"return\");\n", "if (childCount == 1) {\n", "add(first);\n", "} else {\n", "Preconditions.checkState(childCount == 0);\n", "}\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.VAR:\n", "if (first != null) {\n", "add(\"var \");\n", "addList(first, false, getContextForNoInOperator(context));\n", "}\n", "break;\n", "\n", "case Token.LABEL_NAME:\n", "Preconditions.checkState(!n.getString().isEmpty());\n", "addIdentifier(n.getString());\n", "break;\n", "\n", "case Token.NAME:\n", "if (first == null || first.isEmpty()) {\n", "addIdentifier(n.getString());\n", "} else {\n", "Preconditions.checkState(childCount == 1);\n", "addIdentifier(n.getString());\n", "cc.addOp(\"=\", true);\n", "if (first.isComma()) {\n", "addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n", "} else {\n", "// Add expression, consider nearby code at lowest level of\n", "// precedence.\n", "addExpr(first, 0, getContextForNoInOperator(context));\n", "}\n", "}\n", "break;\n", "\n", "case Token.ARRAYLIT:\n", "add(\"[\");\n", "addArrayList(first);\n", "add(\"]\");\n", "break;\n", "\n", "case Token.PARAM_LIST:\n", "add(\"(\");\n", "addList(first);\n", "add(\")\");\n", "break;\n", "\n", "case Token.COMMA:\n", "Preconditions.checkState(childCount == 2);\n", "unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n", "break;\n", "\n", "case Token.NUMBER:\n", "Preconditions.checkState(childCount == 0);\n", "cc.addNumber(n.getDouble());\n", "break;\n", "\n", "case Token.TYPEOF:\n", "case Token.VOID:\n", "case Token.NOT:\n", "case Token.BITNOT:\n", "case Token.POS: {\n", "// All of these unary operators are right-associative\n", "Preconditions.checkState(childCount == 1);\n", "cc.addOp(NodeUtil.opToStrNoFail(type), false);\n", "addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n", "break;\n", "}\n", "\n", "case Token.NEG: {\n", "Preconditions.checkState(childCount == 1);\n", "\n", "// It's important to our sanity checker that the code\n", "// we print produces the same AST as the code we parse back.\n", "// NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n", "if (n.getFirstChild().isNumber()) {\n", "cc.addNumber(-n.getFirstChild().getDouble());\n", "} else {\n", "cc.addOp(NodeUtil.opToStrNoFail(type), false);\n", "addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n", "}\n", "\n", "break;\n", "}\n", "\n", "case Token.HOOK: {\n", "Preconditions.checkState(childCount == 3);\n", "int p = NodeUtil.precedence(type);\n", "addExpr(first, p + 1, context);\n", "cc.addOp(\"?\", true);\n", "addExpr(first.getNext(), 1, Context.OTHER);\n", "cc.addOp(\":\", true);\n", "addExpr(last, 1, Context.OTHER);\n", "break;\n", "}\n", "\n", "case Token.REGEXP:\n", "if (!first.isString() ||\n", "!last.isString()) {\n", "throw new Error(\"Expected children to be strings\");\n", "}\n", "\n", "String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n", "\n", "// I only use one .add because whitespace matters\n", "if (childCount == 2) {\n", "add(regexp + last.getString());\n", "} else {\n", "Preconditions.checkState(childCount == 1);\n", "add(regexp);\n", "}\n", "break;\n", "\n", "case Token.FUNCTION:\n", "if (n.getClass() != Node.class) {\n", "throw new Error(\"Unexpected Node subclass.\");\n", "}\n", "Preconditions.checkState(childCount == 3);\n", "boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n", "if (funcNeedsParens) {\n", "add(\"(\");\n", "}\n", "\n", "add(\"function\");\n", "add(first);\n", "\n", "add(first.getNext());\n", "add(last, Context.PRESERVE_BLOCK);\n", "cc.endFunction(context == Context.STATEMENT);\n", "\n", "if (funcNeedsParens) {\n", "add(\")\");\n", "}\n", "break;\n", "\n", "case Token.GETTER_DEF:\n", "case Token.SETTER_DEF:\n", "Preconditions.checkState(n.getParent().isObjectLit());\n", "Preconditions.checkState(childCount == 1);\n", "Preconditions.checkState(first.isFunction());\n", "\n", "// Get methods are unnamed\n", "Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n", "if (type == Token.GETTER_DEF) {\n", "// Get methods have no parameters.\n", "Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n", "add(\"get \");\n", "} else {\n", "// Set methods have one parameter.\n", "Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n", "add(\"set \");\n", "}\n", "\n", "// The name is on the GET or SET node.\n", "String name = n.getString();\n", "Node fn = first;\n", "Node parameters = fn.getChildAtIndex(1);\n", "Node body = fn.getLastChild();\n", "\n", "// Add the property name.\n", "if (!n.isQuotedString() &&\n", "TokenStream.isJSIdentifier(name) &&\n", "// do not encode literally any non-literal characters that were\n", "// unicode escaped.\n", "NodeUtil.isLatin(name)) {\n", "add(name);\n", "} else {\n", "// Determine if the string is a simple number.\n", "double d = getSimpleNumber(name);\n", "if (!Double.isNaN(d)) {\n", "cc.addNumber(d);\n", "} else {\n", "addJsString(n);\n", "}\n", "}\n", "\n", "add(parameters);\n", "add(body, Context.PRESERVE_BLOCK);\n", "break;\n", "\n", "case Token.SCRIPT:\n", "case Token.BLOCK: {\n", "if (n.getClass() != Node.class) {\n", "throw new Error(\"Unexpected Node subclass.\");\n", "}\n", "boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n", "if (preserveBlock) {\n", "cc.beginBlock();\n", "}\n", "\n", "boolean preferLineBreaks =\n", "type == Token.SCRIPT ||\n", "(type == Token.BLOCK &&\n", "!preserveBlock &&\n", "n.getParent() != null &&\n", "n.getParent().isScript());\n", "for (Node c = first; c != null; c = c.getNext()) {\n", "add(c, Context.STATEMENT);\n", "\n", "// VAR doesn't include ';' since it gets used in expressions\n", "if (c.isVar()) {\n", "cc.endStatement();\n", "}\n", "\n", "if (c.isFunction()) {\n", "cc.maybeLineBreak();\n", "}\n", "\n", "// Prefer to break lines in between top-level statements\n", "// because top level statements are more homogeneous.\n", "if (preferLineBreaks) {\n", "cc.notePreferredLineBreak();\n", "}\n", "}\n", "if (preserveBlock) {\n", "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n", "}\n", "break;\n", "}\n", "\n", "case Token.FOR:\n", "if (childCount == 4) {\n", "add(\"for(\");\n", "if (first.isVar()) {\n", "add(first, Context.IN_FOR_INIT_CLAUSE);\n", "} else {\n", "addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n", "}\n", "add(\";\");\n", "add(first.getNext());\n", "add(\";\");\n", "add(first.getNext().getNext());\n", "add(\")\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "} else {\n", "Preconditions.checkState(childCount == 3);\n", "add(\"for(\");\n", "add(first);\n", "add(\"in\");\n", "add(first.getNext());\n", "add(\")\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "}\n", "break;\n", "\n", "case Token.DO:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"do\");\n", "addNonEmptyStatement(first, Context.OTHER, false);\n", "add(\"while(\");\n", "add(last);\n", "add(\")\");\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.WHILE:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"while(\");\n", "add(first);\n", "add(\")\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "break;\n", "\n", "case Token.EMPTY:\n", "Preconditions.checkState(childCount == 0);\n", "break;\n", "\n", "case Token.GETPROP: {\n", "Preconditions.checkState(\n", "childCount == 2,\n", "\"Bad GETPROP: expected 2 children, but got %s\", childCount);\n", "Preconditions.checkState(\n", "last.isString(),\n", "\"Bad GETPROP: RHS should be STRING\");\n", "boolean needsParens = (first.isNumber());\n", "if (needsParens) {\n", "add(\"(\");\n", "}\n", "addExpr(first, NodeUtil.precedence(type), context);\n", "if (needsParens) {\n", "add(\")\");\n", "}\n", "add(\".\");\n", "addIdentifier(last.getString());\n", "break;\n", "}\n", "\n", "case Token.GETELEM:\n", "Preconditions.checkState(\n", "childCount == 2,\n", "\"Bad GETELEM: expected 2 children but got %s\", childCount);\n", "addExpr(first, NodeUtil.precedence(type), context);\n", "add(\"[\");\n", "add(first.getNext());\n", "add(\"]\");\n", "break;\n", "\n", "case Token.WITH:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"with(\");\n", "add(first);\n", "add(\")\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "break;\n", "\n", "case Token.INC:\n", "case Token.DEC: {\n", "Preconditions.checkState(childCount == 1);\n", "String o = type == Token.INC ? \"++\" : \"--\";\n", "int postProp = n.getIntProp(Node.INCRDECR_PROP);\n", "// A non-zero post-prop value indicates a post inc/dec, default of zero\n", "// is a pre-inc/dec.\n", "if (postProp != 0) {\n", "addExpr(first, NodeUtil.precedence(type), context);\n", "cc.addOp(o, false);\n", "} else {\n", "cc.addOp(o, false);\n", "add(first);\n", "}\n", "break;\n", "}\n", "\n", "case Token.CALL:\n", "// We have two special cases here:\n", "// 1) If the left hand side of the call is a direct reference to eval,\n", "// then it must have a DIRECT_EVAL annotation. If it does not, then\n", "// that means it was originally an indirect call to eval, and that\n", "// indirectness must be preserved.\n", "// 2) If the left hand side of the call is a property reference,\n", "// then the call must not a FREE_CALL annotation. If it does, then\n", "// that means it was originally an call without an explicit this and\n", "// that must be preserved.\n", "if (isIndirectEval(first)\n", "|| n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n", "add(\"(0,\");\n", "addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n", "add(\")\");\n", "} else {\n", "addExpr(first, NodeUtil.precedence(type), context);\n", "}\n", "add(\"(\");\n", "addList(first.getNext());\n", "add(\")\");\n", "break;\n", "\n", "case Token.IF:\n", "boolean hasElse = childCount == 3;\n", "boolean ambiguousElseClause =\n", "context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n", "if (ambiguousElseClause) {\n", "cc.beginBlock();\n", "}\n", "\n", "add(\"if(\");\n", "add(first);\n", "add(\")\");\n", "\n", "if (hasElse) {\n", "addNonEmptyStatement(\n", "first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n", "add(\"else\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "} else {\n", "addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n", "Preconditions.checkState(childCount == 2);\n", "}\n", "\n", "if (ambiguousElseClause) {\n", "cc.endBlock();\n", "}\n", "break;\n", "\n", "case Token.NULL:\n", "Preconditions.checkState(childCount == 0);\n", "add(\"null\");\n", "break;\n", "\n", "case Token.THIS:\n", "Preconditions.checkState(childCount == 0);\n", "add(\"this\");\n", "break;\n", "\n", "case Token.FALSE:\n", "Preconditions.checkState(childCount == 0);\n", "add(\"false\");\n", "break;\n", "\n", "case Token.TRUE:\n", "Preconditions.checkState(childCount == 0);\n", "add(\"true\");\n", "break;\n", "\n", "case Token.CONTINUE:\n", "Preconditions.checkState(childCount <= 1);\n", "add(\"continue\");\n", "if (childCount == 1) {\n", "if (!first.isLabelName()) {\n", "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n", "}\n", "add(\" \");\n", "add(first);\n", "}\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.DEBUGGER:\n", "Preconditions.checkState(childCount == 0);\n", "add(\"debugger\");\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.BREAK:\n", "Preconditions.checkState(childCount <= 1);\n", "add(\"break\");\n", "if (childCount == 1) {\n", "if (!first.isLabelName()) {\n", "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n", "}\n", "add(\" \");\n", "add(first);\n", "}\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.EXPR_RESULT:\n", "Preconditions.checkState(childCount == 1);\n", "add(first, Context.START_OF_EXPR);\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.NEW:\n", "add(\"new \");\n", "int precedence = NodeUtil.precedence(type);\n", "\n", "// If the first child contains a CALL, then claim higher precedence\n", "// to force parentheses. Otherwise, when parsed, NEW will bind to the\n", "// first viable parentheses (don't traverse into functions).\n", "if (NodeUtil.containsType(\n", "first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n", "precedence = NodeUtil.precedence(first.getType()) + 1;\n", "}\n", "addExpr(first, precedence, Context.OTHER);\n", "\n", "// '()' is optional when no arguments are present\n", "Node next = first.getNext();\n", "if (next != null) {\n", "add(\"(\");\n", "addList(next);\n", "add(\")\");\n", "}\n", "break;\n", "\n", "case Token.STRING:\n", "if (childCount !=\n", "((n.getParent() != null &&\n", "n.getParent().isObjectLit()) ? 1 : 0)) {\n", "throw new IllegalStateException(\n", "\"Unexpected String children: \" + n.getParent().toStringTree());\n", "}\n", "addJsString(n);\n", "break;\n", "\n", "case Token.DELPROP:\n", "Preconditions.checkState(childCount == 1);\n", "add(\"delete \");\n", "add(first);\n", "break;\n", "\n", "case Token.OBJECTLIT: {\n", "boolean needsParens = (context == Context.START_OF_EXPR);\n", "if (needsParens) {\n", "add(\"(\");\n", "}\n", "add(\"{\");\n", "for (Node c = first; c != null; c = c.getNext()) {\n", "if (c != first) {\n", "cc.listSeparator();\n", "}\n", "\n", "if (c.isGetterDef() || c.isSetterDef()) {\n", "add(c);\n", "} else {\n", "Preconditions.checkState(c.isString());\n", "String key = c.getString();\n", "// Object literal property names don't have to be quoted if they\n", "// are not JavaScript keywords\n", "if (!c.isQuotedString() &&\n", "!TokenStream.isKeyword(key) &&\n", "TokenStream.isJSIdentifier(key) &&\n", "// do not encode literally any non-literal characters that\n", "// were unicode escaped.\n", "NodeUtil.isLatin(key)) {\n", "add(key);\n", "} else {\n", "// Determine if the string is a simple number.\n", "double d = getSimpleNumber(key);\n", "if (!Double.isNaN(d)) {\n", "cc.addNumber(d);\n", "} else {\n", "addExpr(c, 1, Context.OTHER);\n", "}\n", "}\n", "add(\":\");\n", "addExpr(c.getFirstChild(), 1, Context.OTHER);\n", "}\n", "}\n", "add(\"}\");\n", "if (needsParens) {\n", "add(\")\");\n", "}\n", "break;\n", "}\n", "\n", "case Token.SWITCH:\n", "add(\"switch(\");\n", "add(first);\n", "add(\")\");\n", "cc.beginBlock();\n", "addAllSiblings(first.getNext());\n", "cc.endBlock(context == Context.STATEMENT);\n", "break;\n", "\n", "case Token.CASE:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"case \");\n", "add(first);\n", "addCaseBody(last);\n", "break;\n", "\n", "case Token.DEFAULT_CASE:\n", "Preconditions.checkState(childCount == 1);\n", "add(\"default\");\n", "addCaseBody(first);\n", "break;\n", "\n", "case Token.LABEL:\n", "Preconditions.checkState(childCount == 2);\n", "if (!first.isLabelName()) {\n", "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n", "}\n", "add(first);\n", "add(\":\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), true);\n", "break;\n", "\n", "default:\n", "throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n", "}\n", "\n", "cc.endSourceMapping(n);\n", "}\n"], "faulty_lines": [38, 39, 40], "cluster": 7}, {"pid": "Closure", "bid": 34, "method_path": "./dataset/Closure/34/CodeGenerator.java", "method": ["private void unrollBinaryOperator(\n", "Node n, int op, String opStr, Context context,\n", "Context rhsContext, int leftPrecedence, int rightPrecedence) {\n", "Node firstNonOperator = n.getFirstChild();\n", "while (firstNonOperator.getType() == op) {\n", "firstNonOperator = firstNonOperator.getFirstChild();\n", "}\n", "\n", "addExpr(firstNonOperator, leftPrecedence, context);\n", "\n", "Node current = firstNonOperator;\n", "do {\n", "current = current.getParent();\n", "cc.listSeparator();\n", "addExpr(current.getFirstChild().getNext(), rightPrecedence, rhsContext);\n", "} while (current != n);\n", "}\n"], "faulty_lines": [14], "cluster": 2}, {"pid": "Closure", "bid": 34, "method_path": "./dataset/Closure/34/CodePrinter.java", "method": ["void appendOp(String op, boolean binOp) {\n", "if (binOp) {\n", "if (getLastChar() != ' ') {\n", "append(\" \");\n", "}\n", "append(op);\n", "append(\" \");\n", "} else {\n", "append(op);\n", "}\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Closure", "bid": 35, "method_path": "./dataset/Closure/35/TypeInference.java", "method": ["private void inferPropertyTypesToMatchConstraint(\n", "JSType type, JSType constraint) {\n", "if (type == null || constraint == null) {\n", "return;\n", "}\n", "\n", "ObjectType constraintObj =\n", "ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n", "if (constraintObj != null && constraintObj.isRecordType()) {\n", "ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n", "if (objType != null) {\n", "for (String prop : constraintObj.getOwnPropertyNames()) {\n", "JSType propType = constraintObj.getPropertyType(prop);\n", "if (!objType.isPropertyTypeDeclared(prop)) {\n", "JSType typeToInfer = propType;\n", "if (!objType.hasProperty(prop)) {\n", "typeToInfer =\n", "getNativeType(VOID_TYPE).getLeastSupertype(propType);\n", "}\n", "objType.defineInferredProperty(prop, typeToInfer, null);\n", "}\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], "cluster": 8}, {"pid": "Closure", "bid": 36, "method_path": "./dataset/Closure/36/InlineVariables.java", "method": ["private boolean canInline(\n", "Reference declaration,\n", "Reference initialization,\n", "Reference reference) {\n", "if (!isValidDeclaration(declaration)\n", "|| !isValidInitialization(initialization)\n", "|| !isValidReference(reference)) {\n", "return false;\n", "}\n", "\n", "// If the value is read more than once, skip it.\n", "// VAR declarations and EXPR_RESULT don't need the value, but other\n", "// ASSIGN expressions parents do.\n", "if (declaration != initialization &&\n", "!initialization.getGrandparent().isExprResult()) {\n", "return false;\n", "}\n", "\n", "// Be very conservative and do no cross control structures or\n", "// scope boundaries\n", "if (declaration.getBasicBlock() != initialization.getBasicBlock()\n", "|| declaration.getBasicBlock() != reference.getBasicBlock()) {\n", "return false;\n", "}\n", "\n", "// Do not inline into a call node. This would change\n", "// the context in which it was being called. For example,\n", "//   var a = b.c;\n", "//   a();\n", "// should not be inlined, because it calls a in the context of b\n", "// rather than the context of the window.\n", "//   var a = b.c;\n", "//   f(a)\n", "// is ok.\n", "Node value = initialization.getAssignedValue();\n", "Preconditions.checkState(value != null);\n", "if (value.isGetProp()\n", "&& reference.getParent().isCall()\n", "&& reference.getParent().getFirstChild() == reference.getNode()) {\n", "return false;\n", "}\n", "\n", "if (value.isFunction()) {\n", "Node callNode = reference.getParent();\n", "if (reference.getParent().isCall()) {\n", "CodingConvention convention = compiler.getCodingConvention();\n", "// Bug 2388531: Don't inline subclass definitions into class defining\n", "// calls as this confused class removing logic.\n", "SubclassRelationship relationship =\n", "convention.getClassesDefinedByCall(callNode);\n", "if (relationship != null) {\n", "return false;\n", "}\n", "\n", "// issue 668: Don't inline singleton getter methods\n", "// calls as this confused class removing logic.\n", "}\n", "}\n", "\n", "return canMoveAggressively(value) ||\n", "canMoveModerately(initialization, reference);\n", "}\n"], "faulty_lines": [57], "cluster": 7}, {"pid": "Closure", "bid": 38, "method_path": "./dataset/Closure/38/CodeConsumer.java", "method": ["void addNumber(double x) {\n", "// This is not pretty printing. This is to prevent misparsing of x- -4 as\n", "// x--4 (which is a syntax error).\n", "char prev = getLastChar();\n", "boolean negativeZero = isNegativeZero(x);\n", "if (x < 0 && prev == '-') {\n", "add(\" \");\n", "}\n", "\n", "if ((long) x == x && !negativeZero) {\n", "long value = (long) x;\n", "long mantissa = value;\n", "int exp = 0;\n", "if (Math.abs(x) >= 100) {\n", "while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n", "mantissa /= 10;\n", "exp++;\n", "}\n", "}\n", "if (exp > 2) {\n", "add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n", "} else {\n", "add(Long.toString(value));\n", "}\n", "} else {\n", "add(String.valueOf(x));\n", "}\n", "}\n"], "faulty_lines": [6], "cluster": 8}, {"pid": "Closure", "bid": 40, "method_path": "./dataset/Closure/40/NameAnalyzer.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "\n", "// Record global variable and function declarations\n", "if (t.inGlobalScope()) {\n", "if (NodeUtil.isVarDeclaration(n)) {\n", "NameInformation ns = createNameInformation(t, n, parent);\n", "Preconditions.checkNotNull(ns);\n", "recordSet(ns.name, n);\n", "} else if (NodeUtil.isFunctionDeclaration(n)) {\n", "Node nameNode = n.getFirstChild();\n", "NameInformation ns = createNameInformation(t, nameNode, n);\n", "if (ns != null) {\n", "JsName nameInfo = getName(nameNode.getString(), true);\n", "recordSet(nameInfo.name, nameNode);\n", "}\n", "} else if (NodeUtil.isObjectLitKey(n, parent)) {\n", "NameInformation ns = createNameInformation(t, n, parent);\n", "if (ns != null) {\n", "recordSet(ns.name, n);\n", "}\n", "}\n", "}\n", "\n", "// Record assignments and call sites\n", "if (n.isAssign()) {\n", "Node nameNode = n.getFirstChild();\n", "\n", "NameInformation ns = createNameInformation(t, nameNode, n);\n", "if (ns != null) {\n", "if (ns.isPrototype) {\n", "recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n", "} else {\n", "recordSet(ns.name, nameNode);\n", "}\n", "}\n", "} else if (n.isCall()) {\n", "Node nameNode = n.getFirstChild();\n", "NameInformation ns = createNameInformation(t, nameNode, n);\n", "if (ns != null && ns.onlyAffectsClassDef) {\n", "JsName name = getName(ns.name, false);\n", "if (name != null) {\n", "refNodes.add(new ClassDefiningFunctionNode(\n", "name, n, parent, parent.getParent()));\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [40, 41, 44], "cluster": 7}, {"pid": "Closure", "bid": 43, "method_path": "./dataset/Closure/43/TypedScopeCreator.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "inputId = t.getInputId();\n", "attachLiteralTypes(t, n);\n", "\n", "switch (n.getType()) {\n", "case Token.CALL:\n", "checkForClassDefiningCalls(t, n, parent);\n", "checkForCallingConventionDefiningCalls(n, delegateCallingConventions);\n", "break;\n", "\n", "case Token.FUNCTION:\n", "if (t.getInput() == null || !t.getInput().isExtern()) {\n", "nonExternFunctions.add(n);\n", "}\n", "\n", "// Hoisted functions are handled during pre-traversal.\n", "if (!NodeUtil.isHoistedFunctionDeclaration(n)) {\n", "defineFunctionLiteral(n, parent);\n", "}\n", "break;\n", "\n", "case Token.ASSIGN:\n", "// Handle initialization of properties.\n", "Node firstChild = n.getFirstChild();\n", "if (firstChild.isGetProp() &&\n", "firstChild.isQualifiedName()) {\n", "maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n", "firstChild, n, firstChild.getNext());\n", "}\n", "break;\n", "\n", "case Token.CATCH:\n", "defineCatch(n, parent);\n", "break;\n", "\n", "case Token.VAR:\n", "defineVar(n, parent);\n", "break;\n", "\n", "case Token.GETPROP:\n", "// Handle stubbed properties.\n", "if (parent.isExprResult() &&\n", "n.isQualifiedName()) {\n", "maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n", "}\n", "break;\n", "}\n", "\n", "// Analyze any @lends object literals in this statement.\n", "}\n"], "faulty_lines": [50], "cluster": 1}, {"pid": "Closure", "bid": 43, "method_path": "./dataset/Closure/43/TypedScopeCreator.java", "method": ["private void attachLiteralTypes(NodeTraversal t, Node n) {\n", "switch (n.getType()) {\n", "case Token.NULL:\n", "n.setJSType(getNativeType(NULL_TYPE));\n", "break;\n", "\n", "case Token.VOID:\n", "n.setJSType(getNativeType(VOID_TYPE));\n", "break;\n", "\n", "case Token.STRING:\n", "// Defer keys to the Token.OBJECTLIT case\n", "if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n", "n.setJSType(getNativeType(STRING_TYPE));\n", "}\n", "break;\n", "\n", "case Token.NUMBER:\n", "n.setJSType(getNativeType(NUMBER_TYPE));\n", "break;\n", "\n", "case Token.TRUE:\n", "case Token.FALSE:\n", "n.setJSType(getNativeType(BOOLEAN_TYPE));\n", "break;\n", "\n", "case Token.REGEXP:\n", "n.setJSType(getNativeType(REGEXP_TYPE));\n", "break;\n", "\n", "case Token.OBJECTLIT:\n", "defineObjectLiteral(n);\n", "break;\n", "\n", "// NOTE(nicksantos): If we ever support Array tuples,\n", "// we will need to put ARRAYLIT here as well.\n", "}\n", "}\n"], "faulty_lines": [32, 33], "cluster": 8}, {"pid": "Closure", "bid": 44, "method_path": "./dataset/Closure/44/CodeConsumer.java", "method": ["void add(String newcode) {\n", "maybeEndStatement();\n", "\n", "if (newcode.length() == 0) {\n", "return;\n", "}\n", "\n", "char c = newcode.charAt(0);\n", "if ((isWordChar(c) || c == '\\\\') &&\n", "isWordChar(getLastChar())) {\n", "// need space to separate. This is not pretty printing.\n", "// For example: \"return foo;\"\n", "append(\" \");\n", "// Do not allow a forward slash to appear after a DIV.\n", "// For example,\n", "// REGEXP DIV REGEXP\n", "// is valid and should print like\n", "// / // / /\n", "}\n", "\n", "append(newcode);\n", "}\n"], "faulty_lines": [14, 19], "cluster": 2}, {"pid": "Closure", "bid": 45, "method_path": "./dataset/Closure/45/RemoveUnusedVars.java", "method": ["private static class Assign {\n", "\n", "final Node assignNode;\n", "\n", "final Node nameNode;\n", "\n", "// If false, then this is an assign to the normal variable. Otherwise,\n", "// this is an assign to a property of that variable.\n", "final boolean isPropertyAssign;\n", "\n", "// Secondary side effects are any side effects in this assign statement\n", "// that aren't caused by the assignment operation itself. For example,\n", "// a().b = 3;\n", "// a = b();\n", "// var foo = (a = b);\n", "// In the first two cases, the sides of the assignment have side-effects.\n", "// In the last one, the result of the assignment is used, so we\n", "// are conservative and assume that it may be used in a side-effecting\n", "// way.\n", "final boolean mayHaveSecondarySideEffects;\n", "\n", "// If true, the value may have escaped and any modification is a use.\n", "final boolean maybeAliased;\n", "\n", "Assign(Node assignNode, Node nameNode, boolean isPropertyAssign) {\n", "Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n", "this.assignNode = assignNode;\n", "this.nameNode = nameNode;\n", "this.isPropertyAssign = isPropertyAssign;\n", "\n", "this.maybeAliased = !assignNode.getParent().isExprResult();\n", "this.mayHaveSecondarySideEffects =\n", "maybeAliased ||\n", "NodeUtil.mayHaveSideEffects(assignNode.getFirstChild()) ||\n", "NodeUtil.mayHaveSideEffects(assignNode.getLastChild());\n", "}\n", "\n", "/**\n", "* If this is an assign to a variable or its property, return it.\n", "* Otherwise, return null.\n", "*/\n", "static Assign maybeCreateAssign(Node assignNode) {\n", "Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n", "\n", "// Skip one level of GETPROPs or GETELEMs.\n", "//\n", "// Don't skip more than one level, because then we get into\n", "// situations where assigns to properties of properties will always\n", "// trigger side-effects, and the variable they're on cannot be removed.\n", "boolean isPropAssign = false;\n", "Node current = assignNode.getFirstChild();\n", "if (NodeUtil.isGet(current)) {\n", "current = current.getFirstChild();\n", "isPropAssign = true;\n", "\n", "if (current.isGetProp() &&\n", "current.getLastChild().getString().equals(\"prototype\")) {\n", "// Prototype properties sets should be considered like normal\n", "// property sets.\n", "current = current.getFirstChild();\n", "}\n", "}\n", "\n", "if (current.isName()) {\n", "return new Assign(assignNode, current, isPropAssign);\n", "}\n", "return null;\n", "}\n", "\n", "/**\n", "* Replace the current assign with its right hand side.\n", "*/\n", "void remove() {\n", "Node parent = assignNode.getParent();\n", "if (mayHaveSecondarySideEffects) {\n", "Node replacement = assignNode.getLastChild().detachFromParent();\n", "\n", "// Aggregate any expressions in GETELEMs.\n", "for (Node current = assignNode.getFirstChild();\n", "!current.isName();\n", "current = current.getFirstChild()) {\n", "if (current.isGetElem()) {\n", "replacement = IR.comma(\n", "current.getLastChild().detachFromParent(), replacement);\n", "replacement.copyInformationFrom(current);\n", "}\n", "}\n", "\n", "parent.replaceChild(assignNode, replacement);\n", "} else {\n", "Node gramps = parent.getParent();\n", "if (parent.isExprResult()) {\n", "gramps.removeChild(parent);\n", "} else {\n", "parent.replaceChild(assignNode,\n", "assignNode.getLastChild().detachFromParent());\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [31], "cluster": 7}, {"pid": "Closure", "bid": 47, "method_path": "./dataset/Closure/47/SourceMapConsumerV3.java", "method": ["private OriginalMapping getOriginalMappingForEntry(Entry entry) {\n", "if (entry.getSourceFileId() == UNMAPPED) {\n", "return null;\n", "} else {\n", "// Adjust the line/column here to be start at 1.\n", "Builder x = OriginalMapping.newBuilder()\n", ".setOriginalFile(sources[entry.getSourceFileId()])\n", ".setLineNumber(entry.getSourceLine())\n", ".setColumnPosition(entry.getSourceColumn());\n", "if (entry.getNameId() != UNMAPPED) {\n", "x.setIdentifier(names[entry.getNameId()]);\n", "}\n", "return x.build();\n", "}\n", "}\n"], "faulty_lines": [8, 9], "cluster": 2}, {"pid": "Closure", "bid": 47, "method_path": "./dataset/Closure/47/SourceMap.java", "method": ["public void addMapping(\n", "Node node,\n", "FilePosition outputStartPosition,\n", "FilePosition outputEndPosition) {\n", "String sourceFile = node.getSourceFileName();\n", "\n", "// If the node does not have an associated source file or\n", "// its line number is -1, then the node does not have sufficient\n", "// information for a mapping to be useful.\n", "if (sourceFile == null || node.getLineno() < 0) {\n", "return;\n", "}\n", "\n", "sourceFile = fixupSourceLocation(sourceFile);\n", "\n", "String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n", "\n", "// Strangely, Rhino source lines are one based but columns are\n", "// zero based.\n", "// We don't change this for the v1 or v2 source maps but for\n", "// v3 we make them both 0 based.\n", "\n", "generator.addMapping(\n", "sourceFile, originalName,\n", "new FilePosition(node.getLineno(), node.getCharno()),\n", "outputStartPosition, outputEndPosition);\n", "}\n"], "faulty_lines": [22, 25], "cluster": 8}, {"pid": "Closure", "bid": 49, "method_path": "./dataset/Closure/49/MakeDeclaredNamesUnique.java", "method": ["public void enterScope(NodeTraversal t) {\n", "Node declarationRoot = t.getScopeRoot();\n", "Renamer renamer;\n", "if (nameStack.isEmpty()) {\n", "// If the contextual renamer is being used the starting context can not\n", "// be a function.\n", "Preconditions.checkState(\n", "declarationRoot.getType() != Token.FUNCTION ||\n", "!(rootRenamer instanceof ContextualRenamer));\n", "Preconditions.checkState(t.inGlobalScope());\n", "renamer = rootRenamer;\n", "} else {\n", "renamer = nameStack.peek().forChildScope();\n", "}\n", "\n", "if (declarationRoot.getType() == Token.FUNCTION) {\n", "for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n", "String name = c.getString();\n", "renamer.addDeclaredName(name);\n", "}\n", "Node functionBody = declarationRoot.getLastChild();\n", "findDeclaredNames(functionBody, null, renamer);\n", "}  else\n", "if (declarationRoot.getType() != Token.FUNCTION) {\n", "// Add the block declarations\n", "findDeclaredNames(declarationRoot, null, renamer);\n", "}\n", "nameStack.push(renamer);\n", "}\n"], "faulty_lines": [16, 17, 18, 19, 20, 21, 22, 23], "cluster": 8}, {"pid": "Closure", "bid": 49, "method_path": "./dataset/Closure/49/MakeDeclaredNamesUnique.java", "method": ["public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n", "\n", "switch (n.getType()) {\n", "case Token.FUNCTION:\n", "{\n", "// Add recursive function name, if needed.\n", "// NOTE: \"enterScope\" is called after we need to pick up this name.\n", "Renamer renamer = nameStack.peek().forChildScope();\n", "\n", "// If needed, add the function recursive name.\n", "String name = n.getFirstChild().getString();\n", "if (name != null && !name.isEmpty() && parent != null\n", "&& !NodeUtil.isFunctionDeclaration(n)) {\n", "renamer.addDeclaredName(name);\n", "}\n", "\n", "\n", "\n", "// Add the function parameters\n", "\n", "// Add the function body declarations\n", "\n", "nameStack.push(renamer);\n", "}\n", "break;\n", "\n", "case Token.CATCH:\n", "{\n", "Renamer renamer = nameStack.peek().forChildScope();\n", "\n", "String name = n.getFirstChild().getString();\n", "renamer.addDeclaredName(name);\n", "\n", "nameStack.push(renamer);\n", "}\n", "break;\n", "}\n", "\n", "return true;\n", "}\n"], "faulty_lines": [17, 18, 20, 22], "cluster": 8}, {"pid": "Closure", "bid": 49, "method_path": "./dataset/Closure/49/MakeDeclaredNamesUnique.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "switch (n.getType()) {\n", "case Token.NAME:\n", "String newName = getReplacementName(n.getString());\n", "if (newName != null) {\n", "Renamer renamer = nameStack.peek();\n", "if (renamer.stripConstIfReplaced()) {\n", "// TODO(johnlenz): Do we need to do anything about the javadoc?\n", "n.removeProp(Node.IS_CONSTANT_NAME);\n", "}\n", "n.setString(newName);\n", "t.getCompiler().reportCodeChange();\n", "}\n", "break;\n", "\n", "case Token.FUNCTION:\n", "// Remove the function body scope\n", "// Remove function recursive name (if any).\n", "nameStack.pop();\n", "break;\n", "\n", "// Note: The parameters and function body variables live in the\n", "// same scope, we introduce the scope when in the \"shouldTraverse\"\n", "// visit of LP, but remove it when when we exit the function above.\n", "\n", "case Token.CATCH:\n", "// Remove catch except name from the stack of names.\n", "nameStack.pop();\n", "break;\n", "}\n", "}\n"], "faulty_lines": [18, 22, 25], "cluster": 8}, {"pid": "Closure", "bid": 50, "method_path": "./dataset/Closure/50/PeepholeReplaceKnownMethods.java", "method": ["private Node tryFoldArrayJoin(Node n) {\n", "Node callTarget = n.getFirstChild();\n", "\n", "if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n", "return n;\n", "}\n", "\n", "Node right = callTarget.getNext();\n", "if (right != null) {\n", "if (!NodeUtil.isImmutableValue(right)) {\n", "return n;\n", "}\n", "}\n", "\n", "Node arrayNode = callTarget.getFirstChild();\n", "Node functionName = arrayNode.getNext();\n", "\n", "if ((arrayNode.getType() != Token.ARRAYLIT) ||\n", "!functionName.getString().equals(\"join\")) {\n", "return n;\n", "}\n", "\n", "// \",\" is the default, it doesn't need to be explicit\n", "\n", "String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n", "List<Node> arrayFoldedChildren = Lists.newLinkedList();\n", "StringBuilder sb = null;\n", "int foldedSize = 0;\n", "Node prev = null;\n", "Node elem = arrayNode.getFirstChild();\n", "// Merges adjacent String nodes.\n", "while (elem != null) {\n", "if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n", "if (sb == null) {\n", "sb = new StringBuilder();\n", "} else {\n", "sb.append(joinString);\n", "}\n", "sb.append(NodeUtil.getArrayElementStringValue(elem));\n", "} else {\n", "if (sb != null) {\n", "Preconditions.checkNotNull(prev);\n", "// + 2 for the quotes.\n", "foldedSize += sb.length() + 2;\n", "arrayFoldedChildren.add(\n", "Node.newString(sb.toString()).copyInformationFrom(prev));\n", "sb = null;\n", "}\n", "foldedSize += InlineCostEstimator.getCost(elem);\n", "arrayFoldedChildren.add(elem);\n", "}\n", "prev = elem;\n", "elem = elem.getNext();\n", "}\n", "\n", "if (sb != null) {\n", "Preconditions.checkNotNull(prev);\n", "// + 2 for the quotes.\n", "foldedSize += sb.length() + 2;\n", "arrayFoldedChildren.add(\n", "Node.newString(sb.toString()).copyInformationFrom(prev));\n", "}\n", "// one for each comma.\n", "foldedSize += arrayFoldedChildren.size() - 1;\n", "\n", "int originalSize = InlineCostEstimator.getCost(n);\n", "switch (arrayFoldedChildren.size()) {\n", "case 0:\n", "Node emptyStringNode = Node.newString(\"\");\n", "n.getParent().replaceChild(n, emptyStringNode);\n", "reportCodeChange();\n", "return emptyStringNode;\n", "case 1:\n", "Node foldedStringNode = arrayFoldedChildren.remove(0);\n", "if (foldedSize > originalSize) {\n", "return n;\n", "}\n", "arrayNode.detachChildren();\n", "if (foldedStringNode.getType() != Token.STRING) {\n", "// If the Node is not a string literal, ensure that\n", "// it is coerced to a string.\n", "Node replacement = new Node(Token.ADD,\n", "Node.newString(\"\").copyInformationFrom(n),\n", "foldedStringNode);\n", "foldedStringNode = replacement;\n", "}\n", "n.getParent().replaceChild(n, foldedStringNode);\n", "reportCodeChange();\n", "return foldedStringNode;\n", "default:\n", "// No folding could actually be performed.\n", "if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n", "return n;\n", "}\n", "int kJoinOverhead = \"[].join()\".length();\n", "foldedSize += kJoinOverhead;\n", "foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n", "if (foldedSize > originalSize) {\n", "return n;\n", "}\n", "arrayNode.detachChildren();\n", "for (Node node : arrayFoldedChildren) {\n", "arrayNode.addChildToBack(node);\n", "}\n", "reportCodeChange();\n", "break;\n", "}\n", "\n", "return n;\n", "}\n"], "faulty_lines": [10], "cluster": 7}, {"pid": "Closure", "bid": 50, "method_path": "./dataset/Closure/50/PeepholeReplaceKnownMethods.java", "method": ["private Node tryFoldArrayJoin(Node n) {\n", "Node callTarget = n.getFirstChild();\n", "\n", "if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n", "return n;\n", "}\n", "\n", "Node right = callTarget.getNext();\n", "if (right != null) {\n", "if (!NodeUtil.isImmutableValue(right)) {\n", "return n;\n", "}\n", "}\n", "\n", "Node arrayNode = callTarget.getFirstChild();\n", "Node functionName = arrayNode.getNext();\n", "\n", "if ((arrayNode.getType() != Token.ARRAYLIT) ||\n", "!functionName.getString().equals(\"join\")) {\n", "return n;\n", "}\n", "\n", "// \",\" is the default, it doesn't need to be explicit\n", "\n", "String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n", "List<Node> arrayFoldedChildren = Lists.newLinkedList();\n", "StringBuilder sb = null;\n", "int foldedSize = 0;\n", "Node prev = null;\n", "Node elem = arrayNode.getFirstChild();\n", "// Merges adjacent String nodes.\n", "while (elem != null) {\n", "if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n", "if (sb == null) {\n", "sb = new StringBuilder();\n", "} else {\n", "sb.append(joinString);\n", "}\n", "sb.append(NodeUtil.getArrayElementStringValue(elem));\n", "} else {\n", "if (sb != null) {\n", "Preconditions.checkNotNull(prev);\n", "// + 2 for the quotes.\n", "foldedSize += sb.length() + 2;\n", "arrayFoldedChildren.add(\n", "Node.newString(sb.toString()).copyInformationFrom(prev));\n", "sb = null;\n", "}\n", "foldedSize += InlineCostEstimator.getCost(elem);\n", "arrayFoldedChildren.add(elem);\n", "}\n", "prev = elem;\n", "elem = elem.getNext();\n", "}\n", "\n", "if (sb != null) {\n", "Preconditions.checkNotNull(prev);\n", "// + 2 for the quotes.\n", "foldedSize += sb.length() + 2;\n", "arrayFoldedChildren.add(\n", "Node.newString(sb.toString()).copyInformationFrom(prev));\n", "}\n", "// one for each comma.\n", "foldedSize += arrayFoldedChildren.size() - 1;\n", "\n", "int originalSize = InlineCostEstimator.getCost(n);\n", "switch (arrayFoldedChildren.size()) {\n", "case 0:\n", "Node emptyStringNode = Node.newString(\"\");\n", "n.getParent().replaceChild(n, emptyStringNode);\n", "reportCodeChange();\n", "return emptyStringNode;\n", "case 1:\n", "Node foldedStringNode = arrayFoldedChildren.remove(0);\n", "if (foldedSize > originalSize) {\n", "return n;\n", "}\n", "arrayNode.detachChildren();\n", "if (foldedStringNode.getType() != Token.STRING) {\n", "// If the Node is not a string literal, ensure that\n", "// it is coerced to a string.\n", "Node replacement = new Node(Token.ADD,\n", "Node.newString(\"\").copyInformationFrom(n),\n", "foldedStringNode);\n", "foldedStringNode = replacement;\n", "}\n", "n.getParent().replaceChild(n, foldedStringNode);\n", "reportCodeChange();\n", "return foldedStringNode;\n", "default:\n", "// No folding could actually be performed.\n", "if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n", "return n;\n", "}\n", "int kJoinOverhead = \"[].join()\".length();\n", "foldedSize += kJoinOverhead;\n", "foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n", "if (foldedSize > originalSize) {\n", "return n;\n", "}\n", "arrayNode.detachChildren();\n", "for (Node node : arrayFoldedChildren) {\n", "arrayNode.addChildToBack(node);\n", "}\n", "reportCodeChange();\n", "break;\n", "}\n", "\n", "return n;\n", "}\n"], "faulty_lines": [23, 24], "cluster": 7}, {"pid": "Closure", "bid": 51, "method_path": "./dataset/Closure/51/CodeConsumer.java", "method": ["void addNumber(double x) {\n", "// This is not pretty printing. This is to prevent misparsing of x- -4 as\n", "// x--4 (which is a syntax error).\n", "char prev = getLastChar();\n", "if (x < 0 && prev == '-') {\n", "add(\" \");\n", "}\n", "\n", "if ((long) x == x) {\n", "long value = (long) x;\n", "long mantissa = value;\n", "int exp = 0;\n", "if (Math.abs(x) >= 100) {\n", "while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n", "mantissa /= 10;\n", "exp++;\n", "}\n", "}\n", "if (exp > 2) {\n", "add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n", "} else {\n", "add(Long.toString(value));\n", "}\n", "} else {\n", "add(String.valueOf(x));\n", "}\n", "\n", "}\n"], "faulty_lines": [9], "cluster": 8}, {"pid": "Closure", "bid": 51, "method_path": "./dataset/Closure/51/CodeConsumer.java", "method": ["void addNumber(double x) {\n", "// This is not pretty printing. This is to prevent misparsing of x- -4 as\n", "// x--4 (which is a syntax error).\n", "char prev = getLastChar();\n", "if (x < 0 && prev == '-') {\n", "add(\" \");\n", "}\n", "\n", "if ((long) x == x) {\n", "long value = (long) x;\n", "long mantissa = value;\n", "int exp = 0;\n", "if (Math.abs(x) >= 100) {\n", "while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n", "mantissa /= 10;\n", "exp++;\n", "}\n", "}\n", "if (exp > 2) {\n", "add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n", "} else {\n", "add(Long.toString(value));\n", "}\n", "} else {\n", "add(String.valueOf(x));\n", "}\n", "\n", "}\n"], "faulty_lines": [27, 28], "cluster": 8}, {"pid": "Closure", "bid": 53, "method_path": "./dataset/Closure/53/InlineObjectLiterals.java", "method": ["private void replaceAssignmentExpression(Var v, Reference ref,\n", "Map<String, String> varmap) {\n", "// Compute all of the assignments necessary\n", "List<Node> nodes = Lists.newArrayList();\n", "Node val = ref.getAssignedValue();\n", "blacklistVarReferencesInTree(val, v.scope);\n", "Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n", "Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n", "for (Node key = val.getFirstChild(); key != null;\n", "key = key.getNext()) {\n", "String var = key.getString();\n", "Node value = key.removeFirstChild();\n", "// TODO(user): Copy type information.\n", "nodes.add(\n", "new Node(Token.ASSIGN,\n", "Node.newString(Token.NAME, varmap.get(var)), value));\n", "all.remove(var);\n", "}\n", "\n", "// TODO(user): Better source information.\n", "for (String var : all) {\n", "nodes.add(\n", "new Node(Token.ASSIGN,\n", "Node.newString(Token.NAME, varmap.get(var)),\n", "NodeUtil.newUndefinedNode(null)));\n", "}\n", "\n", "Node replacement;\n", "// All assignments evaluate to true, so make sure that the\n", "// expr statement evaluates to true in case it matters.\n", "nodes.add(new Node(Token.TRUE));\n", "\n", "// Join these using COMMA.  A COMMA node must have 2 children, so we\n", "// create a tree. In the tree the first child be the COMMA to match\n", "// the parser, otherwise tree equality tests fail.\n", "nodes = Lists.reverse(nodes);\n", "replacement = new Node(Token.COMMA);\n", "Node cur = replacement;\n", "int i;\n", "for (i = 0; i < nodes.size() - 2; i++) {\n", "cur.addChildToFront(nodes.get(i));\n", "Node t = new Node(Token.COMMA);\n", "cur.addChildToFront(t);\n", "cur = t;\n", "}\n", "cur.addChildToFront(nodes.get(i));\n", "cur.addChildToFront(nodes.get(i + 1));\n", "\n", "Node replace = ref.getParent();\n", "replacement.copyInformationFromForTree(replace);\n", "\n", "if (replace.getType() == Token.VAR) {\n", "replace.getParent().replaceChild(\n", "replace, NodeUtil.newExpr(replacement));\n", "} else {\n", "replace.getParent().replaceChild(replace, replacement);\n", "}\n", "}\n"], "faulty_lines": [29], "cluster": 7}, {"pid": "Closure", "bid": 53, "method_path": "./dataset/Closure/53/InlineObjectLiterals.java", "method": ["private void replaceAssignmentExpression(Var v, Reference ref,\n", "Map<String, String> varmap) {\n", "// Compute all of the assignments necessary\n", "List<Node> nodes = Lists.newArrayList();\n", "Node val = ref.getAssignedValue();\n", "blacklistVarReferencesInTree(val, v.scope);\n", "Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n", "Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n", "for (Node key = val.getFirstChild(); key != null;\n", "key = key.getNext()) {\n", "String var = key.getString();\n", "Node value = key.removeFirstChild();\n", "// TODO(user): Copy type information.\n", "nodes.add(\n", "new Node(Token.ASSIGN,\n", "Node.newString(Token.NAME, varmap.get(var)), value));\n", "all.remove(var);\n", "}\n", "\n", "// TODO(user): Better source information.\n", "for (String var : all) {\n", "nodes.add(\n", "new Node(Token.ASSIGN,\n", "Node.newString(Token.NAME, varmap.get(var)),\n", "NodeUtil.newUndefinedNode(null)));\n", "}\n", "\n", "Node replacement;\n", "// All assignments evaluate to true, so make sure that the\n", "// expr statement evaluates to true in case it matters.\n", "nodes.add(new Node(Token.TRUE));\n", "\n", "// Join these using COMMA.  A COMMA node must have 2 children, so we\n", "// create a tree. In the tree the first child be the COMMA to match\n", "// the parser, otherwise tree equality tests fail.\n", "nodes = Lists.reverse(nodes);\n", "replacement = new Node(Token.COMMA);\n", "Node cur = replacement;\n", "int i;\n", "for (i = 0; i < nodes.size() - 2; i++) {\n", "cur.addChildToFront(nodes.get(i));\n", "Node t = new Node(Token.COMMA);\n", "cur.addChildToFront(t);\n", "cur = t;\n", "}\n", "cur.addChildToFront(nodes.get(i));\n", "cur.addChildToFront(nodes.get(i + 1));\n", "\n", "Node replace = ref.getParent();\n", "replacement.copyInformationFromForTree(replace);\n", "\n", "if (replace.getType() == Token.VAR) {\n", "replace.getParent().replaceChild(\n", "replace, NodeUtil.newExpr(replacement));\n", "} else {\n", "replace.getParent().replaceChild(replace, replacement);\n", "}\n", "}\n"], "faulty_lines": [48], "cluster": 7}, {"pid": "Closure", "bid": 54, "method_path": "./dataset/Closure/54/TypedScopeCreator.java", "method": ["void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n", "Node n, Node parent, Node rhsValue) {\n", "Node ownerNode = n.getFirstChild();\n", "String ownerName = ownerNode.getQualifiedName();\n", "String qName = n.getQualifiedName();\n", "String propName = n.getLastChild().getString();\n", "Preconditions.checkArgument(qName != null && ownerName != null);\n", "\n", "// Precedence of type information on GETPROPs:\n", "// 1) @type annnotation / @enum annotation\n", "// 2) ASSIGN to FUNCTION literal\n", "// 3) @param/@return annotation (with no function literal)\n", "// 4) ASSIGN to something marked @const\n", "// 5) ASSIGN to anything else\n", "//\n", "// 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n", "// the function has jsdoc or has not been declared before.\n", "//\n", "// FUNCTION literals are special because TypedScopeCreator is very smart\n", "// about getting as much type information as possible for them.\n", "\n", "// Determining type for #1 + #2 + #3 + #4\n", "JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n", "if (valueType == null && rhsValue != null) {\n", "// Determining type for #5\n", "valueType = rhsValue.getJSType();\n", "}\n", "// Function prototypes are special.\n", "// It's a common JS idiom to do:\n", "// F.prototype = { ... };\n", "// So if F does not have an explicitly declared super type,\n", "// allow F.prototype to be redefined arbitrarily.\n", "if (\"prototype\".equals(propName)) {\n", "Var qVar = scope.getVar(qName);\n", "if (qVar != null) {\n", "// If the programmer has declared that F inherits from Super,\n", "// and they assign F.prototype to an object literal,\n", "// then they are responsible for making sure that the object literal's\n", "// implicit prototype is set up appropriately. We just obey\n", "// the @extends tag.\n", "if (!qVar.isTypeInferred()) {\n", "// If the programmer has declared that F inherits from Super,\n", "// and they assign F.prototype to some arbitrary expression,\n", "// there's not much we can do. We just ignore the expression,\n", "// and hope they've annotated their code in a way to tell us\n", "// what props are going to be on that prototype.\n", "return;\n", "}\n", "if (qVar.getScope() == scope) {\n", "scope.undeclare(qVar);\n", "}\n", "}\n", "}\n", "\n", "if (valueType == null) {\n", "if (parent.getType() == Token.EXPR_RESULT) {\n", "stubDeclarations.add(new StubDeclaration(\n", "n,\n", "t.getInput() != null && t.getInput().isExtern(),\n", "ownerName));\n", "}\n", "\n", "return;\n", "}\n", "\n", "boolean inferred = true;\n", "if (info != null) {\n", "// Determining declaration for #1 + #3 + #4\n", "inferred = !(info.hasType()\n", "|| info.hasEnumParameterType()\n", "|| (info.isConstant() && valueType != null\n", "&& !valueType.isUnknownType())\n", "|| FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n", "}\n", "\n", "if (inferred) {\n", "// Determining declaration for #2\n", "inferred = !(rhsValue != null &&\n", "rhsValue.getType() == Token.FUNCTION &&\n", "(info != null || !scope.isDeclared(qName, false)));\n", "}\n", "\n", "if (!inferred) {\n", "ObjectType ownerType = getObjectSlot(ownerName);\n", "if (ownerType != null) {\n", "// Only declare this as an official property if it has not been\n", "// declared yet.\n", "boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n", "if ((!ownerType.hasOwnProperty(propName) ||\n", "ownerType.isPropertyTypeInferred(propName)) &&\n", "((isExtern && !ownerType.isNativeObjectType()) ||\n", "!ownerType.isInstanceType())) {\n", "// If the property is undeclared or inferred, declare it now.\n", "ownerType.defineDeclaredProperty(propName, valueType, n);\n", "}\n", "}\n", "\n", "// If the property is already declared, the error will be\n", "// caught when we try to declare it in the current scope.\n", "defineSlot(n, parent, valueType, inferred);\n", "} else if (rhsValue != null &&\n", "rhsValue.getType() == Token.TRUE) {\n", "// We declare these for delegate proxy method properties.\n", "FunctionType ownerType =\n", "JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n", "if (ownerType != null) {\n", "JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n", "String delegateName = codingConvention.getDelegateSuperclassName();\n", "JSType delegateType = delegateName == null ?\n", "null : typeRegistry.getType(delegateName);\n", "if (delegateType != null &&\n", "ownerTypeOfThis.isSubtype(delegateType)) {\n", "defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [41], "cluster": 7}, {"pid": "Closure", "bid": 54, "method_path": "./dataset/Closure/54/FunctionType.java", "method": ["public void setPrototypeBasedOn(ObjectType baseType) {\n", "// This is a bit weird. We need to successfully handle these\n", "// two cases:\n", "// Foo.prototype = new Bar();\n", "// and\n", "// Foo.prototype = {baz: 3};\n", "// In the first case, we do not want new properties to get\n", "// added to Bar. In the second case, we do want new properties\n", "// to get added to the type of the anonymous object.\n", "//\n", "// We handle this by breaking it into two cases:\n", "//\n", "// In the first case, we create a new PrototypeObjectType and set\n", "// its implicit prototype to the type being assigned. This ensures\n", "// that Bar will not get any properties of Foo.prototype, but properties\n", "// later assigned to Bar will get inherited properly.\n", "//\n", "// In the second case, we just use the anonymous object as the prototype.\n", "if (baseType.hasReferenceName() ||\n", "baseType.isUnknownType() ||\n", "isNativeObjectType() ||\n", "baseType.isFunctionPrototypeType() ||\n", "!(baseType instanceof PrototypeObjectType)) {\n", "\n", "baseType = new PrototypeObjectType(\n", "registry, this.getReferenceName() + \".prototype\", baseType);\n", "}\n", "setPrototype((PrototypeObjectType) baseType);\n", "}\n"], "faulty_lines": [20], "cluster": 8}, {"pid": "Closure", "bid": 54, "method_path": "./dataset/Closure/54/FunctionType.java", "method": ["public boolean setPrototype(PrototypeObjectType prototype) {\n", "if (prototype == null) {\n", "return false;\n", "}\n", "// getInstanceType fails if the function is not a constructor\n", "if (isConstructor() && prototype == getInstanceType()) {\n", "return false;\n", "}\n", "\n", "boolean replacedPrototype = prototype != null;\n", "\n", "this.prototype = prototype;\n", "this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n", "this.prototype.setOwnerFunction(this);\n", "\n", "// Disassociating the old prototype makes this easier to debug--\n", "// we don't have to worry about two prototypes running around.\n", "\n", "if (isConstructor() || isInterface()) {\n", "FunctionType superClass = getSuperClassConstructor();\n", "if (superClass != null) {\n", "superClass.addSubType(this);\n", "}\n", "\n", "if (isInterface()) {\n", "for (ObjectType interfaceType : getExtendedInterfaces()) {\n", "if (interfaceType.getConstructor() != null) {\n", "interfaceType.getConstructor().addSubType(this);\n", "}\n", "}\n", "}\n", "}\n", "\n", "if (replacedPrototype) {\n", "clearCachedValues();\n", "}\n", "\n", "return true;\n", "}\n"], "faulty_lines": [10, 16, 18], "cluster": 8}, {"pid": "Closure", "bid": 55, "method_path": "./dataset/Closure/55/FunctionRewriter.java", "method": ["private static boolean isReduceableFunctionExpression(Node n) {\n", "return NodeUtil.isFunctionExpression(n);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Closure", "bid": 56, "method_path": "./dataset/Closure/56/SourceFile.java", "method": ["public String getLine(int lineNumber) {\n", "String js = \"\";\n", "try {\n", "// NOTE(nicksantos): Right now, this is optimized for few warnings.\n", "// This is probably the right trade-off, but will be slow if there\n", "// are lots of warnings in one file.\n", "js = getCode();\n", "} catch (IOException e) {\n", "return null;\n", "}\n", "\n", "int pos = 0;\n", "int startLine = 1;\n", "\n", "// If we've saved a previous offset and it's for a line less than the\n", "// one we're searching for, then start at that point.\n", "if (lineNumber >= lastLine) {\n", "pos = lastOffset;\n", "startLine = lastLine;\n", "}\n", "\n", "for (int n = startLine; n < lineNumber; n++) {\n", "int nextpos = js.indexOf('\\n', pos);\n", "if (nextpos == -1) {\n", "return null;\n", "}\n", "pos = nextpos + 1;\n", "}\n", "\n", "// Remember this offset for the next search we do.\n", "lastOffset = pos;\n", "lastLine = lineNumber;\n", "\n", "if (js.indexOf('\\n', pos) == -1) {\n", "// If next new line cannot be found, there are two cases\n", "// 1. pos already reaches the end of file, then null should be returned\n", "// 2. otherwise, return the contents between pos and the end of file.\n", "return null;\n", "} else {\n", "return js.substring(pos, js.indexOf('\\n', pos));\n", "}\n", "}\n"], "faulty_lines": [38, 39], "cluster": 1}, {"pid": "Closure", "bid": 57, "method_path": "./dataset/Closure/57/ClosureCodingConvention.java", "method": ["private static String extractClassNameIfGoog(Node node, Node parent,\n", "String functionName){\n", "String className = null;\n", "if (NodeUtil.isExprCall(parent)) {\n", "Node callee = node.getFirstChild();\n", "if (callee != null && callee.getType() == Token.GETPROP) {\n", "String qualifiedName = callee.getQualifiedName();\n", "if (functionName.equals(qualifiedName)) {\n", "Node target = callee.getNext();\n", "if (target != null) {\n", "className = target.getString();\n", "}\n", "}\n", "}\n", "}\n", "return className;\n", "}\n"], "faulty_lines": [10], "cluster": 2}, {"pid": "Closure", "bid": 58, "method_path": "./dataset/Closure/58/LiveVariablesAnalysis.java", "method": ["boolean conditional) {\n", "\n", "switch (n.getType()) {\n", "case Token.SCRIPT:\n", "case Token.BLOCK:\n", "case Token.FUNCTION:\n", "return;\n", "\n", "case Token.WHILE:\n", "case Token.DO:\n", "case Token.IF:\n", "computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n", "conditional);\n", "return;\n", "\n", "case Token.FOR:\n", "if (!NodeUtil.isForIn(n)) {\n", "computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n", "conditional);\n", "} else {\n", "// for(x in y) {...}\n", "Node lhs = n.getFirstChild();\n", "Node rhs = lhs.getNext();\n", "if (NodeUtil.isVar(lhs)) {\n", "// for(var x in y) {...}\n", "lhs = lhs.getLastChild();\n", "}\n", "addToSetIfLocal(lhs, kill);\n", "addToSetIfLocal(lhs, gen);\n", "computeGenKill(rhs, gen, kill, conditional);\n", "}\n", "return;\n", "\n", "case Token.VAR:\n", "for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n", "if (c.hasChildren()) {\n", "computeGenKill(c.getFirstChild(), gen, kill, conditional);\n", "if (!conditional) {\n", "addToSetIfLocal(c, kill);\n", "}\n", "}\n", "}\n", "return;\n", "\n", "case Token.AND:\n", "case Token.OR:\n", "computeGenKill(n.getFirstChild(), gen, kill, conditional);\n", "// May short circuit.\n", "computeGenKill(n.getLastChild(), gen, kill, true);\n", "return;\n", "\n", "case Token.HOOK:\n", "computeGenKill(n.getFirstChild(), gen, kill, conditional);\n", "// Assume both sides are conditional.\n", "computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n", "computeGenKill(n.getLastChild(), gen, kill, true);\n", "return;\n", "\n", "case Token.NAME:\n", "if (isArgumentsName(n)) {\n", "markAllParametersEscaped();\n", "} else {\n", "addToSetIfLocal(n, gen);\n", "}\n", "return;\n", "\n", "default:\n", "if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n", "Node lhs = n.getFirstChild();\n", "if (!conditional) {\n", "addToSetIfLocal(lhs, kill);\n", "}\n", "if (!NodeUtil.isAssign(n)) {\n", "// assignments such as a += 1 reads a.\n", "addToSetIfLocal(lhs, gen);\n", "}\n", "computeGenKill(lhs.getNext(), gen, kill, conditional);\n", "} else {\n", "for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n", "computeGenKill(c, gen, kill, conditional);\n", "}\n", "}\n", "return;\n", "}\n", "}\n"], "faulty_lines": [28, 30], "cluster": 7}, {"pid": "Closure", "bid": 59, "method_path": "./dataset/Closure/59/Compiler.java", "method": ["public void initOptions(CompilerOptions options) {\n", "this.options = options;\n", "if (errorManager == null) {\n", "if (outStream == null) {\n", "setErrorManager(\n", "new LoggerErrorManager(createMessageFormatter(), logger));\n", "} else {\n", "PrintStreamErrorManager printer =\n", "new PrintStreamErrorManager(createMessageFormatter(), outStream);\n", "printer.setSummaryDetailLevel(options.summaryDetailLevel);\n", "setErrorManager(printer);\n", "}\n", "}\n", "\n", "// DiagnosticGroups override the plain checkTypes option.\n", "if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n", "options.checkTypes = true;\n", "} else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n", "options.checkTypes = false;\n", "} else if (!options.checkTypes) {\n", "// If DiagnosticGroups did not override the plain checkTypes\n", "// option, and checkTypes is enabled, then turn off the\n", "// parser type warnings.\n", "options.setWarningLevel(\n", "DiagnosticGroup.forType(\n", "RhinoErrorReporter.TYPE_PARSE_ERROR),\n", "CheckLevel.OFF);\n", "}\n", "\n", "if (options.checkGlobalThisLevel.isOn()) {\n", "options.setWarningLevel(\n", "DiagnosticGroups.GLOBAL_THIS,\n", "options.checkGlobalThisLevel);\n", "}\n", "\n", "if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n", "options.setWarningLevel(\n", "DiagnosticGroups.ES5_STRICT,\n", "CheckLevel.ERROR);\n", "}\n", "\n", "// Initialize the warnings guard.\n", "List<WarningsGuard> guards = Lists.newArrayList();\n", "guards.add(\n", "new SuppressDocWarningsGuard(\n", "getDiagnosticGroups().getRegisteredGroups()));\n", "guards.add(options.getWarningsGuard());\n", "\n", "ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n", "\n", "// All passes must run the variable check. This synthesizes\n", "// variables later so that the compiler doesn't crash. It also\n", "// checks the externs file for validity. If you don't want to warn\n", "// about missing variable declarations, we shut that specific\n", "// error off.\n", "if (!options.checkSymbols &&\n", "!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n", "composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n", "DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n", "}\n", "\n", "this.warningsGuard = composedGuards;\n", "}\n"], "faulty_lines": [30], "cluster": 7}, {"pid": "Closure", "bid": 62, "method_path": "./dataset/Closure/62/LightweightMessageFormatter.java", "method": ["private String format(JSError error, boolean warning) {\n", "// extract source excerpt\n", "SourceExcerptProvider source = getSource();\n", "String sourceExcerpt = source == null ? null :\n", "excerpt.get(\n", "source, error.sourceName, error.lineNumber, excerptFormatter);\n", "\n", "// formatting the message\n", "StringBuilder b = new StringBuilder();\n", "if (error.sourceName != null) {\n", "b.append(error.sourceName);\n", "if (error.lineNumber > 0) {\n", "b.append(':');\n", "b.append(error.lineNumber);\n", "}\n", "b.append(\": \");\n", "}\n", "\n", "b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n", "b.append(\" - \");\n", "\n", "b.append(error.description);\n", "b.append('\\n');\n", "if (sourceExcerpt != null) {\n", "b.append(sourceExcerpt);\n", "b.append('\\n');\n", "int charno = error.getCharno();\n", "\n", "// padding equal to the excerpt and arrow at the end\n", "// charno == sourceExpert.length() means something is missing\n", "// at the end of the line\n", "if (excerpt.equals(LINE)\n", "&& 0 <= charno && charno < sourceExcerpt.length()) {\n", "for (int i = 0; i < charno; i++) {\n", "char c = sourceExcerpt.charAt(i);\n", "if (Character.isWhitespace(c)) {\n", "b.append(c);\n", "} else {\n", "b.append(' ');\n", "}\n", "}\n", "b.append(\"^\\n\");\n", "}\n", "}\n", "return b.toString();\n", "}\n"], "faulty_lines": [33], "cluster": 5}, {"pid": "Closure", "bid": 64, "method_path": "./dataset/Closure/64/Compiler.java", "method": ["public Void call() throws Exception {\n", "if (options.printInputDelimiter) {\n", "if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n", "cb.append(\"\\n\");  // Make sure that the label starts on a new line\n", "}\n", "Preconditions.checkState(root.getType() == Token.SCRIPT);\n", "\n", "String delimiter = options.inputDelimiter;\n", "\n", "String sourceName = (String)root.getProp(Node.SOURCENAME_PROP);\n", "Preconditions.checkState(sourceName != null);\n", "Preconditions.checkState(!sourceName.isEmpty());\n", "\n", "delimiter = delimiter.replaceAll(\"%name%\", sourceName)\n", ".replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n", "\n", "cb.append(delimiter)\n", ".append(\"\\n\");\n", "}\n", "if (root.getJSDocInfo() != null &&\n", "root.getJSDocInfo().getLicense() != null) {\n", "cb.append(\"/*\\n\")\n", ".append(root.getJSDocInfo().getLicense())\n", ".append(\"*/\\n\");\n", "}\n", "\n", "// If there is a valid source map, then indicate to it that the current\n", "// root node's mappings are offset by the given string builder buffer.\n", "if (options.sourceMapOutputPath != null) {\n", "sourceMap.setStartingPosition(\n", "cb.getLineIndex(), cb.getColumnIndex());\n", "}\n", "\n", "// if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n", "// for the first input file\n", "String code = toSource(root, sourceMap);\n", "if (!code.isEmpty()) {\n", "cb.append(code);\n", "\n", "// In order to avoid parse ambiguity when files are concatenated\n", "// together, all files should end in a semi-colon. Do a quick\n", "// heuristic check if there's an obvious semi-colon already there.\n", "int length = code.length();\n", "char lastChar = code.charAt(length - 1);\n", "char secondLastChar = length >= 2 ?\n", "code.charAt(length - 2) : '\\0';\n", "boolean hasSemiColon = lastChar == ';' ||\n", "(lastChar == '\\n' && secondLastChar == ';');\n", "if (!hasSemiColon) {\n", "cb.append(\";\");\n", "}\n", "}\n", "return null;\n", "}\n"], "faulty_lines": [36], "cluster": 7}, {"pid": "Closure", "bid": 67, "method_path": "./dataset/Closure/67/AnalyzePrototypeProperties.java", "method": ["private boolean isPrototypePropertyAssign(Node assign) {\n", "Node n = assign.getFirstChild();\n", "if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n", "&& n.getType() == Token.GETPROP\n", ") {\n", "// We want to exclude the assignment itself from the usage list\n", "boolean isChainedProperty =\n", "n.getFirstChild().getType() == Token.GETPROP;\n", "\n", "if (isChainedProperty) {\n", "Node child = n.getFirstChild().getFirstChild().getNext();\n", "\n", "if (child.getType() == Token.STRING &&\n", "child.getString().equals(\"prototype\")) {\n", "return true;\n", "}\n", "}\n", "}\n", "\n", "return false;\n", "}\n"], "faulty_lines": [5], "cluster": 2}, {"pid": "Closure", "bid": 68, "method_path": "./dataset/Closure/68/JsDocInfoParser.java", "method": ["private Node parseBasicTypeExpression(JsDocToken token) {\n", "if (token == JsDocToken.STAR) {\n", "return newNode(Token.STAR);\n", "} else if (token == JsDocToken.LB) {\n", "skipEOLs();\n", "return parseArrayType(next());\n", "} else if (token == JsDocToken.LC) {\n", "skipEOLs();\n", "return parseRecordType(next());\n", "} else if (token == JsDocToken.LP) {\n", "skipEOLs();\n", "return parseUnionType(next());\n", "} else if (token == JsDocToken.STRING) {\n", "String string = stream.getString();\n", "if (\"function\".equals(string)) {\n", "skipEOLs();\n", "return parseFunctionType(next());\n", "} else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n", "return newStringNode(string);\n", "} else {\n", "return parseTypeName(token);\n", "}\n", "}\n", "\n", "return reportGenericTypeSyntaxWarning();\n", "}\n"], "faulty_lines": [25], "cluster": 8}, {"pid": "Closure", "bid": 68, "method_path": "./dataset/Closure/68/JsDocInfoParser.java", "method": ["private Node parseFunctionType(JsDocToken token) {\n", "// NOTE(nicksantos): We're not implementing generics at the moment, so\n", "// just throw out TypeParameters.\n", "if (token != JsDocToken.LP) {\n", "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n", "}\n", "\n", "Node functionType = newNode(Token.FUNCTION);\n", "Node parameters = null;\n", "skipEOLs();\n", "if (!match(JsDocToken.RP)) {\n", "token = next();\n", "\n", "boolean hasParams = true;\n", "if (token == JsDocToken.STRING) {\n", "String tokenStr = stream.getString();\n", "boolean isThis = \"this\".equals(tokenStr);\n", "boolean isNew = \"new\".equals(tokenStr);\n", "if (isThis || isNew) {\n", "if (match(JsDocToken.COLON)) {\n", "next();\n", "skipEOLs();\n", "Node contextType = wrapNode(\n", "isThis ? Token.THIS : Token.NEW,\n", "parseTypeName(next()));\n", "if (contextType == null) {\n", "return null;\n", "}\n", "\n", "functionType.addChildToFront(contextType);\n", "} else {\n", "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n", "}\n", "\n", "if (match(JsDocToken.COMMA)) {\n", "next();\n", "skipEOLs();\n", "token = next();\n", "} else {\n", "hasParams = false;\n", "}\n", "}\n", "}\n", "\n", "if (hasParams) {\n", "parameters = parseParametersType(token);\n", "if (parameters == null) {\n", "return null;\n", "}\n", "}\n", "}\n", "\n", "if (parameters != null) {\n", "functionType.addChildToBack(parameters);\n", "}\n", "\n", "skipEOLs();\n", "if (!match(JsDocToken.RP)) {\n", "return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n", "}\n", "\n", "skipEOLs();\n", "Node resultType = parseResultType(next());\n", "if (resultType == null) {\n", "return null;\n", "} else {\n", "functionType.addChildToBack(resultType);\n", "}\n", "return functionType;\n", "}\n"], "faulty_lines": [5], "cluster": 6}, {"pid": "Closure", "bid": 70, "method_path": "./dataset/Closure/70/TypedScopeCreator.java", "method": ["private void declareArguments(Node functionNode) {\n", "Node astParameters = functionNode.getFirstChild().getNext();\n", "Node body = astParameters.getNext();\n", "FunctionType functionType = (FunctionType) functionNode.getJSType();\n", "if (functionType != null) {\n", "Node jsDocParameters = functionType.getParametersNode();\n", "if (jsDocParameters != null) {\n", "Node jsDocParameter = jsDocParameters.getFirstChild();\n", "for (Node astParameter : astParameters.children()) {\n", "if (jsDocParameter != null) {\n", "defineSlot(astParameter, functionNode,\n", "jsDocParameter.getJSType(), true);\n", "jsDocParameter = jsDocParameter.getNext();\n", "} else {\n", "defineSlot(astParameter, functionNode, null, true);\n", "}\n", "}\n", "}\n", "}\n", "} // end declareArguments\n"], "faulty_lines": [12], "cluster": 2}, {"pid": "Closure", "bid": 71, "method_path": "./dataset/Closure/71/CheckAccessControls.java", "method": ["private void checkPropertyVisibility(NodeTraversal t,\n", "Node getprop, Node parent) {\n", "ObjectType objectType =\n", "ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n", "String propertyName = getprop.getLastChild().getString();\n", "\n", "if (objectType != null) {\n", "// Is this a normal property access, or are we trying to override\n", "// an existing property?\n", "boolean isOverride = t.inGlobalScope() &&\n", "parent.getType() == Token.ASSIGN &&\n", "parent.getFirstChild() == getprop;\n", "\n", "// Find the lowest property defined on a class with visibility\n", "// information.\n", "if (isOverride) {\n", "objectType = objectType.getImplicitPrototype();\n", "}\n", "JSDocInfo docInfo = null;\n", "for (; objectType != null;\n", "objectType = objectType.getImplicitPrototype()) {\n", "docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n", "if (docInfo != null &&\n", "docInfo.getVisibility() != Visibility.INHERITED) {\n", "break;\n", "}\n", "}\n", "\n", "if (objectType == null) {\n", "// We couldn't find a visibility modifier; assume it's public.\n", "return;\n", "}\n", "\n", "boolean sameInput =\n", "t.getInput().getName().equals(docInfo.getSourceName());\n", "Visibility visibility = docInfo.getVisibility();\n", "JSType ownerType = normalizeClassType(objectType);\n", "if (isOverride) {\n", "// Check an ASSIGN statement that's trying to override a property\n", "// on a superclass.\n", "JSDocInfo overridingInfo = parent.getJSDocInfo();\n", "Visibility overridingVisibility = overridingInfo == null ?\n", "Visibility.INHERITED : overridingInfo.getVisibility();\n", "\n", "// Check that (a) the property *can* be overridden, and\n", "// (b) that the visibility of the override is the same as the\n", "// visibility of the original property.\n", "if (visibility == Visibility.PRIVATE && !sameInput) {\n", "compiler.report(\n", "t.makeError(getprop, PRIVATE_OVERRIDE,\n", "objectType.toString()));\n", "} else if (overridingVisibility != Visibility.INHERITED &&\n", "overridingVisibility != visibility) {\n", "compiler.report(\n", "t.makeError(getprop, VISIBILITY_MISMATCH,\n", "visibility.name(), objectType.toString(),\n", "overridingVisibility.name()));\n", "}\n", "} else {\n", "if (sameInput) {\n", "// private access is always allowed in the same file.\n", "return;\n", "} else if (visibility == Visibility.PRIVATE &&\n", "(currentClass == null || ownerType.differsFrom(currentClass))) {\n", "if (docInfo.isConstructor() &&\n", "isValidPrivateConstructorAccess(parent)) {\n", "return;\n", "}\n", "\n", "// private access is not allowed outside the file from a different\n", "// enclosing class.\n", "compiler.report(\n", "t.makeError(getprop,\n", "BAD_PRIVATE_PROPERTY_ACCESS,\n", "propertyName,\n", "validator.getReadableJSTypeName(\n", "getprop.getFirstChild(), true)));\n", "} else if (visibility == Visibility.PROTECTED) {\n", "// There are 3 types of legal accesses of a protected property:\n", "// 1) Accesses in the same file\n", "// 2) Overriding the property in a subclass\n", "// 3) Accessing the property from inside a subclass\n", "// The first two have already been checked for.\n", "if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n", "compiler.report(\n", "t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n", "propertyName,\n", "validator.getReadableJSTypeName(\n", "getprop.getFirstChild(), true)));\n", "}\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [10], "cluster": 7}, {"pid": "Closure", "bid": 72, "method_path": "./dataset/Closure/72/FunctionToBlockMutator.java", "method": ["private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n", "Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n", "// Make variable names unique to this instance.\n", "NodeTraversal.traverse(\n", "compiler, fnNode, new MakeDeclaredNamesUnique(\n", "new InlineRenamer(\n", "idSupplier,\n", "\"inline_\",\n", "isCallInLoop)));\n", "// Make label names unique to this instance.\n", "}\n"], "faulty_lines": [11], "cluster": 4}, {"pid": "Closure", "bid": 72, "method_path": "./dataset/Closure/72/RenameLabels.java", "method": ["private void visitLabel(Node node, Node parent) {\n", "Node nameNode = node.getFirstChild();\n", "Preconditions.checkState(nameNode != null);\n", "String name = nameNode.getString();\n", "LabelInfo li = getLabelInfo(name);\n", "// This is a label...\n", "if (li.referenced) {\n", "String newName = getNameForId(li.id);\n", "if (!name.equals(newName)) {\n", "// ... and it is used, give it the short name.\n", "nameNode.setString(newName);\n", "compiler.reportCodeChange();\n", "}\n", "} else {\n", "// ... and it is not referenced, just remove it.\n", "Node newChild = node.getLastChild();\n", "node.removeChild(newChild);\n", "parent.replaceChild(node, newChild);\n", "if (newChild.getType() == Token.BLOCK) {\n", "NodeUtil.tryMergeBlock(newChild);\n", "}\n", "compiler.reportCodeChange();\n", "}\n", "\n", "// Remove the label from the current stack of labels.\n", "namespaceStack.peek().renameMap.remove(name);\n", "}\n"], "faulty_lines": [7], "cluster": 8}, {"pid": "Closure", "bid": 74, "method_path": "./dataset/Closure/74/PeepholeFoldConstants.java", "method": ["boolean undefinedRight = ((Token.NAME == right.getType()\n", "&& right.getString().equals(\"undefined\"))\n", "|| (Token.VOID == right.getType()\n", "&& NodeUtil.isLiteralValue(right.getFirstChild(), false)));\n", "int lhType = left.getType();\n", "int rhType = right.getType();\n", "switch (lhType) {\n", "case Token.VOID:\n", "if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {\n", "return n;\n", "} else if (!rightLiteral) {\n", "return n;\n", "} else {\n", "result = compareToUndefined(right, op);\n", "}\n", "break;\n", "\n", "case Token.NULL:\n", "case Token.TRUE:\n", "case Token.FALSE:\n", "if (undefinedRight) {\n", "result = compareToUndefined(left, op);\n", "break;\n", "}\n", "if (rhType != Token.TRUE &&\n", "rhType != Token.FALSE &&\n", "rhType != Token.NULL) {\n", "return n;\n", "}\n", "switch (op) {\n", "case Token.SHEQ:\n", "case Token.EQ:\n", "result = lhType == rhType;\n", "break;\n", "\n", "case Token.SHNE:\n", "case Token.NE:\n", "result = lhType != rhType;\n", "break;\n", "\n", "case Token.GE:\n", "case Token.LE:\n", "case Token.GT:\n", "case Token.LT:\n", "Boolean compareResult = compareAsNumbers(op, left, right);\n", "if (compareResult != null) {\n", "result = compareResult;\n", "} else {\n", "return n;\n", "}\n", "break;\n", "\n", "default:\n", "return n;  // we only handle == and != here\n", "}\n", "break;\n", "\n", "case Token.THIS:\n", "if (right.getType() != Token.THIS) {\n", "return n;\n", "}\n", "switch (op) {\n", "case Token.SHEQ:\n", "case Token.EQ:\n", "result = true;\n", "break;\n", "\n", "case Token.SHNE:\n", "case Token.NE:\n", "result = false;\n", "break;\n", "\n", "// We can only handle == and != here.\n", "// GT, LT, GE, LE depend on the type of \"this\" and how it will\n", "// be converted to number.  The results are different depending on\n", "// whether it is a string, NaN or other number value.\n", "default:\n", "return n;\n", "}\n", "break;\n", "\n", "case Token.STRING:\n", "if (undefinedRight) {\n", "result = compareToUndefined(left, op);\n", "break;\n", "}\n", "if (Token.STRING != right.getType()) {\n", "return n;  // Only eval if they are the same type\n", "}\n", "switch (op) {\n", "case Token.SHEQ:\n", "case Token.EQ:\n", "result = left.getString().equals(right.getString());\n", "break;\n", "\n", "case Token.SHNE:\n", "case Token.NE:\n", "result = !left.getString().equals(right.getString());\n", "break;\n", "\n", "default:\n", "return n;  // we only handle == and != here\n", "}\n", "break;\n", "\n", "case Token.NUMBER:\n", "if (undefinedRight) {\n", "result = compareToUndefined(left, op);\n", "break;\n", "}\n", "if (Token.NUMBER != right.getType()) {\n", "return n;  // Only eval if they are the same type\n", "}\n", "Boolean compareResult = compareAsNumbers(op, left, right);\n", "if (compareResult != null) {\n", "result = compareResult;\n", "} else {\n", "return null;\n", "}\n", "break;\n", "\n", "case Token.NAME:\n", "if (undefinedRight) {\n", "result = compareToUndefined(left, op);\n", "break;\n", "}\n", "\n", "if (rightLiteral) {\n", "boolean undefinedLeft = (left.getString().equals(\"undefined\"));\n", "if (undefinedLeft) {\n", "result = compareToUndefined(right, op);\n", "break;\n", "}\n", "}\n", "\n", "if (Token.NAME != right.getType()) {\n", "return n;  // Only eval if they are the same type\n", "}\n", "String ln = left.getString();\n", "String rn = right.getString();\n", "if (!ln.equals(rn)) {\n", "return n;  // Not the same value name.\n", "}\n", "\n", "switch (op) {\n", "// If we knew the named value wouldn't be NaN, it would be nice\n", "// to handle EQ,NE,LE,GE,SHEQ, and SHNE.\n", "case Token.LT:\n", "case Token.GT:\n", "result = false;\n", "break;\n", "default:\n", "return n;  // don't handle that op\n", "}\n", "break;\n", "\n", "default:\n", "// assert, this should cover all consts\n", "return n;\n", "}\n"], "faulty_lines": [5, 6], "cluster": 7}, {"pid": "Closure", "bid": 76, "method_path": "./dataset/Closure/76/DeadAssignmentsElimination.java", "method": ["private boolean isVariableStillLiveWithinExpression(\n", "Node n, Node exprRoot, String variable) {\n", "while (n != exprRoot) {\n", "VariableLiveness state = VariableLiveness.MAYBE_LIVE;\n", "switch (n.getParent().getType()) {\n", "case Token.OR:\n", "case Token.AND:\n", "// If the currently node is the first child of\n", "// AND/OR, be conservative only consider the READs\n", "// of the second operand.\n", "\n", "case Token.HOOK:\n", "// If current node is the condition, check each following\n", "// branch, otherwise it is a conditional branch and the\n", "// other branch can be ignored.\n", "\n", "default:\n", "for(Node sibling = n.getNext(); sibling != null;\n", "sibling = sibling.getNext()) {\n", "if (!ControlFlowGraph.isEnteringNewCfgNode(sibling)) {\n", "state = isVariableReadBeforeKill(sibling, variable);\n", "\n", "// If we see a READ or KILL there is no need to continue.\n", "if (state == VariableLiveness.READ) {\n", "return true;\n", "} else if (state == VariableLiveness.KILL) {\n", "return false;\n", "}\n", "}\n", "}\n", "}\n", "n = n.getParent();\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [11, 16, 20, 22, 28, 29, 30], "cluster": 8}, {"pid": "Closure", "bid": 76, "method_path": "./dataset/Closure/76/DeadAssignmentsElimination.java", "method": ["private VariableLiveness isVariableReadBeforeKill(\n", "Node n, String variable) {\n", "\n", "if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n", "if (NodeUtil.isLhs(n, n.getParent())) {\n", "Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n", "// The expression to which the assignment is made is evaluated before\n", "// the RHS is evaluated (normal left to right evaluation) but the KILL\n", "// occurs after the RHS is evaluated.\n", "Node rhs = n.getNext();\n", "VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n", "if (state == VariableLiveness.READ) {\n", "return state;\n", "}\n", "return VariableLiveness.KILL;\n", "} else {\n", "return VariableLiveness.READ;\n", "}\n", "}\n", "\n", "switch (n.getType()) {\n", "// Conditionals\n", "case Token.OR:\n", "case Token.AND:\n", "// With a AND/OR the first branch always runs, but the second is\n", "// may not.\n", "case Token.HOOK:\n", "return checkHookBranchReadBeforeKill(\n", "n.getFirstChild().getNext(), n.getLastChild(), variable);\n", "\n", "default:\n", "// Expressions are evaluated left-right, depth first.\n", "for (Node child = n.getFirstChild();\n", "child != null; child = child.getNext()) {\n", "if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n", "VariableLiveness state = isVariableReadBeforeKill(child, variable);\n", "if (state != VariableLiveness.MAYBE_LIVE) {\n", "return state;\n", "}\n", "}\n", "}\n", "}\n", "\n", "return VariableLiveness.MAYBE_LIVE;\n", "}\n"], "faulty_lines": [3], "cluster": 1}, {"pid": "Closure", "bid": 76, "method_path": "./dataset/Closure/76/DeadAssignmentsElimination.java", "method": ["private VariableLiveness isVariableReadBeforeKill(\n", "Node n, String variable) {\n", "\n", "if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n", "if (NodeUtil.isLhs(n, n.getParent())) {\n", "Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n", "// The expression to which the assignment is made is evaluated before\n", "// the RHS is evaluated (normal left to right evaluation) but the KILL\n", "// occurs after the RHS is evaluated.\n", "Node rhs = n.getNext();\n", "VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n", "if (state == VariableLiveness.READ) {\n", "return state;\n", "}\n", "return VariableLiveness.KILL;\n", "} else {\n", "return VariableLiveness.READ;\n", "}\n", "}\n", "\n", "switch (n.getType()) {\n", "// Conditionals\n", "case Token.OR:\n", "case Token.AND:\n", "// With a AND/OR the first branch always runs, but the second is\n", "// may not.\n", "case Token.HOOK:\n", "return checkHookBranchReadBeforeKill(\n", "n.getFirstChild().getNext(), n.getLastChild(), variable);\n", "\n", "default:\n", "// Expressions are evaluated left-right, depth first.\n", "for (Node child = n.getFirstChild();\n", "child != null; child = child.getNext()) {\n", "if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n", "VariableLiveness state = isVariableReadBeforeKill(child, variable);\n", "if (state != VariableLiveness.MAYBE_LIVE) {\n", "return state;\n", "}\n", "}\n", "}\n", "}\n", "\n", "return VariableLiveness.MAYBE_LIVE;\n", "}\n"], "faulty_lines": [25, 27, 28], "cluster": 1}, {"pid": "Closure", "bid": 76, "method_path": "./dataset/Closure/76/DeadAssignmentsElimination.java", "method": ["private VariableLiveness isVariableReadBeforeKill(\n", "Node n, String variable) {\n", "\n", "if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n", "if (NodeUtil.isLhs(n, n.getParent())) {\n", "Preconditions.checkState(n.getParent().getType() == Token.ASSIGN);\n", "// The expression to which the assignment is made is evaluated before\n", "// the RHS is evaluated (normal left to right evaluation) but the KILL\n", "// occurs after the RHS is evaluated.\n", "Node rhs = n.getNext();\n", "VariableLiveness state = isVariableReadBeforeKill(rhs, variable);\n", "if (state == VariableLiveness.READ) {\n", "return state;\n", "}\n", "return VariableLiveness.KILL;\n", "} else {\n", "return VariableLiveness.READ;\n", "}\n", "}\n", "\n", "switch (n.getType()) {\n", "// Conditionals\n", "case Token.OR:\n", "case Token.AND:\n", "// With a AND/OR the first branch always runs, but the second is\n", "// may not.\n", "case Token.HOOK:\n", "return checkHookBranchReadBeforeKill(\n", "n.getFirstChild().getNext(), n.getLastChild(), variable);\n", "\n", "default:\n", "// Expressions are evaluated left-right, depth first.\n", "for (Node child = n.getFirstChild();\n", "child != null; child = child.getNext()) {\n", "if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n", "VariableLiveness state = isVariableReadBeforeKill(child, variable);\n", "if (state != VariableLiveness.MAYBE_LIVE) {\n", "return state;\n", "}\n", "}\n", "}\n", "}\n", "\n", "return VariableLiveness.MAYBE_LIVE;\n", "}\n"], "faulty_lines": [35, 41], "cluster": 1}, {"pid": "Closure", "bid": 78, "method_path": "./dataset/Closure/78/PeepholeFoldConstants.java", "method": ["private Node performArithmeticOp(int opType, Node left, Node right) {\n", "// Unlike other operations, ADD operands are not always converted\n", "// to Number.\n", "if (opType == Token.ADD\n", "&& (NodeUtil.mayBeString(left, false)\n", "|| NodeUtil.mayBeString(right, false))) {\n", "return null;\n", "}\n", "\n", "double result;\n", "\n", "// TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n", "// to zero so this is a little akward here.\n", "\n", "Double lValObj = NodeUtil.getNumberValue(left);\n", "if (lValObj == null) {\n", "return null;\n", "}\n", "Double rValObj = NodeUtil.getNumberValue(right);\n", "if (rValObj == null) {\n", "return null;\n", "}\n", "\n", "double lval = lValObj;\n", "double rval = rValObj;\n", "\n", "switch (opType) {\n", "case Token.BITAND:\n", "result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n", "break;\n", "case Token.BITOR:\n", "result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n", "break;\n", "case Token.BITXOR:\n", "result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n", "break;\n", "case Token.ADD:\n", "result = lval + rval;\n", "break;\n", "case Token.SUB:\n", "result = lval - rval;\n", "break;\n", "case Token.MUL:\n", "result = lval * rval;\n", "break;\n", "case Token.MOD:\n", "if (rval == 0) {\n", "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n", "return null;\n", "}\n", "result = lval % rval;\n", "break;\n", "case Token.DIV:\n", "if (rval == 0) {\n", "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n", "return null;\n", "}\n", "result = lval / rval;\n", "break;\n", "default:\n", "throw new Error(\"Unexpected arithmetic operator\");\n", "}\n", "\n", "// TODO(johnlenz): consider removing the result length check.\n", "// length of the left and right value plus 1 byte for the operator.\n", "if (String.valueOf(result).length() <=\n", "String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n", "\n", "// Do not try to fold arithmetic for numbers > 2^53. After that\n", "// point, fixed-point math starts to break down and become inaccurate.\n", "Math.abs(result) <= MAX_FOLD_NUMBER) {\n", "Node newNumber = Node.newNumber(result);\n", "return newNumber;\n", "} else if (Double.isNaN(result)) {\n", "return Node.newString(Token.NAME, \"NaN\");\n", "} else if (result == Double.POSITIVE_INFINITY) {\n", "return Node.newString(Token.NAME, \"Infinity\");\n", "} else if (result == Double.NEGATIVE_INFINITY) {\n", "return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n", "}\n", "\n", "return null;\n", "}\n"], "faulty_lines": [48, 55], "cluster": 3}, {"pid": "Closure", "bid": 79, "method_path": "./dataset/Closure/79/Normalize.java", "method": ["public void process(Node externs, Node root) {\n", "new NodeTraversal(\n", "compiler, new NormalizeStatements(compiler, assertOnChange))\n", ".traverse(root);\n", "if (MAKE_LOCAL_NAMES_UNIQUE) {\n", "MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n", "NodeTraversal t = new NodeTraversal(compiler, renamer);\n", "t.traverseRoots(externs, root);\n", "}\n", "// It is important that removeDuplicateDeclarations runs after\n", "// MakeDeclaredNamesUnique in order for catch block exception names to be\n", "// handled properly. Specifically, catch block exception names are\n", "// only valid within the catch block, but our currect Scope logic\n", "// has no concept of this and includes it in the containing function\n", "// (or global scope). MakeDeclaredNamesUnique makes the catch exception\n", "// names unique so that removeDuplicateDeclarations() will properly handle\n", "// cases where a function scope variable conflict with a exception name:\n", "//   function f() {\n", "//      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n", "//      var e = 1; // f scope 'e'\n", "//   }\n", "// otherwise 'var e = 1' would be rewritten as 'e = 1'.\n", "// TODO(johnlenz): Introduce a seperate scope for catch nodes.\n", "removeDuplicateDeclarations(externs, root);\n", "new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)\n", ".process(externs, root);\n", "\n", "if (!compiler.getLifeCycleStage().isNormalized()) {\n", "compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n", "}\n", "}\n"], "faulty_lines": [4], "cluster": 1}, {"pid": "Closure", "bid": 79, "method_path": "./dataset/Closure/79/VarCheck.java", "method": ["private void createSynthesizedExternVar(String varName) {\n", "Node nameNode = Node.newString(Token.NAME, varName);\n", "\n", "// Mark the variable as constant if it matches the coding convention\n", "// for constant vars.\n", "// NOTE(nicksantos): honestly, i'm not sure how much this matters.\n", "// AFAIK, all people who use the CONST coding convention also\n", "// compile with undeclaredVars as errors. We have some test\n", "// cases for this configuration though, and it makes them happier.\n", "if (compiler.getCodingConvention().isConstant(varName)) {\n", "nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n", "}\n", "\n", "getSynthesizedExternsRoot().addChildToBack(\n", "new Node(Token.VAR, nameNode));\n", "varsToDeclareInExterns.remove(varName);\n", "}\n"], "faulty_lines": [17], "cluster": 2}, {"pid": "Closure", "bid": 82, "method_path": "./dataset/Closure/82/JSType.java", "method": ["public final boolean isEmptyType() {\n", "return isNoType() || isNoObjectType() || isNoResolvedType();\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Closure", "bid": 83, "method_path": "./dataset/Closure/83/CommandLineRunner.java", "method": ["public int parseArguments(Parameters params) throws CmdLineException {\n", "String param = params.getParameter(0);\n", "\n", "if (param == null) {\n", "setter.addValue(true);\n", "return 0;\n", "} else {\n", "String lowerParam = param.toLowerCase();\n", "if (TRUES.contains(lowerParam)) {\n", "setter.addValue(true);\n", "} else if (FALSES.contains(lowerParam)) {\n", "setter.addValue(false);\n", "} else {\n", "setter.addValue(true);\n", "return 0;\n", "}\n", "return 1;\n", "}\n", "}\n"], "faulty_lines": [2], "cluster": 2}, {"pid": "Closure", "bid": 85, "method_path": "./dataset/Closure/85/UnreachableCodeElimination.java", "method": ["private Node tryRemoveUnconditionalBranching(Node n) {\n", "/*\n", "* For each of the unconditional branching control flow node, check to see\n", "* if the ControlFlowAnalysis.computeFollowNode of that node is same as\n", "* the branching target. If it is, the branch node is safe to be removed.\n", "*\n", "* This is not as clever as MinimizeExitPoints because it doesn't do any\n", "* if-else conversion but it handles more complicated switch statements\n", "* much nicer.\n", "*/\n", "\n", "// If n is null the target is the end of the function, nothing to do.\n", "if (n == null) {\n", "return n;\n", "}\n", "\n", "DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\n", "\n", "if (gNode == null) {\n", "return n;\n", "}\n", "\n", "if (n.getParent() == null) {\n", "List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n", "if (outEdges.size() == 1) {\n", "return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n", "}\n", "}\n", "switch (n.getType()) {\n", "case Token.BLOCK:\n", "if (n.hasChildren()) {\n", "Node first = n.getFirstChild();\n", "return tryRemoveUnconditionalBranching(first);\n", "} else {\n", "return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));\n", "}\n", "case Token.RETURN:\n", "if (n.hasChildren()) {\n", "break;\n", "}\n", "case Token.BREAK:\n", "case Token.CONTINUE:\n", "\n", "// We are looking for a control flow changing statement that always\n", "// branches to the same node. If removing it the control flow still\n", "// branches to that same node. It is safe to remove it.\n", "List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n", "if (outEdges.size() == 1 &&\n", "// If there is a next node, there is no chance this jump is useless.\n", "(n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n", "\n", "Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n", "Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));\n", "Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n", "if (nextCfgNode == fallThrough) {\n", "removeDeadExprStatementSafely(n);\n", "return fallThrough;\n", "}\n", "}\n", "}\n", "return n;\n", "}\n"], "faulty_lines": [23, 24, 25, 26, 27, 28, 30, 31, 32, 33, 34, 35, 36], "cluster": 7}, {"pid": "Closure", "bid": 85, "method_path": "./dataset/Closure/85/UnreachableCodeElimination.java", "method": ["private Node tryRemoveUnconditionalBranching(Node n) {\n", "/*\n", "* For each of the unconditional branching control flow node, check to see\n", "* if the ControlFlowAnalysis.computeFollowNode of that node is same as\n", "* the branching target. If it is, the branch node is safe to be removed.\n", "*\n", "* This is not as clever as MinimizeExitPoints because it doesn't do any\n", "* if-else conversion but it handles more complicated switch statements\n", "* much nicer.\n", "*/\n", "\n", "// If n is null the target is the end of the function, nothing to do.\n", "if (n == null) {\n", "return n;\n", "}\n", "\n", "DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\n", "\n", "if (gNode == null) {\n", "return n;\n", "}\n", "\n", "if (n.getParent() == null) {\n", "List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n", "if (outEdges.size() == 1) {\n", "return tryRemoveUnconditionalBranching(outEdges.get(0).getDestination().getValue());\n", "}\n", "}\n", "switch (n.getType()) {\n", "case Token.BLOCK:\n", "if (n.hasChildren()) {\n", "Node first = n.getFirstChild();\n", "return tryRemoveUnconditionalBranching(first);\n", "} else {\n", "return tryRemoveUnconditionalBranching(ControlFlowAnalysis.computeFollowNode(n));\n", "}\n", "case Token.RETURN:\n", "if (n.hasChildren()) {\n", "break;\n", "}\n", "case Token.BREAK:\n", "case Token.CONTINUE:\n", "\n", "// We are looking for a control flow changing statement that always\n", "// branches to the same node. If removing it the control flow still\n", "// branches to that same node. It is safe to remove it.\n", "List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n", "if (outEdges.size() == 1 &&\n", "// If there is a next node, there is no chance this jump is useless.\n", "(n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n", "\n", "Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n", "Node fallThrough = tryRemoveUnconditionalBranching(computeFollowing(n));\n", "Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n", "if (nextCfgNode == fallThrough) {\n", "removeDeadExprStatementSafely(n);\n", "return fallThrough;\n", "}\n", "}\n", "}\n", "return n;\n", "}\n"], "faulty_lines": [53], "cluster": 7}, {"pid": "Closure", "bid": 85, "method_path": "./dataset/Closure/85/UnreachableCodeElimination.java", "method": ["private Node computeFollowing(Node n) {\n", "Node next = ControlFlowAnalysis.computeFollowNode(n);\n", "return next;\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Closure", "bid": 87, "method_path": "./dataset/Closure/87/PeepholeSubstituteAlternateSyntax.java", "method": ["private boolean isFoldableExpressBlock(Node n) {\n", "if (n.getType() == Token.BLOCK) {\n", "if (n.hasOneChild()) {\n", "Node maybeExpr = n.getFirstChild();\n", "// IE has a bug where event handlers behave differently when\n", "// their return value is used vs. when their return value is in\n", "// an EXPR_RESULT. It's pretty freaking weird. See:\n", "// http://code.google.com/p/closure-compiler/issues/detail?id=291\n", "// We try to detect this case, and not fold EXPR_RESULTs\n", "// into other expressions.\n", "\n", "// We only have to worry about methods with an implicit 'this'\n", "// param, or this doesn't happen.\n", "\n", "return NodeUtil.isExpressionNode(maybeExpr);\n", "}\n", "}\n", "\n", "return false;\n", "}\n"], "faulty_lines": [5, 11, 14, 15], "cluster": 2}, {"pid": "Closure", "bid": 88, "method_path": "./dataset/Closure/88/DeadAssignmentsElimination.java", "method": ["private VariableLiveness isVariableReadBeforeKill(\n", "Node n, String variable) {\n", "if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n", "if (NodeUtil.isLhs(n, n.getParent())) {\n", "// The expression to which the assignment is made is evaluated before\n", "// the RHS is evaluated (normal left to right evaluation) but the KILL\n", "// occurs after the RHS is evaluated.\n", "return VariableLiveness.KILL;\n", "} else {\n", "return VariableLiveness.READ;\n", "}\n", "}\n", "\n", "// Expressions are evaluated left-right, depth first.\n", "for (Node child = n.getFirstChild();\n", "child != null; child = child.getNext()) {\n", "if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n", "VariableLiveness state = isVariableReadBeforeKill(child, variable);\n", "if (state != VariableLiveness.MAYBE_LIVE) {\n", "return state;\n", "}\n", "}\n", "}\n", "return VariableLiveness.MAYBE_LIVE;\n", "}\n"], "faulty_lines": [5, 8], "cluster": 8}, {"pid": "Closure", "bid": 89, "method_path": "./dataset/Closure/89/CollapseProperties.java", "method": ["private void updateSimpleDeclaration(String alias, Name refName, Ref ref) {\n", "Node rvalue = ref.node.getNext();\n", "Node parent = ref.node.getParent();\n", "Node gramps = parent.getParent();\n", "Node greatGramps = gramps.getParent();\n", "Node greatGreatGramps = greatGramps.getParent();\n", "\n", "\n", "// Create the new alias node.\n", "Node nameNode = NodeUtil.newName(\n", "compiler.getCodingConvention(), alias, gramps.getFirstChild(),\n", "refName.fullName());\n", "NodeUtil.copyNameAnnotations(ref.node.getLastChild(), nameNode);\n", "\n", "if (gramps.getType() == Token.EXPR_RESULT) {\n", "// BEFORE: a.b.c = ...;\n", "//   exprstmt\n", "//     assign\n", "//       getprop\n", "//         getprop\n", "//           name a\n", "//           string b\n", "//         string c\n", "//       NODE\n", "// AFTER: var a$b$c = ...;\n", "//   var\n", "//     name a$b$c\n", "//       NODE\n", "\n", "// Remove the rvalue (NODE).\n", "parent.removeChild(rvalue);\n", "nameNode.addChildToFront(rvalue);\n", "\n", "Node varNode = new Node(Token.VAR, nameNode);\n", "greatGramps.replaceChild(gramps, varNode);\n", "} else {\n", "// This must be a complex assignment.\n", "Preconditions.checkNotNull(ref.getTwin());\n", "\n", "// BEFORE:\n", "// ... (x.y = 3);\n", "//\n", "// AFTER:\n", "// var x$y;\n", "// ... (x$y = 3);\n", "\n", "Node current = gramps;\n", "Node currentParent = gramps.getParent();\n", "for (; currentParent.getType() != Token.SCRIPT &&\n", "currentParent.getType() != Token.BLOCK;\n", "current = currentParent,\n", "currentParent = currentParent.getParent()) {}\n", "\n", "// Create a stub variable declaration right\n", "// before the current statement.\n", "Node stubVar = new Node(Token.VAR, nameNode.cloneTree())\n", ".copyInformationFrom(nameNode);\n", "currentParent.addChildBefore(stubVar, current);\n", "\n", "parent.replaceChild(ref.node, nameNode);\n", "}\n", "\n", "compiler.reportCodeChange();\n", "}\n"], "faulty_lines": [8], "cluster": 7}, {"pid": "Closure", "bid": 89, "method_path": "./dataset/Closure/89/GlobalNamespace.java", "method": ["boolean canCollapseUnannotatedChildNames() {\n", "if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n", "return false;\n", "}\n", "\n", "// Don't try to collapse if the one global set is a twin reference.\n", "// We could theoretically handle this case in CollapseProperties, but\n", "// it's probably not worth the effort.\n", "Preconditions.checkNotNull(declaration);\n", "if (declaration.getTwin() != null) {\n", "return false;\n", "}\n", "\n", "if (isClassOrEnum) {\n", "return true;\n", "}\n", "\n", "// If this is a key of an aliased object literal, then it will be aliased\n", "// later. So we won't be able to collapse its properties.\n", "if (parent != null && parent.shouldKeepKeys()) {\n", "return false;\n", "}\n", "\n", "// If this is aliased, then its properties can't be collapsed either.\n", "if (type != Type.FUNCTION && aliasingGets > 0) {\n", "return false;\n", "}\n", "\n", "return (parent == null || parent.canCollapseUnannotatedChildNames());\n", "}\n"], "faulty_lines": [25], "cluster": 8}, {"pid": "Closure", "bid": 90, "method_path": "./dataset/Closure/90/FunctionTypeBuilder.java", "method": ["public boolean apply(JSType type) {\n", "// TODO(user): Doing an instanceof check here is too\n", "// restrictive as (Date,Error) is, for instance, an object type\n", "// even though its implementation is a UnionType. Would need to\n", "// create interfaces JSType, ObjectType, FunctionType etc and have\n", "// separate implementation instead of the class hierarchy, so that\n", "// union types can also be object types, etc.\n", "if (!type.isSubtype(\n", "typeRegistry.getNativeType(OBJECT_TYPE))) {\n", "reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n", "return false;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [8], "cluster": 2}, {"pid": "Closure", "bid": 91, "method_path": "./dataset/Closure/91/CheckGlobalThis.java", "method": ["public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n", "\n", "if (n.getType() == Token.FUNCTION) {\n", "// Don't traverse functions that are constructors or have the @this\n", "// or @override annotation.\n", "JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n", "if (jsDoc != null &&\n", "(jsDoc.isConstructor() ||\n", "jsDoc.isInterface() ||\n", "jsDoc.hasThisType() ||\n", "jsDoc.isOverride())) {\n", "return false;\n", "}\n", "\n", "// Don't traverse functions unless they would normally\n", "// be able to have a @this annotation associated with them. e.g.,\n", "// var a = function() { }; // or\n", "// function a() {} // or\n", "// a.x = function() {}; // or\n", "// var a = {x: function() {}};\n", "int pType = parent.getType();\n", "if (!(pType == Token.BLOCK ||\n", "pType == Token.SCRIPT ||\n", "pType == Token.NAME ||\n", "pType == Token.ASSIGN ||\n", "\n", "// object literal keys\n", "pType == Token.STRING ||\n", "pType == Token.NUMBER)) {\n", "return false;\n", "}\n", "\n", "// Don't traverse functions that are getting lent to a prototype.\n", "}\n", "\n", "if (parent != null && parent.getType() == Token.ASSIGN) {\n", "Node lhs = parent.getFirstChild();\n", "Node rhs = lhs.getNext();\n", "\n", "if (n == lhs) {\n", "// Always traverse the left side of the assignment. To handle\n", "// nested assignments properly (e.g., (a = this).property = c;),\n", "// assignLhsChild should not be overridden.\n", "if (assignLhsChild == null) {\n", "assignLhsChild = lhs;\n", "}\n", "} else {\n", "// Only traverse the right side if it's not an assignment to a prototype\n", "// property or subproperty.\n", "if (NodeUtil.isGet(lhs)) {\n", "if (lhs.getType() == Token.GETPROP &&\n", "lhs.getLastChild().getString().equals(\"prototype\")) {\n", "return false;\n", "}\n", "Node llhs = lhs.getFirstChild();\n", "if (llhs.getType() == Token.GETPROP &&\n", "llhs.getLastChild().getString().equals(\"prototype\")) {\n", "return false;\n", "}\n", "}\n", "}\n", "}\n", "\n", "return true;\n", "}\n"], "faulty_lines": [34], "cluster": 7}, {"pid": "Closure", "bid": 92, "method_path": "./dataset/Closure/92/ProcessClosurePrimitives.java", "method": ["void replace() {\n", "if (firstNode == null) {\n", "// Don't touch the base case ('goog').\n", "replacementNode = candidateDefinition;\n", "return;\n", "}\n", "\n", "// Handle the case where there is a duplicate definition for an explicitly\n", "// provided symbol.\n", "if (candidateDefinition != null && explicitNode != null) {\n", "explicitNode.detachFromParent();\n", "compiler.reportCodeChange();\n", "\n", "// Does this need a VAR keyword?\n", "replacementNode = candidateDefinition;\n", "if (NodeUtil.isExpressionNode(candidateDefinition)) {\n", "candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n", "Node assignNode = candidateDefinition.getFirstChild();\n", "Node nameNode = assignNode.getFirstChild();\n", "if (nameNode.getType() == Token.NAME) {\n", "// Need to convert this assign to a var declaration.\n", "Node valueNode = nameNode.getNext();\n", "assignNode.removeChild(nameNode);\n", "assignNode.removeChild(valueNode);\n", "nameNode.addChildToFront(valueNode);\n", "Node varNode = new Node(Token.VAR, nameNode);\n", "varNode.copyInformationFrom(candidateDefinition);\n", "candidateDefinition.getParent().replaceChild(\n", "candidateDefinition, varNode);\n", "nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n", "compiler.reportCodeChange();\n", "replacementNode = varNode;\n", "}\n", "}\n", "} else {\n", "// Handle the case where there's not a duplicate definition.\n", "replacementNode = createDeclarationNode();\n", "if (firstModule == minimumModule) {\n", "firstNode.getParent().addChildBefore(replacementNode, firstNode);\n", "} else {\n", "// In this case, the name was implicitly provided by two independent\n", "// modules. We need to move this code up to a common module.\n", "int indexOfDot = namespace.indexOf('.');\n", "if (indexOfDot == -1) {\n", "// Any old place is fine.\n", "compiler.getNodeForCodeInsertion(minimumModule)\n", ".addChildToBack(replacementNode);\n", "} else {\n", "// Add it after the parent namespace.\n", "ProvidedName parentName =\n", "providedNames.get(namespace.substring(0, indexOfDot));\n", "Preconditions.checkNotNull(parentName);\n", "Preconditions.checkNotNull(parentName.replacementNode);\n", "parentName.replacementNode.getParent().addChildAfter(\n", "replacementNode, parentName.replacementNode);\n", "}\n", "}\n", "if (explicitNode != null) {\n", "explicitNode.detachFromParent();\n", "}\n", "compiler.reportCodeChange();\n", "}\n", "}\n"], "faulty_lines": [43], "cluster": 7}, {"pid": "Closure", "bid": 96, "method_path": "./dataset/Closure/96/TypeCheck.java", "method": ["private void visitParameterList(NodeTraversal t, Node call,\n", "FunctionType functionType) {\n", "Iterator<Node> arguments = call.children().iterator();\n", "arguments.next(); // skip the function name\n", "\n", "Iterator<Node> parameters = functionType.getParameters().iterator();\n", "int ordinal = 0;\n", "Node parameter = null;\n", "Node argument = null;\n", "while (arguments.hasNext() &&\n", "parameters.hasNext()) {\n", "// If there are no parameters left in the list, then the while loop\n", "// above implies that this must be a var_args function.\n", "parameter = parameters.next();\n", "argument = arguments.next();\n", "ordinal++;\n", "\n", "validator.expectArgumentMatchesParameter(t, argument,\n", "getJSType(argument), getJSType(parameter), call, ordinal);\n", "}\n", "\n", "int numArgs = call.getChildCount() - 1;\n", "int minArgs = functionType.getMinArguments();\n", "int maxArgs = functionType.getMaxArguments();\n", "if (minArgs > numArgs || maxArgs < numArgs) {\n", "report(t, call, WRONG_ARGUMENT_COUNT,\n", "validator.getReadableJSTypeName(call.getFirstChild(), false),\n", "String.valueOf(numArgs), String.valueOf(minArgs),\n", "maxArgs != Integer.MAX_VALUE ?\n", "\" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n", "}\n", "}\n"], "faulty_lines": [11, 14, 15], "cluster": 1}, {"pid": "Closure", "bid": 97, "method_path": "./dataset/Closure/97/PeepholeFoldConstants.java", "method": ["private Node tryFoldShift(Node n, Node left, Node right) {\n", "if (left.getType() == Token.NUMBER &&\n", "right.getType() == Token.NUMBER) {\n", "\n", "double result;\n", "double lval = left.getDouble();\n", "double rval = right.getDouble();\n", "\n", "// check ranges.  We do not do anything that would clip the double to\n", "// a 32-bit range, since the user likely does not intend that.\n", "if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n", "error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n", "return n;\n", "}\n", "\n", "// only the lower 5 bits are used when shifting, so don't do anything\n", "// if the shift amount is outside [0,32)\n", "if (!(rval >= 0 && rval < 32)) {\n", "error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n", "return n;\n", "}\n", "\n", "// Convert the numbers to ints\n", "int lvalInt = (int) lval;\n", "if (lvalInt != lval) {\n", "error(FRACTIONAL_BITWISE_OPERAND, left);\n", "return n;\n", "}\n", "\n", "int rvalInt = (int) rval;\n", "if (rvalInt != rval) {\n", "error(FRACTIONAL_BITWISE_OPERAND, right);\n", "return n;\n", "}\n", "\n", "switch (n.getType()) {\n", "case Token.LSH:\n", "result = lvalInt << rvalInt;\n", "break;\n", "case Token.RSH:\n", "result = lvalInt >> rvalInt;\n", "break;\n", "case Token.URSH:\n", "// JavaScript handles zero shifts on signed numbers differently than\n", "// Java as an Java int can not represent the unsigned 32-bit number\n", "// where JavaScript can so use a long here.\n", "result = lvalInt >>> rvalInt;\n", "break;\n", "default:\n", "throw new AssertionError(\"Unknown shift operator: \" +\n", "Node.tokenToName(n.getType()));\n", "}\n", "\n", "Node newNumber = Node.newNumber(result);\n", "n.getParent().replaceChild(n, newNumber);\n", "reportCodeChange();\n", "\n", "return newNumber;\n", "}\n", "\n", "return n;\n", "}\n"], "faulty_lines": [47], "cluster": 3}, {"pid": "Closure", "bid": 98, "method_path": "./dataset/Closure/98/ReferenceCollectingCallback.java", "method": ["boolean isAssignedOnceInLifetime() {\n", "Reference ref = getOneAndOnlyAssignment();\n", "if (ref == null) {\n", "return false;\n", "}\n", "\n", "// Make sure this assignment is not in a loop.\n", "\n", "return true;\n", "}\n"], "faulty_lines": [8], "cluster": 0}, {"pid": "Closure", "bid": 99, "method_path": "./dataset/Closure/99/CheckGlobalThis.java", "method": ["public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n", "\n", "if (n.getType() == Token.FUNCTION) {\n", "// Don't traverse functions that are constructors or have the @this\n", "// or @override annotation.\n", "JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n", "if (jsDoc != null &&\n", "(jsDoc.isConstructor() ||\n", "jsDoc.hasThisType() ||\n", "jsDoc.isOverride())) {\n", "return false;\n", "}\n", "\n", "// Don't traverse functions unless they would normally\n", "// be able to have a @this annotation associated with them. e.g.,\n", "// var a = function() { }; // or\n", "// function a() {} // or\n", "// a.x = function() {};\n", "int pType = parent.getType();\n", "if (!(pType == Token.BLOCK ||\n", "pType == Token.SCRIPT ||\n", "pType == Token.NAME ||\n", "pType == Token.ASSIGN)) {\n", "return false;\n", "}\n", "}\n", "\n", "if (parent != null && parent.getType() == Token.ASSIGN) {\n", "Node lhs = parent.getFirstChild();\n", "Node rhs = lhs.getNext();\n", "\n", "if (n == lhs) {\n", "// Always traverse the left side of the assignment. To handle\n", "// nested assignments properly (e.g., (a = this).property = c;),\n", "// assignLhsChild should not be overridden.\n", "if (assignLhsChild == null) {\n", "assignLhsChild = lhs;\n", "}\n", "} else {\n", "// Only traverse the right side if it's not an assignment to a prototype\n", "// property or subproperty.\n", "if (lhs.getType() == Token.GETPROP &&\n", "lhs.getLastChild().getString().equals(\"prototype\")) {\n", "return false;\n", "}\n", "if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n", "return false;\n", "}\n", "}\n", "}\n", "\n", "return true;\n", "}\n"], "faulty_lines": [9], "cluster": 7}, {"pid": "Closure", "bid": 99, "method_path": "./dataset/Closure/99/CheckGlobalThis.java", "method": ["public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n", "\n", "if (n.getType() == Token.FUNCTION) {\n", "// Don't traverse functions that are constructors or have the @this\n", "// or @override annotation.\n", "JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n", "if (jsDoc != null &&\n", "(jsDoc.isConstructor() ||\n", "jsDoc.hasThisType() ||\n", "jsDoc.isOverride())) {\n", "return false;\n", "}\n", "\n", "// Don't traverse functions unless they would normally\n", "// be able to have a @this annotation associated with them. e.g.,\n", "// var a = function() { }; // or\n", "// function a() {} // or\n", "// a.x = function() {};\n", "int pType = parent.getType();\n", "if (!(pType == Token.BLOCK ||\n", "pType == Token.SCRIPT ||\n", "pType == Token.NAME ||\n", "pType == Token.ASSIGN)) {\n", "return false;\n", "}\n", "}\n", "\n", "if (parent != null && parent.getType() == Token.ASSIGN) {\n", "Node lhs = parent.getFirstChild();\n", "Node rhs = lhs.getNext();\n", "\n", "if (n == lhs) {\n", "// Always traverse the left side of the assignment. To handle\n", "// nested assignments properly (e.g., (a = this).property = c;),\n", "// assignLhsChild should not be overridden.\n", "if (assignLhsChild == null) {\n", "assignLhsChild = lhs;\n", "}\n", "} else {\n", "// Only traverse the right side if it's not an assignment to a prototype\n", "// property or subproperty.\n", "if (lhs.getType() == Token.GETPROP &&\n", "lhs.getLastChild().getString().equals(\"prototype\")) {\n", "return false;\n", "}\n", "if (lhs.getQualifiedName() != null && lhs.getQualifiedName().contains(\".prototype.\")) {\n", "return false;\n", "}\n", "}\n", "}\n", "\n", "return true;\n", "}\n"], "faulty_lines": [42, 46, 49], "cluster": 7}, {"pid": "Closure", "bid": 100, "method_path": "./dataset/Closure/100/CheckGlobalThis.java", "method": ["public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n", "\n", "if (n.getType() == Token.FUNCTION) {\n", "// Don't traverse functions that are constructors or have the @this\n", "// annotation.\n", "JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n", "if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n", "return false;\n", "}\n", "\n", "// Don't traverse functions unless they would normally\n", "// be able to have a @this annotation associated with them. e.g.,\n", "// var a = function() { }; // or\n", "// function a() {} // or\n", "// a.x = function() {};\n", "}\n", "\n", "if (parent != null && parent.getType() == Token.ASSIGN) {\n", "Node lhs = parent.getFirstChild();\n", "Node rhs = lhs.getNext();\n", "\n", "if (n == lhs) {\n", "// Always traverse the left side of the assignment. To handle\n", "// nested assignments properly (e.g., (a = this).property = c;),\n", "// assignLhsChild should not be overridden.\n", "if (assignLhsChild == null) {\n", "assignLhsChild = lhs;\n", "}\n", "} else {\n", "// Only traverse the right side if it's not an assignment to a prototype\n", "// property or subproperty.\n", "if (lhs.getType() == Token.GETPROP) {\n", "if (lhs.getLastChild().getString().equals(\"prototype\")) {\n", "return false;\n", "}\n", "String leftName = lhs.getQualifiedName();\n", "if (leftName != null && leftName.contains(\".prototype.\")) {\n", "return false;\n", "}\n", "}\n", "}\n", "}\n", "\n", "return true;\n", "}\n"], "faulty_lines": [16], "cluster": 1}, {"pid": "Closure", "bid": 100, "method_path": "./dataset/Closure/100/CheckGlobalThis.java", "method": ["private boolean shouldReportThis(Node n, Node parent) {\n", "if (assignLhsChild != null) {\n", "// Always report a THIS on the left side of an assign.\n", "return true;\n", "}\n", "\n", "// Also report a THIS with a property access.\n", "return false;\n", "}\n"], "faulty_lines": [8], "cluster": 0}, {"pid": "Closure", "bid": 101, "method_path": "./dataset/Closure/101/CommandLineRunner.java", "method": ["protected CompilerOptions createOptions() {\n", "CompilerOptions options = new CompilerOptions();\n", "options.setCodingConvention(new ClosureCodingConvention());\n", "CompilationLevel level = flags.compilation_level;\n", "level.setOptionsForCompilationLevel(options);\n", "if (flags.debug) {\n", "level.setDebugOptionsForCompilationLevel(options);\n", "}\n", "\n", "WarningLevel wLevel = flags.warning_level;\n", "wLevel.setOptionsForWarningLevel(options);\n", "for (FormattingOption formattingOption : flags.formatting) {\n", "formattingOption.applyToOptions(options);\n", "}\n", "if (flags.process_closure_primitives) {\n", "options.closurePass = true;\n", "}\n", "\n", "initOptionsFromFlags(options);\n", "return options;\n", "}\n"], "faulty_lines": [15, 16, 17, 19], "cluster": 2}, {"pid": "Closure", "bid": 102, "method_path": "./dataset/Closure/102/Normalize.java", "method": ["public void process(Node externs, Node root) {\n", "NodeTraversal.traverse(compiler, root, this);\n", "if (MAKE_LOCAL_NAMES_UNIQUE) {\n", "MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n", "NodeTraversal t = new NodeTraversal(compiler, renamer);\n", "t.traverseRoots(externs, root);\n", "}\n", "removeDuplicateDeclarations(root);\n", "new PropogateConstantAnnotations(compiler, assertOnChange)\n", ".process(externs, root);\n", "}\n"], "faulty_lines": [3, 8], "cluster": 4}, {"pid": "Closure", "bid": 103, "method_path": "./dataset/Closure/103/ControlFlowAnalysis.java", "method": ["private static boolean mayThrowException(Node n) {\n", "switch (n.getType()) {\n", "case Token.CALL:\n", "case Token.GETPROP:\n", "case Token.GETELEM:\n", "case Token.THROW:\n", "case Token.NEW:\n", "case Token.ASSIGN:\n", "case Token.INC:\n", "case Token.DEC:\n", "return true;\n", "case Token.FUNCTION:\n", "return false;\n", "}\n", "for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n", "if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n", "return true;\n", "}\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [11], "cluster": 2}, {"pid": "Closure", "bid": 105, "method_path": "./dataset/Closure/105/FoldConstants.java", "method": ["void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n", "Node parent) {\n", "if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n", "return;\n", "}\n", "\n", "Node arrayNode = left.getFirstChild();\n", "Node functionName = arrayNode.getNext();\n", "\n", "if ((arrayNode.getType() != Token.ARRAYLIT) ||\n", "!functionName.getString().equals(\"join\")) {\n", "return;\n", "}\n", "\n", "String joinString = NodeUtil.getStringValue(right);\n", "List<Node> arrayFoldedChildren = Lists.newLinkedList();\n", "StringBuilder sb = new StringBuilder();\n", "int foldedSize = 0;\n", "Node elem = arrayNode.getFirstChild();\n", "// Merges adjacent String nodes.\n", "while (elem != null) {\n", "if (NodeUtil.isImmutableValue(elem)) {\n", "if (sb.length() > 0) {\n", "sb.append(joinString);\n", "}\n", "sb.append(NodeUtil.getStringValue(elem));\n", "} else {\n", "if (sb.length() > 0) {\n", "// + 2 for the quotes.\n", "foldedSize += sb.length() + 2;\n", "arrayFoldedChildren.add(Node.newString(sb.toString()));\n", "sb = new StringBuilder();\n", "}\n", "foldedSize += InlineCostEstimator.getCost(elem);\n", "arrayFoldedChildren.add(elem);\n", "}\n", "elem = elem.getNext();\n", "}\n", "\n", "if (sb.length() > 0) {\n", "// + 2 for the quotes.\n", "foldedSize += sb.length() + 2;\n", "arrayFoldedChildren.add(Node.newString(sb.toString()));\n", "}\n", "// one for each comma.\n", "foldedSize += arrayFoldedChildren.size() - 1;\n", "\n", "int originalSize = InlineCostEstimator.getCost(n);\n", "switch (arrayFoldedChildren.size()) {\n", "case 0:\n", "Node emptyStringNode = Node.newString(\"\");\n", "parent.replaceChild(n, emptyStringNode);\n", "break;\n", "\n", "case 1:\n", "Node foldedStringNode = arrayFoldedChildren.remove(0);\n", "if (foldedSize > originalSize) {\n", "return;\n", "}\n", "arrayNode.detachChildren();\n", "if (foldedStringNode.getType() != Token.STRING) {\n", "// If the Node is not a string literal, ensure that\n", "// it is coerced to a string.\n", "Node replacement = new Node(Token.ADD,\n", "Node.newString(\"\"), foldedStringNode);\n", "foldedStringNode = replacement;\n", "}\n", "parent.replaceChild(n, foldedStringNode);\n", "break;\n", "\n", "default:\n", "// No folding could actually be performed.\n", "if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n", "return;\n", "}\n", "int kJoinOverhead = \"[].join()\".length();\n", "foldedSize += kJoinOverhead;\n", "foldedSize += InlineCostEstimator.getCost(right);\n", "if (foldedSize > originalSize) {\n", "return;\n", "}\n", "arrayNode.detachChildren();\n", "for (Node node : arrayFoldedChildren) {\n", "arrayNode.addChildToBack(node);\n", "}\n", "break;\n", "}\n", "t.getCompiler().reportCodeChange();\n", "}\n"], "faulty_lines": [17, 23, 28, 32], "cluster": 7}, {"pid": "Closure", "bid": 105, "method_path": "./dataset/Closure/105/FoldConstants.java", "method": ["void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n", "Node parent) {\n", "if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n", "return;\n", "}\n", "\n", "Node arrayNode = left.getFirstChild();\n", "Node functionName = arrayNode.getNext();\n", "\n", "if ((arrayNode.getType() != Token.ARRAYLIT) ||\n", "!functionName.getString().equals(\"join\")) {\n", "return;\n", "}\n", "\n", "String joinString = NodeUtil.getStringValue(right);\n", "List<Node> arrayFoldedChildren = Lists.newLinkedList();\n", "StringBuilder sb = new StringBuilder();\n", "int foldedSize = 0;\n", "Node elem = arrayNode.getFirstChild();\n", "// Merges adjacent String nodes.\n", "while (elem != null) {\n", "if (NodeUtil.isImmutableValue(elem)) {\n", "if (sb.length() > 0) {\n", "sb.append(joinString);\n", "}\n", "sb.append(NodeUtil.getStringValue(elem));\n", "} else {\n", "if (sb.length() > 0) {\n", "// + 2 for the quotes.\n", "foldedSize += sb.length() + 2;\n", "arrayFoldedChildren.add(Node.newString(sb.toString()));\n", "sb = new StringBuilder();\n", "}\n", "foldedSize += InlineCostEstimator.getCost(elem);\n", "arrayFoldedChildren.add(elem);\n", "}\n", "elem = elem.getNext();\n", "}\n", "\n", "if (sb.length() > 0) {\n", "// + 2 for the quotes.\n", "foldedSize += sb.length() + 2;\n", "arrayFoldedChildren.add(Node.newString(sb.toString()));\n", "}\n", "// one for each comma.\n", "foldedSize += arrayFoldedChildren.size() - 1;\n", "\n", "int originalSize = InlineCostEstimator.getCost(n);\n", "switch (arrayFoldedChildren.size()) {\n", "case 0:\n", "Node emptyStringNode = Node.newString(\"\");\n", "parent.replaceChild(n, emptyStringNode);\n", "break;\n", "\n", "case 1:\n", "Node foldedStringNode = arrayFoldedChildren.remove(0);\n", "if (foldedSize > originalSize) {\n", "return;\n", "}\n", "arrayNode.detachChildren();\n", "if (foldedStringNode.getType() != Token.STRING) {\n", "// If the Node is not a string literal, ensure that\n", "// it is coerced to a string.\n", "Node replacement = new Node(Token.ADD,\n", "Node.newString(\"\"), foldedStringNode);\n", "foldedStringNode = replacement;\n", "}\n", "parent.replaceChild(n, foldedStringNode);\n", "break;\n", "\n", "default:\n", "// No folding could actually be performed.\n", "if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n", "return;\n", "}\n", "int kJoinOverhead = \"[].join()\".length();\n", "foldedSize += kJoinOverhead;\n", "foldedSize += InlineCostEstimator.getCost(right);\n", "if (foldedSize > originalSize) {\n", "return;\n", "}\n", "arrayNode.detachChildren();\n", "for (Node node : arrayFoldedChildren) {\n", "arrayNode.addChildToBack(node);\n", "}\n", "break;\n", "}\n", "t.getCompiler().reportCodeChange();\n", "}\n"], "faulty_lines": [40], "cluster": 7}, {"pid": "Closure", "bid": 106, "method_path": "./dataset/Closure/106/GlobalNamespace.java", "method": ["boolean canCollapseUnannotatedChildNames() {\n", "if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n", "return false;\n", "}\n", "\n", "// Don't try to collapse if the one global set is a twin reference.\n", "// We could theoretically handle this case in CollapseProperties, but\n", "// it's probably not worth the effort.\n", "\n", "if (isClassOrEnum) {\n", "return true;\n", "}\n", "return (type == Type.FUNCTION || aliasingGets == 0) &&\n", "(parent == null || parent.canCollapseUnannotatedChildNames());\n", "}\n"], "faulty_lines": [9], "cluster": 4}, {"pid": "Closure", "bid": 106, "method_path": "./dataset/Closure/106/JSDocInfoBuilder.java", "method": ["public boolean recordBlockDescription(String description) {\n", "if (parseDocumentation) {\n", "populated = true;\n", "}\n", "return currentInfo.documentBlock(description);\n", "}\n"], "faulty_lines": [2, 4], "cluster": 0}, {"pid": "Closure", "bid": 107, "method_path": "./dataset/Closure/107/CommandLineRunner.java", "method": ["protected CompilerOptions createOptions() {\n", "CompilerOptions options = new CompilerOptions();\n", "if (flags.processJqueryPrimitives) {\n", "options.setCodingConvention(new JqueryCodingConvention());\n", "} else {\n", "options.setCodingConvention(new ClosureCodingConvention());\n", "}\n", "\n", "options.setExtraAnnotationNames(flags.extraAnnotationName);\n", "\n", "CompilationLevel level = flags.compilationLevel;\n", "level.setOptionsForCompilationLevel(options);\n", "\n", "if (flags.debug) {\n", "level.setDebugOptionsForCompilationLevel(options);\n", "}\n", "\n", "if (flags.useTypesForOptimization) {\n", "level.setTypeBasedOptimizationOptions(options);\n", "}\n", "\n", "if (flags.generateExports) {\n", "options.setGenerateExports(flags.generateExports);\n", "}\n", "\n", "WarningLevel wLevel = flags.warningLevel;\n", "wLevel.setOptionsForWarningLevel(options);\n", "for (FormattingOption formattingOption : flags.formatting) {\n", "formattingOption.applyToOptions(options);\n", "}\n", "\n", "options.closurePass = flags.processClosurePrimitives;\n", "\n", "options.jqueryPass = CompilationLevel.ADVANCED_OPTIMIZATIONS == level &&\n", "flags.processJqueryPrimitives;\n", "\n", "options.angularPass = flags.angularPass;\n", "\n", "if (!flags.translationsFile.isEmpty()) {\n", "try {\n", "options.messageBundle = new XtbMessageBundle(\n", "new FileInputStream(flags.translationsFile),\n", "flags.translationsProject);\n", "} catch (IOException e) {\n", "throw new RuntimeException(\"Reading XTB file\", e);\n", "}\n", "} else if (CompilationLevel.ADVANCED_OPTIMIZATIONS == level) {\n", "// In SIMPLE or WHITESPACE mode, if the user hasn't specified a\n", "// translations file, they might reasonably try to write their own\n", "// implementation of goog.getMsg that makes the substitution at\n", "// run-time.\n", "//\n", "// In ADVANCED mode, goog.getMsg is going to be renamed anyway,\n", "// so we might as well inline it. But shut off the i18n warnings,\n", "// because the user didn't really ask for i18n.\n", "options.messageBundle = new EmptyMessageBundle();\n", "}\n", "\n", "return options;\n", "}\n"], "faulty_lines": [57], "cluster": 7}, {"pid": "Closure", "bid": 108, "method_path": "./dataset/Closure/108/ScopedAliases.java", "method": ["public void exitScope(NodeTraversal t) {\n", "if (t.getScopeDepth() > 2) {\n", "findNamespaceShadows(t);\n", "}\n", "\n", "if (t.getScopeDepth() == 2) {\n", "renameNamespaceShadows(t);\n", "aliases.clear();\n", "forbiddenLocals.clear();\n", "transformation = null;\n", "hasNamespaceShadows = false;\n", "}\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Closure", "bid": 108, "method_path": "./dataset/Closure/108/ScopedAliases.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "if (isCallToScopeMethod(n)) {\n", "validateScopeCall(t, n, n.getParent());\n", "}\n", "\n", "if (t.getScopeDepth() < 2) {\n", "return;\n", "}\n", "\n", "int type = n.getType();\n", "Var aliasVar = null;\n", "if (type == Token.NAME) {\n", "String name = n.getString();\n", "Var lexicalVar = t.getScope().getVar(n.getString());\n", "if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n", "aliasVar = lexicalVar;\n", "}\n", "}\n", "\n", "// Validate the top-level of the goog.scope block.\n", "if (t.getScopeDepth() == 2) {\n", "if (aliasVar != null && NodeUtil.isLValue(n)) {\n", "if (aliasVar.getNode() == n) {\n", "aliasDefinitionsInOrder.add(n);\n", "\n", "// Return early, to ensure that we don't record a definition\n", "// twice.\n", "return;\n", "} else {\n", "report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n", "}\n", "}\n", "\n", "if (type == Token.RETURN) {\n", "report(t, n, GOOG_SCOPE_USES_RETURN);\n", "} else if (type == Token.THIS) {\n", "report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n", "} else if (type == Token.THROW) {\n", "report(t, n, GOOG_SCOPE_USES_THROW);\n", "}\n", "}\n", "\n", "// Validate all descendent scopes of the goog.scope block.\n", "if (t.getScopeDepth() >= 2) {\n", "// Check if this name points to an alias.\n", "if (aliasVar != null) {\n", "// Note, to support the transitive case, it's important we don't\n", "// clone aliasedNode here.  For example,\n", "// var g = goog; var d = g.dom; d.createElement('DIV');\n", "// The node in aliasedNode (which is \"g\") will be replaced in the\n", "// changes pass above with \"goog\".  If we cloned here, we'd end up\n", "// with <code>g.dom.createElement('DIV')</code>.\n", "aliasUsages.add(new AliasedNode(aliasVar, n));\n", "}\n", "\n", "// When we inject declarations, we duplicate jsdoc. Make sure\n", "// we only process that jsdoc once.\n", "JSDocInfo info = n.getJSDocInfo();\n", "if (info != null) {\n", "for (Node node : info.getTypeNodes()) {\n", "fixTypeNode(node);\n", "}\n", "}\n", "\n", "// TODO(robbyw): Error for goog.scope not at root.\n", "}\n", "}\n"], "faulty_lines": [59], "cluster": 7}, {"pid": "Closure", "bid": 109, "method_path": "./dataset/Closure/109/JsDocInfoParser.java", "method": ["private Node parseContextTypeExpression(JsDocToken token) {\n", "return parseTypeName(token);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Closure", "bid": 110, "method_path": "./dataset/Closure/110/ScopedAliases.java", "method": ["private void findAliases(NodeTraversal t) {\n", "Scope scope = t.getScope();\n", "for (Var v : scope.getVarIterable()) {\n", "Node n = v.getNode();\n", "Node parent = n.getParent();\n", "boolean isVar = parent.isVar();\n", "if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n", "recordAlias(v);\n", "} else if (v.isBleedingFunction()) {\n", "// Bleeding functions already get a BAD_PARAMETERS error, so just\n", "// do nothing.\n", "} else if (parent.getType() == Token.LP) {\n", "// Parameters of the scope function also get a BAD_PARAMETERS\n", "// error.\n", "} else if (isVar) {\n", "Node grandparent = parent.getParent();\n", "Node value = n.hasChildren() ?\n", "v.getInitialValue().detachFromParent() :\n", "null;\n", "Node varNode = parent;\n", "\n", "String name = n.getString();\n", "int nameCount = scopedAliasNames.count(name);\n", "scopedAliasNames.add(name);\n", "String globalName =\n", "\"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n", "\n", "compiler.ensureLibraryInjected(\"base\");\n", "\n", "// First, we need to free up the function expression (EXPR)\n", "// to be used in another expression.\n", "// Replace \"function NAME() { ... }\" with \"var NAME;\".\n", "\n", "// We can't keep the local name on the function expression,\n", "// because IE is buggy and will leak the name into the global\n", "// scope. This is covered in more detail here:\n", "// http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n", "//\n", "// This will only cause problems if this is a hoisted, recursive\n", "// function, and the programmer is using the hoisting.\n", "\n", "// If this is a VAR, we can just detach the expression and\n", "// the tree will still be valid.\n", "\n", "// Add $jscomp.scope.name = EXPR;\n", "// Make sure we copy over all the jsdoc and debug info.\n", "if (value != null || v.getJSDocInfo() != null) {\n", "Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n", "compiler.getCodingConvention(),\n", "globalName,\n", "value,\n", "v.getJSDocInfo())\n", ".useSourceInfoIfMissingFromForTree(n);\n", "NodeUtil.setDebugInformation(\n", "newDecl.getFirstChild().getFirstChild(), n, name);\n", "\n", "grandparent.addChildBefore(newDecl, varNode);\n", "}\n", "\n", "// Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n", "v.getNameNode().addChildToFront(\n", "NodeUtil.newQualifiedNameNode(\n", "compiler.getCodingConvention(), globalName, n, name));\n", "\n", "recordAlias(v);\n", "} else {\n", "// Do not other kinds of local symbols, like catch params.\n", "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "}\n", "}\n", "}\n"], "faulty_lines": [7], "cluster": 7}, {"pid": "Closure", "bid": 110, "method_path": "./dataset/Closure/110/ScopedAliases.java", "method": ["boolean isVar = parent.isVar();\n", "if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n", "recordAlias(v);\n", "} else if (v.isBleedingFunction()) {\n", "// Bleeding functions already get a BAD_PARAMETERS error, so just\n", "// do nothing.\n", "} else if (parent.getType() == Token.LP) {\n", "// Parameters of the scope function also get a BAD_PARAMETERS\n", "// error.\n", "} else if (isVar) {\n", "Node grandparent = parent.getParent();\n", "Node value = n.hasChildren() ?\n", "v.getInitialValue().detachFromParent() :\n", "null;\n", "Node varNode = parent;\n", "\n", "String name = n.getString();\n", "int nameCount = scopedAliasNames.count(name);\n", "scopedAliasNames.add(name);\n", "String globalName =\n", "\"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n", "\n", "compiler.ensureLibraryInjected(\"base\");\n", "\n", "// First, we need to free up the function expression (EXPR)\n", "// to be used in another expression.\n", "// Replace \"function NAME() { ... }\" with \"var NAME;\".\n", "\n", "// We can't keep the local name on the function expression,\n", "// because IE is buggy and will leak the name into the global\n", "// scope. This is covered in more detail here:\n", "// http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n", "//\n", "// This will only cause problems if this is a hoisted, recursive\n", "// function, and the programmer is using the hoisting.\n", "\n", "// If this is a VAR, we can just detach the expression and\n", "// the tree will still be valid.\n", "\n", "// Add $jscomp.scope.name = EXPR;\n", "// Make sure we copy over all the jsdoc and debug info.\n", "if (value != null || v.getJSDocInfo() != null) {\n", "Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n", "compiler.getCodingConvention(),\n", "globalName,\n", "value,\n", "v.getJSDocInfo())\n", ".useSourceInfoIfMissingFromForTree(n);\n", "NodeUtil.setDebugInformation(\n", "newDecl.getFirstChild().getFirstChild(), n, name);\n", "\n", "grandparent.addChildBefore(newDecl, varNode);\n", "}\n", "\n", "// Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n", "v.getNameNode().addChildToFront(\n", "NodeUtil.newQualifiedNameNode(\n", "compiler.getCodingConvention(), globalName, n, name));\n", "\n", "recordAlias(v);\n", "} else {\n", "// Do not other kinds of local symbols, like catch params.\n", "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "}\n"], "faulty_lines": [10, 12, 13, 15], "cluster": 7}, {"pid": "Closure", "bid": 110, "method_path": "./dataset/Closure/110/ScopedAliases.java", "method": ["boolean isVar = parent.isVar();\n", "if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n", "recordAlias(v);\n", "} else if (v.isBleedingFunction()) {\n", "// Bleeding functions already get a BAD_PARAMETERS error, so just\n", "// do nothing.\n", "} else if (parent.getType() == Token.LP) {\n", "// Parameters of the scope function also get a BAD_PARAMETERS\n", "// error.\n", "} else if (isVar) {\n", "Node grandparent = parent.getParent();\n", "Node value = n.hasChildren() ?\n", "v.getInitialValue().detachFromParent() :\n", "null;\n", "Node varNode = parent;\n", "\n", "String name = n.getString();\n", "int nameCount = scopedAliasNames.count(name);\n", "scopedAliasNames.add(name);\n", "String globalName =\n", "\"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n", "\n", "compiler.ensureLibraryInjected(\"base\");\n", "\n", "// First, we need to free up the function expression (EXPR)\n", "// to be used in another expression.\n", "// Replace \"function NAME() { ... }\" with \"var NAME;\".\n", "\n", "// We can't keep the local name on the function expression,\n", "// because IE is buggy and will leak the name into the global\n", "// scope. This is covered in more detail here:\n", "// http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n", "//\n", "// This will only cause problems if this is a hoisted, recursive\n", "// function, and the programmer is using the hoisting.\n", "\n", "// If this is a VAR, we can just detach the expression and\n", "// the tree will still be valid.\n", "\n", "// Add $jscomp.scope.name = EXPR;\n", "// Make sure we copy over all the jsdoc and debug info.\n", "if (value != null || v.getJSDocInfo() != null) {\n", "Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n", "compiler.getCodingConvention(),\n", "globalName,\n", "value,\n", "v.getJSDocInfo())\n", ".useSourceInfoIfMissingFromForTree(n);\n", "NodeUtil.setDebugInformation(\n", "newDecl.getFirstChild().getFirstChild(), n, name);\n", "\n", "grandparent.addChildBefore(newDecl, varNode);\n", "}\n", "\n", "// Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n", "v.getNameNode().addChildToFront(\n", "NodeUtil.newQualifiedNameNode(\n", "compiler.getCodingConvention(), globalName, n, name));\n", "\n", "recordAlias(v);\n", "} else {\n", "// Do not other kinds of local symbols, like catch params.\n", "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "}\n"], "faulty_lines": [27, 28], "cluster": 7}, {"pid": "Closure", "bid": 110, "method_path": "./dataset/Closure/110/ScopedAliases.java", "method": ["boolean isVar = parent.isVar();\n", "if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n", "recordAlias(v);\n", "} else if (v.isBleedingFunction()) {\n", "// Bleeding functions already get a BAD_PARAMETERS error, so just\n", "// do nothing.\n", "} else if (parent.getType() == Token.LP) {\n", "// Parameters of the scope function also get a BAD_PARAMETERS\n", "// error.\n", "} else if (isVar) {\n", "Node grandparent = parent.getParent();\n", "Node value = n.hasChildren() ?\n", "v.getInitialValue().detachFromParent() :\n", "null;\n", "Node varNode = parent;\n", "\n", "String name = n.getString();\n", "int nameCount = scopedAliasNames.count(name);\n", "scopedAliasNames.add(name);\n", "String globalName =\n", "\"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n", "\n", "compiler.ensureLibraryInjected(\"base\");\n", "\n", "// First, we need to free up the function expression (EXPR)\n", "// to be used in another expression.\n", "// Replace \"function NAME() { ... }\" with \"var NAME;\".\n", "\n", "// We can't keep the local name on the function expression,\n", "// because IE is buggy and will leak the name into the global\n", "// scope. This is covered in more detail here:\n", "// http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n", "//\n", "// This will only cause problems if this is a hoisted, recursive\n", "// function, and the programmer is using the hoisting.\n", "\n", "// If this is a VAR, we can just detach the expression and\n", "// the tree will still be valid.\n", "\n", "// Add $jscomp.scope.name = EXPR;\n", "// Make sure we copy over all the jsdoc and debug info.\n", "if (value != null || v.getJSDocInfo() != null) {\n", "Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n", "compiler.getCodingConvention(),\n", "globalName,\n", "value,\n", "v.getJSDocInfo())\n", ".useSourceInfoIfMissingFromForTree(n);\n", "NodeUtil.setDebugInformation(\n", "newDecl.getFirstChild().getFirstChild(), n, name);\n", "\n", "grandparent.addChildBefore(newDecl, varNode);\n", "}\n", "\n", "// Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n", "v.getNameNode().addChildToFront(\n", "NodeUtil.newQualifiedNameNode(\n", "compiler.getCodingConvention(), globalName, n, name));\n", "\n", "recordAlias(v);\n", "} else {\n", "// Do not other kinds of local symbols, like catch params.\n", "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "}\n"], "faulty_lines": [36, 37, 39], "cluster": 7}, {"pid": "Closure", "bid": 110, "method_path": "./dataset/Closure/110/ScopedAliases.java", "method": ["boolean isVar = parent.isVar();\n", "if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n", "recordAlias(v);\n", "} else if (v.isBleedingFunction()) {\n", "// Bleeding functions already get a BAD_PARAMETERS error, so just\n", "// do nothing.\n", "} else if (parent.getType() == Token.LP) {\n", "// Parameters of the scope function also get a BAD_PARAMETERS\n", "// error.\n", "} else if (isVar) {\n", "Node grandparent = parent.getParent();\n", "Node value = n.hasChildren() ?\n", "v.getInitialValue().detachFromParent() :\n", "null;\n", "Node varNode = parent;\n", "\n", "String name = n.getString();\n", "int nameCount = scopedAliasNames.count(name);\n", "scopedAliasNames.add(name);\n", "String globalName =\n", "\"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n", "\n", "compiler.ensureLibraryInjected(\"base\");\n", "\n", "// First, we need to free up the function expression (EXPR)\n", "// to be used in another expression.\n", "// Replace \"function NAME() { ... }\" with \"var NAME;\".\n", "\n", "// We can't keep the local name on the function expression,\n", "// because IE is buggy and will leak the name into the global\n", "// scope. This is covered in more detail here:\n", "// http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n", "//\n", "// This will only cause problems if this is a hoisted, recursive\n", "// function, and the programmer is using the hoisting.\n", "\n", "// If this is a VAR, we can just detach the expression and\n", "// the tree will still be valid.\n", "\n", "// Add $jscomp.scope.name = EXPR;\n", "// Make sure we copy over all the jsdoc and debug info.\n", "if (value != null || v.getJSDocInfo() != null) {\n", "Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n", "compiler.getCodingConvention(),\n", "globalName,\n", "value,\n", "v.getJSDocInfo())\n", ".useSourceInfoIfMissingFromForTree(n);\n", "NodeUtil.setDebugInformation(\n", "newDecl.getFirstChild().getFirstChild(), n, name);\n", "\n", "grandparent.addChildBefore(newDecl, varNode);\n", "}\n", "\n", "// Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n", "v.getNameNode().addChildToFront(\n", "NodeUtil.newQualifiedNameNode(\n", "compiler.getCodingConvention(), globalName, n, name));\n", "\n", "recordAlias(v);\n", "} else {\n", "// Do not other kinds of local symbols, like catch params.\n", "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "}\n"], "faulty_lines": [52, 53], "cluster": 7}, {"pid": "Closure", "bid": 110, "method_path": "./dataset/Closure/110/Node.java", "method": ["public Node getChildBefore(Node child) {\n", "if (child == first) {\n", "return null;\n", "}\n", "Node n = first;\n", "\n", "while (n.next != child) {\n", "n = n.next;\n", "if (n == null) {\n", "throw new RuntimeException(\"node is not a child\");\n", "}\n", "}\n", "return n;\n", "}\n"], "faulty_lines": [6], "cluster": 4}, {"pid": "Closure", "bid": 111, "method_path": "./dataset/Closure/111/ClosureReverseAbstractInterpreter.java", "method": ["protected JSType caseTopType(JSType topType) {\n", "return topType;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Closure", "bid": 112, "method_path": "./dataset/Closure/112/TypeInference.java", "method": ["private boolean inferTemplatedTypesForCall(\n", "Node n, FunctionType fnType) {\n", "final ImmutableList<TemplateType> keys = fnType.getTemplateTypeMap()\n", ".getTemplateKeys();\n", "if (keys.isEmpty()) {\n", "return false;\n", "}\n", "\n", "// Try to infer the template types\n", "Map<TemplateType, JSType> inferred =\n", "inferTemplateTypesFromParameters(fnType, n);\n", "\n", "\n", "// Replace all template types. If we couldn't find a replacement, we\n", "// replace it with UNKNOWN.\n", "TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n", "registry, inferred);\n", "Node callTarget = n.getFirstChild();\n", "\n", "FunctionType replacementFnType = fnType.visit(replacer)\n", ".toMaybeFunctionType();\n", "Preconditions.checkNotNull(replacementFnType);\n", "\n", "callTarget.setJSType(replacementFnType);\n", "n.setJSType(replacementFnType.getReturnType());\n", "\n", "return replacer.madeChanges;\n", "}\n"], "faulty_lines": [10, 11, 12], "cluster": 8}, {"pid": "Closure", "bid": 113, "method_path": "./dataset/Closure/113/ProcessClosurePrimitives.java", "method": ["private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n", "Node left = n.getFirstChild();\n", "Node arg = left.getNext();\n", "if (verifyLastArgumentIsString(t, left, arg)) {\n", "String ns = arg.getString();\n", "ProvidedName provided = providedNames.get(ns);\n", "if (provided == null || !provided.isExplicitlyProvided()) {\n", "unrecognizedRequires.add(\n", "new UnrecognizedRequire(n, ns, t.getSourceName()));\n", "} else {\n", "JSModule providedModule = provided.explicitModule;\n", "\n", "// This must be non-null, because there was an explicit provide.\n", "Preconditions.checkNotNull(providedModule);\n", "\n", "JSModule module = t.getModule();\n", "if (moduleGraph != null &&\n", "module != providedModule &&\n", "!moduleGraph.dependsOn(module, providedModule)) {\n", "compiler.report(\n", "t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n", "providedModule.getName(),\n", "module.getName()));\n", "}\n", "}\n", "\n", "maybeAddToSymbolTable(left);\n", "maybeAddStringNodeToSymbolTable(arg);\n", "\n", "// Requires should be removed before further processing.\n", "// Some clients run closure pass multiple times, first with\n", "// the checks for broken requires turned off. In these cases, we\n", "// allow broken requires to be preserved by the first run to\n", "// let them be caught in the subsequent run.\n", "if (provided != null) {\n", "parent.detachFromParent();\n", "compiler.reportCodeChange();\n", "}\n", "}\n", "}\n"], "faulty_lines": [35], "cluster": 1}, {"pid": "Closure", "bid": 114, "method_path": "./dataset/Closure/114/NameAnalyzer.java", "method": ["private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n", "Node nameNode = n.getFirstChild();\n", "Node parent = n.getParent();\n", "NameInformation ns = createNameInformation(t, nameNode);\n", "if (ns != null) {\n", "if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n", "// Patch for assignments that appear in the init,\n", "// condition or iteration part of a FOR loop.  Without\n", "// this change, all 3 of those parts try to claim the for\n", "// loop as their dependency scope.  The last assignment in\n", "// those three fields wins, which can result in incorrect\n", "// reference edges between referenced and assigned variables.\n", "//\n", "// TODO(user) revisit the dependency scope calculation\n", "// logic.\n", "if (parent.getFirstChild().getNext() != n) {\n", "recordDepScope(recordNode, ns);\n", "} else {\n", "recordDepScope(nameNode, ns);\n", "}\n", "} else {\n", "// The rhs of the assignment is the caller, so it's used by the\n", "// context. Don't associate it w/ the lhs.\n", "// FYI: this fixes only the specific case where the assignment is the\n", "// caller expression, but it could be nested deeper in the caller and\n", "// we would still get a bug.\n", "// See testAssignWithCall2 for an example of this.\n", "recordDepScope(recordNode, ns);\n", "}\n", "}\n", "}\n"], "faulty_lines": [21], "cluster": 1}, {"pid": "Closure", "bid": 115, "method_path": "./dataset/Closure/115/FunctionInjector.java", "method": ["private CanInlineResult canInlineReferenceDirectly(\n", "Node callNode, Node fnNode) {\n", "if (!isDirectCallNodeReplacementPossible(fnNode)) {\n", "return CanInlineResult.NO;\n", "}\n", "\n", "Node block = fnNode.getLastChild();\n", "\n", "boolean hasSideEffects = false;\n", "if (block.hasChildren()) {\n", "Preconditions.checkState(block.hasOneChild());\n", "Node stmt = block.getFirstChild();\n", "if (stmt.isReturn()) {\n", "hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n", "}\n", "}\n", "// CALL NODE: [ NAME, ARG1, ARG2, ... ]\n", "Node cArg = callNode.getFirstChild().getNext();\n", "\n", "// Functions called via 'call' and 'apply' have a this-object as\n", "// the first parameter, but this is not part of the called function's\n", "// parameter list.\n", "if (!callNode.getFirstChild().isName()) {\n", "if (NodeUtil.isFunctionObjectCall(callNode)) {\n", "// TODO(johnlenz): Support replace this with a value.\n", "if (cArg == null || !cArg.isThis()) {\n", "return CanInlineResult.NO;\n", "}\n", "cArg = cArg.getNext();\n", "} else {\n", "// \".apply\" call should be filtered before this.\n", "Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n", "}\n", "}\n", "\n", "// FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n", "Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n", "while (cArg != null || fnParam != null) {\n", "// For each named parameter check if a mutable argument use more than one.\n", "if (fnParam != null) {\n", "if (cArg != null) {\n", "if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n", "return CanInlineResult.NO;\n", "}\n", "// Check for arguments that are evaluated more than once.\n", "// Note: Unlike block inlining, there it is not possible that a\n", "// parameter reference will be in a loop.\n", "if (NodeUtil.mayEffectMutableState(cArg, compiler)\n", "&& NodeUtil.getNameReferenceCount(\n", "block, fnParam.getString()) > 1) {\n", "return CanInlineResult.NO;\n", "}\n", "}\n", "\n", "// Move to the next name.\n", "fnParam = fnParam.getNext();\n", "}\n", "\n", "// For every call argument check for side-effects, even if there\n", "// isn't a named parameter to match.\n", "if (cArg != null) {\n", "if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n", "return CanInlineResult.NO;\n", "}\n", "cArg = cArg.getNext();\n", "}\n", "}\n", "\n", "return CanInlineResult.YES;\n", "}\n"], "faulty_lines": [9, 10, 11, 12, 13, 14, 15, 16], "cluster": 7}, {"pid": "Closure", "bid": 116, "method_path": "./dataset/Closure/116/FunctionInjector.java", "method": ["private CanInlineResult canInlineReferenceDirectly(\n", "Node callNode, Node fnNode) {\n", "if (!isDirectCallNodeReplacementPossible(fnNode)) {\n", "return CanInlineResult.NO;\n", "}\n", "\n", "Node block = fnNode.getLastChild();\n", "\n", "\n", "// CALL NODE: [ NAME, ARG1, ARG2, ... ]\n", "Node cArg = callNode.getFirstChild().getNext();\n", "\n", "// Functions called via 'call' and 'apply' have a this-object as\n", "// the first parameter, but this is not part of the called function's\n", "// parameter list.\n", "if (!callNode.getFirstChild().isName()) {\n", "if (NodeUtil.isFunctionObjectCall(callNode)) {\n", "// TODO(johnlenz): Support replace this with a value.\n", "if (cArg == null || !cArg.isThis()) {\n", "return CanInlineResult.NO;\n", "}\n", "cArg = cArg.getNext();\n", "} else {\n", "// \".apply\" call should be filtered before this.\n", "Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n", "}\n", "}\n", "\n", "// FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n", "Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n", "while (cArg != null || fnParam != null) {\n", "// For each named parameter check if a mutable argument use more than one.\n", "if (fnParam != null) {\n", "if (cArg != null) {\n", "\n", "// Check for arguments that are evaluated more than once.\n", "// Note: Unlike block inlining, there it is not possible that a\n", "// parameter reference will be in a loop.\n", "if (NodeUtil.mayEffectMutableState(cArg, compiler)\n", "&& NodeUtil.getNameReferenceCount(\n", "block, fnParam.getString()) > 1) {\n", "return CanInlineResult.NO;\n", "}\n", "}\n", "\n", "// Move to the next name.\n", "fnParam = fnParam.getNext();\n", "}\n", "\n", "// For every call argument check for side-effects, even if there\n", "// isn't a named parameter to match.\n", "if (cArg != null) {\n", "if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n", "return CanInlineResult.NO;\n", "}\n", "cArg = cArg.getNext();\n", "}\n", "}\n", "\n", "return CanInlineResult.YES;\n", "}\n"], "faulty_lines": [9], "cluster": 7}, {"pid": "Closure", "bid": 116, "method_path": "./dataset/Closure/116/FunctionInjector.java", "method": ["private CanInlineResult canInlineReferenceDirectly(\n", "Node callNode, Node fnNode) {\n", "if (!isDirectCallNodeReplacementPossible(fnNode)) {\n", "return CanInlineResult.NO;\n", "}\n", "\n", "Node block = fnNode.getLastChild();\n", "\n", "\n", "// CALL NODE: [ NAME, ARG1, ARG2, ... ]\n", "Node cArg = callNode.getFirstChild().getNext();\n", "\n", "// Functions called via 'call' and 'apply' have a this-object as\n", "// the first parameter, but this is not part of the called function's\n", "// parameter list.\n", "if (!callNode.getFirstChild().isName()) {\n", "if (NodeUtil.isFunctionObjectCall(callNode)) {\n", "// TODO(johnlenz): Support replace this with a value.\n", "if (cArg == null || !cArg.isThis()) {\n", "return CanInlineResult.NO;\n", "}\n", "cArg = cArg.getNext();\n", "} else {\n", "// \".apply\" call should be filtered before this.\n", "Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n", "}\n", "}\n", "\n", "// FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n", "Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n", "while (cArg != null || fnParam != null) {\n", "// For each named parameter check if a mutable argument use more than one.\n", "if (fnParam != null) {\n", "if (cArg != null) {\n", "\n", "// Check for arguments that are evaluated more than once.\n", "// Note: Unlike block inlining, there it is not possible that a\n", "// parameter reference will be in a loop.\n", "if (NodeUtil.mayEffectMutableState(cArg, compiler)\n", "&& NodeUtil.getNameReferenceCount(\n", "block, fnParam.getString()) > 1) {\n", "return CanInlineResult.NO;\n", "}\n", "}\n", "\n", "// Move to the next name.\n", "fnParam = fnParam.getNext();\n", "}\n", "\n", "// For every call argument check for side-effects, even if there\n", "// isn't a named parameter to match.\n", "if (cArg != null) {\n", "if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n", "return CanInlineResult.NO;\n", "}\n", "cArg = cArg.getNext();\n", "}\n", "}\n", "\n", "return CanInlineResult.YES;\n", "}\n"], "faulty_lines": [35], "cluster": 7}, {"pid": "Closure", "bid": 118, "method_path": "./dataset/Closure/118/DisambiguateProperties.java", "method": ["private void handleObjectLit(NodeTraversal t, Node n) {\n", "for (Node child = n.getFirstChild();\n", "child != null;\n", "child = child.getNext()) {\n", "// Maybe STRING, GET, SET\n", "\n", "// We should never see a mix of numbers and strings.\n", "String name = child.getString();\n", "T type = typeSystem.getType(getScope(), n, name);\n", "\n", "Property prop = getProperty(name);\n", "if (!prop.scheduleRenaming(child,\n", "processProperty(t, prop, type, null))) {\n", "// TODO(user): It doesn't look like the user can do much in this\n", "// case right now.\n", "if (propertiesToErrorFor.containsKey(name)) {\n", "compiler.report(JSError.make(\n", "t.getSourceName(), child, propertiesToErrorFor.get(name),\n", "Warnings.INVALIDATION, name,\n", "(type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [6], "cluster": 8}, {"pid": "Closure", "bid": 120, "method_path": "./dataset/Closure/120/ReferenceCollectingCallback.java", "method": ["boolean isAssignedOnceInLifetime() {\n", "Reference ref = getOneAndOnlyAssignment();\n", "if (ref == null) {\n", "return false;\n", "}\n", "\n", "// Make sure this assignment is not in a loop.\n", "for (BasicBlock block = ref.getBasicBlock();\n", "block != null; block = block.getParent()) {\n", "if (block.isFunction) {\n", "break;\n", "} else if (block.isLoop) {\n", "return false;\n", "}\n", "}\n", "\n", "return true;\n", "}\n"], "faulty_lines": [11], "cluster": 4}, {"pid": "Closure", "bid": 121, "method_path": "./dataset/Closure/121/InlineVariables.java", "method": ["boolean maybeModifiedArguments) {\n", "int refCount = referenceInfo.references.size();\n", "Reference declaration = referenceInfo.references.get(0);\n", "Reference init = referenceInfo.getInitializingReference();\n", "int firstRefAfterInit = (declaration == init) ? 2 : 3;\n", "\n", "if (refCount > 1 &&\n", "isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n", "// if the variable is referenced more than once, we can only\n", "// inline it if it's immutable and never defined before referenced.\n", "Node value;\n", "if (init != null) {\n", "value = init.getAssignedValue();\n", "} else {\n", "// Create a new node for variable that is never initialized.\n", "Node srcLocation = declaration.getNode();\n", "value = NodeUtil.newUndefinedNode(srcLocation);\n", "}\n", "Preconditions.checkNotNull(value);\n", "inlineWellDefinedVariable(v, value, referenceInfo.references);\n", "staleVars.add(v);\n", "} else if (refCount == firstRefAfterInit) {\n", "// The variable likely only read once, try some more\n", "// complex inlining heuristics.\n", "Reference reference = referenceInfo.references.get(\n", "firstRefAfterInit - 1);\n", "if (canInline(declaration, init, reference)) {\n", "inline(v, declaration, init, reference);\n", "staleVars.add(v);\n", "}\n", "} else if (declaration != init && refCount == 2) {\n", "if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n", "// The only reference is the initialization, remove the assignment and\n", "// the variable declaration.\n", "Node value = init.getAssignedValue();\n", "Preconditions.checkNotNull(value);\n", "inlineWellDefinedVariable(v, value, referenceInfo.references);\n", "staleVars.add(v);\n", "}\n", "}\n", "\n", "// If this variable was not inlined normally, check if we can\n", "// inline an alias of it. (If the variable was inlined, then the\n", "// reference data is out of sync. We're better off just waiting for\n", "// the next pass.)\n", "if (!maybeModifiedArguments &&\n", "!staleVars.contains(v) &&\n", "referenceInfo.isWellDefined() &&\n", "referenceInfo.isAssignedOnceInLifetime()) {\n", "// Inlining the variable based solely on well-defined and assigned\n", "// once is *NOT* correct. We relax the correctness requirement if\n", "// the variable is declared constant.\n", "List<Reference> refs = referenceInfo.references;\n", "for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n", "Node nameNode = refs.get(i).getNode();\n", "if (aliasCandidates.containsKey(nameNode)) {\n", "AliasCandidate candidate = aliasCandidates.get(nameNode);\n", "if (!staleVars.contains(candidate.alias) &&\n", "!isVarInlineForbidden(candidate.alias)) {\n", "Reference aliasInit;\n", "aliasInit = candidate.refInfo.getInitializingReference();\n", "Node value = aliasInit.getAssignedValue();\n", "Preconditions.checkNotNull(value);\n", "inlineWellDefinedVariable(candidate.alias,\n", "value,\n", "candidate.refInfo.references);\n", "staleVars.add(candidate.alias);\n", "}\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [49, 53], "cluster": 7}, {"pid": "Closure", "bid": 122, "method_path": "./dataset/Closure/122/IRFactory.java", "method": ["private void handleBlockComment(Comment comment) {\n", "if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n", "errorReporter.warning(\n", "SUSPICIOUS_COMMENT_WARNING,\n", "sourceName,\n", "comment.getLineno(), \"\", 0);\n", "}\n", "}\n"], "faulty_lines": [2], "cluster": 4}, {"pid": "Closure", "bid": 123, "method_path": "./dataset/Closure/123/CodeGenerator.java", "method": ["void add(Node n, Context context) {\n", "if (!cc.continueProcessing()) {\n", "return;\n", "}\n", "\n", "int type = n.getType();\n", "String opstr = NodeUtil.opToStr(type);\n", "int childCount = n.getChildCount();\n", "Node first = n.getFirstChild();\n", "Node last = n.getLastChild();\n", "\n", "// Handle all binary operators\n", "if (opstr != null && first != last) {\n", "Preconditions.checkState(\n", "childCount == 2,\n", "\"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n", "opstr, childCount);\n", "int p = NodeUtil.precedence(type);\n", "\n", "// For right-hand-side of operations, only pass context if it's\n", "// the IN_FOR_INIT_CLAUSE one.\n", "Context rhsContext = getContextForNoInOperator(context);\n", "\n", "// Handle associativity.\n", "// e.g. if the parse tree is a * (b * c),\n", "// we can simply generate a * b * c.\n", "if (last.getType() == type &&\n", "NodeUtil.isAssociative(type)) {\n", "addExpr(first, p, context);\n", "cc.addOp(opstr, true);\n", "addExpr(last, p, rhsContext);\n", "} else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n", "// Assignments are the only right-associative binary operators\n", "addExpr(first, p, context);\n", "cc.addOp(opstr, true);\n", "addExpr(last, p, rhsContext);\n", "} else {\n", "unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n", "}\n", "return;\n", "}\n", "\n", "cc.startSourceMapping(n);\n", "\n", "switch (type) {\n", "case Token.TRY: {\n", "Preconditions.checkState(first.getNext().isBlock() &&\n", "!first.getNext().hasMoreThanOneChild());\n", "Preconditions.checkState(childCount >= 2 && childCount <= 3);\n", "\n", "add(\"try\");\n", "add(first, Context.PRESERVE_BLOCK);\n", "\n", "// second child contains the catch block, or nothing if there\n", "// isn't a catch block\n", "Node catchblock = first.getNext().getFirstChild();\n", "if (catchblock != null) {\n", "add(catchblock);\n", "}\n", "\n", "if (childCount == 3) {\n", "add(\"finally\");\n", "add(last, Context.PRESERVE_BLOCK);\n", "}\n", "break;\n", "}\n", "\n", "case Token.CATCH:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"catch(\");\n", "add(first);\n", "add(\")\");\n", "add(last, Context.PRESERVE_BLOCK);\n", "break;\n", "\n", "case Token.THROW:\n", "Preconditions.checkState(childCount == 1);\n", "add(\"throw\");\n", "add(first);\n", "\n", "// Must have a ';' after a throw statement, otherwise safari can't\n", "// parse this.\n", "cc.endStatement(true);\n", "break;\n", "\n", "case Token.RETURN:\n", "add(\"return\");\n", "if (childCount == 1) {\n", "add(first);\n", "} else {\n", "Preconditions.checkState(childCount == 0);\n", "}\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.VAR:\n", "if (first != null) {\n", "add(\"var \");\n", "addList(first, false, getContextForNoInOperator(context));\n", "}\n", "break;\n", "\n", "case Token.LABEL_NAME:\n", "Preconditions.checkState(!n.getString().isEmpty());\n", "addIdentifier(n.getString());\n", "break;\n", "\n", "case Token.NAME:\n", "if (first == null || first.isEmpty()) {\n", "addIdentifier(n.getString());\n", "} else {\n", "Preconditions.checkState(childCount == 1);\n", "addIdentifier(n.getString());\n", "cc.addOp(\"=\", true);\n", "if (first.isComma()) {\n", "addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n", "} else {\n", "// Add expression, consider nearby code at lowest level of\n", "// precedence.\n", "addExpr(first, 0, getContextForNoInOperator(context));\n", "}\n", "}\n", "break;\n", "\n", "case Token.ARRAYLIT:\n", "add(\"[\");\n", "addArrayList(first);\n", "add(\"]\");\n", "break;\n", "\n", "case Token.PARAM_LIST:\n", "add(\"(\");\n", "addList(first);\n", "add(\")\");\n", "break;\n", "\n", "case Token.COMMA:\n", "Preconditions.checkState(childCount == 2);\n", "unrollBinaryOperator(n, Token.COMMA, \",\", context,\n", "getContextForNoInOperator(context), 0, 0);\n", "break;\n", "\n", "case Token.NUMBER:\n", "Preconditions.checkState(childCount == 0);\n", "cc.addNumber(n.getDouble());\n", "break;\n", "\n", "case Token.TYPEOF:\n", "case Token.VOID:\n", "case Token.NOT:\n", "case Token.BITNOT:\n", "case Token.POS: {\n", "// All of these unary operators are right-associative\n", "Preconditions.checkState(childCount == 1);\n", "cc.addOp(NodeUtil.opToStrNoFail(type), false);\n", "addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n", "break;\n", "}\n", "\n", "case Token.NEG: {\n", "Preconditions.checkState(childCount == 1);\n", "\n", "// It's important to our sanity checker that the code\n", "// we print produces the same AST as the code we parse back.\n", "// NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n", "if (n.getFirstChild().isNumber()) {\n", "cc.addNumber(-n.getFirstChild().getDouble());\n", "} else {\n", "cc.addOp(NodeUtil.opToStrNoFail(type), false);\n", "addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n", "}\n", "\n", "break;\n", "}\n", "\n", "case Token.HOOK: {\n", "Preconditions.checkState(childCount == 3);\n", "int p = NodeUtil.precedence(type);\n", "Context rhsContext = Context.OTHER;\n", "addExpr(first, p + 1, context);\n", "cc.addOp(\"?\", true);\n", "addExpr(first.getNext(), 1, rhsContext);\n", "cc.addOp(\":\", true);\n", "addExpr(last, 1, rhsContext);\n", "break;\n", "}\n", "\n", "case Token.REGEXP:\n", "if (!first.isString() ||\n", "!last.isString()) {\n", "throw new Error(\"Expected children to be strings\");\n", "}\n", "\n", "String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n", "\n", "// I only use one .add because whitespace matters\n", "if (childCount == 2) {\n", "add(regexp + last.getString());\n", "} else {\n", "Preconditions.checkState(childCount == 1);\n", "add(regexp);\n", "}\n", "break;\n", "\n", "case Token.FUNCTION:\n", "if (n.getClass() != Node.class) {\n", "throw new Error(\"Unexpected Node subclass.\");\n", "}\n", "Preconditions.checkState(childCount == 3);\n", "boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n", "if (funcNeedsParens) {\n", "add(\"(\");\n", "}\n", "\n", "add(\"function\");\n", "add(first);\n", "\n", "add(first.getNext());\n", "add(last, Context.PRESERVE_BLOCK);\n", "cc.endFunction(context == Context.STATEMENT);\n", "\n", "if (funcNeedsParens) {\n", "add(\")\");\n", "}\n", "break;\n", "\n", "case Token.GETTER_DEF:\n", "case Token.SETTER_DEF:\n", "Preconditions.checkState(n.getParent().isObjectLit());\n", "Preconditions.checkState(childCount == 1);\n", "Preconditions.checkState(first.isFunction());\n", "\n", "// Get methods are unnamed\n", "Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n", "if (type == Token.GETTER_DEF) {\n", "// Get methods have no parameters.\n", "Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n", "add(\"get \");\n", "} else {\n", "// Set methods have one parameter.\n", "Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n", "add(\"set \");\n", "}\n", "\n", "// The name is on the GET or SET node.\n", "String name = n.getString();\n", "Node fn = first;\n", "Node parameters = fn.getChildAtIndex(1);\n", "Node body = fn.getLastChild();\n", "\n", "// Add the property name.\n", "if (!n.isQuotedString() &&\n", "TokenStream.isJSIdentifier(name) &&\n", "// do not encode literally any non-literal characters that were\n", "// Unicode escaped.\n", "NodeUtil.isLatin(name)) {\n", "add(name);\n", "} else {\n", "// Determine if the string is a simple number.\n", "double d = getSimpleNumber(name);\n", "if (!Double.isNaN(d)) {\n", "cc.addNumber(d);\n", "} else {\n", "addJsString(n);\n", "}\n", "}\n", "\n", "add(parameters);\n", "add(body, Context.PRESERVE_BLOCK);\n", "break;\n", "\n", "case Token.SCRIPT:\n", "case Token.BLOCK: {\n", "if (n.getClass() != Node.class) {\n", "throw new Error(\"Unexpected Node subclass.\");\n", "}\n", "boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n", "if (preserveBlock) {\n", "cc.beginBlock();\n", "}\n", "\n", "boolean preferLineBreaks =\n", "type == Token.SCRIPT ||\n", "(type == Token.BLOCK &&\n", "!preserveBlock &&\n", "n.getParent() != null &&\n", "n.getParent().isScript());\n", "for (Node c = first; c != null; c = c.getNext()) {\n", "add(c, Context.STATEMENT);\n", "\n", "// VAR doesn't include ';' since it gets used in expressions\n", "if (c.isVar()) {\n", "cc.endStatement();\n", "}\n", "\n", "if (c.isFunction()) {\n", "cc.maybeLineBreak();\n", "}\n", "\n", "// Prefer to break lines in between top-level statements\n", "// because top-level statements are more homogeneous.\n", "if (preferLineBreaks) {\n", "cc.notePreferredLineBreak();\n", "}\n", "}\n", "if (preserveBlock) {\n", "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n", "}\n", "break;\n", "}\n", "\n", "case Token.FOR:\n", "if (childCount == 4) {\n", "add(\"for(\");\n", "if (first.isVar()) {\n", "add(first, Context.IN_FOR_INIT_CLAUSE);\n", "} else {\n", "addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n", "}\n", "add(\";\");\n", "add(first.getNext());\n", "add(\";\");\n", "add(first.getNext().getNext());\n", "add(\")\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "} else {\n", "Preconditions.checkState(childCount == 3);\n", "add(\"for(\");\n", "add(first);\n", "add(\"in\");\n", "add(first.getNext());\n", "add(\")\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "}\n", "break;\n", "\n", "case Token.DO:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"do\");\n", "addNonEmptyStatement(first, Context.OTHER, false);\n", "add(\"while(\");\n", "add(last);\n", "add(\")\");\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.WHILE:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"while(\");\n", "add(first);\n", "add(\")\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "break;\n", "\n", "case Token.EMPTY:\n", "Preconditions.checkState(childCount == 0);\n", "break;\n", "\n", "case Token.GETPROP: {\n", "Preconditions.checkState(\n", "childCount == 2,\n", "\"Bad GETPROP: expected 2 children, but got %s\", childCount);\n", "Preconditions.checkState(\n", "last.isString(),\n", "\"Bad GETPROP: RHS should be STRING\");\n", "boolean needsParens = (first.isNumber());\n", "if (needsParens) {\n", "add(\"(\");\n", "}\n", "addExpr(first, NodeUtil.precedence(type), context);\n", "if (needsParens) {\n", "add(\")\");\n", "}\n", "if (this.languageMode == LanguageMode.ECMASCRIPT3\n", "&& TokenStream.isKeyword(last.getString())) {\n", "// Check for ECMASCRIPT3 keywords.\n", "add(\"[\");\n", "add(last);\n", "add(\"]\");\n", "} else {\n", "add(\".\");\n", "addIdentifier(last.getString());\n", "}\n", "break;\n", "}\n", "\n", "case Token.GETELEM:\n", "Preconditions.checkState(\n", "childCount == 2,\n", "\"Bad GETELEM: expected 2 children but got %s\", childCount);\n", "addExpr(first, NodeUtil.precedence(type), context);\n", "add(\"[\");\n", "add(first.getNext());\n", "add(\"]\");\n", "break;\n", "\n", "case Token.WITH:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"with(\");\n", "add(first);\n", "add(\")\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "break;\n", "\n", "case Token.INC:\n", "case Token.DEC: {\n", "Preconditions.checkState(childCount == 1);\n", "String o = type == Token.INC ? \"++\" : \"--\";\n", "int postProp = n.getIntProp(Node.INCRDECR_PROP);\n", "// A non-zero post-prop value indicates a post inc/dec, default of zero\n", "// is a pre-inc/dec.\n", "if (postProp != 0) {\n", "addExpr(first, NodeUtil.precedence(type), context);\n", "cc.addOp(o, false);\n", "} else {\n", "cc.addOp(o, false);\n", "add(first);\n", "}\n", "break;\n", "}\n", "\n", "case Token.CALL:\n", "// We have two special cases here:\n", "// 1) If the left hand side of the call is a direct reference to eval,\n", "// then it must have a DIRECT_EVAL annotation. If it does not, then\n", "// that means it was originally an indirect call to eval, and that\n", "// indirectness must be preserved.\n", "// 2) If the left hand side of the call is a property reference,\n", "// then the call must not a FREE_CALL annotation. If it does, then\n", "// that means it was originally an call without an explicit this and\n", "// that must be preserved.\n", "if (isIndirectEval(first)\n", "|| n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n", "add(\"(0,\");\n", "addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n", "add(\")\");\n", "} else {\n", "addExpr(first, NodeUtil.precedence(type), context);\n", "}\n", "add(\"(\");\n", "addList(first.getNext());\n", "add(\")\");\n", "break;\n", "\n", "case Token.IF:\n", "boolean hasElse = childCount == 3;\n", "boolean ambiguousElseClause =\n", "context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n", "if (ambiguousElseClause) {\n", "cc.beginBlock();\n", "}\n", "\n", "add(\"if(\");\n", "add(first);\n", "add(\")\");\n", "\n", "if (hasElse) {\n", "addNonEmptyStatement(\n", "first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n", "add(\"else\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "} else {\n", "addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n", "Preconditions.checkState(childCount == 2);\n", "}\n", "\n", "if (ambiguousElseClause) {\n", "cc.endBlock();\n", "}\n", "break;\n", "\n", "case Token.NULL:\n", "Preconditions.checkState(childCount == 0);\n", "cc.addConstant(\"null\");\n", "break;\n", "\n", "case Token.THIS:\n", "Preconditions.checkState(childCount == 0);\n", "add(\"this\");\n", "break;\n", "\n", "case Token.FALSE:\n", "Preconditions.checkState(childCount == 0);\n", "cc.addConstant(\"false\");\n", "break;\n", "\n", "case Token.TRUE:\n", "Preconditions.checkState(childCount == 0);\n", "cc.addConstant(\"true\");\n", "break;\n", "\n", "case Token.CONTINUE:\n", "Preconditions.checkState(childCount <= 1);\n", "add(\"continue\");\n", "if (childCount == 1) {\n", "if (!first.isLabelName()) {\n", "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n", "}\n", "add(\" \");\n", "add(first);\n", "}\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.DEBUGGER:\n", "Preconditions.checkState(childCount == 0);\n", "add(\"debugger\");\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.BREAK:\n", "Preconditions.checkState(childCount <= 1);\n", "add(\"break\");\n", "if (childCount == 1) {\n", "if (!first.isLabelName()) {\n", "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n", "}\n", "add(\" \");\n", "add(first);\n", "}\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.EXPR_RESULT:\n", "Preconditions.checkState(childCount == 1);\n", "add(first, Context.START_OF_EXPR);\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.NEW:\n", "add(\"new \");\n", "int precedence = NodeUtil.precedence(type);\n", "\n", "// If the first child contains a CALL, then claim higher precedence\n", "// to force parentheses. Otherwise, when parsed, NEW will bind to the\n", "// first viable parentheses (don't traverse into functions).\n", "if (NodeUtil.containsType(\n", "first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n", "precedence = NodeUtil.precedence(first.getType()) + 1;\n", "}\n", "addExpr(first, precedence, Context.OTHER);\n", "\n", "// '()' is optional when no arguments are present\n", "Node next = first.getNext();\n", "if (next != null) {\n", "add(\"(\");\n", "addList(next);\n", "add(\")\");\n", "}\n", "break;\n", "\n", "case Token.STRING_KEY:\n", "Preconditions.checkState(\n", "childCount == 1, \"Object lit key must have 1 child\");\n", "addJsString(n);\n", "break;\n", "\n", "case Token.STRING:\n", "Preconditions.checkState(\n", "childCount == 0, \"A string may not have children\");\n", "addJsString(n);\n", "break;\n", "\n", "case Token.DELPROP:\n", "Preconditions.checkState(childCount == 1);\n", "add(\"delete \");\n", "add(first);\n", "break;\n", "\n", "case Token.OBJECTLIT: {\n", "boolean needsParens = (context == Context.START_OF_EXPR);\n", "if (needsParens) {\n", "add(\"(\");\n", "}\n", "add(\"{\");\n", "for (Node c = first; c != null; c = c.getNext()) {\n", "if (c != first) {\n", "cc.listSeparator();\n", "}\n", "\n", "if (c.isGetterDef() || c.isSetterDef()) {\n", "add(c);\n", "} else {\n", "Preconditions.checkState(c.isStringKey());\n", "String key = c.getString();\n", "// Object literal property names don't have to be quoted if they\n", "// are not JavaScript keywords\n", "if (!c.isQuotedString()\n", "&& !(languageMode == LanguageMode.ECMASCRIPT3\n", "&& TokenStream.isKeyword(key))\n", "&& TokenStream.isJSIdentifier(key)\n", "// do not encode literally any non-literal characters that\n", "// were Unicode escaped.\n", "&& NodeUtil.isLatin(key)) {\n", "add(key);\n", "} else {\n", "// Determine if the string is a simple number.\n", "double d = getSimpleNumber(key);\n", "if (!Double.isNaN(d)) {\n", "cc.addNumber(d);\n", "} else {\n", "addExpr(c, 1, Context.OTHER);\n", "}\n", "}\n", "add(\":\");\n", "addExpr(c.getFirstChild(), 1, Context.OTHER);\n", "}\n", "}\n", "add(\"}\");\n", "if (needsParens) {\n", "add(\")\");\n", "}\n", "break;\n", "}\n", "\n", "case Token.SWITCH:\n", "add(\"switch(\");\n", "add(first);\n", "add(\")\");\n", "cc.beginBlock();\n", "addAllSiblings(first.getNext());\n", "cc.endBlock(context == Context.STATEMENT);\n", "break;\n", "\n", "case Token.CASE:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"case \");\n", "add(first);\n", "addCaseBody(last);\n", "break;\n", "\n", "case Token.DEFAULT_CASE:\n", "Preconditions.checkState(childCount == 1);\n", "add(\"default\");\n", "addCaseBody(first);\n", "break;\n", "\n", "case Token.LABEL:\n", "Preconditions.checkState(childCount == 2);\n", "if (!first.isLabelName()) {\n", "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n", "}\n", "add(first);\n", "add(\":\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), true);\n", "break;\n", "\n", "case Token.CAST:\n", "add(\"(\");\n", "add(first);\n", "add(\")\");\n", "break;\n", "\n", "default:\n", "throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n", "}\n", "\n", "cc.endSourceMapping(n);\n", "}\n"], "faulty_lines": [179], "cluster": 7}, {"pid": "Closure", "bid": 124, "method_path": "./dataset/Closure/124/ExploitAssigns.java", "method": ["private boolean isSafeReplacement(Node node, Node replacement) {\n", "// No checks are needed for simple names.\n", "if (node.isName()) {\n", "return true;\n", "}\n", "Preconditions.checkArgument(node.isGetProp());\n", "\n", "node = node.getFirstChild();\n", "if (node.isName()\n", "&& isNameAssignedTo(node.getString(), replacement)) {\n", "return false;\n", "}\n", "\n", "return true;\n", "}\n"], "faulty_lines": [8, 9], "cluster": 4}, {"pid": "Closure", "bid": 125, "method_path": "./dataset/Closure/125/TypeCheck.java", "method": ["private void visitNew(NodeTraversal t, Node n) {\n", "Node constructor = n.getFirstChild();\n", "JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n", "if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n", "FunctionType fnType = type.toMaybeFunctionType();\n", "if (fnType != null) {\n", "visitParameterList(t, n, fnType);\n", "ensureTyped(t, n, fnType.getInstanceType());\n", "} else {\n", "ensureTyped(t, n);\n", "}\n", "} else {\n", "report(t, n, NOT_A_CONSTRUCTOR);\n", "ensureTyped(t, n);\n", "}\n", "}\n"], "faulty_lines": [6], "cluster": 2}, {"pid": "Closure", "bid": 126, "method_path": "./dataset/Closure/126/MinimizeExitPoints.java", "method": ["void tryMinimizeExits(Node n, int exitType, String labelName) {\n", "\n", "// Just an 'exit'.\n", "if (matchingExitNode(n, exitType, labelName)) {\n", "NodeUtil.removeChild(n.getParent(), n);\n", "compiler.reportCodeChange();\n", "return;\n", "}\n", "\n", "// Just an 'if'.\n", "if (n.isIf()) {\n", "Node ifBlock = n.getFirstChild().getNext();\n", "tryMinimizeExits(ifBlock, exitType, labelName);\n", "Node elseBlock = ifBlock.getNext();\n", "if (elseBlock != null) {\n", "tryMinimizeExits(elseBlock, exitType, labelName);\n", "}\n", "return;\n", "}\n", "\n", "// Just a 'try/catch/finally'.\n", "if (n.isTry()) {\n", "Node tryBlock = n.getFirstChild();\n", "tryMinimizeExits(tryBlock, exitType, labelName);\n", "Node allCatchNodes = NodeUtil.getCatchBlock(n);\n", "if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n", "Preconditions.checkState(allCatchNodes.hasOneChild());\n", "Node catchNode = allCatchNodes.getFirstChild();\n", "Node catchCodeBlock = catchNode.getLastChild();\n", "tryMinimizeExits(catchCodeBlock, exitType, labelName);\n", "}\n", "/* Don't try to minimize the exits of finally blocks, as this\n", "* can cause problems if it changes the completion type of the finally\n", "* block. See ECMA 262 Sections 8.9 & 12.14\n", "*/\n", "if (NodeUtil.hasFinally(n)) {\n", "Node finallyBlock = n.getLastChild();\n", "tryMinimizeExits(finallyBlock, exitType, labelName);\n", "}\n", "}\n", "\n", "// Just a 'label'.\n", "if (n.isLabel()) {\n", "Node labelBlock = n.getLastChild();\n", "tryMinimizeExits(labelBlock, exitType, labelName);\n", "}\n", "\n", "// TODO(johnlenz): The last case of SWITCH statement?\n", "\n", "// The rest assumes a block with at least one child, bail on anything else.\n", "if (!n.isBlock() || n.getLastChild() == null) {\n", "return;\n", "}\n", "\n", "// Multiple if-exits can be converted in a single pass.\n", "// Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n", "// become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n", "// which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n", "for (Node c : n.children()) {\n", "\n", "// An 'if' block to process below.\n", "if (c.isIf()) {\n", "Node ifTree = c;\n", "Node trueBlock, falseBlock;\n", "\n", "// First, the true condition block.\n", "trueBlock = ifTree.getFirstChild().getNext();\n", "falseBlock = trueBlock.getNext();\n", "tryMinimizeIfBlockExits(trueBlock, falseBlock,\n", "ifTree, exitType, labelName);\n", "\n", "// Now the else block.\n", "// The if blocks may have changed, get them again.\n", "trueBlock = ifTree.getFirstChild().getNext();\n", "falseBlock = trueBlock.getNext();\n", "if (falseBlock != null) {\n", "tryMinimizeIfBlockExits(falseBlock, trueBlock,\n", "ifTree, exitType, labelName);\n", "}\n", "}\n", "\n", "if (c == n.getLastChild()) {\n", "break;\n", "}\n", "}\n", "\n", "// Now try to minimize the exits of the last child, if it is removed\n", "// look at what has become the last child.\n", "for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n", "tryMinimizeExits(c, exitType, labelName);\n", "// If the node is still the last child, we are done.\n", "if (c == n.getLastChild()) {\n", "break;\n", "}\n", "}\n", "}\n"], "faulty_lines": [36, 37, 38, 39], "cluster": 7}, {"pid": "Closure", "bid": 129, "method_path": "./dataset/Closure/129/PrepareAst.java", "method": ["private void annotateCalls(Node n) {\n", "Preconditions.checkState(n.isCall());\n", "\n", "// Keep track of of the \"this\" context of a call.  A call without an\n", "// explicit \"this\" is a free call.\n", "Node first = n.getFirstChild();\n", "\n", "// ignore cast nodes.\n", "\n", "if (!NodeUtil.isGet(first)) {\n", "n.putBooleanProp(Node.FREE_CALL, true);\n", "}\n", "\n", "// Keep track of the context in which eval is called. It is important\n", "// to distinguish between \"(0, eval)()\" and \"eval()\".\n", "if (first.isName() &&\n", "\"eval\".equals(first.getString())) {\n", "first.putBooleanProp(Node.DIRECT_EVAL, true);\n", "}\n", "}\n"], "faulty_lines": [9], "cluster": 2}, {"pid": "Closure", "bid": 130, "method_path": "./dataset/Closure/130/CollapseProperties.java", "method": ["private void inlineAliases(GlobalNamespace namespace) {\n", "// Invariant: All the names in the worklist meet condition (a).\n", "Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n", "while (!workList.isEmpty()) {\n", "Name name = workList.pop();\n", "\n", "// Don't attempt to inline a getter or setter property as a variable.\n", "if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n", "continue;\n", "}\n", "\n", "if (name.globalSets == 1 && name.localSets == 0 &&\n", "name.aliasingGets > 0) {\n", "// {@code name} meets condition (b). Find all of its local aliases\n", "// and try to inline them.\n", "List<Ref> refs = Lists.newArrayList(name.getRefs());\n", "for (Ref ref : refs) {\n", "if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n", "// {@code name} meets condition (c). Try to inline it.\n", "if (inlineAliasIfPossible(ref, namespace)) {\n", "name.removeRef(ref);\n", "}\n", "}\n", "}\n", "}\n", "\n", "// Check if {@code name} has any aliases left after the\n", "// local-alias-inlining above.\n", "if ((name.type == Name.Type.OBJECTLIT ||\n", "name.type == Name.Type.FUNCTION) &&\n", "name.aliasingGets == 0 && name.props != null) {\n", "// All of {@code name}'s children meet condition (a), so they can be\n", "// added to the worklist.\n", "workList.addAll(name.props);\n", "}\n", "}\n", "}\n"], "faulty_lines": [12], "cluster": 1}, {"pid": "Closure", "bid": 131, "method_path": "./dataset/Closure/131/TokenStream.java", "method": ["public static boolean isJSIdentifier(String s) {\n", "int length = s.length();\n", "\n", "if (length == 0 ||\n", "!Character.isJavaIdentifierStart(s.charAt(0))) {\n", "return false;\n", "}\n", "\n", "for (int i = 1; i < length; i++) {\n", "if (\n", "!Character.isJavaIdentifierPart(s.charAt(i))) {\n", "return false;\n", "}\n", "}\n", "\n", "return true;\n", "}\n"], "faulty_lines": [5, 10], "cluster": 4}, {"pid": "Closure", "bid": 133, "method_path": "./dataset/Closure/133/JsDocInfoParser.java", "method": ["private String getRemainingJSDocLine() {\n", "String result = stream.getRemainingJSDocLine();\n", "return result;\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Closure", "bid": 134, "method_path": "./dataset/Closure/134/AmbiguateProperties.java", "method": ["public void process(Node externs, Node root) {\n", "NodeTraversal.traverse(compiler, externs, new ProcessExterns());\n", "NodeTraversal.traverse(compiler, root, new ProcessProperties());\n", "\n", "Set<String> reservedNames =\n", "new HashSet<String>(externedNames.size() + quotedNames.size());\n", "reservedNames.addAll(externedNames);\n", "reservedNames.addAll(quotedNames);\n", "\n", "int numRenamedPropertyNames = 0;\n", "int numSkippedPropertyNames = 0;\n", "Set<Property> propsByFreq = new TreeSet<Property>(FREQUENCY_COMPARATOR);\n", "for (Property p : propertyMap.values()) {\n", "if (!p.skipAmbiguating) {\n", "++numRenamedPropertyNames;\n", "computeRelatedTypes(p.type);\n", "propsByFreq.add(p);\n", "} else {\n", "++numSkippedPropertyNames;\n", "reservedNames.add(p.oldName);\n", "}\n", "}\n", "\n", "PropertyGraph graph = new PropertyGraph(Lists.newLinkedList(propsByFreq));\n", "GraphColoring<Property, Void> coloring =\n", "new GreedyGraphColoring<Property, Void>(graph, FREQUENCY_COMPARATOR);\n", "int numNewPropertyNames = coloring.color();\n", "\n", "NameGenerator nameGen = new NameGenerator(\n", "reservedNames, \"\", reservedCharacters);\n", "for (int i = 0; i < numNewPropertyNames; ++i) {\n", "colorMap.put(i, nameGen.generateNextName());\n", "}\n", "for (GraphNode<Property, Void> node : graph.getNodes()) {\n", "node.getValue().newName = colorMap.get(node.getAnnotation().hashCode());\n", "renamingMap.put(node.getValue().oldName, node.getValue().newName);\n", "}\n", "\n", "// Update the string nodes.\n", "for (Node n : stringNodesToRename) {\n", "String oldName = n.getString();\n", "Property p = propertyMap.get(oldName);\n", "if (p != null && p.newName != null) {\n", "Preconditions.checkState(oldName.equals(p.oldName));\n", "if (!p.newName.equals(oldName)) {\n", "n.setString(p.newName);\n", "compiler.reportCodeChange();\n", "}\n", "}\n", "}\n", "\n", "logger.info(\"Collapsed \" + numRenamedPropertyNames + \" properties into \"\n", "+ numNewPropertyNames + \" and skipped renaming \"\n", "+ numSkippedPropertyNames + \" properties.\");\n", "}\n"], "faulty_lines": [16], "cluster": 7}, {"pid": "Closure", "bid": 134, "method_path": "./dataset/Closure/134/AmbiguateProperties.java", "method": ["public boolean isIndependentOf(Property prop) {\n", "if (typesRelatedToSet.intersects(prop.typesSet)) {\n", "return false;\n", "}\n", "return !getRelated(prop.type).intersects(typesInSet);\n", "}\n"], "faulty_lines": [5], "cluster": 0}, {"pid": "Closure", "bid": 134, "method_path": "./dataset/Closure/134/AmbiguateProperties.java", "method": ["public void addNode(Property prop) {\n", "typesInSet.or(prop.typesSet);\n", "typesRelatedToSet.or(getRelated(prop.type));\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Closure", "bid": 134, "method_path": "./dataset/Closure/134/AmbiguateProperties.java", "method": ["private class Property {\n", "final String oldName;\n", "JSType type;\n", "String newName;\n", "int numOccurrences;\n", "boolean skipAmbiguating;\n", "JSTypeBitSet typesSet = new JSTypeBitSet(intForType.size());\n", "\n", "Property(String name) {\n", "this.oldName = name;\n", "\n", "// Properties with this suffix are handled in RenameProperties.\n", "if (name.startsWith(SKIP_PREFIX)) {\n", "skipAmbiguating = true;\n", "}\n", "}\n", "\n", "/** Add this type to this property, calculating */\n", "void addType(JSType newType) {\n", "if (skipAmbiguating) {\n", "return;\n", "}\n", "\n", "++numOccurrences;\n", "\n", "if (newType instanceof UnionType) {\n", "newType = newType.restrictByNotNullOrUndefined();\n", "if (newType instanceof UnionType) {\n", "for (JSType alt : ((UnionType) newType).getAlternates()) {\n", "addNonUnionType(alt);\n", "}\n", "return;\n", "}\n", "}\n", "addNonUnionType(newType);\n", "}\n", "\n", "private void addNonUnionType(JSType newType) {\n", "if (skipAmbiguating || isInvalidatingType(newType)) {\n", "skipAmbiguating = true;\n", "return;\n", "}\n", "\n", "if (type == null) {\n", "type = newType;\n", "} else {\n", "type = type.getLeastSupertype(newType);\n", "}\n", "typesSet.set(getIntForType(newType));\n", "}\n", "}\n"], "faulty_lines": [3, 8], "cluster": 1}, {"pid": "Closure", "bid": 134, "method_path": "./dataset/Closure/134/AmbiguateProperties.java", "method": ["private void addNonUnionType(JSType newType) {\n", "if (skipAmbiguating || isInvalidatingType(newType)) {\n", "skipAmbiguating = true;\n", "return;\n", "}\n", "\n", "if (type == null) {\n", "type = newType;\n", "} else {\n", "type = type.getLeastSupertype(newType);\n", "}\n", "typesSet.set(getIntForType(newType));\n", "}\n"], "faulty_lines": [7, 8, 9, 10, 12], "cluster": 4}, {"pid": "Closure", "bid": 134, "method_path": "./dataset/Closure/134/TypedScopeCreator.java", "method": ["private FunctionType findOverriddenFunction(\n", "ObjectType ownerType, String propName) {\n", "// First, check to see if the property is implemented\n", "// on a superclass.\n", "JSType propType = ownerType.getPropertyType(propName);\n", "if (propType instanceof FunctionType) {\n", "return (FunctionType) propType;\n", "}\n", "// If it's not, then check to see if it's implemented\n", "// on an implemented interface.\n", "\n", "return null;\n", "}\n"], "faulty_lines": [8, 11], "cluster": 4}, {"pid": "Closure", "bid": 135, "method_path": "./dataset/Closure/135/DevirtualizePrototypeMethods.java", "method": ["private void replaceReferencesToThis(Node node, String name) {\n", "if (NodeUtil.isFunction(node)) {\n", "return;\n", "}\n", "\n", "for (Node child : node.children()) {\n", "if (NodeUtil.isThis(child)) {\n", "Node newName = Node.newString(Token.NAME, name);\n", "node.replaceChild(child, newName);\n", "} else {\n", "replaceReferencesToThis(child, name);\n", "}\n", "}\n", "}\n"], "faulty_lines": [9], "cluster": 4}, {"pid": "Closure", "bid": 135, "method_path": "./dataset/Closure/135/FunctionType.java", "method": ["boolean inferred, boolean inExterns) {\n", "if (\"prototype\".equals(name)) {\n", "ObjectType objType = type.toObjectType();\n", "if (objType != null) {\n", "return setPrototype(\n", "new FunctionPrototypeType(\n", "registry, this, objType, isNativeObjectType()));\n", "} else {\n", "return false;\n", "}\n", "}\n", "return super.defineProperty(name, type, inferred, inExterns);\n", "}\n"], "faulty_lines": [5], "cluster": 4}, {"pid": "Closure", "bid": 136, "method_path": "./dataset/Closure/136/MethodCompilerPass.java", "method": ["private void addPossibleSignature(String name, Node node, NodeTraversal t) {\n", "boolean signatureAdded = false;\n", "if (node.getType() == Token.FUNCTION) {\n", "// The node we're looking at is a function, so we can add it directly\n", "addSignature(name, node, t.getSourceName());\n", "signatureAdded = true;\n", "} else if (node.getType() == Token.NAME) {\n", "String functionName = node.getString();\n", "Scope.Var v = t.getScope().getVar(functionName);\n", "if (v == null) {\n", "if (compiler.isIdeMode()) {\n", "return;\n", "} else {\n", "throw new IllegalStateException(\n", "\"VarCheck should have caught this undefined function\");\n", "}\n", "}\n", "Node function = v.getInitialValue();\n", "if (function != null &&\n", "function.getType() == Token.FUNCTION) {\n", "addSignature(name, function, v.getInputName());\n", "signatureAdded = true;\n", "}\n", "}\n", "if (!signatureAdded) {\n", "nonMethodProperties.add(name);\n", "}\n", "}\n"], "faulty_lines": [2, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25], "cluster": 8}, {"pid": "Closure", "bid": 137, "method_path": "./dataset/Closure/137/MakeDeclaredNamesUnique.java", "method": ["private Deque<Renamer> nameStack = new ArrayDeque<Renamer>();\n", "private final Renamer rootRenamer;\n", "\n", "MakeDeclaredNamesUnique() {\n", "this.rootRenamer = new ContextualRenamer();\n", "}\n"], "faulty_lines": [1], "cluster": 0}, {"pid": "Closure", "bid": 137, "method_path": "./dataset/Closure/137/MakeDeclaredNamesUnique.java", "method": ["public void addDeclaredName(String name) {\n", "if (global) {\n", "reserveName(name);\n", "} else {\n", "// It hasn't been declared locally yet, so increment the count.\n", "if (!declarations.containsKey(name)) {\n", "int id = incrementNameCount(name);\n", "String newName = null;\n", "if (id != 0) {\n", "newName = getUniqueName(name, id);\n", "}\n", "declarations.put(name, newName);\n", "}\n", "}\n", "}\n"], "faulty_lines": [2], "cluster": 4}, {"pid": "Closure", "bid": 137, "method_path": "./dataset/Closure/137/MakeDeclaredNamesUnique.java", "method": ["public void addDeclaredName(String name) {\n", "if (global) {\n", "reserveName(name);\n", "} else {\n", "// It hasn't been declared locally yet, so increment the count.\n", "if (!declarations.containsKey(name)) {\n", "int id = incrementNameCount(name);\n", "String newName = null;\n", "if (id != 0) {\n", "newName = getUniqueName(name, id);\n", "}\n", "declarations.put(name, newName);\n", "}\n", "}\n", "}\n"], "faulty_lines": [11, 12], "cluster": 4}, {"pid": "Closure", "bid": 137, "method_path": "./dataset/Closure/137/MakeDeclaredNamesUnique.java", "method": ["public void addDeclaredName(String name) {\n", "if (!declarations.containsKey(name)) {\n", "declarations.put(name, getUniqueName(name));\n", "}\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Closure", "bid": 137, "method_path": "./dataset/Closure/137/Normalize.java", "method": ["public void process(Node externs, Node root) {\n", "NodeTraversal.traverse(compiler, root,\n", "new NormalizeStatements(compiler, assertOnChange));\n", "removeDuplicateDeclarations(root);\n", "if (MAKE_LOCAL_NAMES_UNIQUE) {\n", "MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n", "NodeTraversal t = new NodeTraversal(compiler, renamer);\n", "t.traverseRoots(externs, root);\n", "}\n", "// It is important that removeDuplicateDeclarations runs after\n", "// MakeDeclaredNamesUnique in order for catch block exception names to be\n", "// handled properly. Specifically, catch block exception names are\n", "// only valid within the catch block, but our currect Scope logic\n", "// has no concept of this and includes it in the containing function\n", "// (or global scope). MakeDeclaredNamesUnique makes the catch exception\n", "// names unique so that removeDuplicateDeclarations() will properly handle\n", "// cases where a function scope variable conflict with a exception name:\n", "//   function f() {\n", "//      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n", "//      var e = 1; // f scope 'e'\n", "//   }\n", "// otherwise 'var e = 1' would be rewritten as 'e = 1'.\n", "// TODO(johnlenz): Introduce a seperate scope for catch nodes.\n", "new PropogateConstantAnnotations(compiler, assertOnChange)\n", ".process(externs, root);\n", "}\n"], "faulty_lines": [4], "cluster": 1}, {"pid": "Closure", "bid": 137, "method_path": "./dataset/Closure/137/Normalize.java", "method": ["public void process(Node externs, Node root) {\n", "NodeTraversal.traverse(compiler, root,\n", "new NormalizeStatements(compiler, assertOnChange));\n", "removeDuplicateDeclarations(root);\n", "if (MAKE_LOCAL_NAMES_UNIQUE) {\n", "MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n", "NodeTraversal t = new NodeTraversal(compiler, renamer);\n", "t.traverseRoots(externs, root);\n", "}\n", "// It is important that removeDuplicateDeclarations runs after\n", "// MakeDeclaredNamesUnique in order for catch block exception names to be\n", "// handled properly. Specifically, catch block exception names are\n", "// only valid within the catch block, but our currect Scope logic\n", "// has no concept of this and includes it in the containing function\n", "// (or global scope). MakeDeclaredNamesUnique makes the catch exception\n", "// names unique so that removeDuplicateDeclarations() will properly handle\n", "// cases where a function scope variable conflict with a exception name:\n", "//   function f() {\n", "//      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n", "//      var e = 1; // f scope 'e'\n", "//   }\n", "// otherwise 'var e = 1' would be rewritten as 'e = 1'.\n", "// TODO(johnlenz): Introduce a seperate scope for catch nodes.\n", "new PropogateConstantAnnotations(compiler, assertOnChange)\n", ".process(externs, root);\n", "}\n"], "faulty_lines": [24], "cluster": 1}, {"pid": "Closure", "bid": 138, "method_path": "./dataset/Closure/138/ClosureReverseAbstractInterpreter.java", "method": ["public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n", "FlowScope blindScope, boolean outcome) {\n", "if (condition.getType() == CALL && condition.getChildCount() == 2) {\n", "Node callee = condition.getFirstChild();\n", "Node param = condition.getLastChild();\n", "if (callee.getType() == GETPROP && param.isQualifiedName()) {\n", "JSType paramType =  getTypeIfRefinable(param, blindScope);\n", "if (paramType != null) {\n", "Node left = callee.getFirstChild();\n", "Node right = callee.getLastChild();\n", "if (left.getType() == NAME && \"goog\".equals(left.getString()) &&\n", "right.getType() == STRING) {\n", "Function<TypeRestriction, JSType> restricter =\n", "restricters.get(right.getString());\n", "if (restricter != null) {\n", "return restrictParameter(param, paramType, blindScope, restricter,\n", "outcome);\n", "}\n", "}\n", "}\n", "}\n", "}\n", "return nextPreciserScopeKnowingConditionOutcome(\n", "condition, blindScope, outcome);\n", "}\n"], "faulty_lines": [8], "cluster": 8}, {"pid": "Closure", "bid": 138, "method_path": "./dataset/Closure/138/ClosureReverseAbstractInterpreter.java", "method": ["public FlowScope getPreciserScopeKnowingConditionOutcome(Node condition,\n", "FlowScope blindScope, boolean outcome) {\n", "if (condition.getType() == CALL && condition.getChildCount() == 2) {\n", "Node callee = condition.getFirstChild();\n", "Node param = condition.getLastChild();\n", "if (callee.getType() == GETPROP && param.isQualifiedName()) {\n", "JSType paramType =  getTypeIfRefinable(param, blindScope);\n", "if (paramType != null) {\n", "Node left = callee.getFirstChild();\n", "Node right = callee.getLastChild();\n", "if (left.getType() == NAME && \"goog\".equals(left.getString()) &&\n", "right.getType() == STRING) {\n", "Function<TypeRestriction, JSType> restricter =\n", "restricters.get(right.getString());\n", "if (restricter != null) {\n", "return restrictParameter(param, paramType, blindScope, restricter,\n", "outcome);\n", "}\n", "}\n", "}\n", "}\n", "}\n", "return nextPreciserScopeKnowingConditionOutcome(\n", "condition, blindScope, outcome);\n", "}\n"], "faulty_lines": [18], "cluster": 8}, {"pid": "Closure", "bid": 138, "method_path": "./dataset/Closure/138/TypeInference.java", "method": ["private FlowScope traverseName(Node n, FlowScope scope) {\n", "String varName = n.getString();\n", "Node value = n.getFirstChild();\n", "JSType type = n.getJSType();\n", "if (value != null) {\n", "scope = traverse(value, scope);\n", "updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,\n", "getJSType(value));\n", "return scope;\n", "} else {\n", "StaticSlot<JSType> var = scope.getSlot(varName);\n", "if (var != null &&\n", "!(var.isTypeInferred() && unflowableVarNames.contains(varName))) {\n", "// There are two situations where we don't want to use type information\n", "// from the scope, even if we have it.\n", "\n", "// 1) The var is escaped in a weird way, e.g.,\n", "// function f() { var x = 3; function g() { x = null } (x); }\n", "\n", "// 2) We're reading type information from another scope for an\n", "// inferred variable.\n", "// var t = null; function f() { (t); }\n", "\n", "type = var.getType();\n", "if (type == null) {\n", "type = getNativeType(UNKNOWN_TYPE);\n", "}\n", "}\n", "}\n", "n.setJSType(type);\n", "return scope;\n", "}\n"], "faulty_lines": [12, 13, 19, 23, 24, 27], "cluster": 1}, {"pid": "Closure", "bid": 139, "method_path": "./dataset/Closure/139/Normalize.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "switch (n.getType()) {\n", "case Token.WHILE:\n", "if (CONVERT_WHILE_TO_FOR) {\n", "Node expr = n.getFirstChild();\n", "n.setType(Token.FOR);\n", "n.addChildBefore(new Node(Token.EMPTY), expr);\n", "n.addChildAfter(new Node(Token.EMPTY), expr);\n", "reportCodeChange(\"WHILE node\");\n", "}\n", "break;\n", "\n", "}\n", "}\n"], "faulty_lines": [13], "cluster": 4}, {"pid": "Closure", "bid": 139, "method_path": "./dataset/Closure/139/Normalize.java", "method": ["public void onRedeclaration(\n", "Scope s, String name, Node n, Node parent, Node gramps,\n", "Node nodeWithLineNumber) {\n", "Preconditions.checkState(n.getType() == Token.NAME);\n", "if (parent.getType() == Token.VAR) {\n", "// If name is \"arguments\", Var maybe null.\n", "Preconditions.checkState(parent.hasOneChild());\n", "\n", "replaceVarWithAssignment(n, parent, gramps);\n", "}\n", "}\n"], "faulty_lines": [5, 7], "cluster": 4}, {"pid": "Closure", "bid": 140, "method_path": "./dataset/Closure/140/Compiler.java", "method": ["public void init(JSSourceFile[] externs, JSModule[] modules,\n", "CompilerOptions options) {\n", "initOptions(options);\n", "\n", "checkFirstModule(modules);\n", "\n", "this.externs = makeCompilerInput(externs, true);\n", "this.modules = modules;\n", "// Generate the module graph, and report any errors in the module\n", "// specification as errors.\n", "try {\n", "this.moduleGraph = new JSModuleGraph(modules);\n", "} catch (JSModuleGraph.ModuleDependenceException e) {\n", "// problems with the module format.  Report as an error.  The\n", "// message gives all details.\n", "report(JSError.make(MODULE_DEPENDENCY_ERROR,\n", "e.getModule().getName(), e.getDependentModule().getName()));\n", "return;\n", "}\n", "this.inputs = getAllInputsFromModules();\n", "initBasedOnOptions();\n", "\n", "initInputsByNameMap();\n", "}\n"], "faulty_lines": [6], "cluster": 8}, {"pid": "Closure", "bid": 141, "method_path": "./dataset/Closure/141/PureFunctionIdentifier.java", "method": ["private static Collection<Definition> getCallableDefinitions(\n", "DefinitionProvider definitionProvider, Node name) {\n", "List<Definition> result = Lists.newArrayList();\n", "\n", "if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n", "return null;\n", "}\n", "Collection<Definition> decls =\n", "definitionProvider.getDefinitionsReferencedAt(name);\n", "if (decls == null) {\n", "return null;\n", "}\n", "\n", "for (Definition current : decls) {\n", "Node rValue = current.getRValue();\n", "if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n", "result.add(current);\n", "} else {\n", "return null;\n", "}\n", "}\n", "\n", "return result;\n", "}\n"], "faulty_lines": [3, 5, 6, 7], "cluster": 2}, {"pid": "Closure", "bid": 141, "method_path": "./dataset/Closure/141/PureFunctionIdentifier.java", "method": ["private static Collection<Definition> getCallableDefinitions(\n", "DefinitionProvider definitionProvider, Node name) {\n", "List<Definition> result = Lists.newArrayList();\n", "\n", "if (!NodeUtil.isGetProp(name) && !NodeUtil.isName(name)) {\n", "return null;\n", "}\n", "Collection<Definition> decls =\n", "definitionProvider.getDefinitionsReferencedAt(name);\n", "if (decls == null) {\n", "return null;\n", "}\n", "\n", "for (Definition current : decls) {\n", "Node rValue = current.getRValue();\n", "if ((rValue != null) && NodeUtil.isFunction(rValue)) {\n", "result.add(current);\n", "} else {\n", "return null;\n", "}\n", "}\n", "\n", "return result;\n", "}\n"], "faulty_lines": [24], "cluster": 2}, {"pid": "Closure", "bid": 142, "method_path": "./dataset/Closure/142/CoalesceVariableNames.java", "method": ["public void enterScope(NodeTraversal t) {\n", "// TODO(user): We CAN do this in the global scope, just need to be\n", "// careful when something is exported. Liveness uses bit-vector for live\n", "// sets so I don't see compilation time will be a problem for running this\n", "// pass in the global scope.\n", "Scope scope = t.getScope();\n", "if (scope.isGlobal()) {\n", "return;\n", "}\n", "ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n", "\n", "LiveVariablesAnalysis liveness =\n", "new LiveVariablesAnalysis(cfg, scope, compiler);\n", "// If the function has exactly 2 params, mark them as escaped. This is\n", "// a work-around for an IE bug where it throws an exception if you\n", "// write to the parameters of the callback in a sort(). See:\n", "// http://code.google.com/p/closure-compiler/issues/detail?id=58\n", "liveness.analyze();\n", "\n", "UndiGraph<Var, Void> interferenceGraph =\n", "computeVariableNamesInterferenceGraph(\n", "t, cfg, liveness.getEscapedLocals());\n", "\n", "GraphColoring<Var, Void> coloring =\n", "new GreedyGraphColoring<Var, Void>(interferenceGraph,\n", "coloringTieBreaker);\n", "\n", "coloring.color();\n", "colorings.push(coloring);\n", "}\n"], "faulty_lines": [18], "cluster": 1}, {"pid": "Closure", "bid": 143, "method_path": "./dataset/Closure/143/RemoveConstantExpressions.java", "method": ["private void trySimplify(Node parent, Node node) {\n", "if (node.getType() != Token.EXPR_RESULT) {\n", "return;\n", "}\n", "\n", "Node exprBody = node.getFirstChild();\n", "if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody)\n", ") {\n", "changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody));\n", "}\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Closure", "bid": 145, "method_path": "./dataset/Closure/145/CodeGenerator.java", "method": ["private boolean isOneExactlyFunctionOrDo(Node n) {\n", "// For labels with block children, we need to ensure that a\n", "// labeled FUNCTION or DO isn't generated when extraneous BLOCKs\n", "// are skipped.\n", "// Either a empty statement or an block with more than one child,\n", "// way it isn't a FUNCTION or DO.\n", "return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n", "}\n"], "faulty_lines": [2, 5, 7, 8], "cluster": 4}, {"pid": "Closure", "bid": 146, "method_path": "./dataset/Closure/146/JSType.java", "method": ["public TypePair getTypesUnderInequality(JSType that) {\n", "// unions types\n", "if (that instanceof UnionType) {\n", "TypePair p = that.getTypesUnderInequality(this);\n", "return new TypePair(p.typeB, p.typeA);\n", "}\n", "\n", "// other types\n", "switch (this.testForEquality(that)) {\n", "case TRUE:\n", "return new TypePair(null, null);\n", "\n", "case FALSE:\n", "case UNKNOWN:\n", "return new TypePair(this, that);\n", "}\n", "\n", "// switch case is exhaustive\n", "throw new IllegalStateException();\n", "}\n"], "faulty_lines": [11], "cluster": 4}, {"pid": "Closure", "bid": 147, "method_path": "./dataset/Closure/147/CheckGlobalThis.java", "method": ["public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n", "\n", "if (n.getType() == Token.FUNCTION) {\n", "// Don't traverse functions that are constructors or have the @this\n", "// or @override annotation.\n", "JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n", "if (jsDoc != null &&\n", "(jsDoc.isConstructor() ||\n", "jsDoc.isInterface() ||\n", "jsDoc.hasThisType() ||\n", "jsDoc.isOverride())) {\n", "return false;\n", "}\n", "\n", "// Don't traverse functions unless they would normally\n", "// be able to have a @this annotation associated with them. e.g.,\n", "// var a = function() { }; // or\n", "// function a() {} // or\n", "// a.x = function() {}; // or\n", "// var a = {x: function() {}};\n", "int pType = parent.getType();\n", "if (!(pType == Token.BLOCK ||\n", "pType == Token.SCRIPT ||\n", "pType == Token.NAME ||\n", "pType == Token.ASSIGN)) {\n", "return false;\n", "}\n", "}\n", "\n", "if (parent != null && parent.getType() == Token.ASSIGN) {\n", "Node lhs = parent.getFirstChild();\n", "Node rhs = lhs.getNext();\n", "\n", "if (n == lhs) {\n", "// Always traverse the left side of the assignment. To handle\n", "// nested assignments properly (e.g., (a = this).property = c;),\n", "// assignLhsChild should not be overridden.\n", "if (assignLhsChild == null) {\n", "assignLhsChild = lhs;\n", "}\n", "} else {\n", "// Only traverse the right side if it's not an assignment to a prototype\n", "// property or subproperty.\n", "if (NodeUtil.isGet(lhs)) {\n", "if (lhs.getType() == Token.GETPROP &&\n", "lhs.getLastChild().getString().equals(\"prototype\")) {\n", "return false;\n", "}\n", "Node llhs = lhs.getFirstChild();\n", "if (llhs.getType() == Token.GETPROP &&\n", "llhs.getLastChild().getString().equals(\"prototype\")) {\n", "return false;\n", "}\n", "}\n", "}\n", "}\n", "\n", "return true;\n", "}\n"], "faulty_lines": [25], "cluster": 7}, {"pid": "Closure", "bid": 147, "method_path": "./dataset/Closure/147/RuntimeTypeCheck.java", "method": ["private void visitFunction(NodeTraversal t, Node n) {\n", "FunctionType funType = (FunctionType) n.getJSType();\n", "Node block = n.getLastChild();\n", "Node paramName = NodeUtil.getFnParameters(n).getFirstChild();\n", "Node insertionPoint = null;\n", "\n", "// To satisfy normalization constraints, the type checking must be\n", "// added after any inner function declarations.\n", "\n", "for (Node paramType : funType.getParameters()) {\n", "// Can this ever happen?\n", "if (paramName == null) {\n", "return;\n", "}\n", "\n", "Node checkNode = createCheckTypeCallNode(\n", "paramType.getJSType(), paramName.cloneTree());\n", "\n", "if (checkNode == null) {\n", "// We don't know how to check this parameter type.\n", "paramName = paramName.getNext();\n", "continue;\n", "}\n", "\n", "checkNode = new Node(Token.EXPR_RESULT, checkNode);\n", "if (insertionPoint == null) {\n", "block.addChildToFront(checkNode);\n", "} else {\n", "block.addChildAfter(checkNode, insertionPoint);\n", "}\n", "\n", "compiler.reportCodeChange();\n", "paramName = paramName.getNext();\n", "insertionPoint = checkNode;\n", "}\n", "}\n"], "faulty_lines": [9], "cluster": 8}, {"pid": "Closure", "bid": 148, "method_path": "./dataset/Closure/148/PeepholeFoldConstants.java", "method": ["private Node tryFoldTypeof(Node originalTypeofNode) {\n", "Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);\n", "\n", "Node argumentNode = originalTypeofNode.getFirstChild();\n", "if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {\n", "return originalTypeofNode;\n", "}\n", "\n", "String typeNameString = null;\n", "\n", "switch (argumentNode.getType()) {\n", "case Token.STRING:\n", "typeNameString = \"string\";\n", "break;\n", "case Token.NUMBER:\n", "typeNameString = \"number\";\n", "break;\n", "case Token.TRUE:\n", "case Token.FALSE:\n", "typeNameString = \"boolean\";\n", "break;\n", "case Token.NULL:\n", "case Token.OBJECTLIT:\n", "case Token.ARRAYLIT:\n", "typeNameString = \"object\";\n", "break;\n", "case Token.NAME:\n", "// We assume here that programs don't change the value of the\n", "// keyword undefined to something other than the value undefined.\n", "if (\"undefined\".equals(argumentNode.getString())) {\n", "typeNameString = \"undefined\";\n", "}\n", "break;\n", "}\n", "\n", "if (typeNameString != null) {\n", "Node newNode = Node.newString(typeNameString);\n", "originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);\n", "reportCodeChange();\n", "\n", "return newNode;\n", "}\n", "\n", "return originalTypeofNode;\n", "}\n"], "faulty_lines": [27], "cluster": 1}, {"pid": "Closure", "bid": 148, "method_path": "./dataset/Closure/148/SourceMap.java", "method": ["public class SourceMap {\n", "\n", "\n", "/**\n", "* A mapping from a given position in an input source file to a given position\n", "* in the generated code.\n", "*/\n", "static class Mapping {\n", "/**\n", "* A unique ID for this mapping for record keeping purposes.\n", "*/\n", "int id;\n", "\n", "/**\n", "* The input source file.\n", "*/\n", "String sourceFile;\n", "\n", "/**\n", "* The position of the code in the input source file. Both\n", "* the line number and the character index are indexed by\n", "* 1 for legacy reasons via the Rhino Node class.\n", "*/\n", "Position originalPosition;\n", "\n", "/**\n", "* The starting position of the code in the generated source\n", "* file which this mapping represents. Indexed by 0.\n", "*/\n", "Position startPosition;\n", "\n", "/**\n", "* The ending position of the code in the generated source\n", "* file which this mapping represents. Indexed by 0.\n", "*/\n", "Position endPosition;\n", "\n", "/**\n", "* The original name of the token found at the position\n", "* represented by this mapping (if any).\n", "*/\n", "String originalName;\n", "\n", "/**\n", "* Whether the mapping is actually used by the source map.\n", "*/\n", "\n", "/**\n", "* Cache of escaped source file name.\n", "*/\n", "\n", "/**\n", "* Appends the mapping to the given buffer.\n", "*/\n", "void appendTo(Appendable out) throws IOException {\n", "out.append(\"[\");\n", "\n", "out.append(sourceFile);\n", "// The source file rarely changes, so cache the escaped string.\n", "\n", "out.append(\",\");\n", "\n", "\n", "out.append(String.valueOf(originalPosition.getLineNumber()));\n", "\n", "out.append(\",\");\n", "out.append(String.valueOf(originalPosition.getCharacterIndex()));\n", "\n", "if (originalName != null) {\n", "out.append(\",\");\n", "out.append(originalName);\n", "}\n", "\n", "out.append(\"]\");\n", "}\n", "/**\n", "* Add used mappings to the supplied Appendable.\n", "*/\n", "}\n", "\n", "/**\n", "* A pre-order traversal ordered list of mappings stored in this map.\n", "*/\n", "private List<Mapping> mappings = Lists.newArrayList();\n", "\n", "/**\n", "* The position that the current source map is offset in the\n", "* buffer being used to generated the compiled source file.\n", "*/\n", "private Position offsetPosition = new Position(0, 0);\n", "\n", "/**\n", "* The position that the current source map is offset in the\n", "* generated the compiled source file by the addition of a\n", "* an output wrapper prefix.\n", "*/\n", "private Position prefixPosition = new Position(0, 0);\n", "\n", "/**\n", "* Escapes the given string for JSON.\n", "*/\n", "private static String escapeString(String value) {\n", "return CodeGenerator.escapeToDoubleQuotedJsString(value);\n", "}\n", "private String lastSourceFile = null;\n", "private String lastSourceFileEscaped = null;\n", "\n", "/**\n", "* Adds a mapping for the given node.  Mappings must be added in order.\n", "*\n", "* @param node The node that the new mapping represents.\n", "* @param startPosition The position on the starting line\n", "* @param endPosition The position on the ending line.\n", "*/\n", "void addMapping(Node node, Position startPosition, Position endPosition) {\n", "String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);\n", "\n", "// If the node does not have an associated source file or\n", "// its line number is -1, then the node does not have sufficient\n", "// information for a mapping to be useful.\n", "if (sourceFile == null || node.getLineno() < 0) {\n", "return;\n", "}\n", "\n", "String escapedSourceFile;\n", "if (lastSourceFile != sourceFile) {  // yes, \"s1 != s2\" not \"!s1.equals(s2)\"\n", "lastSourceFile = sourceFile;\n", "lastSourceFileEscaped = escapeString(sourceFile);\n", "}\n", "escapedSourceFile = lastSourceFileEscaped;\n", "// Create the new mapping.\n", "Mapping mapping = new Mapping();\n", "mapping.id = mappings.size();\n", "mapping.sourceFile = escapedSourceFile;\n", "mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n", "\n", "String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);\n", "if (originalName != null) {\n", "mapping.originalName = escapeString(originalName);\n", "}\n", "\n", "// If the mapping is found on the first line, we need to offset\n", "// its character position by the number of characters found on\n", "// the *last* line of the source file to which the code is\n", "// being generated.\n", "int offsetLine = offsetPosition.getLineNumber();\n", "int startOffsetPosition = offsetPosition.getCharacterIndex();\n", "int endOffsetPosition = offsetPosition.getCharacterIndex();\n", "\n", "if (startPosition.getLineNumber() > 0) {\n", "startOffsetPosition = 0;\n", "}\n", "\n", "if (endPosition.getLineNumber() > 0) {\n", "endOffsetPosition = 0;\n", "}\n", "\n", "mapping.startPosition =\n", "new Position(startPosition.getLineNumber() + offsetLine,\n", "startPosition.getCharacterIndex() + startOffsetPosition);\n", "\n", "mapping.endPosition =\n", "new Position(endPosition.getLineNumber() + offsetLine,\n", "endPosition.getCharacterIndex() + endOffsetPosition);\n", "\n", "mappings.add(mapping);\n", "}\n", "\n", "/**\n", "* Sets the prefix used for wrapping the generated source file before\n", "* it is output. This ensures that the source map is adjusted as\n", "* needed.\n", "*\n", "* @param prefix The prefix that is added before the generated source code.\n", "*/\n", "void setWrapperPrefix(String prefix) {\n", "// Determine the current line and character position.\n", "int prefixLine = 0;\n", "int prefixIndex = 0;\n", "\n", "for (int i = 0; i < prefix.length(); ++i) {\n", "if (prefix.charAt(i) == '\\n') {\n", "prefixLine++;\n", "prefixIndex = 0;\n", "} else {\n", "prefixIndex++;\n", "}\n", "}\n", "\n", "prefixPosition = new Position(prefixLine, prefixIndex);\n", "}\n", "\n", "/**\n", "* Sets the source code that exists in the buffer to which the\n", "* generated code is being generated. This ensures that the source map\n", "* accurately reflects the fact that the source is being appended to\n", "* an existing buffer and as such, does not start at line 0, position 0\n", "* but rather some other line and position.\n", "*\n", "* @param offsetLine The index of the current line being printed.\n", "* @param offsetIndex The column index of the current character being printed.\n", "*/\n", "void setStartingPosition(int offsetLine, int offsetIndex) {\n", "// TODO(johnlenz): correct this.\n", "// Preconditions.checkState(mappings.isEmpty(),\n", "//     \"Must be set prior to adding mappings\");\n", "offsetPosition = new Position(offsetLine, offsetIndex);\n", "}\n", "\n", "/**\n", "* Resets the source map for reuse for the generation of a new source file.\n", "*/\n", "void reset() {\n", "mappings = Lists.newArrayList();\n", "offsetPosition = new Position(0, 0);\n", "prefixPosition = new Position(0, 0);\n", "}\n", "\n", "private int findLastLine() {\n", "int maxLine = 0;\n", "for (Mapping mapping : mappings) {\n", "int endPositionLine = mapping.endPosition.getLineNumber();\n", "maxLine = Math.max(maxLine, endPositionLine);\n", "}\n", "return maxLine + prefixPosition.getLineNumber();\n", "}\n", "/**\n", "* Appends the source map in LavaBug format to the given buffer.\n", "*\n", "* @param out The stream to which the map will be appended.\n", "* @param name The name of the generated source file that this source map\n", "*   represents.\n", "*/\n", "public void appendTo(Appendable out, String name) throws IOException {\n", "// Write the mappings out to the file. The format of the generated\n", "// source map is three sections, each deliminated by a magic comment.\n", "//\n", "// The first section contains an array for each line of the generated\n", "// code, where each element in the array is the ID of the mapping which\n", "// best represents the index-th character found on that line of the\n", "// generated source code.\n", "//\n", "// The second section contains an array per generated line. Unused.\n", "//\n", "// The third and final section contains an array per line, each of which\n", "// represents a mapping with a unique ID. The mappings are added in order.\n", "// The array itself contains a tuple representing\n", "// ['source file', line, col (, 'original name')]\n", "//\n", "// Example for 2 lines of generated code (with line numbers added for\n", "// readability):\n", "//\n", "// 1)  /** Begin line maps. **/{ \"count\": 2 }\n", "// 2)  [0,0,0,0,0,0,1,1,1,1,2]\n", "// 3)  [2,2,2,2,2,2,3,4,4,4,4,4]\n", "// 4)  /** Begin file information. **/\n", "// 5)  []\n", "// 6)  []\n", "// 7)  /** Begin mapping definitions. **/\n", "// 8)  [\"a.js\", 1, 34]\n", "// 9)  [\"a.js\", 5, 2]\n", "// 10) [\"b.js\", 1, 3, \"event\"]\n", "// 11) [\"c.js\", 1, 4]\n", "// 12) [\"d.js\", 3, 78, \"foo\"]\n", "\n", "int maxLine = findLastLine();\n", "\n", "// Add the line character maps.\n", "out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n", "out.append(escapeString(name));\n", "out.append(\", \\\"count\\\": \");\n", "out.append(String.valueOf(maxLine + 1));\n", "out.append(\" }\\n\");\n", "(new LineMapper(out)).appendLineMappings();\n", "\n", "// Add the source file maps.\n", "out.append(\"/** Begin file information. **/\\n\");\n", "\n", "// This section is unused but we need one entry per line to\n", "// prevent changing the format.\n", "for (int i = 0; i <= maxLine; ++i) {\n", "out.append(\"[]\\n\");\n", "}\n", "\n", "// Add the mappings themselves.\n", "out.append(\"/** Begin mapping definitions. **/\\n\");\n", "\n", "for (Mapping mapping : mappings) {\n", "mapping.appendTo(out);\n", "out.append(\"\\n\");\n", "}\n", "}\n", "\n", "/**\n", "* Assigns sequential ids to used mappings, and returns the last line mapped.\n", "*/\n", "// Mark any unused mappings.\n", "\n", "// Renumber used mappings and keep track of the last line.\n", "\n", "// Adjust for the prefix.\n", "\n", "private class LineMapper {\n", "// The destination.\n", "private final Appendable out;\n", "private int line;\n", "private int col;\n", "// Whether the current line has had a value written yet.\n", "private boolean firstChar = true;\n", "\n", "private final static String UNMAPPED_STRING = \"-1\";\n", "\n", "private final static int UNMAPPED = -1;\n", "\n", "LineMapper(Appendable out) {\n", "this.out = out;\n", "}\n", "\n", "/**\n", "* As each segment is visited write out the appropriate line mapping.\n", "*/\n", "\n", "// Prevent the creation of unnecessary temporary stings for often\n", "// repeated values.\n", "\n", "\n", "\n", "// Append the line mapping entries.\n", "void appendLineMappings() throws IOException {\n", "Preconditions.checkState(!mappings.isEmpty());\n", "\n", "// Start the first line.\n", "openLine();\n", "\n", "\n", "// And close the final line.\n", "\n", "/**\n", "* Begin the entry for a new line.\n", "*/\n", "\n", "/**\n", "* End the entry for a line.\n", "*/\n", "\n", "/**\n", "* Add a new char position entry.\n", "* @param id The mapping id to record.\n", "*/\n", "\n", "/**\n", "* Mark any visited mapping as \"used\".\n", "*/\n", "/**\n", "* @throws IOException\n", "*/\n", "\n", "/**\n", "* @param m The mapping for the current code segment. null if the segment\n", "*     is unmapped.\n", "* @param line The starting line for this code segment.\n", "* @param col The starting column for this code segment.\n", "* @param endLine The ending line\n", "* @param endCol The ending column\n", "* @throws IOException\n", "*/\n", "\n", "/**\n", "* Walk the mappings and visit each segment of the mappings, unmapped\n", "* segments are visited with a null mapping, unused mapping are not visited.\n", "*/\n", "// The last line and column written\n", "\n", "\n", "// Append the line mapping entries.\n", "\n", "// The mapping list is ordered as a pre-order traversal.  The mapping\n", "// positions give us enough information to rebuild the stack and this\n", "// allows the building of the source map in O(n) time.\n", "Deque<Mapping> stack = new ArrayDeque<Mapping>();\n", "for (Mapping m : mappings) {\n", "// Find the closest ancestor of the current mapping:\n", "// An overlapping mapping is an ancestor of the current mapping, any\n", "// non-overlapping mappings are siblings (or cousins) and must be\n", "// closed in the reverse order of when they encountered.\n", "while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n", "Mapping previous = stack.pop();\n", "writeClosedMapping(previous);\n", "}\n", "\n", "// Any gaps between the current line position and the start of the\n", "// current mapping belong to the parent.\n", "Mapping parent = stack.peek();\n", "writeCharsBetween(parent, m);\n", "\n", "stack.push(m);\n", "}\n", "\n", "// There are no more children to be had, simply close the remaining\n", "// mappings in the reverse order of when they encountered.\n", "while (!stack.isEmpty()) {\n", "Mapping m = stack.pop();\n", "writeClosedMapping(m);\n", "}\n", "closeLine();\n", "}\n", "private void openLine() throws IOException {\n", "out.append(\"[\");\n", "this.firstChar = true;\n", "}\n", "private void closeLine() throws IOException {\n", "out.append(\"]\\n\");\n", "}\n", "private void addCharEntry(String id) throws IOException {\n", "if (firstChar) {\n", "firstChar = false;\n", "} else {\n", "out.append(\",\");\n", "}\n", "out.append(id);\n", "}\n", "\n", "/**\n", "* @return The line adjusted for the prefix position.\n", "*/\n", "private int getAdjustedLine(Position p) {\n", "return p.getLineNumber() + prefixPosition.getLineNumber();\n", "}\n", "\n", "/**\n", "* @return The column adjusted for the prefix position.\n", "*/\n", "private int getAdjustedCol(Position p) {\n", "int rawLine = p.getLineNumber();\n", "int rawCol = p.getCharacterIndex();\n", "// Only the first line needs the character position adjusted.\n", "return (rawLine != 0)\n", "? rawCol : rawCol + prefixPosition.getCharacterIndex();\n", "}\n", "\n", "/**\n", "* @return Whether m1 ends before m2 starts.\n", "*/\n", "private boolean isOverlapped(Mapping m1, Mapping m2) {\n", "// No need to use adjusted values here, relative positions are sufficient.\n", "int l1 = m1.endPosition.getLineNumber();\n", "int l2 = m2.startPosition.getLineNumber();\n", "int c1 = m1.endPosition.getCharacterIndex();\n", "int c2 = m2.startPosition.getCharacterIndex();\n", "\n", "return (l1 == l2 && c1 >= c2) || l1 > l2;\n", "}\n", "\n", "/**\n", "* Write any needed entries from the current position to the end of the\n", "* provided mapping.\n", "*/\n", "private void writeClosedMapping(Mapping m) throws IOException {\n", "int nextLine = getAdjustedLine(m.endPosition);\n", "int nextCol = getAdjustedCol(m.endPosition);\n", "// If this anything remaining in this mapping beyond the\n", "// current line and column position, write it out now.\n", "if (line < nextLine || (line == nextLine && col < nextCol)) {\n", "writeCharsUpTo(nextLine, nextCol, m.id);\n", "}\n", "}\n", "\n", "/**\n", "* Write any needed entries to complete the provided mapping.\n", "*/\n", "private void writeCharsBetween(Mapping prev, Mapping next)\n", "throws IOException {\n", "int nextLine = getAdjustedLine(next.startPosition);\n", "int nextCol = getAdjustedCol(next.startPosition);\n", "// If the previous value is null, no mapping exists.\n", "int id = (prev != null) ? prev.id : UNMAPPED;\n", "writeCharsUpTo(nextLine, nextCol, id);\n", "}\n", "\n", "/**\n", "* Write any entries needed between the current position the next position\n", "* and update the current position.\n", "*/\n", "private void writeCharsUpTo(\n", "int nextLine, int nextCol, int id)\n", "throws IOException {\n", "Preconditions.checkState(line <= nextLine, \"\");\n", "Preconditions.checkState(line < nextLine || col <= nextCol);\n", "\n", "if (line == nextLine && col == nextCol) {\n", "// Nothing to do.\n", "return;\n", "}\n", "\n", "String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\n", "for (int i = line; i <= nextLine; i++) {\n", "if (i == nextLine) {\n", "for (int j = col; j < nextCol; j++) {\n", "addCharEntry(idString);\n", "}\n", "break;\n", "}\n", "closeLine();\n", "openLine();\n", "}\n", "\n", "line = nextLine;\n", "col = nextCol;\n", "}\n", "}\n", "}\n"], "faulty_lines": [3], "cluster": 3}, {"pid": "Closure", "bid": 148, "method_path": "./dataset/Closure/148/SourceMap.java", "method": ["public class SourceMap {\n", "\n", "\n", "/**\n", "* A mapping from a given position in an input source file to a given position\n", "* in the generated code.\n", "*/\n", "static class Mapping {\n", "/**\n", "* A unique ID for this mapping for record keeping purposes.\n", "*/\n", "int id;\n", "\n", "/**\n", "* The input source file.\n", "*/\n", "String sourceFile;\n", "\n", "/**\n", "* The position of the code in the input source file. Both\n", "* the line number and the character index are indexed by\n", "* 1 for legacy reasons via the Rhino Node class.\n", "*/\n", "Position originalPosition;\n", "\n", "/**\n", "* The starting position of the code in the generated source\n", "* file which this mapping represents. Indexed by 0.\n", "*/\n", "Position startPosition;\n", "\n", "/**\n", "* The ending position of the code in the generated source\n", "* file which this mapping represents. Indexed by 0.\n", "*/\n", "Position endPosition;\n", "\n", "/**\n", "* The original name of the token found at the position\n", "* represented by this mapping (if any).\n", "*/\n", "String originalName;\n", "\n", "/**\n", "* Whether the mapping is actually used by the source map.\n", "*/\n", "\n", "/**\n", "* Cache of escaped source file name.\n", "*/\n", "\n", "/**\n", "* Appends the mapping to the given buffer.\n", "*/\n", "void appendTo(Appendable out) throws IOException {\n", "out.append(\"[\");\n", "\n", "out.append(sourceFile);\n", "// The source file rarely changes, so cache the escaped string.\n", "\n", "out.append(\",\");\n", "\n", "\n", "out.append(String.valueOf(originalPosition.getLineNumber()));\n", "\n", "out.append(\",\");\n", "out.append(String.valueOf(originalPosition.getCharacterIndex()));\n", "\n", "if (originalName != null) {\n", "out.append(\",\");\n", "out.append(originalName);\n", "}\n", "\n", "out.append(\"]\");\n", "}\n", "/**\n", "* Add used mappings to the supplied Appendable.\n", "*/\n", "}\n", "\n", "/**\n", "* A pre-order traversal ordered list of mappings stored in this map.\n", "*/\n", "private List<Mapping> mappings = Lists.newArrayList();\n", "\n", "/**\n", "* The position that the current source map is offset in the\n", "* buffer being used to generated the compiled source file.\n", "*/\n", "private Position offsetPosition = new Position(0, 0);\n", "\n", "/**\n", "* The position that the current source map is offset in the\n", "* generated the compiled source file by the addition of a\n", "* an output wrapper prefix.\n", "*/\n", "private Position prefixPosition = new Position(0, 0);\n", "\n", "/**\n", "* Escapes the given string for JSON.\n", "*/\n", "private static String escapeString(String value) {\n", "return CodeGenerator.escapeToDoubleQuotedJsString(value);\n", "}\n", "private String lastSourceFile = null;\n", "private String lastSourceFileEscaped = null;\n", "\n", "/**\n", "* Adds a mapping for the given node.  Mappings must be added in order.\n", "*\n", "* @param node The node that the new mapping represents.\n", "* @param startPosition The position on the starting line\n", "* @param endPosition The position on the ending line.\n", "*/\n", "void addMapping(Node node, Position startPosition, Position endPosition) {\n", "String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);\n", "\n", "// If the node does not have an associated source file or\n", "// its line number is -1, then the node does not have sufficient\n", "// information for a mapping to be useful.\n", "if (sourceFile == null || node.getLineno() < 0) {\n", "return;\n", "}\n", "\n", "String escapedSourceFile;\n", "if (lastSourceFile != sourceFile) {  // yes, \"s1 != s2\" not \"!s1.equals(s2)\"\n", "lastSourceFile = sourceFile;\n", "lastSourceFileEscaped = escapeString(sourceFile);\n", "}\n", "escapedSourceFile = lastSourceFileEscaped;\n", "// Create the new mapping.\n", "Mapping mapping = new Mapping();\n", "mapping.id = mappings.size();\n", "mapping.sourceFile = escapedSourceFile;\n", "mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n", "\n", "String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);\n", "if (originalName != null) {\n", "mapping.originalName = escapeString(originalName);\n", "}\n", "\n", "// If the mapping is found on the first line, we need to offset\n", "// its character position by the number of characters found on\n", "// the *last* line of the source file to which the code is\n", "// being generated.\n", "int offsetLine = offsetPosition.getLineNumber();\n", "int startOffsetPosition = offsetPosition.getCharacterIndex();\n", "int endOffsetPosition = offsetPosition.getCharacterIndex();\n", "\n", "if (startPosition.getLineNumber() > 0) {\n", "startOffsetPosition = 0;\n", "}\n", "\n", "if (endPosition.getLineNumber() > 0) {\n", "endOffsetPosition = 0;\n", "}\n", "\n", "mapping.startPosition =\n", "new Position(startPosition.getLineNumber() + offsetLine,\n", "startPosition.getCharacterIndex() + startOffsetPosition);\n", "\n", "mapping.endPosition =\n", "new Position(endPosition.getLineNumber() + offsetLine,\n", "endPosition.getCharacterIndex() + endOffsetPosition);\n", "\n", "mappings.add(mapping);\n", "}\n", "\n", "/**\n", "* Sets the prefix used for wrapping the generated source file before\n", "* it is output. This ensures that the source map is adjusted as\n", "* needed.\n", "*\n", "* @param prefix The prefix that is added before the generated source code.\n", "*/\n", "void setWrapperPrefix(String prefix) {\n", "// Determine the current line and character position.\n", "int prefixLine = 0;\n", "int prefixIndex = 0;\n", "\n", "for (int i = 0; i < prefix.length(); ++i) {\n", "if (prefix.charAt(i) == '\\n') {\n", "prefixLine++;\n", "prefixIndex = 0;\n", "} else {\n", "prefixIndex++;\n", "}\n", "}\n", "\n", "prefixPosition = new Position(prefixLine, prefixIndex);\n", "}\n", "\n", "/**\n", "* Sets the source code that exists in the buffer to which the\n", "* generated code is being generated. This ensures that the source map\n", "* accurately reflects the fact that the source is being appended to\n", "* an existing buffer and as such, does not start at line 0, position 0\n", "* but rather some other line and position.\n", "*\n", "* @param offsetLine The index of the current line being printed.\n", "* @param offsetIndex The column index of the current character being printed.\n", "*/\n", "void setStartingPosition(int offsetLine, int offsetIndex) {\n", "// TODO(johnlenz): correct this.\n", "// Preconditions.checkState(mappings.isEmpty(),\n", "//     \"Must be set prior to adding mappings\");\n", "offsetPosition = new Position(offsetLine, offsetIndex);\n", "}\n", "\n", "/**\n", "* Resets the source map for reuse for the generation of a new source file.\n", "*/\n", "void reset() {\n", "mappings = Lists.newArrayList();\n", "offsetPosition = new Position(0, 0);\n", "prefixPosition = new Position(0, 0);\n", "}\n", "\n", "private int findLastLine() {\n", "int maxLine = 0;\n", "for (Mapping mapping : mappings) {\n", "int endPositionLine = mapping.endPosition.getLineNumber();\n", "maxLine = Math.max(maxLine, endPositionLine);\n", "}\n", "return maxLine + prefixPosition.getLineNumber();\n", "}\n", "/**\n", "* Appends the source map in LavaBug format to the given buffer.\n", "*\n", "* @param out The stream to which the map will be appended.\n", "* @param name The name of the generated source file that this source map\n", "*   represents.\n", "*/\n", "public void appendTo(Appendable out, String name) throws IOException {\n", "// Write the mappings out to the file. The format of the generated\n", "// source map is three sections, each deliminated by a magic comment.\n", "//\n", "// The first section contains an array for each line of the generated\n", "// code, where each element in the array is the ID of the mapping which\n", "// best represents the index-th character found on that line of the\n", "// generated source code.\n", "//\n", "// The second section contains an array per generated line. Unused.\n", "//\n", "// The third and final section contains an array per line, each of which\n", "// represents a mapping with a unique ID. The mappings are added in order.\n", "// The array itself contains a tuple representing\n", "// ['source file', line, col (, 'original name')]\n", "//\n", "// Example for 2 lines of generated code (with line numbers added for\n", "// readability):\n", "//\n", "// 1)  /** Begin line maps. **/{ \"count\": 2 }\n", "// 2)  [0,0,0,0,0,0,1,1,1,1,2]\n", "// 3)  [2,2,2,2,2,2,3,4,4,4,4,4]\n", "// 4)  /** Begin file information. **/\n", "// 5)  []\n", "// 6)  []\n", "// 7)  /** Begin mapping definitions. **/\n", "// 8)  [\"a.js\", 1, 34]\n", "// 9)  [\"a.js\", 5, 2]\n", "// 10) [\"b.js\", 1, 3, \"event\"]\n", "// 11) [\"c.js\", 1, 4]\n", "// 12) [\"d.js\", 3, 78, \"foo\"]\n", "\n", "int maxLine = findLastLine();\n", "\n", "// Add the line character maps.\n", "out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n", "out.append(escapeString(name));\n", "out.append(\", \\\"count\\\": \");\n", "out.append(String.valueOf(maxLine + 1));\n", "out.append(\" }\\n\");\n", "(new LineMapper(out)).appendLineMappings();\n", "\n", "// Add the source file maps.\n", "out.append(\"/** Begin file information. **/\\n\");\n", "\n", "// This section is unused but we need one entry per line to\n", "// prevent changing the format.\n", "for (int i = 0; i <= maxLine; ++i) {\n", "out.append(\"[]\\n\");\n", "}\n", "\n", "// Add the mappings themselves.\n", "out.append(\"/** Begin mapping definitions. **/\\n\");\n", "\n", "for (Mapping mapping : mappings) {\n", "mapping.appendTo(out);\n", "out.append(\"\\n\");\n", "}\n", "}\n", "\n", "/**\n", "* Assigns sequential ids to used mappings, and returns the last line mapped.\n", "*/\n", "// Mark any unused mappings.\n", "\n", "// Renumber used mappings and keep track of the last line.\n", "\n", "// Adjust for the prefix.\n", "\n", "private class LineMapper {\n", "// The destination.\n", "private final Appendable out;\n", "private int line;\n", "private int col;\n", "// Whether the current line has had a value written yet.\n", "private boolean firstChar = true;\n", "\n", "private final static String UNMAPPED_STRING = \"-1\";\n", "\n", "private final static int UNMAPPED = -1;\n", "\n", "LineMapper(Appendable out) {\n", "this.out = out;\n", "}\n", "\n", "/**\n", "* As each segment is visited write out the appropriate line mapping.\n", "*/\n", "\n", "// Prevent the creation of unnecessary temporary stings for often\n", "// repeated values.\n", "\n", "\n", "\n", "// Append the line mapping entries.\n", "void appendLineMappings() throws IOException {\n", "Preconditions.checkState(!mappings.isEmpty());\n", "\n", "// Start the first line.\n", "openLine();\n", "\n", "\n", "// And close the final line.\n", "\n", "/**\n", "* Begin the entry for a new line.\n", "*/\n", "\n", "/**\n", "* End the entry for a line.\n", "*/\n", "\n", "/**\n", "* Add a new char position entry.\n", "* @param id The mapping id to record.\n", "*/\n", "\n", "/**\n", "* Mark any visited mapping as \"used\".\n", "*/\n", "/**\n", "* @throws IOException\n", "*/\n", "\n", "/**\n", "* @param m The mapping for the current code segment. null if the segment\n", "*     is unmapped.\n", "* @param line The starting line for this code segment.\n", "* @param col The starting column for this code segment.\n", "* @param endLine The ending line\n", "* @param endCol The ending column\n", "* @throws IOException\n", "*/\n", "\n", "/**\n", "* Walk the mappings and visit each segment of the mappings, unmapped\n", "* segments are visited with a null mapping, unused mapping are not visited.\n", "*/\n", "// The last line and column written\n", "\n", "\n", "// Append the line mapping entries.\n", "\n", "// The mapping list is ordered as a pre-order traversal.  The mapping\n", "// positions give us enough information to rebuild the stack and this\n", "// allows the building of the source map in O(n) time.\n", "Deque<Mapping> stack = new ArrayDeque<Mapping>();\n", "for (Mapping m : mappings) {\n", "// Find the closest ancestor of the current mapping:\n", "// An overlapping mapping is an ancestor of the current mapping, any\n", "// non-overlapping mappings are siblings (or cousins) and must be\n", "// closed in the reverse order of when they encountered.\n", "while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n", "Mapping previous = stack.pop();\n", "writeClosedMapping(previous);\n", "}\n", "\n", "// Any gaps between the current line position and the start of the\n", "// current mapping belong to the parent.\n", "Mapping parent = stack.peek();\n", "writeCharsBetween(parent, m);\n", "\n", "stack.push(m);\n", "}\n", "\n", "// There are no more children to be had, simply close the remaining\n", "// mappings in the reverse order of when they encountered.\n", "while (!stack.isEmpty()) {\n", "Mapping m = stack.pop();\n", "writeClosedMapping(m);\n", "}\n", "closeLine();\n", "}\n", "private void openLine() throws IOException {\n", "out.append(\"[\");\n", "this.firstChar = true;\n", "}\n", "private void closeLine() throws IOException {\n", "out.append(\"]\\n\");\n", "}\n", "private void addCharEntry(String id) throws IOException {\n", "if (firstChar) {\n", "firstChar = false;\n", "} else {\n", "out.append(\",\");\n", "}\n", "out.append(id);\n", "}\n", "\n", "/**\n", "* @return The line adjusted for the prefix position.\n", "*/\n", "private int getAdjustedLine(Position p) {\n", "return p.getLineNumber() + prefixPosition.getLineNumber();\n", "}\n", "\n", "/**\n", "* @return The column adjusted for the prefix position.\n", "*/\n", "private int getAdjustedCol(Position p) {\n", "int rawLine = p.getLineNumber();\n", "int rawCol = p.getCharacterIndex();\n", "// Only the first line needs the character position adjusted.\n", "return (rawLine != 0)\n", "? rawCol : rawCol + prefixPosition.getCharacterIndex();\n", "}\n", "\n", "/**\n", "* @return Whether m1 ends before m2 starts.\n", "*/\n", "private boolean isOverlapped(Mapping m1, Mapping m2) {\n", "// No need to use adjusted values here, relative positions are sufficient.\n", "int l1 = m1.endPosition.getLineNumber();\n", "int l2 = m2.startPosition.getLineNumber();\n", "int c1 = m1.endPosition.getCharacterIndex();\n", "int c2 = m2.startPosition.getCharacterIndex();\n", "\n", "return (l1 == l2 && c1 >= c2) || l1 > l2;\n", "}\n", "\n", "/**\n", "* Write any needed entries from the current position to the end of the\n", "* provided mapping.\n", "*/\n", "private void writeClosedMapping(Mapping m) throws IOException {\n", "int nextLine = getAdjustedLine(m.endPosition);\n", "int nextCol = getAdjustedCol(m.endPosition);\n", "// If this anything remaining in this mapping beyond the\n", "// current line and column position, write it out now.\n", "if (line < nextLine || (line == nextLine && col < nextCol)) {\n", "writeCharsUpTo(nextLine, nextCol, m.id);\n", "}\n", "}\n", "\n", "/**\n", "* Write any needed entries to complete the provided mapping.\n", "*/\n", "private void writeCharsBetween(Mapping prev, Mapping next)\n", "throws IOException {\n", "int nextLine = getAdjustedLine(next.startPosition);\n", "int nextCol = getAdjustedCol(next.startPosition);\n", "// If the previous value is null, no mapping exists.\n", "int id = (prev != null) ? prev.id : UNMAPPED;\n", "writeCharsUpTo(nextLine, nextCol, id);\n", "}\n", "\n", "/**\n", "* Write any entries needed between the current position the next position\n", "* and update the current position.\n", "*/\n", "private void writeCharsUpTo(\n", "int nextLine, int nextCol, int id)\n", "throws IOException {\n", "Preconditions.checkState(line <= nextLine, \"\");\n", "Preconditions.checkState(line < nextLine || col <= nextCol);\n", "\n", "if (line == nextLine && col == nextCol) {\n", "// Nothing to do.\n", "return;\n", "}\n", "\n", "String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\n", "for (int i = line; i <= nextLine; i++) {\n", "if (i == nextLine) {\n", "for (int j = col; j < nextCol; j++) {\n", "addCharEntry(idString);\n", "}\n", "break;\n", "}\n", "closeLine();\n", "openLine();\n", "}\n", "\n", "line = nextLine;\n", "col = nextCol;\n", "}\n", "}\n", "}\n"], "faulty_lines": [12], "cluster": 3}, {"pid": "Closure", "bid": 148, "method_path": "./dataset/Closure/148/SourceMap.java", "method": ["void addMapping(Node node, Position startPosition, Position endPosition) {\n", "String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);\n", "\n", "// If the node does not have an associated source file or\n", "// its line number is -1, then the node does not have sufficient\n", "// information for a mapping to be useful.\n", "if (sourceFile == null || node.getLineno() < 0) {\n", "return;\n", "}\n", "\n", "String escapedSourceFile;\n", "if (lastSourceFile != sourceFile) {  // yes, \"s1 != s2\" not \"!s1.equals(s2)\"\n", "lastSourceFile = sourceFile;\n", "lastSourceFileEscaped = escapeString(sourceFile);\n", "}\n", "escapedSourceFile = lastSourceFileEscaped;\n", "// Create the new mapping.\n", "Mapping mapping = new Mapping();\n", "mapping.id = mappings.size();\n", "mapping.sourceFile = escapedSourceFile;\n", "mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n", "\n", "String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);\n", "if (originalName != null) {\n", "mapping.originalName = escapeString(originalName);\n", "}\n", "\n", "// If the mapping is found on the first line, we need to offset\n", "// its character position by the number of characters found on\n", "// the *last* line of the source file to which the code is\n", "// being generated.\n", "int offsetLine = offsetPosition.getLineNumber();\n", "int startOffsetPosition = offsetPosition.getCharacterIndex();\n", "int endOffsetPosition = offsetPosition.getCharacterIndex();\n", "\n", "if (startPosition.getLineNumber() > 0) {\n", "startOffsetPosition = 0;\n", "}\n", "\n", "if (endPosition.getLineNumber() > 0) {\n", "endOffsetPosition = 0;\n", "}\n", "\n", "mapping.startPosition =\n", "new Position(startPosition.getLineNumber() + offsetLine,\n", "startPosition.getCharacterIndex() + startOffsetPosition);\n", "\n", "mapping.endPosition =\n", "new Position(endPosition.getLineNumber() + offsetLine,\n", "endPosition.getCharacterIndex() + endOffsetPosition);\n", "\n", "mappings.add(mapping);\n", "}\n"], "faulty_lines": [11, 12, 13, 14, 15, 16, 19, 20, 25, 28], "cluster": 3}, {"pid": "Closure", "bid": 148, "method_path": "./dataset/Closure/148/SourceMap.java", "method": ["void addMapping(Node node, Position startPosition, Position endPosition) {\n", "String sourceFile = (String)node.getProp(Node.SOURCEFILE_PROP);\n", "\n", "// If the node does not have an associated source file or\n", "// its line number is -1, then the node does not have sufficient\n", "// information for a mapping to be useful.\n", "if (sourceFile == null || node.getLineno() < 0) {\n", "return;\n", "}\n", "\n", "String escapedSourceFile;\n", "if (lastSourceFile != sourceFile) {  // yes, \"s1 != s2\" not \"!s1.equals(s2)\"\n", "lastSourceFile = sourceFile;\n", "lastSourceFileEscaped = escapeString(sourceFile);\n", "}\n", "escapedSourceFile = lastSourceFileEscaped;\n", "// Create the new mapping.\n", "Mapping mapping = new Mapping();\n", "mapping.id = mappings.size();\n", "mapping.sourceFile = escapedSourceFile;\n", "mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n", "\n", "String originalName = (String)node.getProp(Node.ORIGINALNAME_PROP);\n", "if (originalName != null) {\n", "mapping.originalName = escapeString(originalName);\n", "}\n", "\n", "// If the mapping is found on the first line, we need to offset\n", "// its character position by the number of characters found on\n", "// the *last* line of the source file to which the code is\n", "// being generated.\n", "int offsetLine = offsetPosition.getLineNumber();\n", "int startOffsetPosition = offsetPosition.getCharacterIndex();\n", "int endOffsetPosition = offsetPosition.getCharacterIndex();\n", "\n", "if (startPosition.getLineNumber() > 0) {\n", "startOffsetPosition = 0;\n", "}\n", "\n", "if (endPosition.getLineNumber() > 0) {\n", "endOffsetPosition = 0;\n", "}\n", "\n", "mapping.startPosition =\n", "new Position(startPosition.getLineNumber() + offsetLine,\n", "startPosition.getCharacterIndex() + startOffsetPosition);\n", "\n", "mapping.endPosition =\n", "new Position(endPosition.getLineNumber() + offsetLine,\n", "endPosition.getCharacterIndex() + endOffsetPosition);\n", "\n", "mappings.add(mapping);\n", "}\n"], "faulty_lines": [51], "cluster": 3}, {"pid": "Closure", "bid": 148, "method_path": "./dataset/Closure/148/SourceMap.java", "method": ["public void appendTo(Appendable out, String name) throws IOException {\n", "// Write the mappings out to the file. The format of the generated\n", "// source map is three sections, each deliminated by a magic comment.\n", "//\n", "// The first section contains an array for each line of the generated\n", "// code, where each element in the array is the ID of the mapping which\n", "// best represents the index-th character found on that line of the\n", "// generated source code.\n", "//\n", "// The second section contains an array per generated line. Unused.\n", "//\n", "// The third and final section contains an array per line, each of which\n", "// represents a mapping with a unique ID. The mappings are added in order.\n", "// The array itself contains a tuple representing\n", "// ['source file', line, col (, 'original name')]\n", "//\n", "// Example for 2 lines of generated code (with line numbers added for\n", "// readability):\n", "//\n", "// 1)  /** Begin line maps. **/{ \"count\": 2 }\n", "// 2)  [0,0,0,0,0,0,1,1,1,1,2]\n", "// 3)  [2,2,2,2,2,2,3,4,4,4,4,4]\n", "// 4)  /** Begin file information. **/\n", "// 5)  []\n", "// 6)  []\n", "// 7)  /** Begin mapping definitions. **/\n", "// 8)  [\"a.js\", 1, 34]\n", "// 9)  [\"a.js\", 5, 2]\n", "// 10) [\"b.js\", 1, 3, \"event\"]\n", "// 11) [\"c.js\", 1, 4]\n", "// 12) [\"d.js\", 3, 78, \"foo\"]\n", "\n", "int maxLine = findLastLine();\n", "\n", "// Add the line character maps.\n", "out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n", "out.append(escapeString(name));\n", "out.append(\", \\\"count\\\": \");\n", "out.append(String.valueOf(maxLine + 1));\n", "out.append(\" }\\n\");\n", "(new LineMapper(out)).appendLineMappings();\n", "\n", "// Add the source file maps.\n", "out.append(\"/** Begin file information. **/\\n\");\n", "\n", "// This section is unused but we need one entry per line to\n", "// prevent changing the format.\n", "for (int i = 0; i <= maxLine; ++i) {\n", "out.append(\"[]\\n\");\n", "}\n", "\n", "// Add the mappings themselves.\n", "out.append(\"/** Begin mapping definitions. **/\\n\");\n", "\n", "for (Mapping mapping : mappings) {\n", "mapping.appendTo(out);\n", "out.append(\"\\n\");\n", "}\n", "}\n"], "faulty_lines": [33], "cluster": 3}, {"pid": "Closure", "bid": 148, "method_path": "./dataset/Closure/148/SourceMap.java", "method": ["void appendLineMappings() throws IOException {\n", "Preconditions.checkState(!mappings.isEmpty());\n", "\n", "// Start the first line.\n", "openLine();\n", "\n", "\n", "// And close the final line.\n", "\n", "/**\n", "* Begin the entry for a new line.\n", "*/\n", "\n", "/**\n", "* End the entry for a line.\n", "*/\n", "\n", "/**\n", "* Add a new char position entry.\n", "* @param id The mapping id to record.\n", "*/\n", "\n", "/**\n", "* Mark any visited mapping as \"used\".\n", "*/\n", "/**\n", "* @throws IOException\n", "*/\n", "\n", "/**\n", "* @param m The mapping for the current code segment. null if the segment\n", "*     is unmapped.\n", "* @param line The starting line for this code segment.\n", "* @param col The starting column for this code segment.\n", "* @param endLine The ending line\n", "* @param endCol The ending column\n", "* @throws IOException\n", "*/\n", "\n", "/**\n", "* Walk the mappings and visit each segment of the mappings, unmapped\n", "* segments are visited with a null mapping, unused mapping are not visited.\n", "*/\n", "// The last line and column written\n", "\n", "\n", "// Append the line mapping entries.\n", "\n", "// The mapping list is ordered as a pre-order traversal.  The mapping\n", "// positions give us enough information to rebuild the stack and this\n", "// allows the building of the source map in O(n) time.\n", "Deque<Mapping> stack = new ArrayDeque<Mapping>();\n", "for (Mapping m : mappings) {\n", "// Find the closest ancestor of the current mapping:\n", "// An overlapping mapping is an ancestor of the current mapping, any\n", "// non-overlapping mappings are siblings (or cousins) and must be\n", "// closed in the reverse order of when they encountered.\n", "while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n", "Mapping previous = stack.pop();\n", "writeClosedMapping(previous);\n", "}\n", "\n", "// Any gaps between the current line position and the start of the\n", "// current mapping belong to the parent.\n", "Mapping parent = stack.peek();\n", "writeCharsBetween(parent, m);\n", "\n", "stack.push(m);\n", "}\n", "\n", "// There are no more children to be had, simply close the remaining\n", "// mappings in the reverse order of when they encountered.\n", "while (!stack.isEmpty()) {\n", "Mapping m = stack.pop();\n", "writeClosedMapping(m);\n", "}\n", "closeLine();\n", "}\n"], "faulty_lines": [7, 9, 13, 17, 22, 26, 29, 30], "cluster": 3}, {"pid": "Closure", "bid": 148, "method_path": "./dataset/Closure/148/SourceMap.java", "method": ["void appendLineMappings() throws IOException {\n", "Preconditions.checkState(!mappings.isEmpty());\n", "\n", "// Start the first line.\n", "openLine();\n", "\n", "\n", "// And close the final line.\n", "\n", "/**\n", "* Begin the entry for a new line.\n", "*/\n", "\n", "/**\n", "* End the entry for a line.\n", "*/\n", "\n", "/**\n", "* Add a new char position entry.\n", "* @param id The mapping id to record.\n", "*/\n", "\n", "/**\n", "* Mark any visited mapping as \"used\".\n", "*/\n", "/**\n", "* @throws IOException\n", "*/\n", "\n", "/**\n", "* @param m The mapping for the current code segment. null if the segment\n", "*     is unmapped.\n", "* @param line The starting line for this code segment.\n", "* @param col The starting column for this code segment.\n", "* @param endLine The ending line\n", "* @param endCol The ending column\n", "* @throws IOException\n", "*/\n", "\n", "/**\n", "* Walk the mappings and visit each segment of the mappings, unmapped\n", "* segments are visited with a null mapping, unused mapping are not visited.\n", "*/\n", "// The last line and column written\n", "\n", "\n", "// Append the line mapping entries.\n", "\n", "// The mapping list is ordered as a pre-order traversal.  The mapping\n", "// positions give us enough information to rebuild the stack and this\n", "// allows the building of the source map in O(n) time.\n", "Deque<Mapping> stack = new ArrayDeque<Mapping>();\n", "for (Mapping m : mappings) {\n", "// Find the closest ancestor of the current mapping:\n", "// An overlapping mapping is an ancestor of the current mapping, any\n", "// non-overlapping mappings are siblings (or cousins) and must be\n", "// closed in the reverse order of when they encountered.\n", "while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n", "Mapping previous = stack.pop();\n", "writeClosedMapping(previous);\n", "}\n", "\n", "// Any gaps between the current line position and the start of the\n", "// current mapping belong to the parent.\n", "Mapping parent = stack.peek();\n", "writeCharsBetween(parent, m);\n", "\n", "stack.push(m);\n", "}\n", "\n", "// There are no more children to be had, simply close the remaining\n", "// mappings in the reverse order of when they encountered.\n", "while (!stack.isEmpty()) {\n", "Mapping m = stack.pop();\n", "writeClosedMapping(m);\n", "}\n", "closeLine();\n", "}\n"], "faulty_lines": [39, 44, 45, 46, 48], "cluster": 3}, {"pid": "Closure", "bid": 148, "method_path": "./dataset/Closure/148/SourceMap.java", "method": ["void appendLineMappings() throws IOException {\n", "Preconditions.checkState(!mappings.isEmpty());\n", "\n", "// Start the first line.\n", "openLine();\n", "\n", "\n", "// And close the final line.\n", "\n", "/**\n", "* Begin the entry for a new line.\n", "*/\n", "\n", "/**\n", "* End the entry for a line.\n", "*/\n", "\n", "/**\n", "* Add a new char position entry.\n", "* @param id The mapping id to record.\n", "*/\n", "\n", "/**\n", "* Mark any visited mapping as \"used\".\n", "*/\n", "/**\n", "* @throws IOException\n", "*/\n", "\n", "/**\n", "* @param m The mapping for the current code segment. null if the segment\n", "*     is unmapped.\n", "* @param line The starting line for this code segment.\n", "* @param col The starting column for this code segment.\n", "* @param endLine The ending line\n", "* @param endCol The ending column\n", "* @throws IOException\n", "*/\n", "\n", "/**\n", "* Walk the mappings and visit each segment of the mappings, unmapped\n", "* segments are visited with a null mapping, unused mapping are not visited.\n", "*/\n", "// The last line and column written\n", "\n", "\n", "// Append the line mapping entries.\n", "\n", "// The mapping list is ordered as a pre-order traversal.  The mapping\n", "// positions give us enough information to rebuild the stack and this\n", "// allows the building of the source map in O(n) time.\n", "Deque<Mapping> stack = new ArrayDeque<Mapping>();\n", "for (Mapping m : mappings) {\n", "// Find the closest ancestor of the current mapping:\n", "// An overlapping mapping is an ancestor of the current mapping, any\n", "// non-overlapping mappings are siblings (or cousins) and must be\n", "// closed in the reverse order of when they encountered.\n", "while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n", "Mapping previous = stack.pop();\n", "writeClosedMapping(previous);\n", "}\n", "\n", "// Any gaps between the current line position and the start of the\n", "// current mapping belong to the parent.\n", "Mapping parent = stack.peek();\n", "writeCharsBetween(parent, m);\n", "\n", "stack.push(m);\n", "}\n", "\n", "// There are no more children to be had, simply close the remaining\n", "// mappings in the reverse order of when they encountered.\n", "while (!stack.isEmpty()) {\n", "Mapping m = stack.pop();\n", "writeClosedMapping(m);\n", "}\n", "closeLine();\n", "}\n"], "faulty_lines": [60, 66], "cluster": 3}, {"pid": "Closure", "bid": 149, "method_path": "./dataset/Closure/149/AbstractCommandLineRunner.java", "method": ["protected int doRun() throws FlagUsageException, IOException {\n", "Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n", "\n", "List<JSSourceFile> externsList = createExterns();\n", "JSSourceFile[] externs = new JSSourceFile[externsList.size()];\n", "externsList.toArray(externs);\n", "\n", "compiler = createCompiler();\n", "B options = createOptions();\n", "\n", "JSModule[] modules = null;\n", "Result result;\n", "\n", "setRunOptions(options);\n", "if (inputCharset == Charsets.UTF_8) {\n", "options.outputCharset = Charsets.US_ASCII;\n", "} else {\n", "options.outputCharset = inputCharset;\n", "}\n", "\n", "boolean writeOutputToFile = !options.jsOutputFile.isEmpty();\n", "if (writeOutputToFile) {\n", "out = toWriter(options.jsOutputFile, inputCharset.name());\n", "}\n", "\n", "List<String> jsFiles = config.js;\n", "List<String> moduleSpecs = config.module;\n", "if (!moduleSpecs.isEmpty()) {\n", "modules = createJsModules(moduleSpecs, jsFiles);\n", "result = compiler.compile(externs, modules, options);\n", "} else {\n", "List<JSSourceFile> inputList = createSourceInputs(jsFiles);\n", "JSSourceFile[] inputs = new JSSourceFile[inputList.size()];\n", "inputList.toArray(inputs);\n", "result = compiler.compile(externs, inputs, options);\n", "}\n", "\n", "int errCode = processResults(result, modules, options);\n", "// Close the output if we are writing to a file.\n", "if (writeOutputToFile) {\n", "((Writer)out).close();\n", "}\n", "return errCode;\n", "}\n"], "faulty_lines": [15, 16, 17, 18, 19], "cluster": 5}, {"pid": "Closure", "bid": 149, "method_path": "./dataset/Closure/149/CommandLineRunner.java", "method": ["protected CompilerOptions createOptions() {\n", "CompilerOptions options = new CompilerOptions();\n", "options.setCodingConvention(new ClosureCodingConvention());\n", "CompilationLevel level = flags.compilation_level;\n", "level.setOptionsForCompilationLevel(options);\n", "if (flags.debug) {\n", "level.setDebugOptionsForCompilationLevel(options);\n", "}\n", "\n", "WarningLevel wLevel = flags.warning_level;\n", "wLevel.setOptionsForWarningLevel(options);\n", "for (FormattingOption formattingOption : flags.formatting) {\n", "formattingOption.applyToOptions(options);\n", "}\n", "\n", "options.closurePass = flags.process_closure_primitives;\n", "initOptionsFromFlags(options);\n", "return options;\n", "}\n"], "faulty_lines": [17], "cluster": 2}, {"pid": "Closure", "bid": 149, "method_path": "./dataset/Closure/149/Compiler.java", "method": ["private String toSource(Node n, SourceMap sourceMap) {\n", "CodePrinter.Builder builder = new CodePrinter.Builder(n);\n", "builder.setPrettyPrint(options.prettyPrint);\n", "builder.setLineBreak(options.lineBreak);\n", "builder.setSourceMap(sourceMap);\n", "builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n", "\n", "Charset charset = options.outputCharset;\n", "builder.setOutputCharset(charset);\n", "\n", "return builder.build();\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Closure", "bid": 151, "method_path": "./dataset/Closure/151/CommandLineRunner.java", "method": ["private void initConfigFromFlags(String[] args, PrintStream err) {\n", "// Args4j has a different format that the old command-line parser.\n", "// So we use some voodoo to get the args into the format that args4j\n", "// expects.\n", "Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n", "Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n", "List<String> processedArgs = Lists.newArrayList();\n", "for (String arg : args) {\n", "Matcher matcher = argPattern.matcher(arg);\n", "if (matcher.matches()) {\n", "processedArgs.add(matcher.group(1));\n", "\n", "String value = matcher.group(2);\n", "Matcher quotesMatcher = quotesPattern.matcher(value);\n", "if (quotesMatcher.matches()) {\n", "processedArgs.add(quotesMatcher.group(1));\n", "} else {\n", "processedArgs.add(value);\n", "}\n", "} else {\n", "processedArgs.add(arg);\n", "}\n", "}\n", "\n", "CmdLineParser parser = new CmdLineParser(flags);\n", "isConfigValid = true;\n", "try {\n", "parser.parseArgument(processedArgs.toArray(new String[] {}));\n", "} catch (CmdLineException e) {\n", "err.println(e.getMessage());\n", "isConfigValid = false;\n", "}\n", "\n", "\n", "if (!isConfigValid || flags.display_help) {\n", "isConfigValid = false;\n", "parser.printUsage(err);\n", "} else {\n", "getCommandLineConfig()\n", ".setPrintTree(flags.print_tree)\n", ".setComputePhaseOrdering(flags.compute_phase_ordering)\n", ".setPrintAst(flags.print_ast)\n", ".setPrintPassGraph(flags.print_pass_graph)\n", ".setJscompDevMode(flags.jscomp_dev_mode)\n", ".setLoggingLevel(flags.logging_level)\n", ".setExterns(flags.externs)\n", ".setJs(flags.js)\n", ".setJsOutputFile(flags.js_output_file)\n", ".setModule(flags.module)\n", ".setVariableMapInputFile(flags.variable_map_input_file)\n", ".setPropertyMapInputFile(flags.property_map_input_file)\n", ".setVariableMapOutputFile(flags.variable_map_output_file)\n", ".setCreateNameMapFiles(flags.create_name_map_files)\n", ".setPropertyMapOutputFile(flags.property_map_output_file)\n", ".setCodingConvention(flags.third_party ?\n", "new DefaultCodingConvention() :\n", "new ClosureCodingConvention())\n", ".setSummaryDetailLevel(flags.summary_detail_level)\n", ".setOutputWrapper(flags.output_wrapper)\n", ".setOutputWrapperMarker(flags.output_wrapper_marker)\n", ".setModuleWrapper(flags.module_wrapper)\n", ".setModuleOutputPathPrefix(flags.module_output_path_prefix)\n", ".setCreateSourceMap(flags.create_source_map)\n", ".setJscompError(flags.jscomp_error)\n", ".setJscompWarning(flags.jscomp_warning)\n", ".setJscompOff(flags.jscomp_off)\n", ".setDefine(flags.define)\n", ".setCharset(flags.charset)\n", ".setManageClosureDependencies(flags.manage_closure_dependencies)\n", ".setOutputManifest(flags.output_manifest);\n", "}\n", "}\n"], "faulty_lines": [34], "cluster": 6}, {"pid": "Closure", "bid": 153, "method_path": "./dataset/Closure/153/Normalize.java", "method": ["private final class DuplicateDeclarationHandler implements\n", "SyntacticScopeCreator.RedeclarationHandler {\n", "\n", "\n", "/**\n", "* Remove duplicate VAR declarations encountered discovered during\n", "* scope creation.\n", "*/\n", "@Override\n", "public void onRedeclaration(\n", "Scope s, String name, Node n, Node parent, Node gramps,\n", "Node nodeWithLineNumber) {\n", "Preconditions.checkState(n.getType() == Token.NAME);\n", "Var v = s.getVar(name);\n", "\n", "// We allow variables to be duplicate declared if one\n", "// declaration appears in source and the other in externs.\n", "// This deals with issues where a browser built-in is declared\n", "// in one browser but not in another.\n", "\n", "// If name is \"arguments\", Var maybe null.\n", "if (v != null && v.getParentNode().getType() == Token.CATCH) {\n", "// Redeclaration of a catch expression variable is hard to model\n", "// without support for \"with\" expressions.\n", "// The EcmaScript spec (section 12.14), declares that a catch\n", "// \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n", "// \"var e\" would refer to the scope variable, but any following\n", "// reference would still refer to \"e\" of the catch expression.\n", "// Until we have support for this disallow it.\n", "// Currently the Scope object adds the catch expression to the\n", "// function scope, which is technically not true but a good\n", "// approximation for most uses.\n", "\n", "// TODO(johnlenz): Consider improving how scope handles catch\n", "// expression.\n", "\n", "// Use the name of the var before it was made unique.\n", "name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n", "name);\n", "compiler.report(\n", "JSError.make(\n", "NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,\n", "CATCH_BLOCK_VAR_ERROR, name));\n", "} else if (v != null && parent.getType() == Token.FUNCTION) {\n", "if (v.getParentNode().getType() == Token.VAR) {\n", "s.undeclare(v);\n", "s.declare(name, n, n.getJSType(), v.input);\n", "replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),\n", "v.getParentNode().getParent());\n", "}\n", "} else if (parent.getType() == Token.VAR) {\n", "Preconditions.checkState(parent.hasOneChild());\n", "\n", "replaceVarWithAssignment(n, parent, gramps);\n", "}\n", "}\n", "\n", "/**\n", "* Remove the parent VAR. There are three cases that need to be handled:\n", "*   1) \"var a = b;\" which is replaced with \"a = b\"\n", "*   2) \"label:var a;\" which is replaced with \"label:;\". Ideally, the\n", "*      label itself would be removed but that is not possible in the\n", "*      context in which \"onRedeclaration\" is called.\n", "*   3) \"for (var a in b) ...\" which is replaced with \"for (a in b)...\"\n", "*      Cases we don't need to handle are VARs with multiple children,\n", "*      which have already been split into separate declarations, so there\n", "*      is no need to handle that here, and \"for (var a;;);\", which has\n", "*      been moved out of the loop.\n", "*      The result of this is that in each case the parent node is replaced\n", "*      which is generally dangerous in a traversal but is fine here with\n", "*      the scope creator, as the next node of interest is the parent's\n", "*      next sibling.\n", "*/\n", "private void replaceVarWithAssignment(Node n, Node parent, Node gramps) {\n", "if (n.hasChildren()) {\n", "// The  *  is being initialize, preserve the new value.\n", "parent.removeChild(n);\n", "// Convert \"var name = value\" to \"name = value\"\n", "Node value = n.getFirstChild();\n", "n.removeChild(value);\n", "Node replacement = new Node(Token.ASSIGN, n, value);\n", "replacement.copyInformationFrom(parent);\n", "gramps.replaceChild(parent, NodeUtil.newExpr(replacement));\n", "} else {\n", "// It is an empty reference remove it.\n", "if (NodeUtil.isStatementBlock(gramps)) {\n", "gramps.removeChild(parent);\n", "} else if (gramps.getType() == Token.FOR) {\n", "// This is the \"for (var a in b)...\" case.  We don't need to worry\n", "// about initializers in \"for (var a;;)...\" as those are moved out\n", "// as part of the other normalizations.\n", "parent.removeChild(n);\n", "gramps.replaceChild(parent, n);\n", "} else {\n", "Preconditions.checkState(gramps.getType() == Token.LABEL);\n", "// We should never get here. LABELs with a single VAR statement should\n", "// already have been normalized to have a BLOCK.\n", "throw new IllegalStateException(\"Unexpected LABEL\");\n", "}\n", "}\n", "reportCodeChange(\"Duplicate VAR declaration\");\n", "}\n", "}\n"], "faulty_lines": [4], "cluster": 7}, {"pid": "Closure", "bid": 153, "method_path": "./dataset/Closure/153/Normalize.java", "method": ["private final class DuplicateDeclarationHandler implements\n", "SyntacticScopeCreator.RedeclarationHandler {\n", "\n", "\n", "/**\n", "* Remove duplicate VAR declarations encountered discovered during\n", "* scope creation.\n", "*/\n", "@Override\n", "public void onRedeclaration(\n", "Scope s, String name, Node n, Node parent, Node gramps,\n", "Node nodeWithLineNumber) {\n", "Preconditions.checkState(n.getType() == Token.NAME);\n", "Var v = s.getVar(name);\n", "\n", "// We allow variables to be duplicate declared if one\n", "// declaration appears in source and the other in externs.\n", "// This deals with issues where a browser built-in is declared\n", "// in one browser but not in another.\n", "\n", "// If name is \"arguments\", Var maybe null.\n", "if (v != null && v.getParentNode().getType() == Token.CATCH) {\n", "// Redeclaration of a catch expression variable is hard to model\n", "// without support for \"with\" expressions.\n", "// The EcmaScript spec (section 12.14), declares that a catch\n", "// \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n", "// \"var e\" would refer to the scope variable, but any following\n", "// reference would still refer to \"e\" of the catch expression.\n", "// Until we have support for this disallow it.\n", "// Currently the Scope object adds the catch expression to the\n", "// function scope, which is technically not true but a good\n", "// approximation for most uses.\n", "\n", "// TODO(johnlenz): Consider improving how scope handles catch\n", "// expression.\n", "\n", "// Use the name of the var before it was made unique.\n", "name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n", "name);\n", "compiler.report(\n", "JSError.make(\n", "NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,\n", "CATCH_BLOCK_VAR_ERROR, name));\n", "} else if (v != null && parent.getType() == Token.FUNCTION) {\n", "if (v.getParentNode().getType() == Token.VAR) {\n", "s.undeclare(v);\n", "s.declare(name, n, n.getJSType(), v.input);\n", "replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),\n", "v.getParentNode().getParent());\n", "}\n", "} else if (parent.getType() == Token.VAR) {\n", "Preconditions.checkState(parent.hasOneChild());\n", "\n", "replaceVarWithAssignment(n, parent, gramps);\n", "}\n", "}\n", "\n", "/**\n", "* Remove the parent VAR. There are three cases that need to be handled:\n", "*   1) \"var a = b;\" which is replaced with \"a = b\"\n", "*   2) \"label:var a;\" which is replaced with \"label:;\". Ideally, the\n", "*      label itself would be removed but that is not possible in the\n", "*      context in which \"onRedeclaration\" is called.\n", "*   3) \"for (var a in b) ...\" which is replaced with \"for (a in b)...\"\n", "*      Cases we don't need to handle are VARs with multiple children,\n", "*      which have already been split into separate declarations, so there\n", "*      is no need to handle that here, and \"for (var a;;);\", which has\n", "*      been moved out of the loop.\n", "*      The result of this is that in each case the parent node is replaced\n", "*      which is generally dangerous in a traversal but is fine here with\n", "*      the scope creator, as the next node of interest is the parent's\n", "*      next sibling.\n", "*/\n", "private void replaceVarWithAssignment(Node n, Node parent, Node gramps) {\n", "if (n.hasChildren()) {\n", "// The  *  is being initialize, preserve the new value.\n", "parent.removeChild(n);\n", "// Convert \"var name = value\" to \"name = value\"\n", "Node value = n.getFirstChild();\n", "n.removeChild(value);\n", "Node replacement = new Node(Token.ASSIGN, n, value);\n", "replacement.copyInformationFrom(parent);\n", "gramps.replaceChild(parent, NodeUtil.newExpr(replacement));\n", "} else {\n", "// It is an empty reference remove it.\n", "if (NodeUtil.isStatementBlock(gramps)) {\n", "gramps.removeChild(parent);\n", "} else if (gramps.getType() == Token.FOR) {\n", "// This is the \"for (var a in b)...\" case.  We don't need to worry\n", "// about initializers in \"for (var a;;)...\" as those are moved out\n", "// as part of the other normalizations.\n", "parent.removeChild(n);\n", "gramps.replaceChild(parent, n);\n", "} else {\n", "Preconditions.checkState(gramps.getType() == Token.LABEL);\n", "// We should never get here. LABELs with a single VAR statement should\n", "// already have been normalized to have a BLOCK.\n", "throw new IllegalStateException(\"Unexpected LABEL\");\n", "}\n", "}\n", "reportCodeChange(\"Duplicate VAR declaration\");\n", "}\n", "}\n"], "faulty_lines": [11, 12, 14, 16, 20], "cluster": 7}, {"pid": "Closure", "bid": 153, "method_path": "./dataset/Closure/153/Normalize.java", "method": ["public void onRedeclaration(\n", "Scope s, String name, Node n, Node parent, Node gramps,\n", "Node nodeWithLineNumber) {\n", "Preconditions.checkState(n.getType() == Token.NAME);\n", "Var v = s.getVar(name);\n", "\n", "// We allow variables to be duplicate declared if one\n", "// declaration appears in source and the other in externs.\n", "// This deals with issues where a browser built-in is declared\n", "// in one browser but not in another.\n", "\n", "// If name is \"arguments\", Var maybe null.\n", "if (v != null && v.getParentNode().getType() == Token.CATCH) {\n", "// Redeclaration of a catch expression variable is hard to model\n", "// without support for \"with\" expressions.\n", "// The EcmaScript spec (section 12.14), declares that a catch\n", "// \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n", "// \"var e\" would refer to the scope variable, but any following\n", "// reference would still refer to \"e\" of the catch expression.\n", "// Until we have support for this disallow it.\n", "// Currently the Scope object adds the catch expression to the\n", "// function scope, which is technically not true but a good\n", "// approximation for most uses.\n", "\n", "// TODO(johnlenz): Consider improving how scope handles catch\n", "// expression.\n", "\n", "// Use the name of the var before it was made unique.\n", "name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n", "name);\n", "compiler.report(\n", "JSError.make(\n", "NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,\n", "CATCH_BLOCK_VAR_ERROR, name));\n", "} else if (v != null && parent.getType() == Token.FUNCTION) {\n", "if (v.getParentNode().getType() == Token.VAR) {\n", "s.undeclare(v);\n", "s.declare(name, n, n.getJSType(), v.input);\n", "replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),\n", "v.getParentNode().getParent());\n", "}\n", "} else if (parent.getType() == Token.VAR) {\n", "Preconditions.checkState(parent.hasOneChild());\n", "\n", "replaceVarWithAssignment(n, parent, gramps);\n", "}\n", "}\n"], "faulty_lines": [33], "cluster": 7}, {"pid": "Closure", "bid": 153, "method_path": "./dataset/Closure/153/Normalize.java", "method": ["public void onRedeclaration(\n", "Scope s, String name, Node n, Node parent, Node gramps,\n", "Node nodeWithLineNumber) {\n", "Preconditions.checkState(n.getType() == Token.NAME);\n", "Var v = s.getVar(name);\n", "\n", "// We allow variables to be duplicate declared if one\n", "// declaration appears in source and the other in externs.\n", "// This deals with issues where a browser built-in is declared\n", "// in one browser but not in another.\n", "\n", "// If name is \"arguments\", Var maybe null.\n", "if (v != null && v.getParentNode().getType() == Token.CATCH) {\n", "// Redeclaration of a catch expression variable is hard to model\n", "// without support for \"with\" expressions.\n", "// The EcmaScript spec (section 12.14), declares that a catch\n", "// \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n", "// \"var e\" would refer to the scope variable, but any following\n", "// reference would still refer to \"e\" of the catch expression.\n", "// Until we have support for this disallow it.\n", "// Currently the Scope object adds the catch expression to the\n", "// function scope, which is technically not true but a good\n", "// approximation for most uses.\n", "\n", "// TODO(johnlenz): Consider improving how scope handles catch\n", "// expression.\n", "\n", "// Use the name of the var before it was made unique.\n", "name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n", "name);\n", "compiler.report(\n", "JSError.make(\n", "NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber,\n", "CATCH_BLOCK_VAR_ERROR, name));\n", "} else if (v != null && parent.getType() == Token.FUNCTION) {\n", "if (v.getParentNode().getType() == Token.VAR) {\n", "s.undeclare(v);\n", "s.declare(name, n, n.getJSType(), v.input);\n", "replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),\n", "v.getParentNode().getParent());\n", "}\n", "} else if (parent.getType() == Token.VAR) {\n", "Preconditions.checkState(parent.hasOneChild());\n", "\n", "replaceVarWithAssignment(n, parent, gramps);\n", "}\n", "}\n"], "faulty_lines": [45], "cluster": 7}, {"pid": "Closure", "bid": 153, "method_path": "./dataset/Closure/153/SyntacticScopeCreator.java", "method": ["private void scanRoot(Node n, Scope parent) {\n", "if (n.getType() == Token.FUNCTION) {\n", "sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n", "\n", "final Node fnNameNode = n.getFirstChild();\n", "final Node args = fnNameNode.getNext();\n", "final Node body = args.getNext();\n", "\n", "// Bleed the function name into the scope, if it hasn't\n", "// been declared in the outer scope.\n", "String fnName = fnNameNode.getString();\n", "if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n", "declareVar(fnName, fnNameNode, n, null, null, n);\n", "}\n", "\n", "// Args: Declare function variables\n", "Preconditions.checkState(args.getType() == Token.LP);\n", "for (Node a = args.getFirstChild(); a != null;\n", "a = a.getNext()) {\n", "Preconditions.checkState(a.getType() == Token.NAME);\n", "declareVar(a.getString(), a, args, n, null, n);\n", "}\n", "\n", "// Body\n", "scanVars(body, n);\n", "} else {\n", "// It's the global block\n", "Preconditions.checkState(scope.getParent() == null);\n", "scanVars(n, null);\n", "}\n", "}\n"], "faulty_lines": [13], "cluster": 1}, {"pid": "Closure", "bid": 153, "method_path": "./dataset/Closure/153/SyntacticScopeCreator.java", "method": ["private void scanRoot(Node n, Scope parent) {\n", "if (n.getType() == Token.FUNCTION) {\n", "sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n", "\n", "final Node fnNameNode = n.getFirstChild();\n", "final Node args = fnNameNode.getNext();\n", "final Node body = args.getNext();\n", "\n", "// Bleed the function name into the scope, if it hasn't\n", "// been declared in the outer scope.\n", "String fnName = fnNameNode.getString();\n", "if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n", "declareVar(fnName, fnNameNode, n, null, null, n);\n", "}\n", "\n", "// Args: Declare function variables\n", "Preconditions.checkState(args.getType() == Token.LP);\n", "for (Node a = args.getFirstChild(); a != null;\n", "a = a.getNext()) {\n", "Preconditions.checkState(a.getType() == Token.NAME);\n", "declareVar(a.getString(), a, args, n, null, n);\n", "}\n", "\n", "// Body\n", "scanVars(body, n);\n", "} else {\n", "// It's the global block\n", "Preconditions.checkState(scope.getParent() == null);\n", "scanVars(n, null);\n", "}\n", "}\n"], "faulty_lines": [21], "cluster": 1}, {"pid": "Closure", "bid": 153, "method_path": "./dataset/Closure/153/SyntacticScopeCreator.java", "method": ["private void scanVars(Node n, Node parent) {\n", "switch (n.getType()) {\n", "case Token.VAR:\n", "// Declare all variables. e.g. var x = 1, y, z;\n", "for (Node child = n.getFirstChild();\n", "child != null;) {\n", "Node next = child.getNext();\n", "Preconditions.checkState(child.getType() == Token.NAME);\n", "String name = child.getString();\n", "declareVar(name, child, n, parent, null, n);\n", "child = next;\n", "}\n", "return;\n", "\n", "case Token.FUNCTION:\n", "if (NodeUtil.isFunctionExpression(n)) {\n", "return;\n", "}\n", "\n", "String fnName = n.getFirstChild().getString();\n", "if (fnName.isEmpty()) {\n", "// This is invalid, but allow it so the checks can catch it.\n", "return;\n", "}\n", "declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n", "return;   // should not examine function's children\n", "\n", "case Token.CATCH:\n", "Preconditions.checkState(n.getChildCount() == 2);\n", "Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n", "// the first child is the catch var and the third child\n", "// is the code block\n", "\n", "final Node var = n.getFirstChild();\n", "final Node block = var.getNext();\n", "\n", "declareVar(var.getString(), var, n, parent, null, n);\n", "scanVars(block, n);\n", "return;  // only one child to scan\n", "\n", "case Token.SCRIPT:\n", "sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n", "break;\n", "}\n", "\n", "// Variables can only occur in statement-level nodes, so\n", "// we only need to traverse children in a couple special cases.\n", "if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n", "for (Node child = n.getFirstChild();\n", "child != null;) {\n", "Node next = child.getNext();\n", "scanVars(child, n);\n", "child = next;\n", "}\n", "}\n", "}\n"], "faulty_lines": [8, 9, 10], "cluster": 7}, {"pid": "Closure", "bid": 153, "method_path": "./dataset/Closure/153/SyntacticScopeCreator.java", "method": ["private void scanVars(Node n, Node parent) {\n", "switch (n.getType()) {\n", "case Token.VAR:\n", "// Declare all variables. e.g. var x = 1, y, z;\n", "for (Node child = n.getFirstChild();\n", "child != null;) {\n", "Node next = child.getNext();\n", "Preconditions.checkState(child.getType() == Token.NAME);\n", "String name = child.getString();\n", "declareVar(name, child, n, parent, null, n);\n", "child = next;\n", "}\n", "return;\n", "\n", "case Token.FUNCTION:\n", "if (NodeUtil.isFunctionExpression(n)) {\n", "return;\n", "}\n", "\n", "String fnName = n.getFirstChild().getString();\n", "if (fnName.isEmpty()) {\n", "// This is invalid, but allow it so the checks can catch it.\n", "return;\n", "}\n", "declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n", "return;   // should not examine function's children\n", "\n", "case Token.CATCH:\n", "Preconditions.checkState(n.getChildCount() == 2);\n", "Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n", "// the first child is the catch var and the third child\n", "// is the code block\n", "\n", "final Node var = n.getFirstChild();\n", "final Node block = var.getNext();\n", "\n", "declareVar(var.getString(), var, n, parent, null, n);\n", "scanVars(block, n);\n", "return;  // only one child to scan\n", "\n", "case Token.SCRIPT:\n", "sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n", "break;\n", "}\n", "\n", "// Variables can only occur in statement-level nodes, so\n", "// we only need to traverse children in a couple special cases.\n", "if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n", "for (Node child = n.getFirstChild();\n", "child != null;) {\n", "Node next = child.getNext();\n", "scanVars(child, n);\n", "child = next;\n", "}\n", "}\n", "}\n"], "faulty_lines": [25], "cluster": 7}, {"pid": "Closure", "bid": 153, "method_path": "./dataset/Closure/153/SyntacticScopeCreator.java", "method": ["private void scanVars(Node n, Node parent) {\n", "switch (n.getType()) {\n", "case Token.VAR:\n", "// Declare all variables. e.g. var x = 1, y, z;\n", "for (Node child = n.getFirstChild();\n", "child != null;) {\n", "Node next = child.getNext();\n", "Preconditions.checkState(child.getType() == Token.NAME);\n", "String name = child.getString();\n", "declareVar(name, child, n, parent, null, n);\n", "child = next;\n", "}\n", "return;\n", "\n", "case Token.FUNCTION:\n", "if (NodeUtil.isFunctionExpression(n)) {\n", "return;\n", "}\n", "\n", "String fnName = n.getFirstChild().getString();\n", "if (fnName.isEmpty()) {\n", "// This is invalid, but allow it so the checks can catch it.\n", "return;\n", "}\n", "declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n", "return;   // should not examine function's children\n", "\n", "case Token.CATCH:\n", "Preconditions.checkState(n.getChildCount() == 2);\n", "Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n", "// the first child is the catch var and the third child\n", "// is the code block\n", "\n", "final Node var = n.getFirstChild();\n", "final Node block = var.getNext();\n", "\n", "declareVar(var.getString(), var, n, parent, null, n);\n", "scanVars(block, n);\n", "return;  // only one child to scan\n", "\n", "case Token.SCRIPT:\n", "sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n", "break;\n", "}\n", "\n", "// Variables can only occur in statement-level nodes, so\n", "// we only need to traverse children in a couple special cases.\n", "if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n", "for (Node child = n.getFirstChild();\n", "child != null;) {\n", "Node next = child.getNext();\n", "scanVars(child, n);\n", "child = next;\n", "}\n", "}\n", "}\n"], "faulty_lines": [37], "cluster": 7}, {"pid": "Closure", "bid": 153, "method_path": "./dataset/Closure/153/SyntacticScopeCreator.java", "method": ["void onRedeclaration(\n", "Scope s, String name,\n", "Node n, Node parent, Node gramps, Node nodeWithLineNumber);\n", "}\n", "\n", "/**\n", "* The default handler for duplicate declarations.\n", "*/\n", "private class DefaultRedeclarationHandler implements RedeclarationHandler {\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Closure", "bid": 153, "method_path": "./dataset/Closure/153/SyntacticScopeCreator.java", "method": ["private class DefaultRedeclarationHandler implements RedeclarationHandler {\n", "public void onRedeclaration(\n", "Scope s, String name,\n", "Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n", "\n", "// Don't allow multiple variables to be declared at the top level scope\n", "if (scope.isGlobal()) {\n", "Scope.Var origVar = scope.getVar(name);\n", "Node origParent = origVar.getParentNode();\n", "if (origParent.getType() == Token.CATCH &&\n", "parent.getType() == Token.CATCH) {\n", "// Okay, both are 'catch(x)' variables.\n", "return;\n", "}\n", "\n", "boolean allowDupe = false;\n", "JSDocInfo info = n.getJSDocInfo();\n", "if (info == null) {\n", "info = parent.getJSDocInfo();\n", "}\n", "allowDupe =\n", "info != null && info.getSuppressions().contains(\"duplicate\");\n", "\n", "if (!allowDupe) {\n", "compiler.report(\n", "JSError.make(sourceName, n,\n", "VAR_MULTIPLY_DECLARED_ERROR,\n", "name,\n", "(origVar.input != null\n", "? origVar.input.getName()\n", ": \"??\")));\n", "}\n", "} else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n", "// Disallow shadowing \"arguments\" as we can't handle with our current\n", "// scope modeling.\n", "compiler.report(\n", "JSError.make(sourceName, n,\n", "VAR_ARGUMENTS_SHADOWED_ERROR));\n", "}\n", "}\n", "}\n"], "faulty_lines": [3, 4], "cluster": 1}, {"pid": "Closure", "bid": 154, "method_path": "./dataset/Closure/154/TypeValidator.java", "method": ["private void expectInterfaceProperty(NodeTraversal t, Node n,\n", "ObjectType instance, ObjectType implementedInterface, String prop) {\n", "if (!instance.hasProperty(prop)) {\n", "// Not implemented\n", "String sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n", "sourceName = sourceName == null ? \"\" : sourceName;\n", "if (shouldReport) {\n", "compiler.report(JSError.make(sourceName, n,\n", "INTERFACE_METHOD_NOT_IMPLEMENTED,\n", "prop, implementedInterface.toString(), instance.toString()));\n", "}\n", "registerMismatch(instance, implementedInterface);\n", "// Implemented, but not correctly typed\n", "}\n", "}\n"], "faulty_lines": [13, 14], "cluster": 2}, {"pid": "Closure", "bid": 155, "method_path": "./dataset/Closure/155/InlineVariables.java", "method": ["private void doInlinesForScope(NodeTraversal t,\n", "Map<Var, ReferenceCollection> referenceMap) {\n", "\n", "for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n", "Var v = it.next();\n", "\n", "ReferenceCollection referenceInfo = referenceMap.get(v);\n", "\n", "// referenceInfo will be null if we're in constants-only mode\n", "// and the variable is not a constant.\n", "if (referenceInfo == null || isVarInlineForbidden(v)) {\n", "// Never try to inline exported variables or variables that\n", "// were not collected or variables that have already been inlined.\n", "continue;\n", "} else if (isInlineableDeclaredConstant(v, referenceInfo)) {\n", "Reference init = referenceInfo.getInitializingReferenceForConstants();\n", "Node value = init.getAssignedValue();\n", "inlineDeclaredConstant(v, value, referenceInfo.references);\n", "staleVars.add(v);\n", "} else if (mode == Mode.CONSTANTS_ONLY) {\n", "// If we're in constants-only mode, don't run more aggressive\n", "// inlining heuristics. See InlineConstantsTest.\n", "continue;\n", "} else {\n", "inlineNonConstants(v, referenceInfo);\n", "}\n", "}\n", "}\n"], "faulty_lines": [4], "cluster": 8}, {"pid": "Closure", "bid": 155, "method_path": "./dataset/Closure/155/InlineVariables.java", "method": ["private void inlineNonConstants(\n", "Var v, ReferenceCollection referenceInfo) {\n", "int refCount = referenceInfo.references.size();\n", "Reference declaration = referenceInfo.references.get(0);\n", "Reference init = referenceInfo.getInitializingReference();\n", "int firstRefAfterInit = (declaration == init) ? 2 : 3;\n", "\n", "if (refCount > 1 &&\n", "isImmutableAndWellDefinedVariable(v, referenceInfo)) {\n", "// if the variable is referenced more than once, we can only\n", "// inline it if it's immutable and never defined before referenced.\n", "Node value;\n", "if (init != null) {\n", "value = init.getAssignedValue();\n", "} else {\n", "// Create a new node for variable that is never initialized.\n", "Node srcLocation = declaration.getNameNode();\n", "value = NodeUtil.newUndefinedNode(srcLocation);\n", "}\n", "Preconditions.checkNotNull(value);\n", "inlineWellDefinedVariable(v, value, referenceInfo.references);\n", "staleVars.add(v);\n", "} else if (refCount == firstRefAfterInit) {\n", "// The variable likely only read once, try some more\n", "// complex inlining heuristics.\n", "Reference reference = referenceInfo.references.get(\n", "firstRefAfterInit - 1);\n", "if (canInline(declaration, init, reference)) {\n", "inline(v, declaration, init, reference);\n", "staleVars.add(v);\n", "}\n", "} else if (declaration != init && refCount == 2) {\n", "if (isValidDeclaration(declaration) && isValidInitialization(init)) {\n", "// The only reference is the initialization, remove the assignment and\n", "// the variable declaration.\n", "Node value = init.getAssignedValue();\n", "Preconditions.checkNotNull(value);\n", "inlineWellDefinedVariable(v, value, referenceInfo.references);\n", "staleVars.add(v);\n", "}\n", "}\n", "\n", "// If this variable was not inlined normally, check if we can\n", "// inline an alias of it. (If the variable was inlined, then the\n", "// reference data is out of sync. We're better off just waiting for\n", "// the next pass.)\n", "if (\n", "!staleVars.contains(v) && referenceInfo.isWellDefined() &&\n", "referenceInfo.isAssignedOnceInLifetime()) {\n", "List<Reference> refs = referenceInfo.references;\n", "for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n", "Node nameNode = refs.get(i).getNameNode();\n", "if (aliasCandidates.containsKey(nameNode)) {\n", "AliasCandidate candidate = aliasCandidates.get(nameNode);\n", "if (!staleVars.contains(candidate.alias) &&\n", "!isVarInlineForbidden(candidate.alias)) {\n", "Reference aliasInit;\n", "aliasInit = candidate.refInfo.getInitializingReference();\n", "Node value = aliasInit.getAssignedValue();\n", "Preconditions.checkNotNull(value);\n", "inlineWellDefinedVariable(candidate.alias,\n", "value,\n", "candidate.refInfo.references);\n", "staleVars.add(candidate.alias);\n", "}\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [47], "cluster": 7}, {"pid": "Closure", "bid": 155, "method_path": "./dataset/Closure/155/ReferenceCollectingCallback.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "if (n.getType() == Token.NAME) {\n", "Var v = t.getScope().getVar(n.getString());\n", "if (v != null && varFilter.apply(v)) {\n", "addReference(t, v,\n", "new Reference(n, parent, t, blockStack.peek()));\n", "}\n", "}\n", "\n", "if (isBlockBoundary(n, parent)) {\n", "blockStack.pop();\n", "}\n", "}\n"], "faulty_lines": [3], "cluster": 4}, {"pid": "Closure", "bid": 156, "method_path": "./dataset/Closure/156/CollapseProperties.java", "method": ["private void updateObjLitOrFunctionDeclaration(Name n, String alias) {\n", "if (n.declaration == null) {\n", "// Some names do not have declarations, because they\n", "// are only defined in local scopes.\n", "return;\n", "}\n", "\n", "if (n.declaration.getTwin() != null) {\n", "// Twin declarations will get handled when normal references\n", "// are handled.\n", "return;\n", "}\n", "\n", "switch (n.declaration.node.getParent().getType()) {\n", "case Token.ASSIGN:\n", "updateObjLitOrFunctionDeclarationAtAssignNode(n, alias);\n", "break;\n", "case Token.VAR:\n", "updateObjLitOrFunctionDeclarationAtVarNode(n);\n", "break;\n", "case Token.FUNCTION:\n", "updateFunctionDeclarationAtFunctionNode(n);\n", "break;\n", "}\n", "}\n"], "faulty_lines": [1], "cluster": 2}, {"pid": "Closure", "bid": 156, "method_path": "./dataset/Closure/156/CollapseProperties.java", "method": ["private void updateObjLitOrFunctionDeclaration(Name n, String alias) {\n", "if (n.declaration == null) {\n", "// Some names do not have declarations, because they\n", "// are only defined in local scopes.\n", "return;\n", "}\n", "\n", "if (n.declaration.getTwin() != null) {\n", "// Twin declarations will get handled when normal references\n", "// are handled.\n", "return;\n", "}\n", "\n", "switch (n.declaration.node.getParent().getType()) {\n", "case Token.ASSIGN:\n", "updateObjLitOrFunctionDeclarationAtAssignNode(n, alias);\n", "break;\n", "case Token.VAR:\n", "updateObjLitOrFunctionDeclarationAtVarNode(n);\n", "break;\n", "case Token.FUNCTION:\n", "updateFunctionDeclarationAtFunctionNode(n);\n", "break;\n", "}\n", "}\n"], "faulty_lines": [16, 19, 22], "cluster": 2}, {"pid": "Closure", "bid": 156, "method_path": "./dataset/Closure/156/CollapseProperties.java", "method": ["private void updateObjLitOrFunctionDeclarationAtAssignNode(\n", "Name n, String alias) {\n", "// NOTE: It's important that we don't add additional nodes\n", "// (e.g. a var node before the exprstmt) because the exprstmt might be\n", "// the child of an if statement that's not inside a block).\n", "\n", "Ref ref = n.declaration;\n", "Node rvalue = ref.node.getNext();\n", "Node varNode = new Node(Token.VAR);\n", "Node varParent = ref.node.getAncestor(3);\n", "Node gramps = ref.node.getAncestor(2);\n", "boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;\n", "boolean insertedVarNode = false;\n", "\n", "if (isObjLit && n.canEliminate()) {\n", "// Eliminate the object literal altogether.\n", "varParent.replaceChild(gramps, varNode);\n", "ref.node = null;\n", "insertedVarNode = true;\n", "\n", "} else if (!n.isSimpleName()) {\n", "// Create a VAR node to declare the name.\n", "if (rvalue.getType() == Token.FUNCTION) {\n", "checkForHosedThisReferences(rvalue, n.docInfo, n);\n", "}\n", "\n", "ref.node.getParent().removeChild(rvalue);\n", "\n", "Node nameNode = NodeUtil.newName(\n", "compiler.getCodingConvention(),\n", "alias, ref.node.getAncestor(2), n.fullName());\n", "\n", "if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {\n", "nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n", "}\n", "\n", "varNode.addChildToBack(nameNode);\n", "nameNode.addChildToFront(rvalue);\n", "varParent.replaceChild(gramps, varNode);\n", "\n", "// Update the node ancestry stored in the reference.\n", "ref.node = nameNode;\n", "insertedVarNode = true;\n", "}\n", "\n", "if (isObjLit) {\n", "declareVarsForObjLitValues(\n", "n, alias, rvalue,\n", "varNode, varParent.getChildBefore(varNode), varParent);\n", "\n", "}\n", "addStubsForUndeclaredProperties(n, alias, varParent, varNode);\n", "\n", "if (insertedVarNode) {\n", "if (!varNode.hasChildren()) {\n", "varParent.removeChild(varNode);\n", "}\n", "compiler.reportCodeChange();\n", "}\n", "}\n"], "faulty_lines": [2], "cluster": 7}, {"pid": "Closure", "bid": 156, "method_path": "./dataset/Closure/156/CollapseProperties.java", "method": ["private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) {\n", "\n", "Ref ref = n.declaration;\n", "String name = ref.node.getString();\n", "Node rvalue = ref.node.getFirstChild();\n", "Node varNode = ref.node.getParent();\n", "Node gramps = varNode.getParent();\n", "\n", "boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;\n", "int numChanges = 0;\n", "\n", "if (isObjLit) {\n", "numChanges += declareVarsForObjLitValues(\n", "n, name, rvalue, varNode, gramps.getChildBefore(varNode),\n", "gramps);\n", "}\n", "\n", "numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode);\n", "\n", "if (isObjLit && n.canEliminate()) {\n", "varNode.removeChild(ref.node);\n", "if (!varNode.hasChildren()) {\n", "gramps.removeChild(varNode);\n", "}\n", "numChanges++;\n", "\n", "// Clear out the object reference, since we've eliminated it from the\n", "// parse tree.\n", "ref.node = null;\n", "}\n", "\n", "if (numChanges > 0) {\n", "compiler.reportCodeChange();\n", "}\n", "}\n"], "faulty_lines": [1], "cluster": 8}, {"pid": "Closure", "bid": 156, "method_path": "./dataset/Closure/156/CollapseProperties.java", "method": ["private void updateFunctionDeclarationAtFunctionNode(Name n) {\n", "\n", "Ref ref = n.declaration;\n", "String fnName = ref.node.getString();\n", "addStubsForUndeclaredProperties(\n", "n, fnName, ref.node.getAncestor(2), ref.node.getParent());\n", "}\n"], "faulty_lines": [1], "cluster": 4}, {"pid": "Closure", "bid": 157, "method_path": "./dataset/Closure/157/RenamePrototypes.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "switch (n.getType()) {\n", "case Token.GETPROP:\n", "case Token.GETELEM:\n", "Node dest = n.getFirstChild().getNext();\n", "if (dest.getType() == Token.STRING) {\n", "String s = dest.getString();\n", "if (s.equals(\"prototype\")) {\n", "processPrototypeParent(parent, t.getInput());\n", "} else {\n", "markPropertyAccessCandidate(dest, t.getInput());\n", "}\n", "}\n", "break;\n", "case Token.OBJECTLIT:\n", "if (!prototypeObjLits.contains(n)) {\n", "// Object literals have their property name/value pairs as a flat\n", "// list as their children. We want every other node in order to get\n", "// only the property names.\n", "for (Node child = n.getFirstChild();\n", "child != null;\n", "child = child.getNext()) {\n", "\n", "if (child.getType() != Token.NUMBER) {\n", "markObjLitPropertyCandidate(child, t.getInput());\n", "}\n", "}\n", "}\n", "break;\n", "}\n", "}\n"], "faulty_lines": [24], "cluster": 8}, {"pid": "Closure", "bid": 157, "method_path": "./dataset/Closure/157/RenamePrototypes.java", "method": ["private void processPrototypeParent(Node n, CompilerInput input) {\n", "switch (n.getType()) {\n", "// Foo.prototype.getBar = function() { ... }\n", "case Token.GETPROP:\n", "case Token.GETELEM:\n", "Node dest = n.getFirstChild().getNext();\n", "if (dest.getType() == Token.STRING) {\n", "markPrototypePropertyCandidate(dest, input);\n", "}\n", "break;\n", "\n", "// Foo.prototype = { \"getBar\" : function() { ... } }\n", "case Token.ASSIGN:\n", "case Token.CALL:\n", "Node map;\n", "if (n.getType() == Token.ASSIGN) {\n", "map = n.getFirstChild().getNext();\n", "} else {\n", "map = n.getLastChild();\n", "}\n", "if (map.getType() == Token.OBJECTLIT) {\n", "// Remember this node so that we can avoid processing it again when\n", "// the traversal reaches it.\n", "prototypeObjLits.add(map);\n", "\n", "for (Node key = map.getFirstChild();\n", "key != null; key = key.getNext()) {\n", "if (key.getType() != Token.NUMBER) {\n", "// May be STRING, GET, or SET\n", "markPrototypePropertyCandidate(key, input);\n", "}\n", "}\n", "}\n", "break;\n", "}\n", "}\n"], "faulty_lines": [28], "cluster": 1}, {"pid": "Closure", "bid": 157, "method_path": "./dataset/Closure/157/IRFactory.java", "method": ["private Node transformAsString(AstNode n) {\n", "Node ret;\n", "if (n instanceof Name) {\n", "ret = transformNameAsString((Name)n);\n", "} else {\n", "ret = transform(n);\n", "Preconditions.checkState(ret.getType() == Token.NUMBER\n", "|| ret.getType() == Token.STRING);\n", "if (ret.getType() == Token.STRING) {\n", "ret.putBooleanProp(Node.QUOTED_PROP, true);\n", "}\n", "}\n", "return ret;\n", "}\n"], "faulty_lines": [5, 7, 8, 9, 11, 13], "cluster": 4}, {"pid": "Closure", "bid": 158, "method_path": "./dataset/Closure/158/CommandLineRunner.java", "method": ["private static class Flags {\n", "\n", "@Option(name = \"--help\",\n", "handler = BooleanOptionHandler.class,\n", "usage = \"Displays this message\")\n", "private boolean display_help = false;\n", "\n", "@Option(name = \"--print_tree\",\n", "handler = BooleanOptionHandler.class,\n", "usage = \"Prints out the parse tree and exits\")\n", "private boolean print_tree = false;\n", "\n", "@Option(name = \"--compute_phase_ordering\",\n", "handler = BooleanOptionHandler.class,\n", "usage = \"Runs the compile job many times, then prints out the \" +\n", "\"best phase ordering from this run\")\n", "private boolean compute_phase_ordering = false;\n", "\n", "@Option(name = \"--print_ast\",\n", "handler = BooleanOptionHandler.class,\n", "usage = \"Prints a dot file describing the internal abstract syntax\"\n", "+ \" tree and exits\")\n", "private boolean print_ast = false;\n", "\n", "@Option(name = \"--print_pass_graph\",\n", "handler = BooleanOptionHandler.class,\n", "usage = \"Prints a dot file describing the passes that will get run\"\n", "+ \" and exits\")\n", "private boolean print_pass_graph = false;\n", "\n", "// Turn on (very slow) extra sanity checks for use when modifying the\n", "// compiler.\n", "@Option(name = \"--jscomp_dev_mode\",\n", "// hidden, no usage\n", "aliases = {\"--dev_mode\"})\n", "private CompilerOptions.DevMode jscomp_dev_mode =\n", "CompilerOptions.DevMode.OFF;\n", "\n", "@Option(name = \"--logging_level\",\n", "usage = \"The logging level (standard java.util.logging.Level\"\n", "+ \" values) for Compiler progress. Does not control errors or\"\n", "+ \" warnings for the JavaScript code under compilation\")\n", "private String logging_level = Level.WARNING.getName();\n", "\n", "@Option(name = \"--externs\",\n", "usage = \"The file containing javascript externs. You may specify\"\n", "+ \" multiple\")\n", "private List<String> externs = Lists.newArrayList();\n", "\n", "@Option(name = \"--js\",\n", "usage = \"The javascript filename. You may specify multiple\")\n", "private List<String> js = Lists.newArrayList();\n", "\n", "@Option(name = \"--js_output_file\",\n", "usage = \"Primary output filename. If not specified, output is \" +\n", "\"written to stdout\")\n", "private String js_output_file = \"\";\n", "\n", "@Option(name = \"--module\",\n", "usage = \"A javascript module specification. The format is \"\n", "+ \"<name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be \"\n", "+ \"unique. Each dep is the name of a module that this module \"\n", "+ \"depends on. Modules must be listed in dependency order, and js \"\n", "+ \"source files must be listed in the corresponding order. Where \"\n", "+ \"--module flags occur in relation to --js flags is unimportant\")\n", "private List<String> module = Lists.newArrayList();\n", "\n", "@Option(name = \"--variable_map_input_file\",\n", "usage = \"File containing the serialized version of the variable \"\n", "+ \"renaming map produced by a previous compilation\")\n", "private String variable_map_input_file = \"\";\n", "\n", "@Option(name = \"--property_map_input_file\",\n", "usage = \"File containing the serialized version of the property \"\n", "+ \"renaming map produced by a previous compilation\")\n", "private String property_map_input_file = \"\";\n", "\n", "@Option(name = \"--variable_map_output_file\",\n", "usage = \"File where the serialized version of the variable \"\n", "+ \"renaming map produced should be saved\")\n", "private String variable_map_output_file = \"\";\n", "\n", "@Option(name = \"--create_name_map_files\",\n", "handler = BooleanOptionHandler.class,\n", "usage = \"If true, variable renaming and property renaming map \"\n", "+ \"files will be produced as {binary name}_vars_map.out and \"\n", "+ \"{binary name}_props_map.out. Note that this flag cannot be used \"\n", "+ \"in conjunction with either variable_map_output_file or \"\n", "+ \"property_map_output_file\")\n", "private boolean create_name_map_files = false;\n", "\n", "@Option(name = \"--property_map_output_file\",\n", "usage = \"File where the serialized version of the property \"\n", "+ \"renaming map produced should be saved\")\n", "private String property_map_output_file = \"\";\n", "\n", "@Option(name = \"--third_party\",\n", "handler = BooleanOptionHandler.class,\n", "usage = \"Check source validity but do not enforce Closure style \"\n", "+ \"rules and conventions\")\n", "private boolean third_party = false;\n", "\n", "\n", "@Option(name = \"--summary_detail_level\",\n", "usage = \"Controls how detailed the compilation summary is. Values:\"\n", "+ \" 0 (never print summary), 1 (print summary only if there are \"\n", "+ \"errors or warnings), 2 (print summary if type checking is on, \"\n", "+ \"see --check_types), 3 (always print summary). The default level \"\n", "+ \"is 1\")\n", "private int summary_detail_level = 1;\n", "\n", "@Option(name = \"--output_wrapper\",\n", "usage = \"Interpolate output into this string at the place denoted\"\n", "+ \" by the marker token %output%. See --output_wrapper_marker\")\n", "private String output_wrapper = \"\";\n", "\n", "@Option(name = \"--module_wrapper\",\n", "usage = \"An output wrapper for a javascript module (optional). \"\n", "+ \"The format is <name>:<wrapper>. The module name must correspond \"\n", "+ \"with a module specified using --module. The wrapper must \"\n", "+ \"contain %s as the code placeholder\")\n", "private List<String> module_wrapper = Lists.newArrayList();\n", "\n", "@Option(name = \"--module_output_path_prefix\",\n", "usage = \"Prefix for filenames of compiled js modules. \"\n", "+ \"<module-name>.js will be appended to this prefix. Directories \"\n", "+ \"will be created as needed. Use with --module\")\n", "private String module_output_path_prefix = \"./\";\n", "\n", "@Option(name = \"--create_source_map\",\n", "usage = \"If specified, a source map file mapping the generated \" +\n", "\"source files back to the original source file will be \" +\n", "\"output to the specified path. The %outname% placeholder will \" +\n", "\"expand to the name of the output file that the source map \" +\n", "\"corresponds to.\")\n", "private String create_source_map = \"\";\n", "\n", "@Option(name = \"--jscomp_error\",\n", "usage = \"Make the named class of warnings an error. Options:\" +\n", "DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n", "private List<String> jscomp_error = Lists.newArrayList();\n", "\n", "@Option(name = \"--jscomp_warning\",\n", "usage = \"Make the named class of warnings a normal warning. \" +\n", "\"Options:\" + DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n", "private List<String> jscomp_warning = Lists.newArrayList();\n", "\n", "@Option(name = \"--jscomp_off\",\n", "usage = \"Turn off the named class of warnings. Options:\" +\n", "DiagnosticGroups.DIAGNOSTIC_GROUP_NAMES)\n", "private List<String> jscomp_off = Lists.newArrayList();\n", "\n", "@Option(name = \"--define\",\n", "aliases = {\"--D\", \"-D\"},\n", "usage = \"Override the value of a variable annotated @define. \" +\n", "\"The format is <name>[=<val>], where <name> is the name of a @define \" +\n", "\"variable and <val> is a boolean, number, or a single-quoted string \" +\n", "\"that contains no single quotes. If [=<val>] is omitted, \" +\n", "\"the variable is marked true\")\n", "private List<String> define = Lists.newArrayList();\n", "\n", "@Option(name = \"--charset\",\n", "usage = \"Input and output charset for all files. By default, we \" +\n", "\"accept UTF-8 as input and output US_ASCII\")\n", "private String charset = \"\";\n", "\n", "@Option(name = \"--compilation_level\",\n", "usage = \"Specifies the compilation level to use. Options: \" +\n", "\"WHITESPACE_ONLY, SIMPLE_OPTIMIZATIONS, ADVANCED_OPTIMIZATIONS\")\n", "private CompilationLevel compilation_level =\n", "CompilationLevel.SIMPLE_OPTIMIZATIONS;\n", "\n", "@Option(name = \"--warning_level\",\n", "usage = \"Specifies the warning level to use. Options: \" +\n", "\"QUIET, DEFAULT, VERBOSE\")\n", "private WarningLevel warning_level = WarningLevel.DEFAULT;\n", "\n", "@Option(name = \"--use_only_custom_externs\",\n", "handler = BooleanOptionHandler.class,\n", "usage = \"Specifies whether the default externs should be excluded\")\n", "private boolean use_only_custom_externs = false;\n", "\n", "@Option(name = \"--debug\",\n", "handler = BooleanOptionHandler.class,\n", "usage = \"Enable debugging options\")\n", "private boolean debug = false;\n", "\n", "@Option(name = \"--generate_exports\",\n", "handler = BooleanOptionHandler.class,\n", "usage = \"Generates export code for those marked with @export\")\n", "private boolean generate_exports = false;\n", "\n", "@Option(name = \"--formatting\",\n", "usage = \"Specifies which formatting options, if any, should be \"\n", "+ \"applied to the output JS. Options: \"\n", "+ \"PRETTY_PRINT, PRINT_INPUT_DELIMITER\")\n", "private List<FormattingOption> formatting = Lists.newArrayList();\n", "\n", "@Option(name = \"--process_closure_primitives\",\n", "handler = BooleanOptionHandler.class,\n", "usage = \"Processes built-ins from the Closure library, such as \"\n", "+ \"goog.require(), goog.provide(), and goog.exportSymbol()\")\n", "private boolean process_closure_primitives = true;\n", "\n", "@Option(name = \"--manage_closure_dependencies\",\n", "handler = BooleanOptionHandler.class,\n", "usage = \"Automatically sort dependencies so that a file that \"\n", "+ \"goog.provides symbol X will always come before a file that \"\n", "+ \"goog.requires symbol X. If an input provides symbols, and \"\n", "+ \"those symbols are never required, then that input will not \"\n", "+ \"be included in the compilation.\")\n", "private boolean manage_closure_dependencies = false;\n", "\n", "@Option(name = \"--closure_entry_point\",\n", "usage = \"Entry points to the program. Must be goog.provide'd \"\n", "+ \"symbols. Any goog.provide'd symbols that are not a transitive \"\n", "+ \"dependency of the entry points will be removed. Files without \"\n", "+ \"goog.provides, and their dependencies, will always be left in. \"\n", "+ \"If any entry points are specified, then the \"\n", "+ \"manage_closure_dependencies option will be set to true and \"\n", "+ \"all files will be sorted in dependency order.\")\n", "private List<String> closure_entry_point = Lists.newArrayList();\n", "\n", "@Option(name = \"--output_manifest\",\n", "usage = \"Prints out a list of all the files in the compilation. \"\n", "+ \"If --manage_closure_dependencies is on, this will not include \"\n", "+ \"files that got dropped because they were not required. \"\n", "+ \"The %outname% placeholder expands to the js output file. \"\n", "+ \"If you're using modularization, using %outname% will create \"\n", "+ \"a manifest for each module.\")\n", "private String output_manifest = \"\";\n", "\n", "@Option(name = \"--accept_const_keyword\",\n", "usage = \"Allows usage of const keyword.\")\n", "private boolean accept_const_keyword = false;\n", "\n", "@Option(name = \"--language_in\",\n", "usage = \"Sets what language spec that input sources conform. \"\n", "+ \"Options: ECMASCRIPT3 (default), ECMASCRIPT5, ECMASCRIPT5_STRICT\")\n", "private String language_in = \"ECMASCRIPT3\";\n", "\n", "@Option(name = \"--version\",\n", "handler = BooleanOptionHandler.class,\n", "usage = \"Prints the compiler version to stderr.\")\n", "private boolean version = false;\n", "\n", "@Option(name = \"--flagfile\",\n", "usage = \"A file containing additional command-line options.\")\n", "private String flag_file = \"\";\n", "\n", "// Our own option parser to be backwards-compatible.\n", "// It needs to be public because of the crazy reflection that args4j does.\n", "public static class BooleanOptionHandler extends OptionHandler<Boolean> {\n", "private static final Set<String> TRUES =\n", "Sets.newHashSet(\"true\", \"on\", \"yes\", \"1\");\n", "private static final Set<String> FALSES =\n", "Sets.newHashSet(\"false\", \"off\", \"no\", \"0\");\n", "\n", "public BooleanOptionHandler(\n", "CmdLineParser parser, OptionDef option,\n", "Setter<? super Boolean> setter) {\n", "super(parser, option, setter);\n", "}\n", "\n", "@Override\n", "public int parseArguments(Parameters params) throws CmdLineException {\n", "String param = null;\n", "try {\n", "param = params.getParameter(0);\n", "} catch (CmdLineException e) {}\n", "\n", "if (param == null) {\n", "setter.addValue(true);\n", "return 0;\n", "} else {\n", "String lowerParam = param.toLowerCase();\n", "if (TRUES.contains(lowerParam)) {\n", "setter.addValue(true);\n", "} else if (FALSES.contains(lowerParam)) {\n", "setter.addValue(false);\n", "} else {\n", "setter.addValue(true);\n", "return 0;\n", "}\n", "return 1;\n", "}\n", "}\n", "\n", "@Override\n", "public String getDefaultMetaVariable() {\n", "return null;\n", "}\n", "}\n", "\n", "// Our own parser for warning guards that preserves the original order\n", "// of the flags.\n", "\n", "\n", "\n", "\n", "\n", "\n", "\n", "}\n"], "faulty_lines": [2], "cluster": 7}, {"pid": "Closure", "bid": 158, "method_path": "./dataset/Closure/158/CommandLineRunner.java", "method": ["private void processFlagFile(PrintStream err)\n", "throws CmdLineException, IOException {\n", "List<String> argsInFile = Lists.newArrayList();\n", "File flagFileInput = new File(flags.flag_file);\n", "StringTokenizer tokenizer = new StringTokenizer(\n", "Files.toString(flagFileInput, Charset.defaultCharset()));\n", "\n", "while (tokenizer.hasMoreTokens()) {\n", "argsInFile.add(tokenizer.nextToken());\n", "}\n", "\n", "flags.flag_file = \"\";\n", "List<String> processedFileArgs\n", "= processArgs(argsInFile.toArray(new String[] {}));\n", "CmdLineParser parserFileArgs = new CmdLineParser(flags);\n", "parserFileArgs.parseArgument(processedFileArgs.toArray(new String[] {}));\n", "\n", "// Currently we are not supporting this (prevent direct/indirect loops)\n", "if (!flags.flag_file.equals(\"\")) {\n", "err.println(\"ERROR - Arguments in the file cannot contain \"\n", "+ \"--flagfile option.\");\n", "isConfigValid = false;\n", "}\n", "}\n"], "faulty_lines": [16], "cluster": 8}, {"pid": "Closure", "bid": 158, "method_path": "./dataset/Closure/158/CommandLineRunner.java", "method": ["private void initConfigFromFlags(String[] args, PrintStream err) {\n", "\n", "List<String> processedArgs = processArgs(args);\n", "\n", "CmdLineParser parser = new CmdLineParser(flags);\n", "isConfigValid = true;\n", "try {\n", "parser.parseArgument(processedArgs.toArray(new String[] {}));\n", "// For contains --flagfile flag\n", "if (!flags.flag_file.equals(\"\")) {\n", "processFlagFile(err);\n", "}\n", "} catch (CmdLineException e) {\n", "err.println(e.getMessage());\n", "isConfigValid = false;\n", "} catch (IOException ioErr) {\n", "err.println(\"ERROR - \" + flags.flag_file + \" read error.\");\n", "isConfigValid = false;\n", "}\n", "\n", "if (flags.version) {\n", "ResourceBundle config = ResourceBundle.getBundle(configResource);\n", "err.println(\n", "\"Closure Compiler (http://code.google.com/closure/compiler)\\n\" +\n", "\"Version: \" + config.getString(\"compiler.version\") + \"\\n\" +\n", "\"Built on: \" + config.getString(\"compiler.date\"));\n", "err.flush();\n", "}\n", "\n", "if (!isConfigValid || flags.display_help) {\n", "isConfigValid = false;\n", "parser.printUsage(err);\n", "} else {\n", "getCommandLineConfig()\n", ".setPrintTree(flags.print_tree)\n", ".setComputePhaseOrdering(flags.compute_phase_ordering)\n", ".setPrintAst(flags.print_ast)\n", ".setPrintPassGraph(flags.print_pass_graph)\n", ".setJscompDevMode(flags.jscomp_dev_mode)\n", ".setLoggingLevel(flags.logging_level)\n", ".setExterns(flags.externs)\n", ".setJs(flags.js)\n", ".setJsOutputFile(flags.js_output_file)\n", ".setModule(flags.module)\n", ".setVariableMapInputFile(flags.variable_map_input_file)\n", ".setPropertyMapInputFile(flags.property_map_input_file)\n", ".setVariableMapOutputFile(flags.variable_map_output_file)\n", ".setCreateNameMapFiles(flags.create_name_map_files)\n", ".setPropertyMapOutputFile(flags.property_map_output_file)\n", ".setCodingConvention(flags.third_party ?\n", "new DefaultCodingConvention() :\n", "new ClosureCodingConvention())\n", ".setSummaryDetailLevel(flags.summary_detail_level)\n", ".setOutputWrapper(flags.output_wrapper)\n", ".setModuleWrapper(flags.module_wrapper)\n", ".setModuleOutputPathPrefix(flags.module_output_path_prefix)\n", ".setCreateSourceMap(flags.create_source_map)\n", ".setJscompError(flags.jscomp_error)\n", ".setJscompWarning(flags.jscomp_warning)\n", ".setJscompOff(flags.jscomp_off)\n", ".setDefine(flags.define)\n", ".setCharset(flags.charset)\n", ".setManageClosureDependencies(flags.manage_closure_dependencies)\n", ".setClosureEntryPoints(flags.closure_entry_point)\n", ".setOutputManifest(flags.output_manifest)\n", ".setAcceptConstKeyword(flags.accept_const_keyword)\n", ".setLanguageIn(flags.language_in);\n", "}\n", "}\n"], "faulty_lines": [6], "cluster": 6}, {"pid": "Closure", "bid": 158, "method_path": "./dataset/Closure/158/CommandLineRunner.java", "method": ["private void initConfigFromFlags(String[] args, PrintStream err) {\n", "\n", "List<String> processedArgs = processArgs(args);\n", "\n", "CmdLineParser parser = new CmdLineParser(flags);\n", "isConfigValid = true;\n", "try {\n", "parser.parseArgument(processedArgs.toArray(new String[] {}));\n", "// For contains --flagfile flag\n", "if (!flags.flag_file.equals(\"\")) {\n", "processFlagFile(err);\n", "}\n", "} catch (CmdLineException e) {\n", "err.println(e.getMessage());\n", "isConfigValid = false;\n", "} catch (IOException ioErr) {\n", "err.println(\"ERROR - \" + flags.flag_file + \" read error.\");\n", "isConfigValid = false;\n", "}\n", "\n", "if (flags.version) {\n", "ResourceBundle config = ResourceBundle.getBundle(configResource);\n", "err.println(\n", "\"Closure Compiler (http://code.google.com/closure/compiler)\\n\" +\n", "\"Version: \" + config.getString(\"compiler.version\") + \"\\n\" +\n", "\"Built on: \" + config.getString(\"compiler.date\"));\n", "err.flush();\n", "}\n", "\n", "if (!isConfigValid || flags.display_help) {\n", "isConfigValid = false;\n", "parser.printUsage(err);\n", "} else {\n", "getCommandLineConfig()\n", ".setPrintTree(flags.print_tree)\n", ".setComputePhaseOrdering(flags.compute_phase_ordering)\n", ".setPrintAst(flags.print_ast)\n", ".setPrintPassGraph(flags.print_pass_graph)\n", ".setJscompDevMode(flags.jscomp_dev_mode)\n", ".setLoggingLevel(flags.logging_level)\n", ".setExterns(flags.externs)\n", ".setJs(flags.js)\n", ".setJsOutputFile(flags.js_output_file)\n", ".setModule(flags.module)\n", ".setVariableMapInputFile(flags.variable_map_input_file)\n", ".setPropertyMapInputFile(flags.property_map_input_file)\n", ".setVariableMapOutputFile(flags.variable_map_output_file)\n", ".setCreateNameMapFiles(flags.create_name_map_files)\n", ".setPropertyMapOutputFile(flags.property_map_output_file)\n", ".setCodingConvention(flags.third_party ?\n", "new DefaultCodingConvention() :\n", "new ClosureCodingConvention())\n", ".setSummaryDetailLevel(flags.summary_detail_level)\n", ".setOutputWrapper(flags.output_wrapper)\n", ".setModuleWrapper(flags.module_wrapper)\n", ".setModuleOutputPathPrefix(flags.module_output_path_prefix)\n", ".setCreateSourceMap(flags.create_source_map)\n", ".setJscompError(flags.jscomp_error)\n", ".setJscompWarning(flags.jscomp_warning)\n", ".setJscompOff(flags.jscomp_off)\n", ".setDefine(flags.define)\n", ".setCharset(flags.charset)\n", ".setManageClosureDependencies(flags.manage_closure_dependencies)\n", ".setClosureEntryPoints(flags.closure_entry_point)\n", ".setOutputManifest(flags.output_manifest)\n", ".setAcceptConstKeyword(flags.accept_const_keyword)\n", ".setLanguageIn(flags.language_in);\n", "}\n", "}\n"], "faulty_lines": [58, 59, 60], "cluster": 6}, {"pid": "Closure", "bid": 159, "method_path": "./dataset/Closure/159/InlineFunctions.java", "method": ["private void findCalledFunctions(\n", "Node node, Set<String> changed) {\n", "Preconditions.checkArgument(changed != null);\n", "// For each referenced function, add a new reference\n", "if (node.getType() == Token.CALL) {\n", "Node child = node.getFirstChild();\n", "if (child.getType() == Token.NAME) {\n", "changed.add(child.getString());\n", "}\n", "}\n", "\n", "for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n", "findCalledFunctions(c, changed);\n", "}\n", "}\n"], "faulty_lines": [5, 6, 7, 8], "cluster": 4}, {"pid": "Closure", "bid": 160, "method_path": "./dataset/Closure/160/Compiler.java", "method": ["public void initOptions(CompilerOptions options) {\n", "this.options = options;\n", "if (errorManager == null) {\n", "if (outStream == null) {\n", "setErrorManager(\n", "new LoggerErrorManager(createMessageFormatter(), logger));\n", "} else {\n", "PrintStreamErrorManager printer =\n", "new PrintStreamErrorManager(createMessageFormatter(), outStream);\n", "printer.setSummaryDetailLevel(options.summaryDetailLevel);\n", "setErrorManager(printer);\n", "}\n", "}\n", "\n", "// DiagnosticGroups override the plain checkTypes option.\n", "if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n", "options.checkTypes = true;\n", "} else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n", "options.checkTypes = false;\n", "} else if (!options.checkTypes) {\n", "// If DiagnosticGroups did not override the plain checkTypes\n", "// option, and checkTypes is enabled, then turn off the\n", "// parser type warnings.\n", "options.setWarningLevel(\n", "DiagnosticGroup.forType(\n", "RhinoErrorReporter.TYPE_PARSE_ERROR),\n", "CheckLevel.OFF);\n", "}\n", "\n", "if (options.checkGlobalThisLevel.isOn()) {\n", "options.setWarningLevel(\n", "DiagnosticGroups.GLOBAL_THIS,\n", "options.checkGlobalThisLevel);\n", "}\n", "\n", "// Initialize the warnings guard.\n", "List<WarningsGuard> guards = Lists.newArrayList();\n", "guards.add(\n", "new SuppressDocWarningsGuard(\n", "getDiagnosticGroups().getRegisteredGroups()));\n", "guards.add(options.getWarningsGuard());\n", "\n", "\n", "// All passes must run the variable check. This synthesizes\n", "// variables later so that the compiler doesn't crash. It also\n", "// checks the externs file for validity. If you don't want to warn\n", "// about missing variable declarations, we shut that specific\n", "// error off.\n", "if (!options.checkSymbols &&\n", "(warningsGuard == null || !warningsGuard.disables(\n", "DiagnosticGroups.CHECK_VARIABLES))) {\n", "guards.add(new DiagnosticGroupWarningsGuard(\n", "DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n", "}\n", "\n", "this.warningsGuard = new ComposeWarningsGuard(guards);\n", "}\n"], "faulty_lines": [43], "cluster": 7}, {"pid": "Closure", "bid": 160, "method_path": "./dataset/Closure/160/Compiler.java", "method": ["public void initOptions(CompilerOptions options) {\n", "this.options = options;\n", "if (errorManager == null) {\n", "if (outStream == null) {\n", "setErrorManager(\n", "new LoggerErrorManager(createMessageFormatter(), logger));\n", "} else {\n", "PrintStreamErrorManager printer =\n", "new PrintStreamErrorManager(createMessageFormatter(), outStream);\n", "printer.setSummaryDetailLevel(options.summaryDetailLevel);\n", "setErrorManager(printer);\n", "}\n", "}\n", "\n", "// DiagnosticGroups override the plain checkTypes option.\n", "if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n", "options.checkTypes = true;\n", "} else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n", "options.checkTypes = false;\n", "} else if (!options.checkTypes) {\n", "// If DiagnosticGroups did not override the plain checkTypes\n", "// option, and checkTypes is enabled, then turn off the\n", "// parser type warnings.\n", "options.setWarningLevel(\n", "DiagnosticGroup.forType(\n", "RhinoErrorReporter.TYPE_PARSE_ERROR),\n", "CheckLevel.OFF);\n", "}\n", "\n", "if (options.checkGlobalThisLevel.isOn()) {\n", "options.setWarningLevel(\n", "DiagnosticGroups.GLOBAL_THIS,\n", "options.checkGlobalThisLevel);\n", "}\n", "\n", "// Initialize the warnings guard.\n", "List<WarningsGuard> guards = Lists.newArrayList();\n", "guards.add(\n", "new SuppressDocWarningsGuard(\n", "getDiagnosticGroups().getRegisteredGroups()));\n", "guards.add(options.getWarningsGuard());\n", "\n", "\n", "// All passes must run the variable check. This synthesizes\n", "// variables later so that the compiler doesn't crash. It also\n", "// checks the externs file for validity. If you don't want to warn\n", "// about missing variable declarations, we shut that specific\n", "// error off.\n", "if (!options.checkSymbols &&\n", "(warningsGuard == null || !warningsGuard.disables(\n", "DiagnosticGroups.CHECK_VARIABLES))) {\n", "guards.add(new DiagnosticGroupWarningsGuard(\n", "DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n", "}\n", "\n", "this.warningsGuard = new ComposeWarningsGuard(guards);\n", "}\n"], "faulty_lines": [50, 51, 52, 56], "cluster": 7}, {"pid": "Closure", "bid": 161, "method_path": "./dataset/Closure/161/PeepholeFoldConstants.java", "method": ["private Node tryFoldArrayAccess(Node n, Node left, Node right) {\n", "Node parent = n.getParent();\n", "// If GETPROP/GETELEM is used as assignment target the array literal is\n", "// acting as a temporary we can't fold it here:\n", "//    \"[][0] += 1\"\n", "\n", "if (right.getType() != Token.NUMBER) {\n", "// Sometimes people like to use complex expressions to index into\n", "// arrays, or strings to index into array methods.\n", "return n;\n", "}\n", "\n", "double index = right.getDouble();\n", "int intIndex = (int) index;\n", "if (intIndex != index) {\n", "error(INVALID_GETELEM_INDEX_ERROR, right);\n", "return n;\n", "}\n", "\n", "if (intIndex < 0) {\n", "error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n", "return n;\n", "}\n", "\n", "Node elem = left.getFirstChild();\n", "for (int i = 0; elem != null && i < intIndex; i++) {\n", "elem = elem.getNext();\n", "}\n", "\n", "if (elem == null) {\n", "error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n", "return n;\n", "}\n", "\n", "if (elem.getType() == Token.EMPTY) {\n", "elem = NodeUtil.newUndefinedNode(elem);\n", "} else {\n", "left.removeChild(elem);\n", "}\n", "\n", "// Replace the entire GETELEM with the value\n", "n.getParent().replaceChild(n, elem);\n", "reportCodeChange();\n", "return elem;\n", "}\n"], "faulty_lines": [6], "cluster": 1}, {"pid": "Closure", "bid": 162, "method_path": "./dataset/Closure/162/ScopedAliases.java", "method": ["public void enterScope(NodeTraversal t) {\n", "Node n = t.getCurrentNode().getParent();\n", "if (n != null && isCallToScopeMethod(n)) {\n", "transformation = transformationHandler.logAliasTransformation(\n", "n.getSourceFileName(), getSourceRegion(n));\n", "}\n", "}\n"], "faulty_lines": [6], "cluster": 4}, {"pid": "Closure", "bid": 162, "method_path": "./dataset/Closure/162/ScopedAliases.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "if (isCallToScopeMethod(n)) {\n", "validateScopeCall(t, n, n.getParent());\n", "}\n", "\n", "\n", "\n", "// Validate the top level of the goog.scope block.\n", "if (t.getScopeDepth() == 2) {\n", "int type = n.getType();\n", "if (type == Token.NAME && parent.getType() == Token.VAR) {\n", "if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n", "String name = n.getString();\n", "Var aliasVar = t.getScope().getVar(name);\n", "aliases.put(name, aliasVar);\n", "aliasDefinitionsInOrder.add(n);\n", "\n", "String qualifiedName =\n", "aliasVar.getInitialValue().getQualifiedName();\n", "transformation.addAlias(name, qualifiedName);\n", "// Return early, to ensure that we don't record a definition\n", "// twice.\n", "return;\n", "} else {\n", "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "}\n", "}\n", "if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&\n", "n == parent.getFirstChild()) {\n", "report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n", "}\n", "\n", "if (type == Token.RETURN) {\n", "report(t, n, GOOG_SCOPE_USES_RETURN);\n", "} else if (type == Token.THIS) {\n", "report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n", "} else if (type == Token.THROW) {\n", "report(t, n, GOOG_SCOPE_USES_THROW);\n", "}\n", "}\n", "\n", "// Validate all descendent scopes of the goog.scope block.\n", "if (t.getScopeDepth() >= 2) {\n", "// Check if this name points to an alias.\n", "if (n.getType() == Token.NAME) {\n", "String name = n.getString();\n", "Var aliasVar = aliases.get(name);\n", "if (aliasVar != null &&\n", "t.getScope().getVar(name) == aliasVar) {\n", "// Note, to support the transitive case, it's important we don't\n", "// clone aliasedNode here.  For example,\n", "// var g = goog; var d = g.dom; d.createElement('DIV');\n", "// The node in aliasedNode (which is \"g\") will be replaced in the\n", "// changes pass above with \"goog\".  If we cloned here, we'd end up\n", "// with <code>g.dom.createElement('DIV')</code>.\n", "Node aliasedNode = aliasVar.getInitialValue();\n", "aliasUsages.add(new AliasedNode(n, aliasedNode));\n", "}\n", "}\n", "\n", "JSDocInfo info = n.getJSDocInfo();\n", "if (info != null) {\n", "for (Node node : info.getTypeNodes()) {\n", "fixTypeNode(node);\n", "}\n", "}\n", "\n", "// TODO(robbyw): Error for goog.scope not at root.\n", "}\n", "}\n"], "faulty_lines": [6, 7, 10, 11, 12, 13, 14, 15, 18, 19, 20, 25, 28, 29, 30, 31], "cluster": 7}, {"pid": "Closure", "bid": 162, "method_path": "./dataset/Closure/162/ScopedAliases.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "if (isCallToScopeMethod(n)) {\n", "validateScopeCall(t, n, n.getParent());\n", "}\n", "\n", "\n", "\n", "// Validate the top level of the goog.scope block.\n", "if (t.getScopeDepth() == 2) {\n", "int type = n.getType();\n", "if (type == Token.NAME && parent.getType() == Token.VAR) {\n", "if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n", "String name = n.getString();\n", "Var aliasVar = t.getScope().getVar(name);\n", "aliases.put(name, aliasVar);\n", "aliasDefinitionsInOrder.add(n);\n", "\n", "String qualifiedName =\n", "aliasVar.getInitialValue().getQualifiedName();\n", "transformation.addAlias(name, qualifiedName);\n", "// Return early, to ensure that we don't record a definition\n", "// twice.\n", "return;\n", "} else {\n", "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "}\n", "}\n", "if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&\n", "n == parent.getFirstChild()) {\n", "report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n", "}\n", "\n", "if (type == Token.RETURN) {\n", "report(t, n, GOOG_SCOPE_USES_RETURN);\n", "} else if (type == Token.THIS) {\n", "report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n", "} else if (type == Token.THROW) {\n", "report(t, n, GOOG_SCOPE_USES_THROW);\n", "}\n", "}\n", "\n", "// Validate all descendent scopes of the goog.scope block.\n", "if (t.getScopeDepth() >= 2) {\n", "// Check if this name points to an alias.\n", "if (n.getType() == Token.NAME) {\n", "String name = n.getString();\n", "Var aliasVar = aliases.get(name);\n", "if (aliasVar != null &&\n", "t.getScope().getVar(name) == aliasVar) {\n", "// Note, to support the transitive case, it's important we don't\n", "// clone aliasedNode here.  For example,\n", "// var g = goog; var d = g.dom; d.createElement('DIV');\n", "// The node in aliasedNode (which is \"g\") will be replaced in the\n", "// changes pass above with \"goog\".  If we cloned here, we'd end up\n", "// with <code>g.dom.createElement('DIV')</code>.\n", "Node aliasedNode = aliasVar.getInitialValue();\n", "aliasUsages.add(new AliasedNode(n, aliasedNode));\n", "}\n", "}\n", "\n", "JSDocInfo info = n.getJSDocInfo();\n", "if (info != null) {\n", "for (Node node : info.getTypeNodes()) {\n", "fixTypeNode(node);\n", "}\n", "}\n", "\n", "// TODO(robbyw): Error for goog.scope not at root.\n", "}\n", "}\n"], "faulty_lines": [45, 46, 47, 48, 49], "cluster": 7}, {"pid": "Closure", "bid": 162, "method_path": "./dataset/Closure/162/ScopedAliases.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "if (isCallToScopeMethod(n)) {\n", "validateScopeCall(t, n, n.getParent());\n", "}\n", "\n", "\n", "\n", "// Validate the top level of the goog.scope block.\n", "if (t.getScopeDepth() == 2) {\n", "int type = n.getType();\n", "if (type == Token.NAME && parent.getType() == Token.VAR) {\n", "if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n", "String name = n.getString();\n", "Var aliasVar = t.getScope().getVar(name);\n", "aliases.put(name, aliasVar);\n", "aliasDefinitionsInOrder.add(n);\n", "\n", "String qualifiedName =\n", "aliasVar.getInitialValue().getQualifiedName();\n", "transformation.addAlias(name, qualifiedName);\n", "// Return early, to ensure that we don't record a definition\n", "// twice.\n", "return;\n", "} else {\n", "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "}\n", "}\n", "if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&\n", "n == parent.getFirstChild()) {\n", "report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n", "}\n", "\n", "if (type == Token.RETURN) {\n", "report(t, n, GOOG_SCOPE_USES_RETURN);\n", "} else if (type == Token.THIS) {\n", "report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n", "} else if (type == Token.THROW) {\n", "report(t, n, GOOG_SCOPE_USES_THROW);\n", "}\n", "}\n", "\n", "// Validate all descendent scopes of the goog.scope block.\n", "if (t.getScopeDepth() >= 2) {\n", "// Check if this name points to an alias.\n", "if (n.getType() == Token.NAME) {\n", "String name = n.getString();\n", "Var aliasVar = aliases.get(name);\n", "if (aliasVar != null &&\n", "t.getScope().getVar(name) == aliasVar) {\n", "// Note, to support the transitive case, it's important we don't\n", "// clone aliasedNode here.  For example,\n", "// var g = goog; var d = g.dom; d.createElement('DIV');\n", "// The node in aliasedNode (which is \"g\") will be replaced in the\n", "// changes pass above with \"goog\".  If we cloned here, we'd end up\n", "// with <code>g.dom.createElement('DIV')</code>.\n", "Node aliasedNode = aliasVar.getInitialValue();\n", "aliasUsages.add(new AliasedNode(n, aliasedNode));\n", "}\n", "}\n", "\n", "JSDocInfo info = n.getJSDocInfo();\n", "if (info != null) {\n", "for (Node node : info.getTypeNodes()) {\n", "fixTypeNode(node);\n", "}\n", "}\n", "\n", "// TODO(robbyw): Error for goog.scope not at root.\n", "}\n", "}\n"], "faulty_lines": [58], "cluster": 7}, {"pid": "Closure", "bid": 163, "method_path": "./dataset/Closure/163/AnalyzePrototypeProperties.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "if (n.isGetProp()) {\n", "String propName = n.getFirstChild().getNext().getString();\n", "\n", "if (propName.equals(\"prototype\")) {\n", "processPrototypeParent(t, parent);\n", "} else if (compiler.getCodingConvention().isExported(propName)) {\n", "addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n", "} else {\n", "// Do not mark prototype prop assigns as a 'use' in the global scope.\n", "addSymbolUse(propName, t.getModule(), PROPERTY);\n", "}\n", "\n", "} else if (n.isObjectLit() &&\n", "// Make sure that we're not handling object literals being\n", "// assigned to a prototype, as in:\n", "// Foo.prototype = {bar: 3, baz: 5};\n", "!(parent.isAssign() &&\n", "parent.getFirstChild().isGetProp() &&\n", "parent.getFirstChild().getLastChild().getString().equals(\n", "\"prototype\"))) {\n", "\n", "// var x = {a: 1, b: 2}\n", "// should count as a use of property a and b.\n", "for (Node propNameNode = n.getFirstChild(); propNameNode != null;\n", "propNameNode = propNameNode.getNext()) {\n", "// May be STRING, GET, or SET, but NUMBER isn't interesting.\n", "if (!propNameNode.isQuotedString()) {\n", "addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n", "}\n", "}\n", "} else if (n.isName()) {\n", "String name = n.getString();\n", "\n", "Var var = t.getScope().getVar(name);\n", "if (var != null) {\n", "// Only process global functions.\n", "if (var.isGlobal()) {\n", "if (var.getInitialValue() != null &&\n", "var.getInitialValue().isFunction()) {\n", "if (t.inGlobalScope()) {\n", "if (!processGlobalFunctionDeclaration(t, n, parent,\n", "parent.getParent())) {\n", "addGlobalUseOfSymbol(name, t.getModule(), VAR);\n", "}\n", "} else {\n", "addSymbolUse(name, t.getModule(), VAR);\n", "}\n", "}\n", "\n", "// If it is not a global, it might be accessing a local of the outer\n", "// scope. If that's the case the functions between the variable's\n", "// declaring scope and the variable reference scope cannot be moved.\n", "} else if (var.getScope() != t.getScope()){\n", "for (int i = symbolStack.size() - 1; i >= 0; i--) {\n", "NameContext context = symbolStack.get(i);\n", "if (context.scope == var.getScope()) {\n", "break;\n", "}\n", "\n", "context.name.readClosureVariables = true;\n", "}\n", "}\n", "}\n", "}\n", "\n", "// Process prototype assignments to non-functions.\n", "if (isPrototypePropertyAssign(n) ||\n", "isGlobalFunctionDeclaration(t, n) ||\n", "n.isFunction()) {\n", "symbolStack.pop();\n", "}\n", "}\n"], "faulty_lines": [5, 6, 9, 11, 14, 18, 19, 20, 21], "cluster": 7}, {"pid": "Closure", "bid": 163, "method_path": "./dataset/Closure/163/AnalyzePrototypeProperties.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "if (n.isGetProp()) {\n", "String propName = n.getFirstChild().getNext().getString();\n", "\n", "if (propName.equals(\"prototype\")) {\n", "processPrototypeParent(t, parent);\n", "} else if (compiler.getCodingConvention().isExported(propName)) {\n", "addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n", "} else {\n", "// Do not mark prototype prop assigns as a 'use' in the global scope.\n", "addSymbolUse(propName, t.getModule(), PROPERTY);\n", "}\n", "\n", "} else if (n.isObjectLit() &&\n", "// Make sure that we're not handling object literals being\n", "// assigned to a prototype, as in:\n", "// Foo.prototype = {bar: 3, baz: 5};\n", "!(parent.isAssign() &&\n", "parent.getFirstChild().isGetProp() &&\n", "parent.getFirstChild().getLastChild().getString().equals(\n", "\"prototype\"))) {\n", "\n", "// var x = {a: 1, b: 2}\n", "// should count as a use of property a and b.\n", "for (Node propNameNode = n.getFirstChild(); propNameNode != null;\n", "propNameNode = propNameNode.getNext()) {\n", "// May be STRING, GET, or SET, but NUMBER isn't interesting.\n", "if (!propNameNode.isQuotedString()) {\n", "addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n", "}\n", "}\n", "} else if (n.isName()) {\n", "String name = n.getString();\n", "\n", "Var var = t.getScope().getVar(name);\n", "if (var != null) {\n", "// Only process global functions.\n", "if (var.isGlobal()) {\n", "if (var.getInitialValue() != null &&\n", "var.getInitialValue().isFunction()) {\n", "if (t.inGlobalScope()) {\n", "if (!processGlobalFunctionDeclaration(t, n, parent,\n", "parent.getParent())) {\n", "addGlobalUseOfSymbol(name, t.getModule(), VAR);\n", "}\n", "} else {\n", "addSymbolUse(name, t.getModule(), VAR);\n", "}\n", "}\n", "\n", "// If it is not a global, it might be accessing a local of the outer\n", "// scope. If that's the case the functions between the variable's\n", "// declaring scope and the variable reference scope cannot be moved.\n", "} else if (var.getScope() != t.getScope()){\n", "for (int i = symbolStack.size() - 1; i >= 0; i--) {\n", "NameContext context = symbolStack.get(i);\n", "if (context.scope == var.getScope()) {\n", "break;\n", "}\n", "\n", "context.name.readClosureVariables = true;\n", "}\n", "}\n", "}\n", "}\n", "\n", "// Process prototype assignments to non-functions.\n", "if (isPrototypePropertyAssign(n) ||\n", "isGlobalFunctionDeclaration(t, n) ||\n", "n.isFunction()) {\n", "symbolStack.pop();\n", "}\n", "}\n"], "faulty_lines": [42, 43], "cluster": 7}, {"pid": "Closure", "bid": 163, "method_path": "./dataset/Closure/163/AnalyzePrototypeProperties.java", "method": ["public void visit(NodeTraversal t, Node n, Node parent) {\n", "if (n.isGetProp()) {\n", "String propName = n.getFirstChild().getNext().getString();\n", "\n", "if (propName.equals(\"prototype\")) {\n", "processPrototypeParent(t, parent);\n", "} else if (compiler.getCodingConvention().isExported(propName)) {\n", "addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n", "} else {\n", "// Do not mark prototype prop assigns as a 'use' in the global scope.\n", "addSymbolUse(propName, t.getModule(), PROPERTY);\n", "}\n", "\n", "} else if (n.isObjectLit() &&\n", "// Make sure that we're not handling object literals being\n", "// assigned to a prototype, as in:\n", "// Foo.prototype = {bar: 3, baz: 5};\n", "!(parent.isAssign() &&\n", "parent.getFirstChild().isGetProp() &&\n", "parent.getFirstChild().getLastChild().getString().equals(\n", "\"prototype\"))) {\n", "\n", "// var x = {a: 1, b: 2}\n", "// should count as a use of property a and b.\n", "for (Node propNameNode = n.getFirstChild(); propNameNode != null;\n", "propNameNode = propNameNode.getNext()) {\n", "// May be STRING, GET, or SET, but NUMBER isn't interesting.\n", "if (!propNameNode.isQuotedString()) {\n", "addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n", "}\n", "}\n", "} else if (n.isName()) {\n", "String name = n.getString();\n", "\n", "Var var = t.getScope().getVar(name);\n", "if (var != null) {\n", "// Only process global functions.\n", "if (var.isGlobal()) {\n", "if (var.getInitialValue() != null &&\n", "var.getInitialValue().isFunction()) {\n", "if (t.inGlobalScope()) {\n", "if (!processGlobalFunctionDeclaration(t, n, parent,\n", "parent.getParent())) {\n", "addGlobalUseOfSymbol(name, t.getModule(), VAR);\n", "}\n", "} else {\n", "addSymbolUse(name, t.getModule(), VAR);\n", "}\n", "}\n", "\n", "// If it is not a global, it might be accessing a local of the outer\n", "// scope. If that's the case the functions between the variable's\n", "// declaring scope and the variable reference scope cannot be moved.\n", "} else if (var.getScope() != t.getScope()){\n", "for (int i = symbolStack.size() - 1; i >= 0; i--) {\n", "NameContext context = symbolStack.get(i);\n", "if (context.scope == var.getScope()) {\n", "break;\n", "}\n", "\n", "context.name.readClosureVariables = true;\n", "}\n", "}\n", "}\n", "}\n", "\n", "// Process prototype assignments to non-functions.\n", "if (isPrototypePropertyAssign(n) ||\n", "isGlobalFunctionDeclaration(t, n) ||\n", "n.isFunction()) {\n", "symbolStack.pop();\n", "}\n", "}\n"], "faulty_lines": [68, 69, 70], "cluster": 7}, {"pid": "Closure", "bid": 163, "method_path": "./dataset/Closure/163/AnalyzePrototypeProperties.java", "method": ["private boolean processGlobalFunctionDeclaration(NodeTraversal t,\n", "Node nameNode, Node parent, Node gramps) {\n", "Node firstChild = nameNode.getFirstChild();\n", "\n", "if (// Check for a named FUNCTION.\n", "isGlobalFunctionDeclaration(t, parent) ||\n", "// Check for a VAR declaration.\n", "firstChild != null &&\n", "isGlobalFunctionDeclaration(t, firstChild)) {\n", "String name = nameNode.getString();\n", "getNameInfoForName(name, VAR).getDeclarations().add(\n", "new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n", "\n", "// If the function name is exported, we should create an edge here\n", "// so that it's never removed.\n", "if (compiler.getCodingConvention().isExported(name) ||\n", "anchorUnusedVars) {\n", "addGlobalUseOfSymbol(name, t.getModule(), VAR);\n", "}\n", "\n", "return true;\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [12], "cluster": 8}, {"pid": "Closure", "bid": 163, "method_path": "./dataset/Closure/163/AnalyzePrototypeProperties.java", "method": ["private void processPrototypeParent(NodeTraversal t, Node n) {\n", "\n", "switch (n.getType()) {\n", "// Foo.prototype.getBar = function() { ... }\n", "case Token.GETPROP:\n", "Node dest = n.getFirstChild().getNext();\n", "Node parent = n.getParent();\n", "Node grandParent = parent.getParent();\n", "\n", "if (dest.isString() &&\n", "NodeUtil.isExprAssign(grandParent) &&\n", "NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n", "String name = dest.getString();\n", "Property prop = new AssignmentProperty(\n", "grandParent,\n", "t.getModule());\n", "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n", "}\n", "break;\n", "\n", "// Foo.prototype = { \"getBar\" : function() { ... } }\n", "case Token.ASSIGN:\n", "Node map = n.getFirstChild().getNext();\n", "if (map.isObjectLit()) {\n", "for (Node key = map.getFirstChild();\n", "key != null; key = key.getNext()) {\n", "// May be STRING, GET, or SET,\n", "String name = key.getString();\n", "Property prop = new LiteralProperty(\n", "key, key.getFirstChild(), map, n,\n", "t.getModule());\n", "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n", "}\n", "}\n", "break;\n", "}\n", "}\n"], "faulty_lines": [1, 3], "cluster": 1}, {"pid": "Closure", "bid": 163, "method_path": "./dataset/Closure/163/AnalyzePrototypeProperties.java", "method": ["private void processPrototypeParent(NodeTraversal t, Node n) {\n", "\n", "switch (n.getType()) {\n", "// Foo.prototype.getBar = function() { ... }\n", "case Token.GETPROP:\n", "Node dest = n.getFirstChild().getNext();\n", "Node parent = n.getParent();\n", "Node grandParent = parent.getParent();\n", "\n", "if (dest.isString() &&\n", "NodeUtil.isExprAssign(grandParent) &&\n", "NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n", "String name = dest.getString();\n", "Property prop = new AssignmentProperty(\n", "grandParent,\n", "t.getModule());\n", "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n", "}\n", "break;\n", "\n", "// Foo.prototype = { \"getBar\" : function() { ... } }\n", "case Token.ASSIGN:\n", "Node map = n.getFirstChild().getNext();\n", "if (map.isObjectLit()) {\n", "for (Node key = map.getFirstChild();\n", "key != null; key = key.getNext()) {\n", "// May be STRING, GET, or SET,\n", "String name = key.getString();\n", "Property prop = new LiteralProperty(\n", "key, key.getFirstChild(), map, n,\n", "t.getModule());\n", "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n", "}\n", "}\n", "break;\n", "}\n", "}\n"], "faulty_lines": [16, 18], "cluster": 1}, {"pid": "Closure", "bid": 163, "method_path": "./dataset/Closure/163/AnalyzePrototypeProperties.java", "method": ["private void processPrototypeParent(NodeTraversal t, Node n) {\n", "\n", "switch (n.getType()) {\n", "// Foo.prototype.getBar = function() { ... }\n", "case Token.GETPROP:\n", "Node dest = n.getFirstChild().getNext();\n", "Node parent = n.getParent();\n", "Node grandParent = parent.getParent();\n", "\n", "if (dest.isString() &&\n", "NodeUtil.isExprAssign(grandParent) &&\n", "NodeUtil.isVarOrSimpleAssignLhs(n, parent)) {\n", "String name = dest.getString();\n", "Property prop = new AssignmentProperty(\n", "grandParent,\n", "t.getModule());\n", "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n", "}\n", "break;\n", "\n", "// Foo.prototype = { \"getBar\" : function() { ... } }\n", "case Token.ASSIGN:\n", "Node map = n.getFirstChild().getNext();\n", "if (map.isObjectLit()) {\n", "for (Node key = map.getFirstChild();\n", "key != null; key = key.getNext()) {\n", "// May be STRING, GET, or SET,\n", "String name = key.getString();\n", "Property prop = new LiteralProperty(\n", "key, key.getFirstChild(), map, n,\n", "t.getModule());\n", "getNameInfoForName(name, PROPERTY).getDeclarations().add(prop);\n", "}\n", "}\n", "break;\n", "}\n", "}\n"], "faulty_lines": [31, 34, 37], "cluster": 1}, {"pid": "Closure", "bid": 163, "method_path": "./dataset/Closure/163/AnalyzePrototypeProperties.java", "method": ["private class NameContext {\n", "final NameInfo name;\n", "\n", "// If this is a function context, then scope will be the scope of the\n", "// corresponding function. Otherwise, it will be null.\n", "Scope scope;\n", "\n", "NameContext(NameInfo name) {\n", "this.name = name;\n", "}\n", "}\n"], "faulty_lines": [6, 8, 10], "cluster": 4}, {"pid": "Closure", "bid": 163, "method_path": "./dataset/Closure/163/CrossModuleMethodMotion.java", "method": ["boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n", "for (NameInfo nameInfo : allNameInfo) {\n", "if (!nameInfo.isReferenced()) {\n", "// The code below can't do anything with unreferenced name\n", "// infos.  They should be skipped to avoid NPE since their\n", "// deepestCommonModuleRef is null.\n", "continue;\n", "}\n", "\n", "if (nameInfo.readsClosureVariables()) {\n", "continue;\n", "}\n", "\n", "JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n", "if (deepestCommonModuleRef == null) {\n", "compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n", "continue;\n", "}\n", "\n", "Iterator<Symbol> declarations =\n", "nameInfo.getDeclarations().descendingIterator();\n", "while (declarations.hasNext()) {\n", "Symbol symbol = declarations.next();\n", "if (!(symbol instanceof Property)) {\n", "continue;\n", "}\n", "Property prop = (Property) symbol;\n", "\n", "// We should only move a property across modules if:\n", "// 1) We can move it deeper in the module graph, and\n", "// 2) it's a function, and\n", "// 3) it is not a get or a set, and\n", "// 4) the class is available in the global scope.\n", "//\n", "// #1 should be obvious. #2 is more subtle. It's possible\n", "// to copy off of a prototype, as in the code:\n", "// for (var k in Foo.prototype) {\n", "//   doSomethingWith(Foo.prototype[k]);\n", "// }\n", "// This is a common way to implement pseudo-multiple inheritance in JS.\n", "//\n", "// So if we move a prototype method into a deeper module, we must\n", "// replace it with a stub function so that it preserves its original\n", "// behavior.\n", "\n", "Node value = prop.getValue();\n", "if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) &&\n", "value.isFunction()) {\n", "Node valueParent = value.getParent();\n", "if (valueParent.isGetterDef()\n", "|| valueParent.isSetterDef()) {\n", "// TODO(johnlenz): a GET or SET can't be deferred like a normal\n", "// FUNCTION property definition as a mix-in would get the result\n", "// of a GET instead of the function itself.\n", "continue;\n", "}\n", "Node proto = prop.getPrototype();\n", "int stubId = idGenerator.newId();\n", "\n", "// example: JSCompiler_stubMethod(id);\n", "Node stubCall = IR.call(\n", "IR.name(STUB_METHOD_NAME),\n", "IR.number(stubId))\n", ".copyInformationFromForTree(value);\n", "stubCall.putBooleanProp(Node.FREE_CALL, true);\n", "\n", "// stub out the method in the original module\n", "// A.prototype.b = JSCompiler_stubMethod(id);\n", "valueParent.replaceChild(value, stubCall);\n", "\n", "// unstub the function body in the deeper module\n", "Node unstubParent = compiler.getNodeForCodeInsertion(\n", "deepestCommonModuleRef);\n", "Node unstubCall = IR.call(\n", "IR.name(UNSTUB_METHOD_NAME),\n", "IR.number(stubId),\n", "value);\n", "unstubCall.putBooleanProp(Node.FREE_CALL, true);\n", "unstubParent.addChildToFront(\n", "// A.prototype.b = JSCompiler_unstubMethod(id, body);\n", "IR.exprResult(\n", "IR.assign(\n", "IR.getprop(\n", "proto.cloneTree(),\n", "IR.string(nameInfo.name)),\n", "unstubCall))\n", ".copyInformationFromForTree(value));\n", "\n", "compiler.reportCodeChange();\n", "}\n", "}\n", "}\n"], "faulty_lines": [45], "cluster": 7}, {"pid": "Closure", "bid": 165, "method_path": "./dataset/Closure/165/JSTypeRegistry.java", "method": ["public boolean canPropertyBeDefined(JSType type, String propertyName) {\n", "if (typesIndexedByProperty.containsKey(propertyName)) {\n", "for (JSType alt :\n", "typesIndexedByProperty.get(propertyName).getAlternates()) {\n", "JSType greatestSubtype = alt.getGreatestSubtype(type);\n", "if (!greatestSubtype.isEmptyType()) {\n", "// We've found a type with this property. Now we just have to make\n", "// sure it's not a type used for internal bookkeeping.\n", "\n", "return true;\n", "}\n", "}\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [9], "cluster": 4}, {"pid": "Closure", "bid": 165, "method_path": "./dataset/Closure/165/RecordTypeBuilder.java", "method": ["public class RecordTypeBuilder {\n", "private boolean isEmpty = true;\n", "private final JSTypeRegistry registry;\n", "private final HashMap<String, RecordProperty> properties = Maps.newHashMap();\n", "\n", "public RecordTypeBuilder(JSTypeRegistry registry) {\n", "this.registry = registry;\n", "}\n", "\n", "/** See the comments on RecordType about synthetic types. */\n", "\n", "/**\n", "* Adds a property with the given name and type to the record type.\n", "* @param name the name of the new property\n", "* @param type the JSType of the new property\n", "* @param propertyNode the node that holds this property definition\n", "* @return The builder itself for chaining purposes, or null if there's\n", "*          a duplicate.\n", "*/\n", "public RecordTypeBuilder addProperty(String name, JSType type, Node\n", "propertyNode) {\n", "isEmpty = false;\n", "if (properties.containsKey(name)) {\n", "return null;\n", "}\n", "properties.put(name, new RecordProperty(type, propertyNode));\n", "return this;\n", "}\n", "\n", "/**\n", "* Creates a record.\n", "* @return The record type.\n", "*/\n", "public JSType build() {\n", "// If we have an empty record, simply return the object type.\n", "if (isEmpty) {\n", "return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n", "}\n", "\n", "return new RecordType(\n", "registry, Collections.unmodifiableMap(properties));\n", "}\n", "\n", "static class RecordProperty {\n", "private final JSType type;\n", "private final Node propertyNode;\n", "\n", "RecordProperty(JSType type, Node propertyNode) {\n", "this.type = type;\n", "this.propertyNode = propertyNode;\n", "}\n", "\n", "public JSType getType() {\n", "return type;\n", "}\n", "\n", "public Node getPropertyNode() {\n", "return propertyNode;\n", "}\n", "}\n", "}\n"], "faulty_lines": [3], "cluster": 5}, {"pid": "Closure", "bid": 165, "method_path": "./dataset/Closure/165/RecordTypeBuilder.java", "method": ["public JSType build() {\n", "// If we have an empty record, simply return the object type.\n", "if (isEmpty) {\n", "return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n", "}\n", "\n", "return new RecordType(\n", "registry, Collections.unmodifiableMap(properties));\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Closure", "bid": 166, "method_path": "./dataset/Closure/166/PrototypeObjectType.java", "method": ["public void matchConstraint(JSType constraint) {\n", "// We only want to match constraints on anonymous types.\n", "if (hasReferenceName()) {\n", "return;\n", "}\n", "\n", "// Handle the case where the constraint object is a record type.\n", "//\n", "// param constraint {{prop: (number|undefined)}}\n", "// function f(constraint) {}\n", "// f({});\n", "//\n", "// We want to modify the object literal to match the constraint, by\n", "// taking any each property on the record and trying to match\n", "// properties on this object.\n", "if (constraint.isRecordType()) {\n", "matchRecordTypeConstraint(constraint.toObjectType());\n", "}\n", "}\n"], "faulty_lines": [18], "cluster": 2}, {"pid": "Closure", "bid": 167, "method_path": "./dataset/Closure/167/SemanticReverseAbstractInterpreter.java", "method": ["private FlowScope maybeRestrictName(\n", "FlowScope blindScope, Node node, JSType originalType, JSType restrictedType) {\n", "if (restrictedType != null && !restrictedType.equals(originalType)) {\n", "FlowScope informed = blindScope.createChildFlowScope();\n", "declareNameInScope(informed, node, restrictedType);\n", "return informed;\n", "}\n", "return blindScope;\n", "}\n"], "faulty_lines": [3], "cluster": 4}, {"pid": "Closure", "bid": 167, "method_path": "./dataset/Closure/167/SemanticReverseAbstractInterpreter.java", "method": ["private FlowScope maybeRestrictTwoNames(\n", "FlowScope blindScope,\n", "Node left, boolean leftIsRefineable, JSType restrictedLeftType,\n", "Node right, boolean rightIsRefineable, JSType restrictedRightType) {\n", "boolean shouldRefineLeft =\n", "leftIsRefineable && restrictedLeftType != null;\n", "boolean shouldRefineRight =\n", "rightIsRefineable && restrictedRightType != null;\n", "if (shouldRefineLeft || shouldRefineRight) {\n", "FlowScope informed = blindScope.createChildFlowScope();\n", "if (shouldRefineLeft) {\n", "declareNameInScope(informed, left, restrictedLeftType);\n", "}\n", "if (shouldRefineRight) {\n", "declareNameInScope(informed, right, restrictedRightType);\n", "}\n", "return informed;\n", "}\n", "return blindScope;\n", "}\n"], "faulty_lines": [3, 4, 6, 8], "cluster": 2}, {"pid": "Closure", "bid": 167, "method_path": "./dataset/Closure/167/SemanticReverseAbstractInterpreter.java", "method": ["boolean outcome) {\n", "JSType type = getTypeIfRefinable(name, blindScope);\n", "if (type != null) {\n", "JSType restrictedType =\n", "type.getRestrictedTypeGivenToBooleanOutcome(outcome);\n", "FlowScope informed = blindScope.createChildFlowScope();\n", "declareNameInScope(informed, name, restrictedType);\n", "return informed;\n", "}\n", "return blindScope;\n", "}\n"], "faulty_lines": [4, 5, 6, 7, 8], "cluster": 4}, {"pid": "Closure", "bid": 167, "method_path": "./dataset/Closure/167/JSType.java", "method": ["public JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\n", "\n", "BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\n", "if (literals.contains(outcome)) {\n", "return this;\n", "} else {\n", "return getNativeType(JSTypeNative.NO_TYPE);\n", "}\n", "}\n"], "faulty_lines": [2], "cluster": 4}, {"pid": "Closure", "bid": 171, "method_path": "./dataset/Closure/171/TypeInference.java", "method": ["private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n", "JSType type = n.getJSType();\n", "Preconditions.checkNotNull(type);\n", "\n", "for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n", "scope = traverse(name.getFirstChild(), scope);\n", "}\n", "\n", "// Object literals can be reflected on other types.\n", "// See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n", "// Ignore these types of literals.\n", "ObjectType objectType = ObjectType.cast(type);\n", "if (objectType == null) {\n", "return scope;\n", "}\n", "boolean hasLendsName = n.getJSDocInfo() != null &&\n", "n.getJSDocInfo().getLendsName() != null;\n", "if (objectType.hasReferenceName() && !hasLendsName) {\n", "return scope;\n", "}\n", "\n", "String qObjName = NodeUtil.getBestLValueName(\n", "NodeUtil.getBestLValue(n));\n", "for (Node name = n.getFirstChild(); name != null;\n", "name = name.getNext()) {\n", "String memberName = NodeUtil.getObjectLitKeyName(name);\n", "if (memberName != null) {\n", "JSType rawValueType =  name.getFirstChild().getJSType();\n", "JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(\n", "name, rawValueType);\n", "if (valueType == null) {\n", "valueType = unknownType;\n", "}\n", "objectType.defineInferredProperty(memberName, valueType, name);\n", "\n", "// Do normal flow inference if this is a direct property assignment.\n", "if (qObjName != null && name.isStringKey()) {\n", "String qKeyName = qObjName + \".\" + memberName;\n", "Var var = syntacticScope.getVar(qKeyName);\n", "JSType oldType = var == null ? null : var.getType();\n", "if (var != null && var.isTypeInferred()) {\n", "var.setType(oldType == null ?\n", "valueType : oldType.getLeastSupertype(oldType));\n", "}\n", "\n", "scope.inferQualifiedSlot(name, qKeyName,\n", "oldType == null ? unknownType : oldType,\n", "valueType);\n", "}\n", "} else {\n", "n.setJSType(unknownType);\n", "}\n", "}\n", "return scope;\n", "}\n"], "faulty_lines": [13, 14, 15, 16, 17, 18], "cluster": 7}, {"pid": "Closure", "bid": 171, "method_path": "./dataset/Closure/171/TypedScopeCreator.java", "method": ["private boolean isQualifiedNameInferred(\n", "String qName, Node n, JSDocInfo info,\n", "Node rhsValue, JSType valueType) {\n", "if (valueType == null) {\n", "return true;\n", "}\n", "\n", "// Prototype sets are always declared.\n", "\n", "boolean inferred = true;\n", "if (info != null) {\n", "inferred = !(info.hasType()\n", "|| info.hasEnumParameterType()\n", "|| (isConstantSymbol(info, n) && valueType != null\n", "&& !valueType.isUnknownType())\n", "|| FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n", "}\n", "\n", "if (inferred && rhsValue != null && rhsValue.isFunction()) {\n", "if (info != null) {\n", "return false;\n", "} else if (!scope.isDeclared(qName, false) &&\n", "n.isUnscopedQualifiedName()) {\n", "\n", "// Check if this is in a conditional block.\n", "// Functions assigned in conditional blocks are inferred.\n", "for (Node current = n.getParent();\n", "!(current.isScript() || current.isFunction());\n", "current = current.getParent()) {\n", "if (NodeUtil.isControlStructure(current)) {\n", "return true;\n", "}\n", "}\n", "\n", "// Check if this is assigned in an inner scope.\n", "// Functions assigned in inner scopes are inferred.\n", "AstFunctionContents contents =\n", "getFunctionAnalysisResults(scope.getRootNode());\n", "if (contents == null ||\n", "!contents.getEscapedQualifiedNames().contains(qName)) {\n", "return false;\n", "}\n", "}\n", "}\n", "return inferred;\n", "}\n"], "faulty_lines": [9], "cluster": 1}, {"pid": "Closure", "bid": 172, "method_path": "./dataset/Closure/172/TypedScopeCreator.java", "method": ["private boolean isQualifiedNameInferred(\n", "String qName, Node n, JSDocInfo info,\n", "Node rhsValue, JSType valueType) {\n", "if (valueType == null) {\n", "return true;\n", "}\n", "\n", "// Prototypes of constructors and interfaces are always declared.\n", "if (qName != null && qName.endsWith(\".prototype\")) {\n", "return false;\n", "}\n", "\n", "boolean inferred = true;\n", "if (info != null) {\n", "inferred = !(info.hasType()\n", "|| info.hasEnumParameterType()\n", "|| (isConstantSymbol(info, n) && valueType != null\n", "&& !valueType.isUnknownType())\n", "|| FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n", "}\n", "\n", "if (inferred && rhsValue != null && rhsValue.isFunction()) {\n", "if (info != null) {\n", "return false;\n", "} else if (!scope.isDeclared(qName, false) &&\n", "n.isUnscopedQualifiedName()) {\n", "\n", "// Check if this is in a conditional block.\n", "// Functions assigned in conditional blocks are inferred.\n", "for (Node current = n.getParent();\n", "!(current.isScript() || current.isFunction());\n", "current = current.getParent()) {\n", "if (NodeUtil.isControlStructure(current)) {\n", "return true;\n", "}\n", "}\n", "\n", "// Check if this is assigned in an inner scope.\n", "// Functions assigned in inner scopes are inferred.\n", "AstFunctionContents contents =\n", "getFunctionAnalysisResults(scope.getRootNode());\n", "if (contents == null ||\n", "!contents.getEscapedQualifiedNames().contains(qName)) {\n", "return false;\n", "}\n", "}\n", "}\n", "return inferred;\n", "}\n"], "faulty_lines": [10, 11], "cluster": 1}, {"pid": "Closure", "bid": 173, "method_path": "./dataset/Closure/173/CodeGenerator.java", "method": ["void add(Node n, Context context) {\n", "if (!cc.continueProcessing()) {\n", "return;\n", "}\n", "\n", "int type = n.getType();\n", "String opstr = NodeUtil.opToStr(type);\n", "int childCount = n.getChildCount();\n", "Node first = n.getFirstChild();\n", "Node last = n.getLastChild();\n", "\n", "// Handle all binary operators\n", "if (opstr != null && first != last) {\n", "Preconditions.checkState(\n", "childCount == 2,\n", "\"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n", "opstr, childCount);\n", "int p = NodeUtil.precedence(type);\n", "\n", "// For right-hand-side of operations, only pass context if it's\n", "// the IN_FOR_INIT_CLAUSE one.\n", "Context rhsContext = getContextForNoInOperator(context);\n", "\n", "if (last.getType() == type &&\n", "NodeUtil.isAssociative(type)) {\n", "addExpr(first, p, context);\n", "cc.addOp(opstr, true);\n", "addExpr(last, p, rhsContext);\n", "} else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n", "// Assignments are the only right-associative binary operators\n", "addExpr(first, p, context);\n", "cc.addOp(opstr, true);\n", "addExpr(last, p, rhsContext);\n", "} else {\n", "unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n", "}\n", "return;\n", "}\n", "\n", "cc.startSourceMapping(n);\n", "\n", "switch (type) {\n", "case Token.TRY: {\n", "Preconditions.checkState(first.getNext().isBlock() &&\n", "!first.getNext().hasMoreThanOneChild());\n", "Preconditions.checkState(childCount >= 2 && childCount <= 3);\n", "\n", "add(\"try\");\n", "add(first, Context.PRESERVE_BLOCK);\n", "\n", "// second child contains the catch block, or nothing if there\n", "// isn't a catch block\n", "Node catchblock = first.getNext().getFirstChild();\n", "if (catchblock != null) {\n", "add(catchblock);\n", "}\n", "\n", "if (childCount == 3) {\n", "add(\"finally\");\n", "add(last, Context.PRESERVE_BLOCK);\n", "}\n", "break;\n", "}\n", "\n", "case Token.CATCH:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"catch(\");\n", "add(first);\n", "add(\")\");\n", "add(last, Context.PRESERVE_BLOCK);\n", "break;\n", "\n", "case Token.THROW:\n", "Preconditions.checkState(childCount == 1);\n", "add(\"throw\");\n", "add(first);\n", "\n", "// Must have a ';' after a throw statement, otherwise safari can't\n", "// parse this.\n", "cc.endStatement(true);\n", "break;\n", "\n", "case Token.RETURN:\n", "add(\"return\");\n", "if (childCount == 1) {\n", "add(first);\n", "} else {\n", "Preconditions.checkState(childCount == 0);\n", "}\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.VAR:\n", "if (first != null) {\n", "add(\"var \");\n", "addList(first, false, getContextForNoInOperator(context));\n", "}\n", "break;\n", "\n", "case Token.LABEL_NAME:\n", "Preconditions.checkState(!n.getString().isEmpty());\n", "addIdentifier(n.getString());\n", "break;\n", "\n", "case Token.NAME:\n", "if (first == null || first.isEmpty()) {\n", "addIdentifier(n.getString());\n", "} else {\n", "Preconditions.checkState(childCount == 1);\n", "addIdentifier(n.getString());\n", "cc.addOp(\"=\", true);\n", "if (first.isComma()) {\n", "addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n", "} else {\n", "// Add expression, consider nearby code at lowest level of\n", "// precedence.\n", "addExpr(first, 0, getContextForNoInOperator(context));\n", "}\n", "}\n", "break;\n", "\n", "case Token.ARRAYLIT:\n", "add(\"[\");\n", "addArrayList(first);\n", "add(\"]\");\n", "break;\n", "\n", "case Token.PARAM_LIST:\n", "add(\"(\");\n", "addList(first);\n", "add(\")\");\n", "break;\n", "\n", "case Token.COMMA:\n", "Preconditions.checkState(childCount == 2);\n", "unrollBinaryOperator(n, Token.COMMA, \",\", context,\n", "getContextForNoInOperator(context), 0, 0);\n", "break;\n", "\n", "case Token.NUMBER:\n", "Preconditions.checkState(childCount == 0);\n", "cc.addNumber(n.getDouble());\n", "break;\n", "\n", "case Token.TYPEOF:\n", "case Token.VOID:\n", "case Token.NOT:\n", "case Token.BITNOT:\n", "case Token.POS: {\n", "// All of these unary operators are right-associative\n", "Preconditions.checkState(childCount == 1);\n", "cc.addOp(NodeUtil.opToStrNoFail(type), false);\n", "addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n", "break;\n", "}\n", "\n", "case Token.NEG: {\n", "Preconditions.checkState(childCount == 1);\n", "\n", "// It's important to our sanity checker that the code\n", "// we print produces the same AST as the code we parse back.\n", "// NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n", "if (n.getFirstChild().isNumber()) {\n", "cc.addNumber(-n.getFirstChild().getDouble());\n", "} else {\n", "cc.addOp(NodeUtil.opToStrNoFail(type), false);\n", "addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n", "}\n", "\n", "break;\n", "}\n", "\n", "case Token.HOOK: {\n", "Preconditions.checkState(childCount == 3);\n", "int p = NodeUtil.precedence(type);\n", "Context rhsContext = getContextForNoInOperator(context);\n", "addExpr(first, p + 1, context);\n", "cc.addOp(\"?\", true);\n", "addExpr(first.getNext(), 1, rhsContext);\n", "cc.addOp(\":\", true);\n", "addExpr(last, 1, rhsContext);\n", "break;\n", "}\n", "\n", "case Token.REGEXP:\n", "if (!first.isString() ||\n", "!last.isString()) {\n", "throw new Error(\"Expected children to be strings\");\n", "}\n", "\n", "String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n", "\n", "// I only use one .add because whitespace matters\n", "if (childCount == 2) {\n", "add(regexp + last.getString());\n", "} else {\n", "Preconditions.checkState(childCount == 1);\n", "add(regexp);\n", "}\n", "break;\n", "\n", "case Token.FUNCTION:\n", "if (n.getClass() != Node.class) {\n", "throw new Error(\"Unexpected Node subclass.\");\n", "}\n", "Preconditions.checkState(childCount == 3);\n", "boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n", "if (funcNeedsParens) {\n", "add(\"(\");\n", "}\n", "\n", "add(\"function\");\n", "add(first);\n", "\n", "add(first.getNext());\n", "add(last, Context.PRESERVE_BLOCK);\n", "cc.endFunction(context == Context.STATEMENT);\n", "\n", "if (funcNeedsParens) {\n", "add(\")\");\n", "}\n", "break;\n", "\n", "case Token.GETTER_DEF:\n", "case Token.SETTER_DEF:\n", "Preconditions.checkState(n.getParent().isObjectLit());\n", "Preconditions.checkState(childCount == 1);\n", "Preconditions.checkState(first.isFunction());\n", "\n", "// Get methods are unnamed\n", "Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n", "if (type == Token.GETTER_DEF) {\n", "// Get methods have no parameters.\n", "Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n", "add(\"get \");\n", "} else {\n", "// Set methods have one parameter.\n", "Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n", "add(\"set \");\n", "}\n", "\n", "// The name is on the GET or SET node.\n", "String name = n.getString();\n", "Node fn = first;\n", "Node parameters = fn.getChildAtIndex(1);\n", "Node body = fn.getLastChild();\n", "\n", "// Add the property name.\n", "if (!n.isQuotedString() &&\n", "TokenStream.isJSIdentifier(name) &&\n", "// do not encode literally any non-literal characters that were\n", "// Unicode escaped.\n", "NodeUtil.isLatin(name)) {\n", "add(name);\n", "} else {\n", "// Determine if the string is a simple number.\n", "double d = getSimpleNumber(name);\n", "if (!Double.isNaN(d)) {\n", "cc.addNumber(d);\n", "} else {\n", "addJsString(n);\n", "}\n", "}\n", "\n", "add(parameters);\n", "add(body, Context.PRESERVE_BLOCK);\n", "break;\n", "\n", "case Token.SCRIPT:\n", "case Token.BLOCK: {\n", "if (n.getClass() != Node.class) {\n", "throw new Error(\"Unexpected Node subclass.\");\n", "}\n", "boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n", "if (preserveBlock) {\n", "cc.beginBlock();\n", "}\n", "\n", "boolean preferLineBreaks =\n", "type == Token.SCRIPT ||\n", "(type == Token.BLOCK &&\n", "!preserveBlock &&\n", "n.getParent() != null &&\n", "n.getParent().isScript());\n", "for (Node c = first; c != null; c = c.getNext()) {\n", "add(c, Context.STATEMENT);\n", "\n", "// VAR doesn't include ';' since it gets used in expressions\n", "if (c.isVar()) {\n", "cc.endStatement();\n", "}\n", "\n", "if (c.isFunction()) {\n", "cc.maybeLineBreak();\n", "}\n", "\n", "// Prefer to break lines in between top-level statements\n", "// because top-level statements are more homogeneous.\n", "if (preferLineBreaks) {\n", "cc.notePreferredLineBreak();\n", "}\n", "}\n", "if (preserveBlock) {\n", "cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n", "}\n", "break;\n", "}\n", "\n", "case Token.FOR:\n", "if (childCount == 4) {\n", "add(\"for(\");\n", "if (first.isVar()) {\n", "add(first, Context.IN_FOR_INIT_CLAUSE);\n", "} else {\n", "addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n", "}\n", "add(\";\");\n", "add(first.getNext());\n", "add(\";\");\n", "add(first.getNext().getNext());\n", "add(\")\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "} else {\n", "Preconditions.checkState(childCount == 3);\n", "add(\"for(\");\n", "add(first);\n", "add(\"in\");\n", "add(first.getNext());\n", "add(\")\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "}\n", "break;\n", "\n", "case Token.DO:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"do\");\n", "addNonEmptyStatement(first, Context.OTHER, false);\n", "add(\"while(\");\n", "add(last);\n", "add(\")\");\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.WHILE:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"while(\");\n", "add(first);\n", "add(\")\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "break;\n", "\n", "case Token.EMPTY:\n", "Preconditions.checkState(childCount == 0);\n", "break;\n", "\n", "case Token.GETPROP: {\n", "Preconditions.checkState(\n", "childCount == 2,\n", "\"Bad GETPROP: expected 2 children, but got %s\", childCount);\n", "Preconditions.checkState(\n", "last.isString(),\n", "\"Bad GETPROP: RHS should be STRING\");\n", "boolean needsParens = (first.isNumber());\n", "if (needsParens) {\n", "add(\"(\");\n", "}\n", "addExpr(first, NodeUtil.precedence(type), context);\n", "if (needsParens) {\n", "add(\")\");\n", "}\n", "if (this.languageMode == LanguageMode.ECMASCRIPT3\n", "&& TokenStream.isKeyword(last.getString())) {\n", "// Check for ECMASCRIPT3 keywords.\n", "add(\"[\");\n", "add(last);\n", "add(\"]\");\n", "} else {\n", "add(\".\");\n", "addIdentifier(last.getString());\n", "}\n", "break;\n", "}\n", "\n", "case Token.GETELEM:\n", "Preconditions.checkState(\n", "childCount == 2,\n", "\"Bad GETELEM: expected 2 children but got %s\", childCount);\n", "addExpr(first, NodeUtil.precedence(type), context);\n", "add(\"[\");\n", "add(first.getNext());\n", "add(\"]\");\n", "break;\n", "\n", "case Token.WITH:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"with(\");\n", "add(first);\n", "add(\")\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "break;\n", "\n", "case Token.INC:\n", "case Token.DEC: {\n", "Preconditions.checkState(childCount == 1);\n", "String o = type == Token.INC ? \"++\" : \"--\";\n", "int postProp = n.getIntProp(Node.INCRDECR_PROP);\n", "// A non-zero post-prop value indicates a post inc/dec, default of zero\n", "// is a pre-inc/dec.\n", "if (postProp != 0) {\n", "addExpr(first, NodeUtil.precedence(type), context);\n", "cc.addOp(o, false);\n", "} else {\n", "cc.addOp(o, false);\n", "add(first);\n", "}\n", "break;\n", "}\n", "\n", "case Token.CALL:\n", "// We have two special cases here:\n", "// 1) If the left hand side of the call is a direct reference to eval,\n", "// then it must have a DIRECT_EVAL annotation. If it does not, then\n", "// that means it was originally an indirect call to eval, and that\n", "// indirectness must be preserved.\n", "// 2) If the left hand side of the call is a property reference,\n", "// then the call must not a FREE_CALL annotation. If it does, then\n", "// that means it was originally an call without an explicit this and\n", "// that must be preserved.\n", "if (isIndirectEval(first)\n", "|| n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n", "add(\"(0,\");\n", "addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n", "add(\")\");\n", "} else {\n", "addExpr(first, NodeUtil.precedence(type), context);\n", "}\n", "add(\"(\");\n", "addList(first.getNext());\n", "add(\")\");\n", "break;\n", "\n", "case Token.IF:\n", "boolean hasElse = childCount == 3;\n", "boolean ambiguousElseClause =\n", "context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n", "if (ambiguousElseClause) {\n", "cc.beginBlock();\n", "}\n", "\n", "add(\"if(\");\n", "add(first);\n", "add(\")\");\n", "\n", "if (hasElse) {\n", "addNonEmptyStatement(\n", "first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n", "add(\"else\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), false);\n", "} else {\n", "addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n", "Preconditions.checkState(childCount == 2);\n", "}\n", "\n", "if (ambiguousElseClause) {\n", "cc.endBlock();\n", "}\n", "break;\n", "\n", "case Token.NULL:\n", "Preconditions.checkState(childCount == 0);\n", "cc.addConstant(\"null\");\n", "break;\n", "\n", "case Token.THIS:\n", "Preconditions.checkState(childCount == 0);\n", "add(\"this\");\n", "break;\n", "\n", "case Token.FALSE:\n", "Preconditions.checkState(childCount == 0);\n", "cc.addConstant(\"false\");\n", "break;\n", "\n", "case Token.TRUE:\n", "Preconditions.checkState(childCount == 0);\n", "cc.addConstant(\"true\");\n", "break;\n", "\n", "case Token.CONTINUE:\n", "Preconditions.checkState(childCount <= 1);\n", "add(\"continue\");\n", "if (childCount == 1) {\n", "if (!first.isLabelName()) {\n", "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n", "}\n", "add(\" \");\n", "add(first);\n", "}\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.DEBUGGER:\n", "Preconditions.checkState(childCount == 0);\n", "add(\"debugger\");\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.BREAK:\n", "Preconditions.checkState(childCount <= 1);\n", "add(\"break\");\n", "if (childCount == 1) {\n", "if (!first.isLabelName()) {\n", "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n", "}\n", "add(\" \");\n", "add(first);\n", "}\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.EXPR_RESULT:\n", "Preconditions.checkState(childCount == 1);\n", "add(first, Context.START_OF_EXPR);\n", "cc.endStatement();\n", "break;\n", "\n", "case Token.NEW:\n", "add(\"new \");\n", "int precedence = NodeUtil.precedence(type);\n", "\n", "// If the first child contains a CALL, then claim higher precedence\n", "// to force parentheses. Otherwise, when parsed, NEW will bind to the\n", "// first viable parentheses (don't traverse into functions).\n", "if (NodeUtil.containsType(\n", "first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n", "precedence = NodeUtil.precedence(first.getType()) + 1;\n", "}\n", "addExpr(first, precedence, Context.OTHER);\n", "\n", "// '()' is optional when no arguments are present\n", "Node next = first.getNext();\n", "if (next != null) {\n", "add(\"(\");\n", "addList(next);\n", "add(\")\");\n", "}\n", "break;\n", "\n", "case Token.STRING_KEY:\n", "Preconditions.checkState(\n", "childCount == 1, \"Object lit key must have 1 child\");\n", "addJsString(n);\n", "break;\n", "\n", "case Token.STRING:\n", "Preconditions.checkState(\n", "childCount == 0, \"A string may not have children\");\n", "addJsString(n);\n", "break;\n", "\n", "case Token.DELPROP:\n", "Preconditions.checkState(childCount == 1);\n", "add(\"delete \");\n", "add(first);\n", "break;\n", "\n", "case Token.OBJECTLIT: {\n", "boolean needsParens = (context == Context.START_OF_EXPR);\n", "if (needsParens) {\n", "add(\"(\");\n", "}\n", "add(\"{\");\n", "for (Node c = first; c != null; c = c.getNext()) {\n", "if (c != first) {\n", "cc.listSeparator();\n", "}\n", "\n", "if (c.isGetterDef() || c.isSetterDef()) {\n", "add(c);\n", "} else {\n", "Preconditions.checkState(c.isStringKey());\n", "String key = c.getString();\n", "// Object literal property names don't have to be quoted if they\n", "// are not JavaScript keywords\n", "if (!c.isQuotedString()\n", "&& !(languageMode == LanguageMode.ECMASCRIPT3\n", "&& TokenStream.isKeyword(key))\n", "&& TokenStream.isJSIdentifier(key)\n", "// do not encode literally any non-literal characters that\n", "// were Unicode escaped.\n", "&& NodeUtil.isLatin(key)) {\n", "add(key);\n", "} else {\n", "// Determine if the string is a simple number.\n", "double d = getSimpleNumber(key);\n", "if (!Double.isNaN(d)) {\n", "cc.addNumber(d);\n", "} else {\n", "addExpr(c, 1, Context.OTHER);\n", "}\n", "}\n", "add(\":\");\n", "addExpr(c.getFirstChild(), 1, Context.OTHER);\n", "}\n", "}\n", "add(\"}\");\n", "if (needsParens) {\n", "add(\")\");\n", "}\n", "break;\n", "}\n", "\n", "case Token.SWITCH:\n", "add(\"switch(\");\n", "add(first);\n", "add(\")\");\n", "cc.beginBlock();\n", "addAllSiblings(first.getNext());\n", "cc.endBlock(context == Context.STATEMENT);\n", "break;\n", "\n", "case Token.CASE:\n", "Preconditions.checkState(childCount == 2);\n", "add(\"case \");\n", "add(first);\n", "addCaseBody(last);\n", "break;\n", "\n", "case Token.DEFAULT_CASE:\n", "Preconditions.checkState(childCount == 1);\n", "add(\"default\");\n", "addCaseBody(first);\n", "break;\n", "\n", "case Token.LABEL:\n", "Preconditions.checkState(childCount == 2);\n", "if (!first.isLabelName()) {\n", "throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n", "}\n", "add(first);\n", "add(\":\");\n", "addNonEmptyStatement(\n", "last, getContextForNonEmptyExpression(context), true);\n", "break;\n", "\n", "case Token.CAST:\n", "add(\"(\");\n", "add(first);\n", "add(\")\");\n", "break;\n", "\n", "default:\n", "throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n", "}\n", "\n", "cc.endSourceMapping(n);\n", "}\n"], "faulty_lines": [24, 25, 26, 27, 28, 29], "cluster": 7}, {"pid": "Closure", "bid": 174, "method_path": "./dataset/Closure/174/JsAst.java", "method": ["private void parse(AbstractCompiler compiler) {\n", "try {\n", "ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n", "compiler.getParserConfig(),\n", "compiler.getDefaultErrorReporter(),\n", "logger_);\n", "root = result.ast;\n", "compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n", "} catch (IOException e) {\n", "compiler.report(\n", "JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n", "}\n", "\n", "\n", "if (root == null || compiler.hasHaltingErrors()) {\n", "// Most passes try to report as many errors as possible,\n", "// so there may already be errors. We only care if there were\n", "// errors in the code we just parsed.\n", "// There was a parse error or IOException, so use a dummy block.\n", "root = IR.script();\n", "} else {\n", "compiler.prepareAst(root);\n", "}\n", "\n", "// Set the source name so that the compiler passes can track\n", "// the source file and module.\n", "root.setStaticSourceFile(sourceFile);\n", "}\n"], "faulty_lines": [2], "cluster": 8}, {"pid": "Closure", "bid": 174, "method_path": "./dataset/Closure/174/JsAst.java", "method": ["private void parse(AbstractCompiler compiler) {\n", "try {\n", "ParserRunner.ParseResult result = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n", "compiler.getParserConfig(),\n", "compiler.getDefaultErrorReporter(),\n", "logger_);\n", "root = result.ast;\n", "compiler.setOldParseTree(sourceFile.getName(), result.oldAst);\n", "} catch (IOException e) {\n", "compiler.report(\n", "JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n", "}\n", "\n", "\n", "if (root == null || compiler.hasHaltingErrors()) {\n", "// Most passes try to report as many errors as possible,\n", "// so there may already be errors. We only care if there were\n", "// errors in the code we just parsed.\n", "// There was a parse error or IOException, so use a dummy block.\n", "root = IR.script();\n", "} else {\n", "compiler.prepareAst(root);\n", "}\n", "\n", "// Set the source name so that the compiler passes can track\n", "// the source file and module.\n", "root.setStaticSourceFile(sourceFile);\n", "}\n"], "faulty_lines": [15, 19], "cluster": 8}, {"pid": "Closure", "bid": 174, "method_path": "./dataset/Closure/174/NodeUtil.java", "method": ["public static Node newQualifiedNameNodeDeclaration(\n", "CodingConvention convention, String name, Node value, JSDocInfo info) {\n", "Node result;\n", "Node nameNode = newQualifiedNameNode(convention, name);\n", "if (nameNode.isName()) {\n", "result = IR.var(nameNode, value);\n", "result.setJSDocInfo(info);\n", "} else {\n", "result = IR.exprResult(IR.assign(nameNode, value));\n", "result.getFirstChild().setJSDocInfo(info);\n", "}\n", "return result;\n", "}\n"], "faulty_lines": [8, 9], "cluster": 4}, {"pid": "Closure", "bid": 174, "method_path": "./dataset/Closure/174/ScopedAliases.java", "method": ["private void findAliases(NodeTraversal t) {\n", "Scope scope = t.getScope();\n", "for (Var v : scope.getVarIterable()) {\n", "Node n = v.getNode();\n", "Node parent = n.getParent();\n", "boolean isVarAssign = parent.isVar() && n.hasChildren();\n", "if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n", "recordAlias(v);\n", "} else if (v.isBleedingFunction()) {\n", "// Bleeding functions already get a BAD_PARAMETERS error, so just\n", "// do nothing.\n", "} else if (parent.getType() == Token.LP) {\n", "// Parameters of the scope function also get a BAD_PARAMETERS\n", "// error.\n", "} else if (isVarAssign) {\n", "Node value = v.getInitialValue().detachFromParent();\n", "String name = n.getString();\n", "int nameCount = scopedAliasNames.count(name);\n", "scopedAliasNames.add(name);\n", "String globalName =\n", "\"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n", "\n", "compiler.ensureLibraryInjected(\"base\");\n", "\n", "// Add $jscomp.scope.name = EXPR;\n", "// Make sure we copy over all the jsdoc and debug info.\n", "Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n", "compiler.getCodingConvention(),\n", "globalName,\n", "value,\n", "v.getJSDocInfo())\n", ".useSourceInfoIfMissingFromForTree(n);\n", "NodeUtil.setDebugInformation(\n", "newDecl.getFirstChild().getFirstChild(), n, name);\n", "parent.getParent().addChildBefore(newDecl, parent);\n", "\n", "// Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n", "v.getNameNode().addChildToFront(\n", "NodeUtil.newQualifiedNameNode(\n", "compiler.getCodingConvention(), globalName, n, name));\n", "\n", "recordAlias(v);\n", "} else {\n", "// Do not allow hoisted functions or other kinds of local symbols.\n", "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "}\n", "}\n", "}\n"], "faulty_lines": [6, 7], "cluster": 7}, {"pid": "Closure", "bid": 174, "method_path": "./dataset/Closure/174/ScopedAliases.java", "method": ["boolean isVarAssign = parent.isVar() && n.hasChildren();\n", "if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n", "recordAlias(v);\n", "} else if (v.isBleedingFunction()) {\n", "// Bleeding functions already get a BAD_PARAMETERS error, so just\n", "// do nothing.\n", "} else if (parent.getType() == Token.LP) {\n", "// Parameters of the scope function also get a BAD_PARAMETERS\n", "// error.\n", "} else if (isVarAssign) {\n", "Node value = v.getInitialValue().detachFromParent();\n", "String name = n.getString();\n", "int nameCount = scopedAliasNames.count(name);\n", "scopedAliasNames.add(name);\n", "String globalName =\n", "\"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n", "\n", "compiler.ensureLibraryInjected(\"base\");\n", "\n", "// Add $jscomp.scope.name = EXPR;\n", "// Make sure we copy over all the jsdoc and debug info.\n", "Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n", "compiler.getCodingConvention(),\n", "globalName,\n", "value,\n", "v.getJSDocInfo())\n", ".useSourceInfoIfMissingFromForTree(n);\n", "NodeUtil.setDebugInformation(\n", "newDecl.getFirstChild().getFirstChild(), n, name);\n", "parent.getParent().addChildBefore(newDecl, parent);\n", "\n", "// Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n", "v.getNameNode().addChildToFront(\n", "NodeUtil.newQualifiedNameNode(\n", "compiler.getCodingConvention(), globalName, n, name));\n", "\n", "recordAlias(v);\n", "} else {\n", "// Do not allow hoisted functions or other kinds of local symbols.\n", "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "}\n"], "faulty_lines": [10, 11], "cluster": 7}, {"pid": "Closure", "bid": 174, "method_path": "./dataset/Closure/174/ScopedAliases.java", "method": ["boolean isVarAssign = parent.isVar() && n.hasChildren();\n", "if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n", "recordAlias(v);\n", "} else if (v.isBleedingFunction()) {\n", "// Bleeding functions already get a BAD_PARAMETERS error, so just\n", "// do nothing.\n", "} else if (parent.getType() == Token.LP) {\n", "// Parameters of the scope function also get a BAD_PARAMETERS\n", "// error.\n", "} else if (isVarAssign) {\n", "Node value = v.getInitialValue().detachFromParent();\n", "String name = n.getString();\n", "int nameCount = scopedAliasNames.count(name);\n", "scopedAliasNames.add(name);\n", "String globalName =\n", "\"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n", "\n", "compiler.ensureLibraryInjected(\"base\");\n", "\n", "// Add $jscomp.scope.name = EXPR;\n", "// Make sure we copy over all the jsdoc and debug info.\n", "Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n", "compiler.getCodingConvention(),\n", "globalName,\n", "value,\n", "v.getJSDocInfo())\n", ".useSourceInfoIfMissingFromForTree(n);\n", "NodeUtil.setDebugInformation(\n", "newDecl.getFirstChild().getFirstChild(), n, name);\n", "parent.getParent().addChildBefore(newDecl, parent);\n", "\n", "// Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n", "v.getNameNode().addChildToFront(\n", "NodeUtil.newQualifiedNameNode(\n", "compiler.getCodingConvention(), globalName, n, name));\n", "\n", "recordAlias(v);\n", "} else {\n", "// Do not allow hoisted functions or other kinds of local symbols.\n", "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "}\n"], "faulty_lines": [22], "cluster": 7}, {"pid": "Closure", "bid": 174, "method_path": "./dataset/Closure/174/ScopedAliases.java", "method": ["boolean isVarAssign = parent.isVar() && n.hasChildren();\n", "if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n", "recordAlias(v);\n", "} else if (v.isBleedingFunction()) {\n", "// Bleeding functions already get a BAD_PARAMETERS error, so just\n", "// do nothing.\n", "} else if (parent.getType() == Token.LP) {\n", "// Parameters of the scope function also get a BAD_PARAMETERS\n", "// error.\n", "} else if (isVarAssign) {\n", "Node value = v.getInitialValue().detachFromParent();\n", "String name = n.getString();\n", "int nameCount = scopedAliasNames.count(name);\n", "scopedAliasNames.add(name);\n", "String globalName =\n", "\"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n", "\n", "compiler.ensureLibraryInjected(\"base\");\n", "\n", "// Add $jscomp.scope.name = EXPR;\n", "// Make sure we copy over all the jsdoc and debug info.\n", "Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n", "compiler.getCodingConvention(),\n", "globalName,\n", "value,\n", "v.getJSDocInfo())\n", ".useSourceInfoIfMissingFromForTree(n);\n", "NodeUtil.setDebugInformation(\n", "newDecl.getFirstChild().getFirstChild(), n, name);\n", "parent.getParent().addChildBefore(newDecl, parent);\n", "\n", "// Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n", "v.getNameNode().addChildToFront(\n", "NodeUtil.newQualifiedNameNode(\n", "compiler.getCodingConvention(), globalName, n, name));\n", "\n", "recordAlias(v);\n", "} else {\n", "// Do not allow hoisted functions or other kinds of local symbols.\n", "report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "}\n"], "faulty_lines": [31], "cluster": 7}, {"pid": "Closure", "bid": 175, "method_path": "./dataset/Closure/175/FunctionInjector.java", "method": ["private CanInlineResult canInlineReferenceDirectly(\n", "Node callNode, Node fnNode) {\n", "if (!isDirectCallNodeReplacementPossible(fnNode)) {\n", "return CanInlineResult.NO;\n", "}\n", "\n", "Node block = fnNode.getLastChild();\n", "// CALL NODE: [ NAME, ARG1, ARG2, ... ]\n", "Node cArg = callNode.getFirstChild().getNext();\n", "\n", "// Functions called via 'call' and 'apply' have a this-object as\n", "// the first parameter, but this is not part of the called function's\n", "// parameter list.\n", "if (!callNode.getFirstChild().isName()) {\n", "if (NodeUtil.isFunctionObjectCall(callNode)) {\n", "// TODO(johnlenz): Support replace this with a value.\n", "if (cArg == null || !cArg.isThis()) {\n", "return CanInlineResult.NO;\n", "}\n", "cArg = cArg.getNext();\n", "} else {\n", "// \".apply\" call should be filtered before this.\n", "Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n", "}\n", "}\n", "\n", "Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n", "while (cArg != null || fnParam != null) {\n", "if (fnParam != null) {\n", "if (cArg != null) {\n", "if (NodeUtil.mayEffectMutableState(cArg, compiler)\n", "&& NodeUtil.getNameReferenceCount(\n", "block, fnParam.getString()) > 1) {\n", "return CanInlineResult.NO;\n", "}\n", "}\n", "fnParam = fnParam.getNext();\n", "}\n", "// Limit the inlining\n", "if (cArg != null) {\n", "if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n", "return CanInlineResult.NO;\n", "}\n", "cArg = cArg.getNext();\n", "}\n", "}\n", "\n", "return CanInlineResult.YES;\n", "}\n"], "faulty_lines": [27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 40, 41, 43, 44], "cluster": 7}, {"pid": "Closure", "bid": 176, "method_path": "./dataset/Closure/176/TypeInference.java", "method": ["private void updateScopeForTypeChange(\n", "FlowScope scope, Node left, JSType leftType, JSType resultType) {\n", "Preconditions.checkNotNull(resultType);\n", "switch (left.getType()) {\n", "case Token.NAME:\n", "String varName = left.getString();\n", "Var var = syntacticScope.getVar(varName);\n", "boolean isVarDeclaration = left.hasChildren();\n", "\n", "// When looking at VAR initializers for declared VARs, we tend\n", "// to use the declared type over the type it's being\n", "// initialized to in the global scope.\n", "//\n", "// For example,\n", "// /** @param {number} */ var f = goog.abstractMethod;\n", "// it's obvious that the programmer wants you to use\n", "// the declared function signature, not the inferred signature.\n", "//\n", "// Or,\n", "// /** @type {Object.<string>} */ var x = {};\n", "// the one-time anonymous object on the right side\n", "// is as narrow as it can possibly be, but we need to make\n", "// sure we back-infer the <string> element constraint on\n", "// the left hand side, so we use the left hand side.\n", "\n", "boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n", "// Makes it easier to check for NPEs.\n", "\n", "// TODO(nicksantos): This might be a better check once we have\n", "// back-inference of object/array constraints.  It will probably\n", "// introduce more type warnings.  It uses the result type iff it's\n", "// strictly narrower than the declared var type.\n", "//\n", "//boolean isVarTypeBetter = isVarDeclaration &&\n", "//    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n", "//     || !resultType.isSubtype(varType));\n", "\n", "\n", "if (isVarTypeBetter) {\n", "redeclareSimpleVar(scope, left, resultType);\n", "}\n", "left.setJSType(isVarDeclaration || leftType == null ?\n", "resultType : null);\n", "\n", "if (var != null && var.isTypeInferred()) {\n", "JSType oldType = var.getType();\n", "var.setType(oldType == null ?\n", "resultType : oldType.getLeastSupertype(resultType));\n", "}\n", "break;\n", "case Token.GETPROP:\n", "String qualifiedName = left.getQualifiedName();\n", "if (qualifiedName != null) {\n", "scope.inferQualifiedSlot(left, qualifiedName,\n", "leftType == null ? unknownType : leftType,\n", "resultType);\n", "}\n", "\n", "left.setJSType(resultType);\n", "ensurePropertyDefined(left, resultType);\n", "break;\n", "}\n", "}\n"], "faulty_lines": [8], "cluster": 7}, {"pid": "Csv", "bid": 1, "method_path": "./dataset/Csv/1/ExtendedBufferedReader.java", "method": ["public int read() throws IOException {\n", "int current = super.read();\n", "if (current == '\\n') {\n", "lineCounter++;\n", "}\n", "lastChar = current;\n", "return lastChar;\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Csv", "bid": 2, "method_path": "./dataset/Csv/2/CSVRecord.java", "method": ["public String get(final String name) {\n", "if (mapping == null) {\n", "throw new IllegalStateException(\n", "\"No header mapping was specified, the record values can't be accessed by name\");\n", "}\n", "final Integer index = mapping.get(name);\n", "return index != null ? values[index.intValue()] : null;\n", "}\n"], "faulty_lines": [7, 8], "cluster": 4}, {"pid": "Csv", "bid": 4, "method_path": "./dataset/Csv/4/CSVParser.java", "method": ["public Map<String, Integer> getHeaderMap() {\n", "return new LinkedHashMap<String, Integer>(this.headerMap);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Csv", "bid": 5, "method_path": "./dataset/Csv/5/CSVPrinter.java", "method": ["public void println() throws IOException {\n", "final String recordSeparator = format.getRecordSeparator();\n", "out.append(recordSeparator);\n", "newRecord = true;\n", "}\n"], "faulty_lines": [3, 4], "cluster": 0}, {"pid": "Csv", "bid": 7, "method_path": "./dataset/Csv/7/CSVParser.java", "method": ["private Map<String, Integer> initializeHeader() throws IOException {\n", "Map<String, Integer> hdrMap = null;\n", "final String[] formatHeader = this.format.getHeader();\n", "if (formatHeader != null) {\n", "hdrMap = new LinkedHashMap<String, Integer>();\n", "\n", "String[] header = null;\n", "if (formatHeader.length == 0) {\n", "// read the header from the first line of the file\n", "final CSVRecord nextRecord = this.nextRecord();\n", "if (nextRecord != null) {\n", "header = nextRecord.values();\n", "}\n", "} else {\n", "if (this.format.getSkipHeaderRecord()) {\n", "this.nextRecord();\n", "}\n", "header = formatHeader;\n", "}\n", "\n", "// build the name to index mappings\n", "if (header != null) {\n", "for (int i = 0; i < header.length; i++) {\n", "hdrMap.put(header[i], Integer.valueOf(i));\n", "}\n", "}\n", "}\n", "return hdrMap;\n", "}\n"], "faulty_lines": [24], "cluster": 8}, {"pid": "Csv", "bid": 8, "method_path": "./dataset/Csv/8/CSVFormat.java", "method": ["private CSVFormat(final char delimiter, final Character quoteChar,\n", "final Quote quotePolicy, final Character commentStart,\n", "final Character escape, final boolean ignoreSurroundingSpaces,\n", "final boolean ignoreEmptyLines, final String recordSeparator,\n", "final String nullString, final String[] header, final boolean skipHeaderRecord) {\n", "if (isLineBreak(delimiter)) {\n", "throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n", "}\n", "this.delimiter = delimiter;\n", "this.quoteChar = quoteChar;\n", "this.quotePolicy = quotePolicy;\n", "this.commentStart = commentStart;\n", "this.escape = escape;\n", "this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n", "this.ignoreEmptyLines = ignoreEmptyLines;\n", "this.recordSeparator = recordSeparator;\n", "this.nullString = nullString;\n", "if (header == null) {\n", "this.header = null;\n", "} else {\n", "this.header = header.clone();\n", "}\n", "this.skipHeaderRecord = skipHeaderRecord;\n", "}\n"], "faulty_lines": [21], "cluster": 8}, {"pid": "Csv", "bid": 8, "method_path": "./dataset/Csv/8/CSVFormat.java", "method": ["void validate() throws IllegalStateException {\n", "if (quoteChar != null && delimiter == quoteChar.charValue()) {\n", "throw new IllegalStateException(\n", "\"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n", "}\n", "\n", "if (escape != null && delimiter == escape.charValue()) {\n", "throw new IllegalStateException(\n", "\"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n", "}\n", "\n", "if (commentStart != null && delimiter == commentStart.charValue()) {\n", "throw new IllegalStateException(\n", "\"The comment start character and the delimiter cannot be the same ('\" + commentStart + \"')\");\n", "}\n", "\n", "if (quoteChar != null && quoteChar.equals(commentStart)) {\n", "throw new IllegalStateException(\n", "\"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \"')\");\n", "}\n", "\n", "if (escape != null && escape.equals(commentStart)) {\n", "throw new IllegalStateException(\n", "\"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n", "}\n", "\n", "if (escape == null && quotePolicy == Quote.NONE) {\n", "throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n", "}\n", "\n", "if (header != null) {\n", "final Set<String> set = new HashSet<String>(header.length);\n", "set.addAll(Arrays.asList(header));\n", "if (set.size() != header.length) {\n", "throw new IllegalStateException(\"The header contains duplicate names: \" + Arrays.toString(header));\n", "}\n", "}\n", "}\n"], "faulty_lines": [31, 32, 33, 34, 35, 36, 37], "cluster": 1}, {"pid": "Csv", "bid": 10, "method_path": "./dataset/Csv/10/CSVPrinter.java", "method": ["public CSVPrinter(final Appendable out, final CSVFormat format) throws IOException {\n", "Assertions.notNull(out, \"out\");\n", "Assertions.notNull(format, \"format\");\n", "\n", "this.out = out;\n", "this.format = format;\n", "this.format.validate();\n", "// TODO: Is it a good idea to do this here instead of on the first call to a print method?\n", "// It seems a pain to have to track whether the header has already been printed or not.\n", "}\n"], "faulty_lines": [10], "cluster": 4}, {"pid": "Csv", "bid": 11, "method_path": "./dataset/Csv/11/CSVParser.java", "method": ["private Map<String, Integer> initializeHeader() throws IOException {\n", "Map<String, Integer> hdrMap = null;\n", "final String[] formatHeader = this.format.getHeader();\n", "if (formatHeader != null) {\n", "hdrMap = new LinkedHashMap<String, Integer>();\n", "\n", "String[] headerRecord = null;\n", "if (formatHeader.length == 0) {\n", "// read the header from the first line of the file\n", "final CSVRecord nextRecord = this.nextRecord();\n", "if (nextRecord != null) {\n", "headerRecord = nextRecord.values();\n", "}\n", "} else {\n", "if (this.format.getSkipHeaderRecord()) {\n", "this.nextRecord();\n", "}\n", "headerRecord = formatHeader;\n", "}\n", "\n", "// build the name to index mappings\n", "if (headerRecord != null) {\n", "for (int i = 0; i < headerRecord.length; i++) {\n", "final String header = headerRecord[i];\n", "final boolean containsHeader = hdrMap.containsKey(header);\n", "final boolean emptyHeader = header.trim().isEmpty();\n", "if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n", "throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n", "\"\\\" in \" + Arrays.toString(headerRecord));\n", "}\n", "hdrMap.put(header, Integer.valueOf(i));\n", "}\n", "}\n", "}\n", "return hdrMap;\n", "}\n"], "faulty_lines": [26], "cluster": 1}, {"pid": "Csv", "bid": 13, "method_path": "./dataset/Csv/13/CSVPrinter.java", "method": ["private void print(final Object object, final CharSequence value, final int offset, final int len)\n", "throws IOException {\n", "if (!newRecord) {\n", "out.append(format.getDelimiter());\n", "}\n", "if (format.isQuoteCharacterSet()) {\n", "// the original object is needed so can check for Number\n", "printAndQuote(object, value, offset, len);\n", "} else if (format.isEscapeCharacterSet()) {\n", "printAndEscape(value, offset, len);\n", "} else {\n", "out.append(value, offset, offset + len);\n", "}\n", "newRecord = false;\n", "}\n"], "faulty_lines": [6], "cluster": 2}, {"pid": "Csv", "bid": 16, "method_path": "./dataset/Csv/16/CSVParser.java", "method": ["public CSVParser(final Reader reader, final CSVFormat format, final long characterOffset, final long recordNumber)\n", "throws IOException {\n", "Assertions.notNull(reader, \"reader\");\n", "Assertions.notNull(format, \"format\");\n", "\n", "this.format = format;\n", "this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n", "this.headerMap = this.initializeHeader();\n", "this.characterOffset = characterOffset;\n", "this.recordNumber = recordNumber - 1;\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Csv", "bid": 16, "method_path": "./dataset/Csv/16/CSVParser.java", "method": ["public Iterator<CSVRecord> iterator() {\n", "return new Iterator<CSVRecord>() {\n", "private CSVRecord current;\n", "\n", "private CSVRecord getNextRecord() {\n", "try {\n", "return CSVParser.this.nextRecord();\n", "} catch (final IOException e) {\n", "throw new IllegalStateException(\n", "e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n", "}\n", "}\n", "\n", "@Override\n", "public boolean hasNext() {\n", "if (CSVParser.this.isClosed()) {\n", "return false;\n", "}\n", "if (this.current == null) {\n", "this.current = this.getNextRecord();\n", "}\n", "\n", "return this.current != null;\n", "}\n", "\n", "@Override\n", "public CSVRecord next() {\n", "if (CSVParser.this.isClosed()) {\n", "throw new NoSuchElementException(\"CSVParser has been closed\");\n", "}\n", "CSVRecord next = this.current;\n", "this.current = null;\n", "\n", "if (next == null) {\n", "// hasNext() wasn't called before\n", "next = this.getNextRecord();\n", "if (next == null) {\n", "throw new NoSuchElementException(\"No more CSV records available\");\n", "}\n", "}\n", "\n", "return next;\n", "}\n", "\n", "@Override\n", "public void remove() {\n", "throw new UnsupportedOperationException();\n", "}\n", "};\n", "}\n"], "faulty_lines": [2], "cluster": 1}, {"pid": "Cli", "bid": 1, "method_path": "./dataset/Cli/1/CommandLine.java", "method": ["public boolean hasOption(String opt)\n", "{\n", "return options.containsKey(opt);\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Cli", "bid": 1, "method_path": "./dataset/Cli/1/CommandLine.java", "method": ["public Object getOptionObject(String opt)\n", "{\n", "String res = getOptionValue(opt);\n", "\n", "if (!options.containsKey(opt))\n", "{\n", "return null;\n", "}\n", "\n", "Object type = ((Option) options.get(opt)).getType();\n", "\n", "return (res == null)        ? null : TypeHandler.createValue(res, type);\n", "}\n"], "faulty_lines": [5, 10], "cluster": 4}, {"pid": "Cli", "bid": 1, "method_path": "./dataset/Cli/1/CommandLine.java", "method": ["public String[] getOptionValues(String opt)\n", "{\n", "opt = Util.stripLeadingHyphens(opt);\n", "\n", "String key = opt;\n", "if (names.containsKey(opt))\n", "{\n", "key = (String) names.get(opt);\n", "}\n", "if (options.containsKey(key))\n", "{\n", "return ((Option) options.get(key)).getValues();\n", "}\n", "\n", "return null;\n", "}\n"], "faulty_lines": [3, 5, 6, 7, 8, 9, 10, 12], "cluster": 4}, {"pid": "Cli", "bid": 1, "method_path": "./dataset/Cli/1/CommandLine.java", "method": ["void addOption(Option opt)\n", "{\n", "hashcodeMap.put(new Integer(opt.hashCode()), opt);\n", "String key = opt.getKey();\n", "if (key == null)\n", "{\n", "key = opt.getLongOpt();\n", "}\n", "else\n", "{\n", "names.put(opt.getLongOpt(), key);\n", "}\n", "options.put(key, opt);\n", "}\n"], "faulty_lines": [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], "cluster": 4}, {"pid": "Cli", "bid": 1, "method_path": "./dataset/Cli/1/CommandLine.java", "method": ["public Iterator iterator()\n", "{\n", "return hashcodeMap.values().iterator();\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Cli", "bid": 1, "method_path": "./dataset/Cli/1/CommandLine.java", "method": ["public Option[] getOptions()\n", "{\n", "Collection processed = options.values();\n", "\n", "// reinitialise array\n", "Option[] optionsArray = new Option[processed.size()];\n", "\n", "// return the array\n", "return (Option[]) processed.toArray(optionsArray);\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Cli", "bid": 3, "method_path": "./dataset/Cli/3/TypeHandler.java", "method": ["public static Number createNumber(String str)\n", "{\n", "try\n", "{\n", "return org.apache.commons.lang.math.NumberUtils.createNumber(str);\n", "}\n", "catch (NumberFormatException nfe)\n", "{\n", "System.err.println(nfe.getMessage());\n", "}\n", "\n", "return null;\n", "}\n"], "faulty_lines": [5], "cluster": 4}, {"pid": "Cli", "bid": 8, "method_path": "./dataset/Cli/8/HelpFormatter.java", "method": ["protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n", "int nextLineTabStop, String text)\n", "{\n", "int pos = findWrapPos(text, width, 0);\n", "\n", "if (pos == -1)\n", "{\n", "sb.append(rtrim(text));\n", "\n", "return sb;\n", "}\n", "sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n", "\n", "// all following lines must be padded with nextLineTabStop space\n", "// characters\n", "final String padding = createPadding(nextLineTabStop);\n", "\n", "while (true)\n", "{\n", "text = padding + text.substring(pos).trim();\n", "pos = findWrapPos(text, width, nextLineTabStop);\n", "\n", "if (pos == -1)\n", "{\n", "sb.append(text);\n", "\n", "return sb;\n", "}\n", "\n", "sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n", "}\n", "}\n"], "faulty_lines": [21], "cluster": 8}, {"pid": "Cli", "bid": 10, "method_path": "./dataset/Cli/10/Parser.java", "method": ["protected void setOptions(final Options options) {\n", "this.options = options;\n", "this.requiredOptions = options.getRequiredOptions();\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Cli", "bid": 11, "method_path": "./dataset/Cli/11/HelpFormatter.java", "method": ["private static void appendOption(final StringBuffer buff,\n", "final Option option,\n", "final boolean required)\n", "{\n", "if (!required)\n", "{\n", "buff.append(\"[\");\n", "}\n", "\n", "if (option.getOpt() != null)\n", "{\n", "buff.append(\"-\").append(option.getOpt());\n", "}\n", "else\n", "{\n", "buff.append(\"--\").append(option.getLongOpt());\n", "}\n", "\n", "// if the Option has a value\n", "if (option.hasArg() && (option.getArgName() != null))\n", "{\n", "buff.append(\" <\").append(option.getArgName()).append(\">\");\n", "}\n", "\n", "// if the Option is not a required option\n", "if (!required)\n", "{\n", "buff.append(\"]\");\n", "}\n", "}\n"], "faulty_lines": [20], "cluster": 2}, {"pid": "Cli", "bid": 13, "method_path": "./dataset/Cli/13/ArgumentImpl.java", "method": ["public void processValues(final WriteableCommandLine commandLine,\n", "final ListIterator arguments,\n", "final Option option)\n", "throws OptionException {\n", "// count of arguments processed for this option.\n", "int argumentCount = 0;\n", "\n", "while (arguments.hasNext() && (argumentCount < maximum)) {\n", "final String allValuesQuoted = (String) arguments.next();\n", "final String allValues = stripBoundaryQuotes(allValuesQuoted);\n", "\n", "// should we ignore things that look like options?\n", "if (allValuesQuoted.equals(consumeRemaining)) {\n", "while (arguments.hasNext() && (argumentCount < maximum)) {\n", "++argumentCount;\n", "commandLine.addValue(option, arguments.next());\n", "}\n", "}\n", "// does it look like an option?\n", "else if (commandLine.looksLikeOption(allValuesQuoted)) {\n", "arguments.previous();\n", "\n", "break;\n", "}\n", "// should we split the string up?\n", "else if (subsequentSplit) {\n", "final StringTokenizer values =\n", "new StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n", "\n", "arguments.remove();\n", "\n", "while (values.hasMoreTokens() && (argumentCount < maximum)) {\n", "++argumentCount;\n", "\n", "final String token = values.nextToken();\n", "commandLine.addValue(option, token);\n", "arguments.add(token);\n", "}\n", "\n", "if (values.hasMoreTokens()) {\n", "throw new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n", "values.nextToken());\n", "}\n", "}\n", "// it must be a value as it is\n", "else {\n", "++argumentCount;\n", "commandLine.addValue(option, allValues);\n", "}\n", "}\n", "}\n"], "faulty_lines": [6], "cluster": 5}, {"pid": "Cli", "bid": 14, "method_path": "./dataset/Cli/14/GroupImpl.java", "method": ["public void validate(final WriteableCommandLine commandLine)\n", "throws OptionException {\n", "// number of options found\n", "int present = 0;\n", "\n", "// reference to first unexpected option\n", "Option unexpected = null;\n", "\n", "for (final Iterator i = options.iterator(); i.hasNext();) {\n", "final Option option = (Option) i.next();\n", "\n", "// needs validation?\n", "boolean validate = option.isRequired() || option instanceof Group;\n", "if (validate) {\n", "option.validate(commandLine);\n", "}\n", "\n", "// if the child option is present then validate it\n", "if (commandLine.hasOption(option)) {\n", "if (++present > maximum) {\n", "unexpected = option;\n", "\n", "break;\n", "}\n", "\n", "option.validate(commandLine);\n", "}\n", "}\n", "\n", "// too many options\n", "if (unexpected != null) {\n", "throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n", "unexpected.getPreferredName());\n", "}\n", "\n", "// too few option\n", "if (present < minimum) {\n", "throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n", "}\n", "\n", "// validate each anonymous argument\n", "for (final Iterator i = anonymous.iterator(); i.hasNext();) {\n", "final Option option = (Option) i.next();\n", "option.validate(commandLine);\n", "}\n", "}\n"], "faulty_lines": [14, 15, 16], "cluster": 1}, {"pid": "Cli", "bid": 15, "method_path": "./dataset/Cli/15/WriteableCommandLineImpl.java", "method": ["public List getValues(final Option option,\n", "List defaultValues) {\n", "// initialize the return list\n", "List valueList = (List) values.get(option);\n", "\n", "// grab the correct default values\n", "if ((valueList == null) || valueList.isEmpty()) {\n", "valueList = defaultValues;\n", "}\n", "\n", "// augment the list with the default values\n", "if ((valueList == null) || valueList.isEmpty()) {\n", "valueList = (List) this.defaultValues.get(option);\n", "}\n", "// if there are more default values as specified, add them to\n", "// the list.\n", "// copy the list first\n", "\n", "return valueList == null ? Collections.EMPTY_LIST : valueList;\n", "}\n"], "faulty_lines": [7, 8, 12, 13, 14, 17, 18], "cluster": 2}, {"pid": "Cli", "bid": 16, "method_path": "./dataset/Cli/16/WriteableCommandLineImpl.java", "method": ["public void addOption(Option option) {\n", "options.add(option);\n", "nameToOption.put(option.getPreferredName(), option);\n", "\n", "for (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\n", "nameToOption.put(i.next(), option);\n", "}\n", "\n", "// ensure that all parent options are also added\n", "}\n"], "faulty_lines": [10], "cluster": 4}, {"pid": "Cli", "bid": 16, "method_path": "./dataset/Cli/16/GroupImpl.java", "method": ["public GroupImpl(final List options,\n", "final String name,\n", "final String description,\n", "final int minimum,\n", "final int maximum) {\n", "super(0, false);\n", "\n", "this.name = name;\n", "this.description = description;\n", "this.minimum = minimum;\n", "this.maximum = maximum;\n", "\n", "// store a copy of the options to be used by the\n", "// help methods\n", "this.options = Collections.unmodifiableList(options);\n", "\n", "// anonymous Argument temporary storage\n", "final List newAnonymous = new ArrayList();\n", "\n", "// map (key=trigger & value=Option) temporary storage\n", "final SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n", "\n", "// prefixes temporary storage\n", "final Set newPrefixes = new HashSet();\n", "\n", "// process the options\n", "for (final Iterator i = options.iterator(); i.hasNext();) {\n", "final Option option = (Option) i.next();\n", "\n", "if (option instanceof Argument) {\n", "i.remove();\n", "newAnonymous.add(option);\n", "} else {\n", "final Set triggers = option.getTriggers();\n", "\n", "for (Iterator j = triggers.iterator(); j.hasNext();) {\n", "newOptionMap.put(j.next(), option);\n", "}\n", "\n", "// store the prefixes\n", "newPrefixes.addAll(option.getPrefixes());\n", "}\n", "}\n", "\n", "this.anonymous = Collections.unmodifiableList(newAnonymous);\n", "this.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\n", "this.prefixes = Collections.unmodifiableSet(newPrefixes);\n", "}\n"], "faulty_lines": [29], "cluster": 1}, {"pid": "Cli", "bid": 17, "method_path": "./dataset/Cli/17/PosixParser.java", "method": ["protected void burstToken(String token, boolean stopAtNonOption)\n", "{\n", "for (int i = 1; i < token.length(); i++)\n", "{\n", "String ch = String.valueOf(token.charAt(i));\n", "\n", "if (options.hasOption(ch))\n", "{\n", "tokens.add(\"-\" + ch);\n", "currentOption = options.getOption(ch);\n", "\n", "if (currentOption.hasArg() && (token.length() != (i + 1)))\n", "{\n", "tokens.add(token.substring(i + 1));\n", "\n", "break;\n", "}\n", "}\n", "else if (stopAtNonOption)\n", "{\n", "process(token.substring(i));\n", "}\n", "else\n", "{\n", "tokens.add(token);\n", "break;\n", "}\n", "}\n", "}\n"], "faulty_lines": [22], "cluster": 2}, {"pid": "Cli", "bid": 18, "method_path": "./dataset/Cli/18/PosixParser.java", "method": ["protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n", "{\n", "init();\n", "this.options = options;\n", "\n", "// an iterator for the command line tokens\n", "Iterator iter = Arrays.asList(arguments).iterator();\n", "\n", "// process each command line token\n", "while (iter.hasNext())\n", "{\n", "// get the next command line token\n", "String token = (String) iter.next();\n", "\n", "// handle SPECIAL TOKEN\n", "if (token.startsWith(\"--\"))\n", "{\n", "if (token.indexOf('=') != -1)\n", "{\n", "tokens.add(token.substring(0, token.indexOf('=')));\n", "tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n", "}\n", "else\n", "{\n", "tokens.add(token);\n", "}\n", "}\n", "\n", "// single hyphen\n", "else if (\"-\".equals(token))\n", "{\n", "processSingleHyphen(token);\n", "}\n", "else if (token.startsWith(\"-\"))\n", "{\n", "if (token.length() == 2)\n", "{\n", "processOptionToken(token, stopAtNonOption);\n", "}\n", "else if (options.hasOption(token))\n", "{\n", "tokens.add(token);\n", "}\n", "// requires bursting\n", "else\n", "{\n", "burstToken(token, stopAtNonOption);\n", "}\n", "}\n", "else if (stopAtNonOption)\n", "{\n", "process(token);\n", "}\n", "else\n", "{\n", "tokens.add(token);\n", "}\n", "\n", "gobble(iter);\n", "}\n", "\n", "return (String[]) tokens.toArray(new String[tokens.size()]);\n", "}\n"], "faulty_lines": [32], "cluster": 5}, {"pid": "Cli", "bid": 18, "method_path": "./dataset/Cli/18/PosixParser.java", "method": ["private void processOptionToken(String token, boolean stopAtNonOption)\n", "{\n", "if (options.hasOption(token))\n", "{\n", "currentOption = options.getOption(token);\n", "tokens.add(token);\n", "}\n", "else if (stopAtNonOption)\n", "{\n", "eatTheRest = true;\n", "}\n", "}\n"], "faulty_lines": [11], "cluster": 4}, {"pid": "Cli", "bid": 19, "method_path": "./dataset/Cli/19/PosixParser.java", "method": ["private void processOptionToken(String token, boolean stopAtNonOption)\n", "{\n", "if (options.hasOption(token))\n", "{\n", "currentOption = options.getOption(token);\n", "tokens.add(token);\n", "}\n", "else if (stopAtNonOption)\n", "{\n", "eatTheRest = true;\n", "tokens.add(token);\n", "}\n", "}\n"], "faulty_lines": [6, 11, 13], "cluster": 4}, {"pid": "Cli", "bid": 20, "method_path": "./dataset/Cli/20/PosixParser.java", "method": ["protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n", "{\n", "init();\n", "this.options = options;\n", "\n", "// an iterator for the command line tokens\n", "Iterator iter = Arrays.asList(arguments).iterator();\n", "\n", "// process each command line token\n", "while (iter.hasNext())\n", "{\n", "// get the next command line token\n", "String token = (String) iter.next();\n", "\n", "// handle long option --foo or --foo=bar\n", "if (token.startsWith(\"--\"))\n", "{\n", "if (token.indexOf('=') != -1)\n", "{\n", "tokens.add(token.substring(0, token.indexOf('=')));\n", "tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n", "}\n", "else\n", "{\n", "tokens.add(token);\n", "}\n", "}\n", "\n", "// single hyphen\n", "else if (\"-\".equals(token))\n", "{\n", "tokens.add(token);\n", "}\n", "else if (token.startsWith(\"-\"))\n", "{\n", "if (token.length() == 2)\n", "{\n", "processOptionToken(token, stopAtNonOption);\n", "}\n", "else if (options.hasOption(token))\n", "{\n", "tokens.add(token);\n", "}\n", "// requires bursting\n", "else\n", "{\n", "burstToken(token, stopAtNonOption);\n", "}\n", "}\n", "else if (stopAtNonOption)\n", "{\n", "process(token);\n", "}\n", "else\n", "{\n", "tokens.add(token);\n", "}\n", "\n", "gobble(iter);\n", "}\n", "\n", "return (String[]) tokens.toArray(new String[tokens.size()]);\n", "}\n"], "faulty_lines": [18, 20, 21, 25], "cluster": 5}, {"pid": "Cli", "bid": 21, "method_path": "./dataset/Cli/21/WriteableCommandLineImpl.java", "method": ["public boolean looksLikeOption(final String trigger)\n", "{\n", "// this is a reentrant call\n", "\n", "for (final Iterator i = prefixes.iterator(); i.hasNext();)\n", "{\n", "final String prefix = (String) i.next();\n", "\n", "if (trigger.startsWith(prefix))\n", "{\n", "return true;\n", "}\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [3, 4, 5, 11, 12, 14, 15], "cluster": 4}, {"pid": "Cli", "bid": 21, "method_path": "./dataset/Cli/21/GroupImpl.java", "method": ["private boolean looksLikeOption(final WriteableCommandLine commandLine,\n", "final String trigger) {\n", "return commandLine.looksLikeOption(trigger);\n", "}\n"], "faulty_lines": [3, 4], "cluster": 0}, {"pid": "Cli", "bid": 22, "method_path": "./dataset/Cli/22/PosixParser.java", "method": ["protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n", "{\n", "init();\n", "this.options = options;\n", "\n", "// an iterator for the command line tokens\n", "Iterator iter = Arrays.asList(arguments).iterator();\n", "\n", "// process each command line token\n", "while (iter.hasNext())\n", "{\n", "// get the next command line token\n", "String token = (String) iter.next();\n", "\n", "// handle long option --foo or --foo=bar\n", "if (token.startsWith(\"--\"))\n", "{\n", "int pos = token.indexOf('=');\n", "String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n", "\n", "if (!options.hasOption(opt))\n", "{\n", "processNonOptionToken(token);\n", "}\n", "else\n", "{\n", "\n", "tokens.add(opt);\n", "if (pos != -1)\n", "{\n", "tokens.add(token.substring(pos + 1));\n", "}\n", "}\n", "}\n", "\n", "// single hyphen\n", "else if (\"-\".equals(token))\n", "{\n", "tokens.add(token);\n", "}\n", "else if (token.startsWith(\"-\"))\n", "{\n", "if (token.length() == 2 || options.hasOption(token))\n", "{\n", "processOptionToken(token, stopAtNonOption);\n", "}\n", "// requires bursting\n", "else\n", "{\n", "burstToken(token, stopAtNonOption);\n", "}\n", "}\n", "else if (stopAtNonOption)\n", "{\n", "processNonOptionToken(token);\n", "}\n", "else\n", "{\n", "tokens.add(token);\n", "}\n", "\n", "gobble(iter);\n", "}\n", "\n", "return (String[]) tokens.toArray(new String[tokens.size()]);\n", "}\n"], "faulty_lines": [23, 27], "cluster": 5}, {"pid": "Cli", "bid": 22, "method_path": "./dataset/Cli/22/PosixParser.java", "method": ["protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n", "{\n", "init();\n", "this.options = options;\n", "\n", "// an iterator for the command line tokens\n", "Iterator iter = Arrays.asList(arguments).iterator();\n", "\n", "// process each command line token\n", "while (iter.hasNext())\n", "{\n", "// get the next command line token\n", "String token = (String) iter.next();\n", "\n", "// handle long option --foo or --foo=bar\n", "if (token.startsWith(\"--\"))\n", "{\n", "int pos = token.indexOf('=');\n", "String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n", "\n", "if (!options.hasOption(opt))\n", "{\n", "processNonOptionToken(token);\n", "}\n", "else\n", "{\n", "\n", "tokens.add(opt);\n", "if (pos != -1)\n", "{\n", "tokens.add(token.substring(pos + 1));\n", "}\n", "}\n", "}\n", "\n", "// single hyphen\n", "else if (\"-\".equals(token))\n", "{\n", "tokens.add(token);\n", "}\n", "else if (token.startsWith(\"-\"))\n", "{\n", "if (token.length() == 2 || options.hasOption(token))\n", "{\n", "processOptionToken(token, stopAtNonOption);\n", "}\n", "// requires bursting\n", "else\n", "{\n", "burstToken(token, stopAtNonOption);\n", "}\n", "}\n", "else if (stopAtNonOption)\n", "{\n", "processNonOptionToken(token);\n", "}\n", "else\n", "{\n", "tokens.add(token);\n", "}\n", "\n", "gobble(iter);\n", "}\n", "\n", "return (String[]) tokens.toArray(new String[tokens.size()]);\n", "}\n"], "faulty_lines": [53, 54, 55, 56, 59], "cluster": 5}, {"pid": "Cli", "bid": 22, "method_path": "./dataset/Cli/22/PosixParser.java", "method": ["private void processOptionToken(String token, boolean stopAtNonOption)\n", "{\n", "if (stopAtNonOption && !options.hasOption(token))\n", "{\n", "eatTheRest = true;\n", "}\n", "\n", "\n", "tokens.add(token);\n", "}\n"], "faulty_lines": [8], "cluster": 0}, {"pid": "Cli", "bid": 22, "method_path": "./dataset/Cli/22/PosixParser.java", "method": ["protected void burstToken(String token, boolean stopAtNonOption)\n", "{\n", "Option currentOption;\n", "for (int i = 1; i < token.length(); i++)\n", "{\n", "String ch = String.valueOf(token.charAt(i));\n", "\n", "if (options.hasOption(ch))\n", "{\n", "tokens.add(\"-\" + ch);\n", "currentOption = options.getOption(ch);\n", "\n", "if (currentOption.hasArg() && (token.length() != (i + 1)))\n", "{\n", "tokens.add(token.substring(i + 1));\n", "\n", "break;\n", "}\n", "}\n", "else if (stopAtNonOption)\n", "{\n", "processNonOptionToken(token.substring(i));\n", "break;\n", "}\n", "else\n", "{\n", "tokens.add(token);\n", "break;\n", "}\n", "}\n", "}\n"], "faulty_lines": [3], "cluster": 2}, {"pid": "Cli", "bid": 22, "method_path": "./dataset/Cli/22/PosixParser.java", "method": ["protected void burstToken(String token, boolean stopAtNonOption)\n", "{\n", "Option currentOption;\n", "for (int i = 1; i < token.length(); i++)\n", "{\n", "String ch = String.valueOf(token.charAt(i));\n", "\n", "if (options.hasOption(ch))\n", "{\n", "tokens.add(\"-\" + ch);\n", "currentOption = options.getOption(ch);\n", "\n", "if (currentOption.hasArg() && (token.length() != (i + 1)))\n", "{\n", "tokens.add(token.substring(i + 1));\n", "\n", "break;\n", "}\n", "}\n", "else if (stopAtNonOption)\n", "{\n", "processNonOptionToken(token.substring(i));\n", "break;\n", "}\n", "else\n", "{\n", "tokens.add(token);\n", "break;\n", "}\n", "}\n", "}\n"], "faulty_lines": [22], "cluster": 2}, {"pid": "Cli", "bid": 23, "method_path": "./dataset/Cli/23/HelpFormatter.java", "method": ["protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n", "int nextLineTabStop, String text)\n", "{\n", "int pos = findWrapPos(text, width, 0);\n", "\n", "if (pos == -1)\n", "{\n", "sb.append(rtrim(text));\n", "\n", "return sb;\n", "}\n", "sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n", "\n", "// all following lines must be padded with nextLineTabStop space\n", "// characters\n", "final String padding = createPadding(nextLineTabStop);\n", "\n", "while (true)\n", "{\n", "int lastPos = pos;\n", "text = padding + text.substring(pos).trim();\n", "pos = findWrapPos(text, width, 0);\n", "\n", "if (pos == -1)\n", "{\n", "sb.append(text);\n", "\n", "return sb;\n", "} else\n", "if (pos == lastPos)\n", "{\n", "throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n", "}\n", "\n", "sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n", "}\n", "}\n"], "faulty_lines": [20], "cluster": 8}, {"pid": "Cli", "bid": 23, "method_path": "./dataset/Cli/23/HelpFormatter.java", "method": ["protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n", "int nextLineTabStop, String text)\n", "{\n", "int pos = findWrapPos(text, width, 0);\n", "\n", "if (pos == -1)\n", "{\n", "sb.append(rtrim(text));\n", "\n", "return sb;\n", "}\n", "sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n", "\n", "// all following lines must be padded with nextLineTabStop space\n", "// characters\n", "final String padding = createPadding(nextLineTabStop);\n", "\n", "while (true)\n", "{\n", "int lastPos = pos;\n", "text = padding + text.substring(pos).trim();\n", "pos = findWrapPos(text, width, 0);\n", "\n", "if (pos == -1)\n", "{\n", "sb.append(text);\n", "\n", "return sb;\n", "} else\n", "if (pos == lastPos)\n", "{\n", "throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n", "}\n", "\n", "sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n", "}\n", "}\n"], "faulty_lines": [29, 30, 31, 32], "cluster": 8}, {"pid": "Cli", "bid": 24, "method_path": "./dataset/Cli/24/HelpFormatter.java", "method": ["protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n", "int nextLineTabStop, String text)\n", "{\n", "int pos = findWrapPos(text, width, 0);\n", "\n", "if (pos == -1)\n", "{\n", "sb.append(rtrim(text));\n", "\n", "return sb;\n", "}\n", "sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n", "\n", "if (nextLineTabStop >= width)\n", "{\n", "// stops infinite loop happening\n", "throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" +\n", "\"- no room for the description\");\n", "}\n", "\n", "// all following lines must be padded with nextLineTabStop space\n", "// characters\n", "final String padding = createPadding(nextLineTabStop);\n", "\n", "while (true)\n", "{\n", "text = padding + text.substring(pos).trim();\n", "pos = findWrapPos(text, width, 0);\n", "\n", "if (pos == -1)\n", "{\n", "sb.append(text);\n", "\n", "return sb;\n", "}\n", "\n", "if ( (text.length() > width) && (pos == nextLineTabStop - 1) )\n", "{\n", "pos = width;\n", "}\n", "\n", "sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n", "}\n", "}\n"], "faulty_lines": [17, 18], "cluster": 1}, {"pid": "Cli", "bid": 25, "method_path": "./dataset/Cli/25/HelpFormatter.java", "method": ["protected StringBuffer renderWrappedText(StringBuffer sb, int width,\n", "int nextLineTabStop, String text)\n", "{\n", "int pos = findWrapPos(text, width, 0);\n", "\n", "if (pos == -1)\n", "{\n", "sb.append(rtrim(text));\n", "\n", "return sb;\n", "}\n", "sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n", "\n", "if (nextLineTabStop >= width)\n", "{\n", "// stops infinite loop happening\n", "nextLineTabStop = width - 1;\n", "}\n", "\n", "// all following lines must be padded with nextLineTabStop space\n", "// characters\n", "final String padding = createPadding(nextLineTabStop);\n", "\n", "while (true)\n", "{\n", "text = padding + text.substring(pos).trim();\n", "pos = findWrapPos(text, width, 0);\n", "\n", "if (pos == -1)\n", "{\n", "sb.append(text);\n", "\n", "return sb;\n", "}\n", "\n", "if ( (text.length() > width) && (pos == nextLineTabStop - 1) )\n", "{\n", "pos = width;\n", "}\n", "\n", "sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n", "}\n", "}\n"], "faulty_lines": [17], "cluster": 8}, {"pid": "Cli", "bid": 26, "method_path": "./dataset/Cli/26/OptionBuilder.java", "method": ["public static Option create(String opt) throws IllegalArgumentException\n", "{\n", "// create the option\n", "Option option = new Option(opt, description);\n", "\n", "// set the option properties\n", "option.setLongOpt(longopt);\n", "option.setRequired(required);\n", "option.setOptionalArg(optionalArg);\n", "option.setArgs(numberOfArgs);\n", "option.setType(type);\n", "option.setValueSeparator(valuesep);\n", "option.setArgName(argName);\n", "// reset the OptionBuilder properties\n", "OptionBuilder.reset();\n", "\n", "// return the Option instance\n", "return option;\n", "}\n"], "faulty_lines": [3, 4], "cluster": 4}, {"pid": "Cli", "bid": 26, "method_path": "./dataset/Cli/26/OptionBuilder.java", "method": ["public static Option create(String opt) throws IllegalArgumentException\n", "{\n", "// create the option\n", "Option option = new Option(opt, description);\n", "\n", "// set the option properties\n", "option.setLongOpt(longopt);\n", "option.setRequired(required);\n", "option.setOptionalArg(optionalArg);\n", "option.setArgs(numberOfArgs);\n", "option.setType(type);\n", "option.setValueSeparator(valuesep);\n", "option.setArgName(argName);\n", "// reset the OptionBuilder properties\n", "OptionBuilder.reset();\n", "\n", "// return the Option instance\n", "return option;\n", "}\n"], "faulty_lines": [14, 16], "cluster": 4}, {"pid": "Cli", "bid": 27, "method_path": "./dataset/Cli/27/OptionGroup.java", "method": ["public void setSelected(Option option) throws AlreadySelectedException\n", "{\n", "if (option == null)\n", "{\n", "// reset the option previously selected\n", "selected = null;\n", "return;\n", "}\n", "\n", "// if no option has already been selected or the\n", "// same option is being reselected then set the\n", "// selected member variable\n", "if (selected == null || selected.equals(option.getOpt()))\n", "{\n", "selected = option.getOpt();\n", "}\n", "else\n", "{\n", "throw new AlreadySelectedException(this, option);\n", "}\n", "}\n"], "faulty_lines": [13, 15], "cluster": 4}, {"pid": "Cli", "bid": 28, "method_path": "./dataset/Cli/28/Parser.java", "method": ["protected void processProperties(Properties properties)\n", "{\n", "if (properties == null)\n", "{\n", "return;\n", "}\n", "\n", "for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n", "{\n", "String option = e.nextElement().toString();\n", "\n", "if (!cmd.hasOption(option))\n", "{\n", "Option opt = getOptions().getOption(option);\n", "\n", "// get the value from the properties instance\n", "String value = properties.getProperty(option);\n", "\n", "if (opt.hasArg())\n", "{\n", "if (opt.getValues() == null || opt.getValues().length == 0)\n", "{\n", "try\n", "{\n", "opt.addValueForProcessing(value);\n", "}\n", "catch (RuntimeException exp)\n", "{\n", "// if we cannot add the value don't worry about it\n", "}\n", "}\n", "}\n", "else if (!(\"yes\".equalsIgnoreCase(value)\n", "|| \"true\".equalsIgnoreCase(value)\n", "|| \"1\".equalsIgnoreCase(value)))\n", "{\n", "// if the value is not yes, true or 1 then don't add the\n", "// option to the CommandLine\n", "break;\n", "}\n", "\n", "cmd.addOption(opt);\n", "}\n", "}\n", "}\n"], "faulty_lines": [39], "cluster": 8}, {"pid": "Cli", "bid": 30, "method_path": "./dataset/Cli/30/DefaultParser.java", "method": ["private void handleProperties(Properties properties) throws ParseException\n", "{\n", "if (properties == null)\n", "{\n", "return;\n", "}\n", "\n", "for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n", "{\n", "String option = e.nextElement().toString();\n", "\n", "if (!cmd.hasOption(option))\n", "{\n", "Option opt = options.getOption(option);\n", "\n", "// if the option is part of a group, check if another option of the group has been selected\n", "\n", "// get the value from the properties\n", "String value = properties.getProperty(option);\n", "\n", "if (opt.hasArg())\n", "{\n", "if (opt.getValues() == null || opt.getValues().length == 0)\n", "{\n", "opt.addValueForProcessing(value);\n", "}\n", "}\n", "else if (!(\"yes\".equalsIgnoreCase(value)\n", "|| \"true\".equalsIgnoreCase(value)\n", "|| \"1\".equalsIgnoreCase(value)))\n", "{\n", "// if the value is not yes, true or 1 then don't add the option to the CommandLine\n", "continue;\n", "}\n", "\n", "handleOption(opt);\n", "currentOption = null;\n", "}\n", "}\n", "}\n"], "faulty_lines": [12, 14, 17, 18], "cluster": 8}, {"pid": "Cli", "bid": 30, "method_path": "./dataset/Cli/30/Parser.java", "method": ["protected void processProperties(Properties properties) throws ParseException\n", "{\n", "if (properties == null)\n", "{\n", "return;\n", "}\n", "\n", "for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n", "{\n", "String option = e.nextElement().toString();\n", "\n", "if (!cmd.hasOption(option))\n", "{\n", "Option opt = getOptions().getOption(option);\n", "\n", "// if the option is part of a group, check if another option of the group has been selected\n", "\n", "// get the value from the properties instance\n", "String value = properties.getProperty(option);\n", "\n", "if (opt.hasArg())\n", "{\n", "if (opt.getValues() == null || opt.getValues().length == 0)\n", "{\n", "try\n", "{\n", "opt.addValueForProcessing(value);\n", "}\n", "catch (RuntimeException exp)\n", "{\n", "// if we cannot add the value don't worry about it\n", "}\n", "}\n", "}\n", "else if (!(\"yes\".equalsIgnoreCase(value)\n", "|| \"true\".equalsIgnoreCase(value)\n", "|| \"1\".equalsIgnoreCase(value)))\n", "{\n", "// if the value is not yes, true or 1 then don't add the\n", "// option to the CommandLine\n", "continue;\n", "}\n", "\n", "cmd.addOption(opt);\n", "updateRequiredOptions(opt);\n", "}\n", "}\n", "}\n"], "faulty_lines": [12, 14, 17, 18], "cluster": 1}, {"pid": "Cli", "bid": 31, "method_path": "./dataset/Cli/31/HelpFormatter.java", "method": ["private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n", "{\n", "if (!required)\n", "{\n", "buff.append(\"[\");\n", "}\n", "\n", "if (option.getOpt() != null)\n", "{\n", "buff.append(\"-\").append(option.getOpt());\n", "}\n", "else\n", "{\n", "buff.append(\"--\").append(option.getLongOpt());\n", "}\n", "\n", "// if the Option has a value and a non blank argname\n", "if (option.hasArg() && option.hasArgName())\n", "{\n", "buff.append(option.getOpt() == null ? longOptSeparator : \" \");\n", "buff.append(\"<\").append(option.getArgName()).append(\">\");\n", "}\n", "\n", "// if the Option is not a required option\n", "if (!required)\n", "{\n", "buff.append(\"]\");\n", "}\n", "}\n"], "faulty_lines": [18, 21], "cluster": 2}, {"pid": "Cli", "bid": 31, "method_path": "./dataset/Cli/31/OptionBuilder.java", "method": ["private static void reset()\n", "{\n", "description = null;\n", "argName = \"arg\";\n", "longopt = null;\n", "type = null;\n", "required = false;\n", "numberOfArgs = Option.UNINITIALIZED;\n", "optionalArg = false;\n", "valuesep = (char) 0;\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Cli", "bid": 32, "method_path": "./dataset/Cli/32/HelpFormatter.java", "method": ["protected int findWrapPos(String text, int width, int startPos)\n", "{\n", "int pos;\n", "\n", "// the line ends before the max wrap pos or a new line char found\n", "if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n", "|| ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n", "{\n", "return pos + 1;\n", "}\n", "else if (startPos + width >= text.length())\n", "{\n", "return -1;\n", "}\n", "\n", "\n", "// look for the last whitespace character before startPos+width\n", "pos = startPos + width;\n", "\n", "char c;\n", "\n", "while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n", "&& (c != '\\n') && (c != '\\r'))\n", "{\n", "--pos;\n", "}\n", "\n", "// if we found it - just return\n", "if (pos > startPos)\n", "{\n", "return pos;\n", "}\n", "\n", "// if we didn't find one, simply chop at startPos+width\n", "pos = startPos + width;\n", "while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n", "&& (c != '\\n') && (c != '\\r'))\n", "{\n", "++pos;\n", "}\n", "return pos == text.length() ? -1 : pos;\n", "}\n"], "faulty_lines": [36, 37, 38, 39, 40], "cluster": 1}, {"pid": "Cli", "bid": 33, "method_path": "./dataset/Cli/33/HelpFormatter.java", "method": ["public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n", "{\n", "StringBuffer sb = new StringBuffer(text.length());\n", "\n", "renderWrappedText(sb, width, nextLineTabStop, text);\n", "pw.println(sb.toString());\n", "}\n"], "faulty_lines": [5], "cluster": 0}, {"pid": "Cli", "bid": 34, "method_path": "./dataset/Cli/34/OptionBuilder.java", "method": ["private static void reset()\n", "{\n", "description = null;\n", "argName = null;\n", "longopt = null;\n", "type = null;\n", "required = false;\n", "numberOfArgs = Option.UNINITIALIZED;\n", "optionalArg = false;\n", "valuesep = (char) 0;\n", "}\n"], "faulty_lines": [6], "cluster": 0}, {"pid": "Cli", "bid": 35, "method_path": "./dataset/Cli/35/Options.java", "method": ["public List<String> getMatchingOptions(String opt)\n", "{\n", "opt = Util.stripLeadingHyphens(opt);\n", "\n", "List<String> matchingOpts = new ArrayList<String>();\n", "\n", "// for a perfect match return the single option only\n", "\n", "for (String longOpt : longOpts.keySet())\n", "{\n", "if (longOpt.startsWith(opt))\n", "{\n", "matchingOpts.add(longOpt);\n", "}\n", "}\n", "\n", "return matchingOpts;\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Cli", "bid": 37, "method_path": "./dataset/Cli/37/DefaultParser.java", "method": ["private boolean isShortOption(String token)\n", "{\n", "// short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n", "return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n", "\n", "// remove leading \"-\" and \"=value\"\n", "}\n"], "faulty_lines": [4, 7], "cluster": 4}, {"pid": "Cli", "bid": 38, "method_path": "./dataset/Cli/38/DefaultParser.java", "method": ["private boolean isShortOption(String token)\n", "{\n", "// short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n", "if (!token.startsWith(\"-\") || token.length() == 1)\n", "{\n", "return false;\n", "}\n", "\n", "// remove leading \"-\" and \"=value\"\n", "int pos = token.indexOf(\"=\");\n", "String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n", "return options.hasShortOption(optName);\n", "// check for several concatenated short options\n", "}\n"], "faulty_lines": [12, 14], "cluster": 2}, {"pid": "Cli", "bid": 39, "method_path": "./dataset/Cli/39/TypeHandler.java", "method": ["public static Object createValue(final String str, final Class<?> clazz) throws ParseException\n", "{\n", "if (PatternOptionBuilder.STRING_VALUE == clazz)\n", "{\n", "return str;\n", "}\n", "else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n", "{\n", "return createObject(str);\n", "}\n", "else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n", "{\n", "return createNumber(str);\n", "}\n", "else if (PatternOptionBuilder.DATE_VALUE == clazz)\n", "{\n", "return createDate(str);\n", "}\n", "else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n", "{\n", "return createClass(str);\n", "}\n", "else if (PatternOptionBuilder.FILE_VALUE == clazz)\n", "{\n", "return createFile(str);\n", "}\n", "else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n", "{\n", "return createFile(str);\n", "}\n", "else if (PatternOptionBuilder.FILES_VALUE == clazz)\n", "{\n", "return createFiles(str);\n", "}\n", "else if (PatternOptionBuilder.URL_VALUE == clazz)\n", "{\n", "return createURL(str);\n", "}\n", "else\n", "{\n", "return null;\n", "}\n", "}\n"], "faulty_lines": [29], "cluster": 8}, {"pid": "Cli", "bid": 40, "method_path": "./dataset/Cli/40/TypeHandler.java", "method": ["public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n", "{\n", "if (PatternOptionBuilder.STRING_VALUE == clazz)\n", "{\n", "return (T) str;\n", "}\n", "else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n", "{\n", "return (T) createObject(str);\n", "}\n", "else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n", "{\n", "return (T) createNumber(str);\n", "}\n", "else if (PatternOptionBuilder.DATE_VALUE == clazz)\n", "{\n", "return (T) createDate(str);\n", "}\n", "else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n", "{\n", "return (T) createClass(str);\n", "}\n", "else if (PatternOptionBuilder.FILE_VALUE == clazz)\n", "{\n", "return (T) createFile(str);\n", "}\n", "else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n", "{\n", "return (T) openFile(str);\n", "}\n", "else if (PatternOptionBuilder.FILES_VALUE == clazz)\n", "{\n", "return (T) createFiles(str);\n", "}\n", "else if (PatternOptionBuilder.URL_VALUE == clazz)\n", "{\n", "return (T) createURL(str);\n", "}\n", "else\n", "{\n", "return null;\n", "}\n", "}\n"], "faulty_lines": [41], "cluster": 8}, {"pid": "Gson", "bid": 1, "method_path": "./dataset/Gson/1/TypeInfoFactory.java", "method": ["private static Type getActualType(\n", "Type typeToEvaluate, Type parentType, Class<?> rawParentClass) {\n", "if (typeToEvaluate instanceof Class<?>) {\n", "return typeToEvaluate;\n", "} else if (typeToEvaluate instanceof ParameterizedType) {\n", "ParameterizedType castedType = (ParameterizedType) typeToEvaluate;\n", "Type owner = castedType.getOwnerType();\n", "Type[] actualTypeParameters =\n", "extractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass);\n", "Type rawType = castedType.getRawType();\n", "return new ParameterizedTypeImpl(rawType, actualTypeParameters, owner);\n", "} else if (typeToEvaluate instanceof GenericArrayType) {\n", "GenericArrayType castedType = (GenericArrayType) typeToEvaluate;\n", "Type componentType = castedType.getGenericComponentType();\n", "Type actualType = getActualType(componentType, parentType, rawParentClass);\n", "if (componentType.equals(actualType)) {\n", "return castedType;\n", "}\n", "return actualType instanceof Class<?> ?\n", "TypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType))\n", ": new GenericArrayTypeImpl(actualType);\n", "} else if (typeToEvaluate instanceof TypeVariable<?>) {\n", "if (parentType instanceof ParameterizedType) {\n", "// The class definition has the actual types used for the type variables.\n", "// Find the matching actual type for the Type Variable used for the field.\n", "// For example, class Foo<A> { A a; }\n", "// new Foo<Integer>(); defines the actual type of A to be Integer.\n", "// So, to find the type of the field a, we will have to look at the class'\n", "// actual type arguments.\n", "TypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate;\n", "TypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters();\n", "ParameterizedType objParameterizedType = (ParameterizedType) parentType;\n", "int indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);\n", "Type[] actualTypeArguments = objParameterizedType.getActualTypeArguments();\n", "return actualTypeArguments[indexOfActualTypeArgument];\n", "\n", "\n", "}\n", "\n", "throw new UnsupportedOperationException(\"Expecting parameterized type, got \" + parentType\n", "+ \".\\n Are you missing the use of TypeToken idiom?\\n See \"\n", "+ \"http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener\");\n", "} else if (typeToEvaluate instanceof WildcardType) {\n", "WildcardType castedType = (WildcardType) typeToEvaluate;\n", "return getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass);\n", "} else {\n", "throw new IllegalArgumentException(\"Type \\'\" + typeToEvaluate + \"\\' is not a Class, \"\n", "+ \"ParameterizedType, GenericArrayType or TypeVariable. Can't extract type.\");\n", "}\n", "}\n"], "faulty_lines": [36, 37, 38], "cluster": 7}, {"pid": "Gson", "bid": 2, "method_path": "./dataset/Gson/2/TypeAdapters.java", "method": ["public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n", "final Class<? super T2> requestedType = typeToken.getRawType();\n", "if (!clazz.isAssignableFrom(requestedType)) {\n", "return null;\n", "}\n", "return (TypeAdapter<T2>) typeAdapter;\n", "\n", "}\n"], "faulty_lines": [6, 8], "cluster": 4}, {"pid": "Gson", "bid": 3, "method_path": "./dataset/Gson/3/ConstructorConstructor.java", "method": ["private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\n", "final Type type, Class<? super T> rawType) {\n", "if (Collection.class.isAssignableFrom(rawType)) {\n", "if (SortedSet.class.isAssignableFrom(rawType)) {\n", "return new ObjectConstructor<T>() {\n", "@Override public T construct() {\n", "return (T) new TreeSet<Object>();\n", "}\n", "};\n", "} else if (EnumSet.class.isAssignableFrom(rawType)) {\n", "return new ObjectConstructor<T>() {\n", "@SuppressWarnings(\"rawtypes\")\n", "@Override public T construct() {\n", "if (type instanceof ParameterizedType) {\n", "Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n", "if (elementType instanceof Class) {\n", "return (T) EnumSet.noneOf((Class)elementType);\n", "} else {\n", "throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n", "}\n", "} else {\n", "throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n", "}\n", "}\n", "};\n", "} else if (Set.class.isAssignableFrom(rawType)) {\n", "return new ObjectConstructor<T>() {\n", "@Override public T construct() {\n", "return (T) new LinkedHashSet<Object>();\n", "}\n", "};\n", "} else if (Queue.class.isAssignableFrom(rawType)) {\n", "return new ObjectConstructor<T>() {\n", "@Override public T construct() {\n", "return (T) new LinkedList<Object>();\n", "}\n", "};\n", "} else {\n", "return new ObjectConstructor<T>() {\n", "@Override public T construct() {\n", "return (T) new ArrayList<Object>();\n", "}\n", "};\n", "}\n", "}\n", "\n", "if (Map.class.isAssignableFrom(rawType)) {\n", "if (SortedMap.class.isAssignableFrom(rawType)) {\n", "return new ObjectConstructor<T>() {\n", "@Override public T construct() {\n", "return (T) new TreeMap<Object, Object>();\n", "}\n", "};\n", "} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\n", "TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n", "return new ObjectConstructor<T>() {\n", "@Override public T construct() {\n", "return (T) new LinkedHashMap<Object, Object>();\n", "}\n", "};\n", "} else {\n", "return new ObjectConstructor<T>() {\n", "@Override public T construct() {\n", "return (T) new LinkedTreeMap<String, Object>();\n", "}\n", "};\n", "}\n", "}\n", "\n", "return null;\n", "}\n"], "faulty_lines": [48], "cluster": 6}, {"pid": "Gson", "bid": 4, "method_path": "./dataset/Gson/4/JsonWriter.java", "method": ["private JsonWriter open(int empty, String openBracket) throws IOException {\n", "beforeValue(true);\n", "push(empty);\n", "out.write(openBracket);\n", "return this;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Gson", "bid": 4, "method_path": "./dataset/Gson/4/JsonWriter.java", "method": ["public JsonWriter value(String value) throws IOException {\n", "if (value == null) {\n", "return nullValue();\n", "}\n", "writeDeferredName();\n", "beforeValue(false);\n", "string(value);\n", "return this;\n", "}\n"], "faulty_lines": [6], "cluster": 0}, {"pid": "Gson", "bid": 4, "method_path": "./dataset/Gson/4/JsonWriter.java", "method": ["public JsonWriter jsonValue(String value) throws IOException {\n", "if (value == null) {\n", "return nullValue();\n", "}\n", "writeDeferredName();\n", "beforeValue(false);\n", "out.append(value);\n", "return this;\n", "}\n"], "faulty_lines": [6], "cluster": 0}, {"pid": "Gson", "bid": 4, "method_path": "./dataset/Gson/4/JsonWriter.java", "method": ["public JsonWriter nullValue() throws IOException {\n", "if (deferredName != null) {\n", "if (serializeNulls) {\n", "writeDeferredName();\n", "} else {\n", "deferredName = null;\n", "return this; // skip the name and the value\n", "}\n", "}\n", "beforeValue(false);\n", "out.write(\"null\");\n", "return this;\n", "}\n"], "faulty_lines": [10], "cluster": 4}, {"pid": "Gson", "bid": 4, "method_path": "./dataset/Gson/4/JsonWriter.java", "method": ["public JsonWriter value(boolean value) throws IOException {\n", "writeDeferredName();\n", "beforeValue(false);\n", "out.write(value ? \"true\" : \"false\");\n", "return this;\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Gson", "bid": 4, "method_path": "./dataset/Gson/4/JsonWriter.java", "method": ["public JsonWriter value(double value) throws IOException {\n", "if (Double.isNaN(value) || Double.isInfinite(value)) {\n", "throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n", "}\n", "writeDeferredName();\n", "beforeValue(false);\n", "out.append(Double.toString(value));\n", "return this;\n", "}\n"], "faulty_lines": [6], "cluster": 4}, {"pid": "Gson", "bid": 4, "method_path": "./dataset/Gson/4/JsonWriter.java", "method": ["public JsonWriter value(long value) throws IOException {\n", "writeDeferredName();\n", "beforeValue(false);\n", "out.write(Long.toString(value));\n", "return this;\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Gson", "bid": 4, "method_path": "./dataset/Gson/4/JsonWriter.java", "method": ["public JsonWriter value(Number value) throws IOException {\n", "if (value == null) {\n", "return nullValue();\n", "}\n", "\n", "writeDeferredName();\n", "String string = value.toString();\n", "if (!lenient\n", "&& (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n", "throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n", "}\n", "beforeValue(false);\n", "out.append(string);\n", "return this;\n", "}\n"], "faulty_lines": [12], "cluster": 4}, {"pid": "Gson", "bid": 4, "method_path": "./dataset/Gson/4/JsonWriter.java", "method": ["private void beforeValue(boolean root) throws IOException {\n", "switch (peek()) {\n", "case NONEMPTY_DOCUMENT:\n", "if (!lenient) {\n", "throw new IllegalStateException(\n", "\"JSON must have only one top-level value.\");\n", "}\n", "// fall-through\n", "case EMPTY_DOCUMENT: // first in document\n", "if (!lenient && !root) {\n", "throw new IllegalStateException(\n", "\"JSON must start with an array or an object.\");\n", "}\n", "replaceTop(NONEMPTY_DOCUMENT);\n", "break;\n", "\n", "case EMPTY_ARRAY: // first in array\n", "replaceTop(NONEMPTY_ARRAY);\n", "newline();\n", "break;\n", "\n", "case NONEMPTY_ARRAY: // another in array\n", "out.append(',');\n", "newline();\n", "break;\n", "\n", "case DANGLING_NAME: // value for name\n", "out.append(separator);\n", "replaceTop(NONEMPTY_OBJECT);\n", "break;\n", "\n", "default:\n", "throw new IllegalStateException(\"Nesting problem.\");\n", "}\n", "}\n"], "faulty_lines": [1], "cluster": 8}, {"pid": "Gson", "bid": 4, "method_path": "./dataset/Gson/4/JsonWriter.java", "method": ["private void beforeValue(boolean root) throws IOException {\n", "switch (peek()) {\n", "case NONEMPTY_DOCUMENT:\n", "if (!lenient) {\n", "throw new IllegalStateException(\n", "\"JSON must have only one top-level value.\");\n", "}\n", "// fall-through\n", "case EMPTY_DOCUMENT: // first in document\n", "if (!lenient && !root) {\n", "throw new IllegalStateException(\n", "\"JSON must start with an array or an object.\");\n", "}\n", "replaceTop(NONEMPTY_DOCUMENT);\n", "break;\n", "\n", "case EMPTY_ARRAY: // first in array\n", "replaceTop(NONEMPTY_ARRAY);\n", "newline();\n", "break;\n", "\n", "case NONEMPTY_ARRAY: // another in array\n", "out.append(',');\n", "newline();\n", "break;\n", "\n", "case DANGLING_NAME: // value for name\n", "out.append(separator);\n", "replaceTop(NONEMPTY_OBJECT);\n", "break;\n", "\n", "default:\n", "throw new IllegalStateException(\"Nesting problem.\");\n", "}\n", "}\n"], "faulty_lines": [10, 11, 12, 13], "cluster": 8}, {"pid": "Gson", "bid": 7, "method_path": "./dataset/Gson/7/JsonReader.java", "method": ["public long nextLong() throws IOException {\n", "int p = peeked;\n", "if (p == PEEKED_NONE) {\n", "p = doPeek();\n", "}\n", "\n", "if (p == PEEKED_LONG) {\n", "peeked = PEEKED_NONE;\n", "pathIndices[stackSize - 1]++;\n", "return peekedLong;\n", "}\n", "\n", "if (p == PEEKED_NUMBER) {\n", "peekedString = new String(buffer, pos, peekedNumberLength);\n", "pos += peekedNumberLength;\n", "} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n", "peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n", "try {\n", "long result = Long.parseLong(peekedString);\n", "peeked = PEEKED_NONE;\n", "pathIndices[stackSize - 1]++;\n", "return result;\n", "} catch (NumberFormatException ignored) {\n", "// Fall back to parse as a double below.\n", "}\n", "} else {\n", "throw new IllegalStateException(\"Expected a long but was \" + peek()\n", "+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n", "}\n", "\n", "peeked = PEEKED_BUFFERED;\n", "double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n", "long result = (long) asDouble;\n", "if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n", "throw new NumberFormatException(\"Expected a long but was \" + peekedString\n", "+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n", "}\n", "peekedString = null;\n", "peeked = PEEKED_NONE;\n", "pathIndices[stackSize - 1]++;\n", "return result;\n", "}\n"], "faulty_lines": [16, 18], "cluster": 5}, {"pid": "Gson", "bid": 7, "method_path": "./dataset/Gson/7/JsonReader.java", "method": ["public int nextInt() throws IOException {\n", "int p = peeked;\n", "if (p == PEEKED_NONE) {\n", "p = doPeek();\n", "}\n", "\n", "int result;\n", "if (p == PEEKED_LONG) {\n", "result = (int) peekedLong;\n", "if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n", "throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n", "+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n", "}\n", "peeked = PEEKED_NONE;\n", "pathIndices[stackSize - 1]++;\n", "return result;\n", "}\n", "\n", "if (p == PEEKED_NUMBER) {\n", "peekedString = new String(buffer, pos, peekedNumberLength);\n", "pos += peekedNumberLength;\n", "} else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n", "peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n", "try {\n", "result = Integer.parseInt(peekedString);\n", "peeked = PEEKED_NONE;\n", "pathIndices[stackSize - 1]++;\n", "return result;\n", "} catch (NumberFormatException ignored) {\n", "// Fall back to parse as a double below.\n", "}\n", "} else {\n", "throw new IllegalStateException(\"Expected an int but was \" + peek()\n", "+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n", "}\n", "\n", "peeked = PEEKED_BUFFERED;\n", "double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n", "result = (int) asDouble;\n", "if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n", "throw new NumberFormatException(\"Expected an int but was \" + peekedString\n", "+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n", "}\n", "peekedString = null;\n", "peeked = PEEKED_NONE;\n", "pathIndices[stackSize - 1]++;\n", "return result;\n", "}\n"], "faulty_lines": [22, 24], "cluster": 3}, {"pid": "Gson", "bid": 8, "method_path": "./dataset/Gson/8/UnsafeAllocator.java", "method": ["public <T> T newInstance(Class<T> c) throws Exception {\n", "return (T) allocateInstance.invoke(unsafe, c);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Gson", "bid": 8, "method_path": "./dataset/Gson/8/UnsafeAllocator.java", "method": ["public <T> T newInstance(Class<T> c) throws Exception {\n", "return (T) newInstance.invoke(null, c, constructorId);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Gson", "bid": 8, "method_path": "./dataset/Gson/8/UnsafeAllocator.java", "method": ["public <T> T newInstance(Class<T> c) throws Exception {\n", "return (T) newInstance.invoke(null, c, Object.class);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Gson", "bid": 9, "method_path": "./dataset/Gson/9/TypeAdapters.java", "method": ["public void write(JsonWriter out, Boolean value) throws IOException {\n", "if (value == null) {\n", "out.nullValue();\n", "return;\n", "}\n", "out.value(value);\n", "}\n"], "faulty_lines": [2, 3, 4, 5], "cluster": 0}, {"pid": "Gson", "bid": 10, "method_path": "./dataset/Gson/10/ReflectiveTypeAdapterFactory.java", "method": ["private ReflectiveTypeAdapterFactory.BoundField createBoundField(\n", "final Gson context, final Field field, final String name,\n", "final TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\n", "final boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n", "// special casing primitives here saves ~5% on Android...\n", "JsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\n", "TypeAdapter<?> mapped = null;\n", "if (annotation != null) {\n", "mapped = getTypeAdapter(constructorConstructor, context, fieldType, annotation);\n", "}\n", "final boolean jsonAdapterPresent = mapped != null;\n", "if (mapped == null) mapped = context.getAdapter(fieldType);\n", "\n", "final TypeAdapter<?> typeAdapter = mapped;\n", "return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n", "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n", "@Override void write(JsonWriter writer, Object value)\n", "throws IOException, IllegalAccessException {\n", "Object fieldValue = field.get(value);\n", "TypeAdapter t =\n", "new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n", "t.write(writer, fieldValue);\n", "}\n", "@Override void read(JsonReader reader, Object value)\n", "throws IOException, IllegalAccessException {\n", "Object fieldValue = typeAdapter.read(reader);\n", "if (fieldValue != null || !isPrimitive) {\n", "field.set(value, fieldValue);\n", "}\n", "}\n", "@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n", "if (!serialized) return false;\n", "Object fieldValue = field.get(value);\n", "return fieldValue != value; // avoid recursion for example for Throwable.cause\n", "}\n", "};\n", "}\n"], "faulty_lines": [20, 21], "cluster": 5}, {"pid": "Gson", "bid": 11, "method_path": "./dataset/Gson/11/TypeAdapters.java", "method": ["public Number read(JsonReader in) throws IOException {\n", "JsonToken jsonToken = in.peek();\n", "switch (jsonToken) {\n", "case NULL:\n", "in.nextNull();\n", "return null;\n", "case NUMBER:\n", "return new LazilyParsedNumber(in.nextString());\n", "default:\n", "throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n", "}\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Gson", "bid": 14, "method_path": "./dataset/Gson/14/$Gson$Types.java", "method": ["public static WildcardType subtypeOf(Type bound) {\n", "Type[] upperBounds;\n", "upperBounds = new Type[] { bound };\n", "return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY);\n", "}\n"], "faulty_lines": [3, 4], "cluster": 0}, {"pid": "Gson", "bid": 14, "method_path": "./dataset/Gson/14/$Gson$Types.java", "method": ["public static WildcardType supertypeOf(Type bound) {\n", "Type[] lowerBounds;\n", "lowerBounds = new Type[] { bound };\n", "return new WildcardTypeImpl(new Type[] { Object.class }, lowerBounds);\n", "}\n"], "faulty_lines": [3, 4], "cluster": 0}, {"pid": "Gson", "bid": 15, "method_path": "./dataset/Gson/15/JsonWriter.java", "method": ["public JsonWriter value(double value) throws IOException {\n", "writeDeferredName();\n", "if (Double.isNaN(value) || Double.isInfinite(value)) {\n", "throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n", "}\n", "beforeValue();\n", "out.append(Double.toString(value));\n", "return this;\n", "}\n"], "faulty_lines": [3], "cluster": 4}, {"pid": "Gson", "bid": 16, "method_path": "./dataset/Gson/16/$Gson$Types.java", "method": ["private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n", "Collection<TypeVariable> visitedTypeVariables) {\n", "// this implementation is made a little more complicated in an attempt to avoid object-creation\n", "while (true) {\n", "if (toResolve instanceof TypeVariable) {\n", "TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n", "// cannot reduce due to infinite recursion\n", "toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n", "if (toResolve == typeVariable) {\n", "return toResolve;\n", "}\n", "\n", "} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n", "Class<?> original = (Class<?>) toResolve;\n", "Type componentType = original.getComponentType();\n", "Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n", "return componentType == newComponentType\n", "? original\n", ": arrayOf(newComponentType);\n", "\n", "} else if (toResolve instanceof GenericArrayType) {\n", "GenericArrayType original = (GenericArrayType) toResolve;\n", "Type componentType = original.getGenericComponentType();\n", "Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n", "return componentType == newComponentType\n", "? original\n", ": arrayOf(newComponentType);\n", "\n", "} else if (toResolve instanceof ParameterizedType) {\n", "ParameterizedType original = (ParameterizedType) toResolve;\n", "Type ownerType = original.getOwnerType();\n", "Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n", "boolean changed = newOwnerType != ownerType;\n", "\n", "Type[] args = original.getActualTypeArguments();\n", "for (int t = 0, length = args.length; t < length; t++) {\n", "Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n", "if (resolvedTypeArgument != args[t]) {\n", "if (!changed) {\n", "args = args.clone();\n", "changed = true;\n", "}\n", "args[t] = resolvedTypeArgument;\n", "}\n", "}\n", "\n", "return changed\n", "? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n", ": original;\n", "\n", "} else if (toResolve instanceof WildcardType) {\n", "WildcardType original = (WildcardType) toResolve;\n", "Type[] originalLowerBound = original.getLowerBounds();\n", "Type[] originalUpperBound = original.getUpperBounds();\n", "\n", "if (originalLowerBound.length == 1) {\n", "Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n", "if (lowerBound != originalLowerBound[0]) {\n", "return supertypeOf(lowerBound);\n", "}\n", "} else if (originalUpperBound.length == 1) {\n", "Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n", "if (upperBound != originalUpperBound[0]) {\n", "return subtypeOf(upperBound);\n", "}\n", "}\n", "return original;\n", "\n", "} else {\n", "return toResolve;\n", "}\n", "}\n", "}\n"], "faulty_lines": [7, 8], "cluster": 7}, {"pid": "Gson", "bid": 17, "method_path": "./dataset/Gson/17/DefaultDateTypeAdapter.java", "method": ["public Date read(JsonReader in) throws IOException {\n", "if (in.peek() != JsonToken.STRING) {\n", "throw new JsonParseException(\"The date should be a string value\");\n", "}\n", "Date date = deserializeToDate(in.nextString());\n", "if (dateType == Date.class) {\n", "return date;\n", "} else if (dateType == Timestamp.class) {\n", "return new Timestamp(date.getTime());\n", "} else if (dateType == java.sql.Date.class) {\n", "return new java.sql.Date(date.getTime());\n", "} else {\n", "// This must never happen: dateType is guarded in the primary constructor\n", "throw new AssertionError();\n", "}\n", "}\n"], "faulty_lines": [2, 3], "cluster": 2}, {"pid": "Collections", "bid": 25, "method_path": "./dataset/Collections/25/IteratorUtils.java", "method": ["public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n", "final Iterator<? extends E> iterator1,\n", "final Iterator<? extends E> iterator2) {\n", "return new CollatingIterator<E>(comparator, iterator1, iterator2);\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Collections", "bid": 25, "method_path": "./dataset/Collections/25/IteratorUtils.java", "method": ["public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n", "final Iterator<? extends E>... iterators) {\n", "return new CollatingIterator<E>(comparator, iterators);\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Collections", "bid": 25, "method_path": "./dataset/Collections/25/IteratorUtils.java", "method": ["public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n", "final Collection<Iterator<? extends E>> iterators) {\n", "return new CollatingIterator<E>(comparator, iterators);\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Collections", "bid": 26, "method_path": "./dataset/Collections/26/MultiKey.java", "method": ["private Object readResolve() {\n", "calculateHashCode(keys);\n", "return this;\n", "}\n"], "faulty_lines": [1], "cluster": 0}, {"pid": "Jsoup", "bid": 1, "method_path": "./dataset/Jsoup/1/Document.java", "method": ["private void normalise(Element element) {\n", "List<Node> toMove = new ArrayList<Node>();\n", "for (Node node: element.childNodes) {\n", "if (node instanceof TextNode) {\n", "TextNode tn = (TextNode) node;\n", "if (!tn.isBlank())\n", "toMove.add(tn);\n", "}\n", "}\n", "\n", "for (Node node: toMove) {\n", "element.removeChild(node);\n", "body().appendChild(new TextNode(\" \", \"\"));\n", "body().appendChild(node);\n", "}\n", "}\n"], "faulty_lines": [13, 14], "cluster": 4}, {"pid": "Jsoup", "bid": 3, "method_path": "./dataset/Jsoup/3/Element.java", "method": ["public Element append(String html) {\n", "Validate.notNull(html);\n", "\n", "Element fragment = Parser.parseBodyFragment(html, baseUri).body();\n", "for (Node node : fragment.childNodes()) {\n", "node.parentNode = null;\n", "appendChild(node);\n", "}\n", "return this;\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Jsoup", "bid": 3, "method_path": "./dataset/Jsoup/3/Element.java", "method": ["public Element prepend(String html) {\n", "Validate.notNull(html);\n", "\n", "Element fragment = Parser.parseBodyFragment(html, baseUri).body();\n", "List<Node> nodes = fragment.childNodes();\n", "for (int i = nodes.size() - 1; i >= 0; i--) {\n", "Node node = nodes.get(i);\n", "node.parentNode = null;\n", "prependChild(node);\n", "}\n", "return this;\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Jsoup", "bid": 3, "method_path": "./dataset/Jsoup/3/Element.java", "method": ["public Element wrap(String html) {\n", "Validate.notEmpty(html);\n", "\n", "Element wrapBody = Parser.parseBodyFragment(html, baseUri).body();\n", "Elements wrapChildren = wrapBody.children();\n", "Element wrap = wrapChildren.first();\n", "if (wrap == null) // nothing to wrap with; noop\n", "return null;\n", "\n", "Element deepest = getDeepChild(wrap);\n", "parentNode.replaceChild(this, wrap);\n", "deepest.addChild(this);\n", "\n", "// remainder (unbalananced wrap, like <div></div><p></p> -- The <p> is remainder\n", "if (wrapChildren.size() > 1) {\n", "for (int i = 1; i < wrapChildren.size(); i++) { // skip first\n", "Element remainder = wrapChildren.get(i);\n", "remainder.parentNode.removeChild(remainder);\n", "wrap.appendChild(remainder);\n", "}\n", "}\n", "return this;\n", "}\n"], "faulty_lines": [4], "cluster": 2}, {"pid": "Jsoup", "bid": 3, "method_path": "./dataset/Jsoup/3/Parser.java", "method": ["private boolean stackHasValidParent(Tag childTag) {\n", "if (stack.size() == 1 && childTag.equals(htmlTag))\n", "return true; // root is valid for html node\n", "\n", "\n", "// otherwise, look up the stack for valid ancestors\n", "for (int i = stack.size() -1; i >= 0; i--) {\n", "Element el = stack.get(i);\n", "Tag parent2 = el.tag();\n", "if (parent2.isValidParent(childTag)) {\n", "return true;\n", "}\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [5, 10], "cluster": 4}, {"pid": "Jsoup", "bid": 3, "method_path": "./dataset/Jsoup/3/Tag.java", "method": ["boolean canContain(Tag child) {\n", "Validate.notNull(child);\n", "\n", "if (child.isBlock && !this.canContainBlock)\n", "return false;\n", "\n", "if (!child.isBlock && !this.canContainInline) // not block == inline\n", "return false;\n", "\n", "if (this.optionalClosing && this.equals(child))\n", "return false;\n", "\n", "if (this.empty || this.isData())\n", "return false;\n", "\n", "// head can only contain a few. if more than head in here, modify to have a list of valids\n", "// TODO: (could solve this with walk for ancestor)\n", "if (this.tagName.equals(\"head\")) {\n", "if (child.tagName.equals(\"base\") || child.tagName.equals(\"script\") || child.tagName.equals(\"noscript\") || child.tagName.equals(\"link\") ||\n", "child.tagName.equals(\"meta\") || child.tagName.equals(\"title\") || child.tagName.equals(\"style\") || child.tagName.equals(\"object\")) {\n", "return true;\n", "}\n", "return false;\n", "}\n", "\n", "// dt and dd (in dl)\n", "if (this.tagName.equals(\"dt\") && child.tagName.equals(\"dd\"))\n", "return false;\n", "if (this.tagName.equals(\"dd\") && child.tagName.equals(\"dt\"))\n", "return false;\n", "\n", "// don't allow children to contain their parent (directly)\n", "\n", "return true;\n", "}\n"], "faulty_lines": [33], "cluster": 1}, {"pid": "Jsoup", "bid": 5, "method_path": "./dataset/Jsoup/5/Parser.java", "method": ["private Attribute parseAttribute() {\n", "tq.consumeWhitespace();\n", "String key = tq.consumeAttributeKey();\n", "String value = \"\";\n", "tq.consumeWhitespace();\n", "if (tq.matchChomp(\"=\")) {\n", "tq.consumeWhitespace();\n", "\n", "if (tq.matchChomp(SQ)) {\n", "value = tq.chompTo(SQ);\n", "} else if (tq.matchChomp(DQ)) {\n", "value = tq.chompTo(DQ);\n", "} else {\n", "StringBuilder valueAccum = new StringBuilder();\n", "// no ' or \" to look for, so scan to end tag or space (or end of stream)\n", "while (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {\n", "valueAccum.append(tq.consume());\n", "}\n", "value = valueAccum.toString();\n", "}\n", "tq.consumeWhitespace();\n", "}\n", "if (key.length() != 0)\n", "return Attribute.createFromEncoded(key, value);\n", "else {\n", "tq.consume();\n", "\n", "return null;\n", "}\n", "}\n"], "faulty_lines": [26], "cluster": 8}, {"pid": "Jsoup", "bid": 7, "method_path": "./dataset/Jsoup/7/Document.java", "method": ["public Document normalise() {\n", "Element htmlEl = findFirstElementByTagName(\"html\", this);\n", "if (htmlEl == null)\n", "htmlEl = appendElement(\"html\");\n", "if (head() == null)\n", "htmlEl.prependElement(\"head\");\n", "if (body() == null)\n", "htmlEl.appendElement(\"body\");\n", "\n", "// pull text nodes out of root, html, and head els, and push into body. non-text nodes are already taken care\n", "// of. do in inverse order to maintain text order.\n", "normaliseTextNodes(head());\n", "normaliseTextNodes(htmlEl);\n", "normaliseTextNodes(this);\n", "\n", "\n", "return this;\n", "}\n"], "faulty_lines": [16], "cluster": 2}, {"pid": "Jsoup", "bid": 10, "method_path": "./dataset/Jsoup/10/Node.java", "method": ["public String absUrl(String attributeKey) {\n", "Validate.notEmpty(attributeKey);\n", "\n", "String relUrl = attr(attributeKey);\n", "if (!hasAttr(attributeKey)) {\n", "return \"\"; // nothing to make absolute with\n", "} else {\n", "URL base;\n", "try {\n", "try {\n", "base = new URL(baseUri);\n", "} catch (MalformedURLException e) {\n", "// the base is unsuitable, but the attribute may be abs on its own, so try that\n", "URL abs = new URL(relUrl);\n", "return abs.toExternalForm();\n", "}\n", "// workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n", "URL abs = new URL(base, relUrl);\n", "return abs.toExternalForm();\n", "} catch (MalformedURLException e) {\n", "return \"\";\n", "}\n", "}\n", "}\n"], "faulty_lines": [18], "cluster": 2}, {"pid": "Jsoup", "bid": 11, "method_path": "./dataset/Jsoup/11/Selector.java", "method": ["private Elements select() {\n", "tq.consumeWhitespace();\n", "\n", "if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n", "elements.add(root);\n", "combinator(tq.consume().toString());\n", "} else {\n", "addElements(findElements()); // chomp first element matcher off queue\n", "}\n", "\n", "while (!tq.isEmpty()) {\n", "// hierarchy and extras\n", "boolean seenWhite = tq.consumeWhitespace();\n", "\n", "if (tq.matchChomp(\",\")) { // group or\n", "while (!tq.isEmpty()) {\n", "String subQuery = tq.chompTo(\",\");\n", "elements.addAll(select(subQuery, root));\n", "}\n", "} else if (tq.matchesAny(combinators)) {\n", "combinator(tq.consume().toString());\n", "} else if (seenWhite) {\n", "combinator(\" \");\n", "} else { // E.class, E#id, E[attr] etc. AND\n", "Elements candidates = findElements(); // take next el, #. etc off queue\n", "intersectElements(filterForSelf(elements, candidates));\n", "}\n", "}\n", "return new Elements(elements);\n", "}\n"], "faulty_lines": [7], "cluster": 8}, {"pid": "Jsoup", "bid": 11, "method_path": "./dataset/Jsoup/11/Selector.java", "method": ["private Elements findElements() {\n", "if (tq.matchChomp(\"#\")) {\n", "return byId();\n", "} else if (tq.matchChomp(\".\")) {\n", "return byClass();\n", "} else if (tq.matchesWord()) {\n", "return byTag();\n", "} else if (tq.matches(\"[\")) {\n", "return byAttribute();\n", "} else if (tq.matchChomp(\"*\")) {\n", "return allElements();\n", "} else if (tq.matchChomp(\":lt(\")) {\n", "return indexLessThan();\n", "} else if (tq.matchChomp(\":gt(\")) {\n", "return indexGreaterThan();\n", "} else if (tq.matchChomp(\":eq(\")) {\n", "return indexEquals();\n", "} else if (tq.matches(\":has(\")) {\n", "return has();\n", "} else if (tq.matches(\":contains(\")) {\n", "return contains(false);\n", "} else if (tq.matches(\":containsOwn(\")) {\n", "return contains(true);\n", "} else if (tq.matches(\":matches(\")) {\n", "return matches(false);\n", "} else if (tq.matches(\":matchesOwn(\")) {\n", "return matches(true);\n", "} else { // unhandled\n", "throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n", "}\n", "}\n"], "faulty_lines": [28], "cluster": 1}, {"pid": "Jsoup", "bid": 12, "method_path": "./dataset/Jsoup/12/Selector.java", "method": ["private void combinator(char combinator) {\n", "tq.consumeWhitespace();\n", "String subQuery = tq.consumeToAny(combinators);\n", "\n", "Elements output;\n", "if (combinator == '>')\n", "output = filterForChildren(elements, select(subQuery, elements));\n", "else if (combinator == ' ')\n", "output = filterForDescendants(elements, select(subQuery, elements));\n", "else if (combinator == '+')\n", "output = filterForAdjacentSiblings(elements, select(subQuery, root));\n", "else if (combinator == '~')\n", "output = filterForGeneralSiblings(elements, select(subQuery, root));\n", "else\n", "throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n", "\n", "elements.clear(); elements.addAll(output);\n", "}\n"], "faulty_lines": [3], "cluster": 2}, {"pid": "Jsoup", "bid": 13, "method_path": "./dataset/Jsoup/13/Node.java", "method": ["public boolean hasAttr(String attributeKey) {\n", "Validate.notNull(attributeKey);\n", "\n", "return attributes.hasKey(attributeKey);\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Jsoup", "bid": 14, "method_path": "./dataset/Jsoup/14/TokeniserState.java", "method": ["void read(Tokeniser t, CharacterReader r) {\n", "if (r.matches('/')) {\n", "t.createTempBuffer();\n", "t.advanceTransition(RCDATAEndTagOpen);\n", "// diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than\n", "// consuming to EOF; break out here\n", "} else {\n", "t.emit(\"<\");\n", "t.transition(Rcdata);\n", "}\n", "}\n"], "faulty_lines": [5, 7], "cluster": 4}, {"pid": "Jsoup", "bid": 15, "method_path": "./dataset/Jsoup/15/TreeBuilderState.java", "method": ["boolean process(Token t, TreeBuilder tb) {\n", "switch (t.type) {\n", "case Character: {\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "// todo confirm that check\n", "tb.error(this);\n", "return false;\n", "} else if (isWhitespace(c)) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "tb.framesetOk(false);\n", "}\n", "break;\n", "}\n", "case Comment: {\n", "tb.insert(t.asComment());\n", "break;\n", "}\n", "case Doctype: {\n", "tb.error(this);\n", "return false;\n", "}\n", "case StartTag:\n", "Token.StartTag startTag = t.asStartTag();\n", "String name = startTag.name();\n", "if (name.equals(\"html\")) {\n", "tb.error(this);\n", "// merge attributes onto real html\n", "Element html = tb.getStack().getFirst();\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!html.hasAttr(attribute.getKey()))\n", "html.attributes().put(attribute);\n", "}\n", "} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n", "return tb.process(t, InHead);\n", "} else if (name.equals(\"body\")) {\n", "tb.error(this);\n", "LinkedList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else {\n", "tb.framesetOk(false);\n", "Element body = stack.get(1);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!body.hasAttr(attribute.getKey()))\n", "body.attributes().put(attribute);\n", "}\n", "}\n", "} else if (name.equals(\"frameset\")) {\n", "tb.error(this);\n", "LinkedList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else if (!tb.framesetOk()) {\n", "return false; // ignore frameset\n", "} else {\n", "Element second = stack.get(1);\n", "if (second.parent() != null)\n", "second.remove();\n", "// pop up to html element\n", "while (stack.size() > 1)\n", "stack.removeLast();\n", "tb.insert(startTag);\n", "tb.transition(InFrameset);\n", "}\n", "} else if (StringUtil.in(name,\n", "\"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n", "\"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n", "\"p\", \"section\", \"summary\", \"ul\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n", "tb.error(this);\n", "tb.pop();\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.in(name, \"pre\", \"listing\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insert(startTag);\n", "// todo: ignore LF if next token\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"form\")) {\n", "if (tb.getFormElement() != null) {\n", "tb.error(this);\n", "return false;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "Element form = tb.insert(startTag);\n", "tb.setFormElement(form);\n", "} else if (name.equals(\"li\")) {\n", "tb.framesetOk(false);\n", "LinkedList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (el.nodeName().equals(\"li\")) {\n", "tb.process(new Token.EndTag(\"li\"));\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.in(name, \"dd\", \"dt\")) {\n", "tb.framesetOk(false);\n", "LinkedList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n", "tb.process(new Token.EndTag(el.nodeName()));\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"plaintext\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insert(startTag);\n", "tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n", "} else if (name.equals(\"button\")) {\n", "if (tb.inButtonScope(\"button\")) {\n", "// close and reprocess\n", "tb.error(this);\n", "tb.process(new Token.EndTag(\"button\"));\n", "tb.process(startTag);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "}\n", "} else if (name.equals(\"a\")) {\n", "if (tb.getActiveFormattingElement(\"a\") != null) {\n", "tb.error(this);\n", "tb.process(new Token.EndTag(\"a\"));\n", "\n", "// still on stack?\n", "Element remainingA = tb.getFromStack(\"a\");\n", "if (remainingA != null) {\n", "tb.removeFromActiveFormattingElements(remainingA);\n", "tb.removeFromStack(remainingA);\n", "}\n", "}\n", "tb.reconstructFormattingElements();\n", "Element a = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(a);\n", "} else if (StringUtil.in(name,\n", "\"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (name.equals(\"nobr\")) {\n", "tb.reconstructFormattingElements();\n", "if (tb.inScope(\"nobr\")) {\n", "tb.error(this);\n", "tb.process(new Token.EndTag(\"nobr\"));\n", "tb.reconstructFormattingElements();\n", "}\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.insertMarkerToFormattingElements();\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"table\")) {\n", "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "tb.transition(InTable);\n", "} else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n", "tb.reconstructFormattingElements();\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"input\")) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insertEmpty(startTag);\n", "if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n", "tb.framesetOk(false);\n", "} else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n", "tb.insertEmpty(startTag);\n", "} else if (name.equals(\"hr\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"image\")) {\n", "// we're not supposed to ask.\n", "startTag.name(\"img\");\n", "return tb.process(startTag);\n", "} else if (name.equals(\"isindex\")) {\n", "// how much do we care about the early 90s?\n", "tb.error(this);\n", "if (tb.getFormElement() != null)\n", "return false;\n", "\n", "tb.tokeniser.acknowledgeSelfClosingFlag();\n", "tb.process(new Token.StartTag(\"form\"));\n", "if (startTag.attributes.hasKey(\"action\")) {\n", "Element form = tb.getFormElement();\n", "form.attr(\"action\", startTag.attributes.get(\"action\"));\n", "}\n", "tb.process(new Token.StartTag(\"hr\"));\n", "tb.process(new Token.StartTag(\"label\"));\n", "// hope you like english.\n", "String prompt = startTag.attributes.hasKey(\"prompt\") ?\n", "startTag.attributes.get(\"prompt\") :\n", "\"This is a searchable index. Enter search keywords: \";\n", "\n", "tb.process(new Token.Character(prompt));\n", "\n", "// input\n", "Attributes inputAttribs = new Attributes();\n", "for (Attribute attr : startTag.attributes) {\n", "if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n", "inputAttribs.put(attr);\n", "}\n", "inputAttribs.put(\"name\", \"isindex\");\n", "tb.process(new Token.StartTag(\"input\", inputAttribs));\n", "tb.process(new Token.EndTag(\"label\"));\n", "tb.process(new Token.StartTag(\"hr\"));\n", "tb.process(new Token.EndTag(\"form\"));\n", "} else if (name.equals(\"textarea\")) {\n", "tb.insert(startTag);\n", "// todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n", "tb.tokeniser.transition(TokeniserState.Rcdata);\n", "tb.markInsertionMode();\n", "tb.framesetOk(false);\n", "tb.transition(Text);\n", "} else if (name.equals(\"xmp\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.reconstructFormattingElements();\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"iframe\")) {\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"noembed\")) {\n", "// also handle noscript if script enabled\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"select\")) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "\n", "TreeBuilderState state = tb.state();\n", "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n", "tb.transition(InSelectInTable);\n", "else\n", "tb.transition(InSelect);\n", "} else if (StringUtil.in(\"optgroup\", \"option\")) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.process(new Token.EndTag(\"option\"));\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (StringUtil.in(\"rp\", \"rt\")) {\n", "if (tb.inScope(\"ruby\")) {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n", "tb.error(this);\n", "tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n", "}\n", "tb.insert(startTag);\n", "}\n", "} else if (name.equals(\"math\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n", "tb.insert(startTag);\n", "tb.tokeniser.acknowledgeSelfClosingFlag();\n", "} else if (name.equals(\"svg\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n", "tb.insert(startTag);\n", "tb.tokeniser.acknowledgeSelfClosingFlag();\n", "} else if (StringUtil.in(name,\n", "\"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "}\n", "break;\n", "\n", "case EndTag:\n", "Token.EndTag endTag = t.asEndTag();\n", "name = endTag.name();\n", "if (name.equals(\"body\")) {\n", "if (!tb.inScope(\"body\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "// todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n", "tb.transition(AfterBody);\n", "}\n", "} else if (name.equals(\"html\")) {\n", "boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n", "if (notIgnored)\n", "return tb.process(endTag);\n", "} else if (StringUtil.in(name,\n", "\"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n", "\"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n", "\"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n", "// todo: refactor these lookups\n", "if (!tb.inScope(name)) {\n", "// nothing to close\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"form\")) {\n", "Element currentForm = tb.getFormElement();\n", "tb.setFormElement(null);\n", "if (currentForm == null || !tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "// remove currentForm from stack. will shift anything under up.\n", "tb.removeFromStack(currentForm);\n", "}\n", "} else if (name.equals(\"p\")) {\n", "if (!tb.inButtonScope(name)) {\n", "tb.error(this);\n", "tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n", "return tb.process(endTag);\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"li\")) {\n", "if (!tb.inListItemScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.in(name, \"dd\", \"dt\")) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n", "if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n", "}\n", "} else if (name.equals(\"sarcasm\")) {\n", "// *sigh*\n", "return anyOtherEndTag(t, tb);\n", "} else if (StringUtil.in(name,\n", "\"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n", "// Adoption Agency Algorithm.\n", "OUTER:\n", "for (int i = 0; i < 8; i++) {\n", "Element formatEl = tb.getActiveFormattingElement(name);\n", "if (formatEl == null)\n", "return anyOtherEndTag(t, tb);\n", "else if (!tb.onStack(formatEl)) {\n", "tb.error(this);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "} else if (!tb.inScope(formatEl.nodeName())) {\n", "tb.error(this);\n", "return false;\n", "} else if (tb.currentElement() != formatEl)\n", "tb.error(this);\n", "\n", "Element furthestBlock = null;\n", "Element commonAncestor = null;\n", "boolean seenFormattingElement = false;\n", "LinkedList<Element> stack = tb.getStack();\n", "for (int si = 0; si < stack.size(); si++) {\n", "Element el = stack.get(si);\n", "if (el == formatEl) {\n", "commonAncestor = stack.get(si - 1);\n", "seenFormattingElement = true;\n", "} else if (seenFormattingElement && tb.isSpecial(el)) {\n", "furthestBlock = el;\n", "break;\n", "}\n", "}\n", "if (furthestBlock == null) {\n", "tb.popStackToClose(formatEl.nodeName());\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "}\n", "\n", "// todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n", "// does that mean: int pos of format el in list?\n", "Element node = furthestBlock;\n", "Element lastNode = furthestBlock;\n", "INNER:\n", "for (int j = 0; j < 3; j++) {\n", "if (tb.onStack(node))\n", "node = tb.aboveOnStack(node);\n", "if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n", "tb.removeFromStack(node);\n", "continue INNER;\n", "} else if (node == formatEl)\n", "break INNER;\n", "\n", "Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n", "tb.replaceActiveFormattingElement(node, replacement);\n", "tb.replaceOnStack(node, replacement);\n", "node = replacement;\n", "\n", "if (lastNode == furthestBlock) {\n", "// todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n", "// not getting how this bookmark both straddles the element above, but is inbetween here...\n", "}\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "node.appendChild(lastNode);\n", "\n", "lastNode = node;\n", "}\n", "\n", "if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "tb.insertInFosterParent(lastNode);\n", "} else {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "commonAncestor.appendChild(lastNode);\n", "}\n", "\n", "Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n", "Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n", "for (Node childNode : childNodes) {\n", "adopter.appendChild(childNode); // append will reparent. thus the clone to avvoid concurrent mod.\n", "}\n", "furthestBlock.appendChild(adopter);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "// todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n", "tb.removeFromStack(formatEl);\n", "tb.insertOnStackAfter(furthestBlock, adopter);\n", "}\n", "} else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n", "if (!tb.inScope(\"name\")) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "tb.clearFormattingElementsToLastMarker();\n", "}\n", "} else if (name.equals(\"br\")) {\n", "tb.error(this);\n", "tb.process(new Token.StartTag(\"br\"));\n", "return false;\n", "} else {\n", "return anyOtherEndTag(t, tb);\n", "}\n", "\n", "break;\n", "case EOF:\n", "// todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n", "// stop parsing\n", "break;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [38], "cluster": 6}, {"pid": "Jsoup", "bid": 16, "method_path": "./dataset/Jsoup/16/DocumentType.java", "method": ["public DocumentType(String name, String publicId, String systemId, String baseUri) {\n", "super(baseUri);\n", "\n", "attr(\"name\", name);\n", "attr(\"publicId\", publicId);\n", "attr(\"systemId\", systemId);\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Jsoup", "bid": 16, "method_path": "./dataset/Jsoup/16/DocumentType.java", "method": ["void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n", "accum.append(\"<!DOCTYPE html\");\n", "if (!StringUtil.isBlank(attr(\"publicId\")))\n", "accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append(\"\\\"\");\n", "if (!StringUtil.isBlank(attr(\"systemId\")))\n", "accum.append(' ').append(attr(\"systemId\")).append(\"\\\"\");\n", "accum.append('>');\n", "}\n"], "faulty_lines": [2, 6], "cluster": 4}, {"pid": "Jsoup", "bid": 19, "method_path": "./dataset/Jsoup/19/Whitelist.java", "method": ["private boolean testValidProtocol(Element el, Attribute attr, Set<Protocol> protocols) {\n", "// try to resolve relative urls to abs, and optionally update the attribute so output html has abs.\n", "// rels without a baseuri get removed\n", "String value = el.absUrl(attr.getKey());\n", "if (!preserveRelativeLinks)\n", "attr.setValue(value);\n", "\n", "for (Protocol protocol : protocols) {\n", "String prot = protocol.toString() + \":\";\n", "if (value.toLowerCase().startsWith(prot)) {\n", "return true;\n", "}\n", "}\n", "return false;\n", "}\n"], "faulty_lines": [5], "cluster": 2}, {"pid": "Jsoup", "bid": 21, "method_path": "./dataset/Jsoup/21/QueryParser.java", "method": ["private void combinator(char combinator) {\n", "tq.consumeWhitespace();\n", "String subQuery = consumeSubQuery(); // support multi > childs\n", "Evaluator e;\n", "\n", "if (evals.size() == 1)\n", "e = evals.get(0);\n", "else\n", "e = new CombiningEvaluator.And(evals);\n", "evals.clear();\n", "Evaluator f = parse(subQuery);\n", "\n", "if (combinator == '>')\n", "evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediateParent(e)));\n", "else if (combinator == ' ')\n", "evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.Parent(e)));\n", "else if (combinator == '+')\n", "evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.ImmediatePreviousSibling(e)));\n", "else if (combinator == '~')\n", "evals.add(new CombiningEvaluator.And(f, new StructuralEvaluator.PreviousSibling(e)));\n", "else\n", "throw new Selector.SelectorParseException(\"Unknown combinator: \" + combinator);\n", "}\n"], "faulty_lines": [21], "cluster": 8}, {"pid": "Jsoup", "bid": 22, "method_path": "./dataset/Jsoup/22/Element.java", "method": ["public Elements siblingElements() {\n", "\n", "return parent().children();\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Jsoup", "bid": 22, "method_path": "./dataset/Jsoup/22/Element.java", "method": ["public Element nextElementSibling() {\n", "List<Element> siblings = parent().children();\n", "Integer index = indexInList(this, siblings);\n", "Validate.notNull(index);\n", "if (siblings.size() > index+1)\n", "return siblings.get(index+1);\n", "else\n", "return null;\n", "}\n"], "faulty_lines": [2], "cluster": 4}, {"pid": "Jsoup", "bid": 22, "method_path": "./dataset/Jsoup/22/Element.java", "method": ["public Element previousElementSibling() {\n", "List<Element> siblings = parent().children();\n", "Integer index = indexInList(this, siblings);\n", "Validate.notNull(index);\n", "if (index > 0)\n", "return siblings.get(index-1);\n", "else\n", "return null;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Jsoup", "bid": 22, "method_path": "./dataset/Jsoup/22/Node.java", "method": ["public List<Node> siblingNodes() {\n", "\n", "return parent().childNodes();\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Jsoup", "bid": 22, "method_path": "./dataset/Jsoup/22/Node.java", "method": ["public Node previousSibling() {\n", "\n", "List<Node> siblings = parentNode.childNodes;\n", "Integer index = siblingIndex();\n", "Validate.notNull(index);\n", "if (index > 0)\n", "return siblings.get(index-1);\n", "else\n", "return null;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Jsoup", "bid": 24, "method_path": "./dataset/Jsoup/24/TokeniserState.java", "method": ["void read(Tokeniser t, CharacterReader r) {\n", "if (r.matchesLetter()) {\n", "String name = r.consumeLetterSequence();\n", "t.tagPending.appendTagName(name.toLowerCase());\n", "t.dataBuffer.append(name);\n", "r.advance();\n", "return;\n", "}\n", "\n", "if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n", "char c = r.consume();\n", "switch (c) {\n", "case '\\t':\n", "case '\\n':\n", "case '\\f':\n", "case ' ':\n", "t.transition(BeforeAttributeName);\n", "break;\n", "case '/':\n", "t.transition(SelfClosingStartTag);\n", "break;\n", "case '>':\n", "t.emitTagPending();\n", "t.transition(Data);\n", "break;\n", "default:\n", "t.dataBuffer.append(c);\n", "anythingElse(t, r);\n", "break;\n", "}\n", "} else {\n", "anythingElse(t, r);\n", "}\n", "}\n"], "faulty_lines": [6], "cluster": 8}, {"pid": "Jsoup", "bid": 26, "method_path": "./dataset/Jsoup/26/Cleaner.java", "method": ["public Document clean(Document dirtyDocument) {\n", "Validate.notNull(dirtyDocument);\n", "\n", "Document clean = Document.createShell(dirtyDocument.baseUri());\n", "copySafeNodes(dirtyDocument.body(), clean.body());\n", "\n", "return clean;\n", "}\n"], "faulty_lines": [5], "cluster": 0}, {"pid": "Jsoup", "bid": 29, "method_path": "./dataset/Jsoup/29/Document.java", "method": ["public String title() {\n", "// title is a preserve whitespace tag (for document output), but normalised here\n", "Element titleEl = getElementsByTag(\"title\").first();\n", "return titleEl != null ? titleEl.text().trim() : \"\";\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Jsoup", "bid": 30, "method_path": "./dataset/Jsoup/30/Cleaner.java", "method": ["private int copySafeNodes(Element root, Element destination) {\n", "List<Node> sourceChildren = root.childNodes();\n", "int numDiscarded = 0;\n", "\n", "for (Node source : sourceChildren) {\n", "if (source instanceof Element) {\n", "Element sourceEl = (Element) source;\n", "\n", "if (whitelist.isSafeTag(sourceEl.tagName())) { // safe, clone and copy safe attrs\n", "ElementMeta meta = createSafeElement(sourceEl);\n", "Element destChild = meta.el;\n", "destination.appendChild(destChild);\n", "\n", "numDiscarded += meta.numAttribsDiscarded;\n", "numDiscarded += copySafeNodes(sourceEl, destChild);\n", "} else {\n", "numDiscarded++;\n", "numDiscarded += copySafeNodes(sourceEl, destination);\n", "}\n", "} else if (source instanceof TextNode) {\n", "TextNode sourceText = (TextNode) source;\n", "TextNode destText = new TextNode(sourceText.getWholeText(), source.baseUri());\n", "destination.appendChild(destText);\n", "}\n", "}\n", "return numDiscarded;\n", "\n", "\n", "}\n"], "faulty_lines": [1, 2, 3, 5], "cluster": 8}, {"pid": "Jsoup", "bid": 31, "method_path": "./dataset/Jsoup/31/TokeniserState.java", "method": ["void read(Tokeniser t, CharacterReader r) {\n", "// todo: handle bogus comment starting from eof. when does that trigger?\n", "// rewind to capture character that lead us here\n", "r.unconsume();\n", "Token.Comment comment = new Token.Comment();\n", "comment.data.append(r.consumeTo('>'));\n", "// todo: replace nullChar with replaceChar\n", "t.emit(comment);\n", "t.advanceTransition(Data);\n", "}\n"], "faulty_lines": [6], "cluster": 4}, {"pid": "Jsoup", "bid": 31, "method_path": "./dataset/Jsoup/31/XmlTreeBuilder.java", "method": ["void insert(Token.Comment commentToken) {\n", "Comment comment = new Comment(commentToken.getData(), baseUri);\n", "Node insert = comment;\n", "insertNode(insert);\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Jsoup", "bid": 32, "method_path": "./dataset/Jsoup/32/Element.java", "method": ["public Element clone() {\n", "Element clone = (Element) super.clone();\n", "clone.classNames();\n", "return clone;\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Jsoup", "bid": 36, "method_path": "./dataset/Jsoup/36/DataUtil.java", "method": ["public class DataUtil {\n", "private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*\\\"?([^\\\\s;\\\"]*)\");\n", "static final String defaultCharset = \"UTF-8\"; // used if not found in header or meta charset\n", "private static final int bufferSize = 0x20000; // ~130K.\n", "\n", "private DataUtil() {}\n", "\n", "/**\n", "* Loads a file to a Document.\n", "* @param in file to load\n", "* @param charsetName character set of input\n", "* @param baseUri base URI of document, to resolve relative links against\n", "* @return Document\n", "* @throws IOException on IO error\n", "*/\n", "public static Document load(File in, String charsetName, String baseUri) throws IOException {\n", "FileInputStream inStream = null;\n", "try {\n", "inStream = new FileInputStream(in);\n", "ByteBuffer byteData = readToByteBuffer(inStream);\n", "return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n", "} finally {\n", "if (inStream != null)\n", "inStream.close();\n", "}\n", "}\n", "\n", "/**\n", "* Parses a Document from an input steam.\n", "* @param in input stream to parse. You will need to close it.\n", "* @param charsetName character set of input\n", "* @param baseUri base URI of document, to resolve relative links against\n", "* @return Document\n", "* @throws IOException on IO error\n", "*/\n", "public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n", "ByteBuffer byteData = readToByteBuffer(in);\n", "return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n", "}\n", "\n", "/**\n", "* Parses a Document from an input steam, using the provided Parser.\n", "* @param in input stream to parse. You will need to close it.\n", "* @param charsetName character set of input\n", "* @param baseUri base URI of document, to resolve relative links against\n", "* @param parser alternate {@link Parser#xmlParser() parser} to use.\n", "* @return Document\n", "* @throws IOException on IO error\n", "*/\n", "public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n", "ByteBuffer byteData = readToByteBuffer(in);\n", "return parseByteData(byteData, charsetName, baseUri, parser);\n", "}\n", "\n", "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n", "// switching the chartset midstream when a meta http-equiv tag defines the charset.\n", "static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n", "String docData;\n", "Document doc = null;\n", "if (charsetName == null) { // determine from meta. safe parse as UTF-8\n", "// look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n", "docData = Charset.forName(defaultCharset).decode(byteData).toString();\n", "doc = parser.parseInput(docData, baseUri);\n", "Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n", "if (meta != null) { // if not found, will keep utf-8 as best attempt\n", "\n", "String foundCharset;\n", "if (meta.hasAttr(\"http-equiv\")) {\n", "foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n", "} else {\n", "foundCharset = meta.attr(\"charset\");\n", "}\n", "\n", "if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n", "charsetName = foundCharset;\n", "byteData.rewind();\n", "docData = Charset.forName(foundCharset).decode(byteData).toString();\n", "doc = null;\n", "}\n", "}\n", "} else { // specified by content type header (or by user on file load)\n", "Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n", "docData = Charset.forName(charsetName).decode(byteData).toString();\n", "}\n", "if (doc == null) {\n", "// there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n", "// in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n", "// into head mode\n", "if (docData.length() > 0 && docData.charAt(0) == 65279)\n", "docData = docData.substring(1);\n", "\n", "doc = parser.parseInput(docData, baseUri);\n", "doc.outputSettings().charset(charsetName);\n", "}\n", "return doc;\n", "}\n", "\n", "/**\n", "* Read the input stream into a byte buffer.\n", "* @param inStream the input stream to read from\n", "* @param maxSize the maximum size in bytes to read from the stream. Set to 0 to be unlimited.\n", "* @return the filled byte buffer\n", "* @throws IOException if an exception occurs whilst reading from the input stream.\n", "*/\n", "static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n", "Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n", "final boolean capped = maxSize > 0;\n", "byte[] buffer = new byte[bufferSize];\n", "ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);\n", "int read;\n", "int remaining = maxSize;\n", "\n", "while (true) {\n", "read = inStream.read(buffer);\n", "if (read == -1) break;\n", "if (capped) {\n", "if (read > remaining) {\n", "outStream.write(buffer, 0, remaining);\n", "break;\n", "}\n", "remaining -= read;\n", "}\n", "outStream.write(buffer, 0, read);\n", "}\n", "ByteBuffer byteData = ByteBuffer.wrap(outStream.toByteArray());\n", "return byteData;\n", "}\n", "\n", "static ByteBuffer readToByteBuffer(InputStream inStream) throws IOException {\n", "return readToByteBuffer(inStream, 0);\n", "}\n", "\n", "/**\n", "* Parse out a charset from a content type header. If the charset is not supported, returns null (so the default\n", "* will kick in.)\n", "* @param contentType e.g. \"text/html; charset=EUC-JP\"\n", "* @return \"EUC-JP\", or null if not found. Charset is trimmed and uppercased.\n", "*/\n", "static String getCharsetFromContentType(String contentType) {\n", "if (contentType == null) return null;\n", "Matcher m = charsetPattern.matcher(contentType);\n", "if (m.find()) {\n", "String charset = m.group(1).trim();\n", "if (Charset.isSupported(charset)) return charset;\n", "charset = charset.toUpperCase(Locale.ENGLISH);\n", "if (Charset.isSupported(charset)) return charset;\n", "// if our advanced charset matching fails.... we just take the default\n", "}\n", "return null;\n", "}\n", "\n", "\n", "}\n"], "faulty_lines": [2], "cluster": 3}, {"pid": "Jsoup", "bid": 37, "method_path": "./dataset/Jsoup/37/Element.java", "method": ["public String html() {\n", "StringBuilder accum = new StringBuilder();\n", "html(accum);\n", "return accum.toString().trim();\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Jsoup", "bid": 38, "method_path": "./dataset/Jsoup/38/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case Character: {\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "// todo confirm that check\n", "tb.error(this);\n", "return false;\n", "} else if (isWhitespace(c)) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "tb.framesetOk(false);\n", "}\n", "break;\n", "}\n", "case Comment: {\n", "tb.insert(t.asComment());\n", "break;\n", "}\n", "case Doctype: {\n", "tb.error(this);\n", "return false;\n", "}\n", "case StartTag:\n", "Token.StartTag startTag = t.asStartTag();\n", "String name = startTag.name();\n", "if (name.equals(\"html\")) {\n", "tb.error(this);\n", "// merge attributes onto real html\n", "Element html = tb.getStack().getFirst();\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!html.hasAttr(attribute.getKey()))\n", "html.attributes().put(attribute);\n", "}\n", "} else if (StringUtil.in(name, Constants.InBodyStartToHead)) {\n", "return tb.process(t, InHead);\n", "} else if (name.equals(\"body\")) {\n", "tb.error(this);\n", "LinkedList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else {\n", "tb.framesetOk(false);\n", "Element body = stack.get(1);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!body.hasAttr(attribute.getKey()))\n", "body.attributes().put(attribute);\n", "}\n", "}\n", "} else if (name.equals(\"frameset\")) {\n", "tb.error(this);\n", "LinkedList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else if (!tb.framesetOk()) {\n", "return false; // ignore frameset\n", "} else {\n", "Element second = stack.get(1);\n", "if (second.parent() != null)\n", "second.remove();\n", "// pop up to html element\n", "while (stack.size() > 1)\n", "stack.removeLast();\n", "tb.insert(startTag);\n", "tb.transition(InFrameset);\n", "}\n", "} else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.in(name, Constants.Headings)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {\n", "tb.error(this);\n", "tb.pop();\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insert(startTag);\n", "// todo: ignore LF if next token\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"form\")) {\n", "if (tb.getFormElement() != null) {\n", "tb.error(this);\n", "return false;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insertForm(startTag, true);\n", "} else if (name.equals(\"li\")) {\n", "tb.framesetOk(false);\n", "LinkedList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (el.nodeName().equals(\"li\")) {\n", "tb.process(new Token.EndTag(\"li\"));\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.in(name, Constants.DdDt)) {\n", "tb.framesetOk(false);\n", "LinkedList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n", "tb.process(new Token.EndTag(el.nodeName()));\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"plaintext\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insert(startTag);\n", "tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n", "} else if (name.equals(\"button\")) {\n", "if (tb.inButtonScope(\"button\")) {\n", "// close and reprocess\n", "tb.error(this);\n", "tb.process(new Token.EndTag(\"button\"));\n", "tb.process(startTag);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "}\n", "} else if (name.equals(\"a\")) {\n", "if (tb.getActiveFormattingElement(\"a\") != null) {\n", "tb.error(this);\n", "tb.process(new Token.EndTag(\"a\"));\n", "\n", "// still on stack?\n", "Element remainingA = tb.getFromStack(\"a\");\n", "if (remainingA != null) {\n", "tb.removeFromActiveFormattingElements(remainingA);\n", "tb.removeFromStack(remainingA);\n", "}\n", "}\n", "tb.reconstructFormattingElements();\n", "Element a = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(a);\n", "} else if (StringUtil.in(name, Constants.Formatters)) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (name.equals(\"nobr\")) {\n", "tb.reconstructFormattingElements();\n", "if (tb.inScope(\"nobr\")) {\n", "tb.error(this);\n", "tb.process(new Token.EndTag(\"nobr\"));\n", "tb.reconstructFormattingElements();\n", "}\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.insertMarkerToFormattingElements();\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"table\")) {\n", "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "tb.transition(InTable);\n", "} else if (StringUtil.in(name, Constants.InBodyStartEmptyFormatters)) {\n", "tb.reconstructFormattingElements();\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"input\")) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insertEmpty(startTag);\n", "if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n", "tb.framesetOk(false);\n", "} else if (StringUtil.in(name, Constants.InBodyStartMedia)) {\n", "tb.insertEmpty(startTag);\n", "} else if (name.equals(\"hr\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"image\")) {\n", "return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n", "} else if (name.equals(\"isindex\")) {\n", "// how much do we care about the early 90s?\n", "tb.error(this);\n", "if (tb.getFormElement() != null)\n", "return false;\n", "\n", "tb.tokeniser.acknowledgeSelfClosingFlag();\n", "tb.process(new Token.StartTag(\"form\"));\n", "if (startTag.attributes.hasKey(\"action\")) {\n", "Element form = tb.getFormElement();\n", "form.attr(\"action\", startTag.attributes.get(\"action\"));\n", "}\n", "tb.process(new Token.StartTag(\"hr\"));\n", "tb.process(new Token.StartTag(\"label\"));\n", "// hope you like english.\n", "String prompt = startTag.attributes.hasKey(\"prompt\") ?\n", "startTag.attributes.get(\"prompt\") :\n", "\"This is a searchable index. Enter search keywords: \";\n", "\n", "tb.process(new Token.Character(prompt));\n", "\n", "// input\n", "Attributes inputAttribs = new Attributes();\n", "for (Attribute attr : startTag.attributes) {\n", "if (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))\n", "inputAttribs.put(attr);\n", "}\n", "inputAttribs.put(\"name\", \"isindex\");\n", "tb.process(new Token.StartTag(\"input\", inputAttribs));\n", "tb.process(new Token.EndTag(\"label\"));\n", "tb.process(new Token.StartTag(\"hr\"));\n", "tb.process(new Token.EndTag(\"form\"));\n", "} else if (name.equals(\"textarea\")) {\n", "tb.insert(startTag);\n", "// todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n", "tb.tokeniser.transition(TokeniserState.Rcdata);\n", "tb.markInsertionMode();\n", "tb.framesetOk(false);\n", "tb.transition(Text);\n", "} else if (name.equals(\"xmp\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.process(new Token.EndTag(\"p\"));\n", "}\n", "tb.reconstructFormattingElements();\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"iframe\")) {\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"noembed\")) {\n", "// also handle noscript if script enabled\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"select\")) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "\n", "HtmlTreeBuilderState state = tb.state();\n", "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n", "tb.transition(InSelectInTable);\n", "else\n", "tb.transition(InSelect);\n", "} else if (StringUtil.in(name, Constants.InBodyStartOptions)) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.process(new Token.EndTag(\"option\"));\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (StringUtil.in(name, Constants.InBodyStartRuby)) {\n", "if (tb.inScope(\"ruby\")) {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n", "tb.error(this);\n", "tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n", "}\n", "tb.insert(startTag);\n", "}\n", "} else if (name.equals(\"math\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n", "tb.insert(startTag);\n", "tb.tokeniser.acknowledgeSelfClosingFlag();\n", "} else if (name.equals(\"svg\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n", "tb.insert(startTag);\n", "tb.tokeniser.acknowledgeSelfClosingFlag();\n", "} else if (StringUtil.in(name, Constants.InBodyStartDrop)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "}\n", "break;\n", "\n", "case EndTag:\n", "Token.EndTag endTag = t.asEndTag();\n", "name = endTag.name();\n", "if (name.equals(\"body\")) {\n", "if (!tb.inScope(\"body\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "// todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n", "tb.transition(AfterBody);\n", "}\n", "} else if (name.equals(\"html\")) {\n", "boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n", "if (notIgnored)\n", "return tb.process(endTag);\n", "} else if (StringUtil.in(name, Constants.InBodyEndClosers)) {\n", "if (!tb.inScope(name)) {\n", "// nothing to close\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"form\")) {\n", "Element currentForm = tb.getFormElement();\n", "tb.setFormElement(null);\n", "if (currentForm == null || !tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "// remove currentForm from stack. will shift anything under up.\n", "tb.removeFromStack(currentForm);\n", "}\n", "} else if (name.equals(\"p\")) {\n", "if (!tb.inButtonScope(name)) {\n", "tb.error(this);\n", "tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n", "return tb.process(endTag);\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"li\")) {\n", "if (!tb.inListItemScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.in(name, Constants.DdDt)) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.in(name, Constants.Headings)) {\n", "if (!tb.inScope(Constants.Headings)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(Constants.Headings);\n", "}\n", "} else if (name.equals(\"sarcasm\")) {\n", "// *sigh*\n", "return anyOtherEndTag(t, tb);\n", "} else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {\n", "// Adoption Agency Algorithm.\n", "OUTER:\n", "for (int i = 0; i < 8; i++) {\n", "Element formatEl = tb.getActiveFormattingElement(name);\n", "if (formatEl == null)\n", "return anyOtherEndTag(t, tb);\n", "else if (!tb.onStack(formatEl)) {\n", "tb.error(this);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "} else if (!tb.inScope(formatEl.nodeName())) {\n", "tb.error(this);\n", "return false;\n", "} else if (tb.currentElement() != formatEl)\n", "tb.error(this);\n", "\n", "Element furthestBlock = null;\n", "Element commonAncestor = null;\n", "boolean seenFormattingElement = false;\n", "LinkedList<Element> stack = tb.getStack();\n", "// the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n", "// run-aways\n", "final int stackSize = stack.size();\n", "for (int si = 0; si < stackSize && si < 64; si++) {\n", "Element el = stack.get(si);\n", "if (el == formatEl) {\n", "commonAncestor = stack.get(si - 1);\n", "seenFormattingElement = true;\n", "} else if (seenFormattingElement && tb.isSpecial(el)) {\n", "furthestBlock = el;\n", "break;\n", "}\n", "}\n", "if (furthestBlock == null) {\n", "tb.popStackToClose(formatEl.nodeName());\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "}\n", "\n", "// todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n", "// does that mean: int pos of format el in list?\n", "Element node = furthestBlock;\n", "Element lastNode = furthestBlock;\n", "INNER:\n", "for (int j = 0; j < 3; j++) {\n", "if (tb.onStack(node))\n", "node = tb.aboveOnStack(node);\n", "if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n", "tb.removeFromStack(node);\n", "continue INNER;\n", "} else if (node == formatEl)\n", "break INNER;\n", "\n", "Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n", "tb.replaceActiveFormattingElement(node, replacement);\n", "tb.replaceOnStack(node, replacement);\n", "node = replacement;\n", "\n", "if (lastNode == furthestBlock) {\n", "// todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n", "// not getting how this bookmark both straddles the element above, but is inbetween here...\n", "}\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "node.appendChild(lastNode);\n", "\n", "lastNode = node;\n", "}\n", "\n", "if (StringUtil.in(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "tb.insertInFosterParent(lastNode);\n", "} else {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "commonAncestor.appendChild(lastNode);\n", "}\n", "\n", "Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n", "adopter.attributes().addAll(formatEl.attributes());\n", "Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n", "for (Node childNode : childNodes) {\n", "adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n", "}\n", "furthestBlock.appendChild(adopter);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "// todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n", "tb.removeFromStack(formatEl);\n", "tb.insertOnStackAfter(furthestBlock, adopter);\n", "}\n", "} else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\n", "if (!tb.inScope(\"name\")) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "tb.clearFormattingElementsToLastMarker();\n", "}\n", "} else if (name.equals(\"br\")) {\n", "tb.error(this);\n", "tb.process(new Token.StartTag(\"br\"));\n", "return false;\n", "} else {\n", "return anyOtherEndTag(t, tb);\n", "}\n", "\n", "break;\n", "case EOF:\n", "// todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n", "// stop parsing\n", "break;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [209, 210], "cluster": 6}, {"pid": "Jsoup", "bid": 40, "method_path": "./dataset/Jsoup/40/DocumentType.java", "method": ["public DocumentType(String name, String publicId, String systemId, String baseUri) {\n", "super(baseUri);\n", "\n", "Validate.notEmpty(name);\n", "attr(\"name\", name);\n", "attr(\"publicId\", publicId);\n", "attr(\"systemId\", systemId);\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Jsoup", "bid": 41, "method_path": "./dataset/Jsoup/41/Element.java", "method": ["public boolean equals(Object o) {\n", "if (this == o) return true;\n", "if (o == null || getClass() != o.getClass()) return false;\n", "if (!super.equals(o)) return false;\n", "\n", "Element element = (Element) o;\n", "\n", "return this == o;\n", "}\n"], "faulty_lines": [8], "cluster": 0}, {"pid": "Jsoup", "bid": 42, "method_path": "./dataset/Jsoup/42/FormElement.java", "method": ["public List<Connection.KeyVal> formData() {\n", "ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();\n", "\n", "// iterate the form control elements and accumulate their values\n", "for (Element el: elements) {\n", "if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n", "String name = el.attr(\"name\");\n", "if (name.length() == 0) continue;\n", "String type = el.attr(\"type\");\n", "\n", "if (\"select\".equals(el.tagName())) {\n", "Elements options = el.select(\"option[selected]\");\n", "boolean set = false;\n", "for (Element option: options) {\n", "data.add(HttpConnection.KeyVal.create(name, option.val()));\n", "set = true;\n", "}\n", "if (!set) {\n", "Element option = el.select(\"option\").first();\n", "if (option != null)\n", "data.add(HttpConnection.KeyVal.create(name, option.val()));\n", "}\n", "} else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n", "// only add checkbox or radio if they have the checked attribute\n", "if (el.hasAttr(\"checked\")) {\n", "final String val = el.val();\n", "data.add(HttpConnection.KeyVal.create(name, val));\n", "}\n", "} else {\n", "data.add(HttpConnection.KeyVal.create(name, el.val()));\n", "}\n", "}\n", "return data;\n", "}\n"], "faulty_lines": [7], "cluster": 1}, {"pid": "Jsoup", "bid": 43, "method_path": "./dataset/Jsoup/43/Element.java", "method": ["private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n", "Validate.notNull(search);\n", "Validate.notNull(elements);\n", "\n", "for (int i = 0; i < elements.size(); i++) {\n", "E element = elements.get(i);\n", "if (element.equals(search))\n", "return i;\n", "}\n", "return null;\n", "}\n"], "faulty_lines": [7], "cluster": 4}, {"pid": "Jsoup", "bid": 45, "method_path": "./dataset/Jsoup/45/HtmlTreeBuilder.java", "method": ["boolean last = false;\n", "for (int pos = stack.size() -1; pos >= 0; pos--) {\n", "Element node = stack.get(pos);\n", "if (pos == 0) {\n", "last = true;\n", "node = contextElement;\n", "}\n", "String name = node.nodeName();\n", "if (\"select\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InSelect);\n", "break; // frag\n", "} else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n", "transition(HtmlTreeBuilderState.InCell);\n", "break;\n", "} else if (\"tr\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InRow);\n", "break;\n", "} else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InTableBody);\n", "break;\n", "} else if (\"caption\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InCaption);\n", "break;\n", "} else if (\"colgroup\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InColumnGroup);\n", "break; // frag\n", "} else if (\"table\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InTable);\n", "break;\n", "} else if (\"head\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InBody);\n", "break; // frag\n", "} else if (\"body\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InBody);\n", "break;\n", "} else if (\"frameset\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InFrameset);\n", "break; // frag\n", "} else if (\"html\".equals(name)) {\n", "transition(HtmlTreeBuilderState.BeforeHead);\n", "break; // frag\n", "} else if (last) {\n", "transition(HtmlTreeBuilderState.InBody);\n", "break; // frag\n", "}\n", "}\n"], "faulty_lines": [12], "cluster": 6}, {"pid": "Jsoup", "bid": 48, "method_path": "./dataset/Jsoup/48/HttpConnection.java", "method": ["void processResponseHeaders(Map<String, List<String>> resHeaders) {\n", "for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n", "String name = entry.getKey();\n", "if (name == null)\n", "continue; // http/1.1 line\n", "\n", "List<String> values = entry.getValue();\n", "if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n", "for (String value : values) {\n", "if (value == null)\n", "continue;\n", "TokenQueue cd = new TokenQueue(value);\n", "String cookieName = cd.chompTo(\"=\").trim();\n", "String cookieVal = cd.consumeTo(\";\").trim();\n", "// ignores path, date, domain, validateTLSCertificates et al. req'd?\n", "// name not blank, value not null\n", "if (cookieName.length() > 0)\n", "cookie(cookieName, cookieVal);\n", "}\n", "} else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n", "if (!values.isEmpty())\n", "header(name, values.get(0));\n", "}\n", "}\n", "}\n"], "faulty_lines": [21, 23], "cluster": 8}, {"pid": "Jsoup", "bid": 49, "method_path": "./dataset/Jsoup/49/Node.java", "method": ["protected void addChildren(int index, Node... children) {\n", "Validate.noNullElements(children);\n", "ensureChildNodes();\n", "for (int i = children.length - 1; i >= 0; i--) {\n", "Node in = children[i];\n", "reparentChild(in);\n", "childNodes.add(index, in);\n", "}\n", "reindexChildren(index);\n", "}\n"], "faulty_lines": [8, 9], "cluster": 4}, {"pid": "Jsoup", "bid": 51, "method_path": "./dataset/Jsoup/51/CharacterReader.java", "method": ["boolean matchesLetter() {\n", "if (isEmpty())\n", "return false;\n", "char c = input[pos];\n", "return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n", "}\n"], "faulty_lines": [5], "cluster": 0}, {"pid": "Jsoup", "bid": 52, "method_path": "./dataset/Jsoup/52/XmlTreeBuilder.java", "method": ["void insert(Token.Comment commentToken) {\n", "Comment comment = new Comment(commentToken.getData(), baseUri);\n", "Node insert = comment;\n", "if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n", "// so we do a bit of a hack and parse the data as an element to pull the attributes out\n", "String data = comment.getData();\n", "if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n", "String declaration = data.substring(1);\n", "insert = new XmlDeclaration(declaration, comment.baseUri(), data.startsWith(\"!\"));\n", "}\n", "}\n", "insertNode(insert);\n", "}\n"], "faulty_lines": [8, 9], "cluster": 2}, {"pid": "Jsoup", "bid": 53, "method_path": "./dataset/Jsoup/53/TokenQueue.java", "method": ["public String chompBalanced(char open, char close) {\n", "int start = -1;\n", "int end = -1;\n", "int depth = 0;\n", "char last = 0;\n", "\n", "do {\n", "if (isEmpty()) break;\n", "Character c = consume();\n", "if (last == 0 || last != ESC) {\n", "if (c.equals(open)) {\n", "depth++;\n", "if (start == -1)\n", "start = pos;\n", "}\n", "else if (c.equals(close))\n", "depth--;\n", "}\n", "\n", "if (depth > 0 && last != 0)\n", "end = pos; // don't include the outer match pair in the return\n", "last = c;\n", "} while (depth > 0);\n", "return (end >= 0) ? queue.substring(start, end) : \"\";\n", "}\n"], "faulty_lines": [6, 11], "cluster": 2}, {"pid": "Jsoup", "bid": 54, "method_path": "./dataset/Jsoup/54/W3CDom.java", "method": ["private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n", "for (Attribute attribute : source.attributes()) {\n", "// valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n", "String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n", "el.setAttribute(key, attribute.getValue());\n", "}\n", "}\n"], "faulty_lines": [5], "cluster": 4}, {"pid": "Jsoup", "bid": 55, "method_path": "./dataset/Jsoup/55/TokeniserState.java", "method": ["void read(Tokeniser t, CharacterReader r) {\n", "char c = r.consume();\n", "switch (c) {\n", "case '>':\n", "t.tagPending.selfClosing = true;\n", "t.emitTagPending();\n", "t.transition(Data);\n", "break;\n", "case eof:\n", "t.eofError(this);\n", "t.transition(Data);\n", "break;\n", "default:\n", "t.error(this);\n", "t.transition(BeforeAttributeName);\n", "}\n", "}\n"], "faulty_lines": [15], "cluster": 4}, {"pid": "Jsoup", "bid": 56, "method_path": "./dataset/Jsoup/56/DocumentType.java", "method": ["public DocumentType(String name, String publicId, String systemId, String baseUri) {\n", "super(baseUri);\n", "\n", "attr(NAME, name);\n", "attr(PUBLIC_ID, publicId);\n", "attr(SYSTEM_ID, systemId);\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Jsoup", "bid": 56, "method_path": "./dataset/Jsoup/56/DocumentType.java", "method": ["void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\n", "if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {\n", "// looks like a html5 doctype, go lowercase for aesthetics\n", "accum.append(\"<!doctype\");\n", "} else {\n", "accum.append(\"<!DOCTYPE\");\n", "}\n", "if (has(NAME))\n", "accum.append(\" \").append(attr(NAME));\n", "if (has(PUBLIC_ID))\n", "accum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"');\n", "if (has(SYSTEM_ID))\n", "accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"');\n", "accum.append('>');\n", "}\n"], "faulty_lines": [8, 9], "cluster": 2}, {"pid": "Jsoup", "bid": 56, "method_path": "./dataset/Jsoup/56/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "if (isWhitespace(t)) {\n", "return true; // ignore whitespace\n", "} else if (t.isComment()) {\n", "tb.insert(t.asComment());\n", "} else if (t.isDoctype()) {\n", "// todo: parse error check on expected doctypes\n", "// todo: quirk state check on doctype ids\n", "Token.Doctype d = t.asDoctype();\n", "DocumentType doctype = new DocumentType(\n", "tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n", "tb.getDocument().appendChild(doctype);\n", "if (d.isForceQuirks())\n", "tb.getDocument().quirksMode(Document.QuirksMode.quirks);\n", "tb.transition(BeforeHtml);\n", "} else {\n", "// todo: check not iframe srcdoc\n", "tb.transition(BeforeHtml);\n", "return tb.process(t); // re-process token\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [11], "cluster": 8}, {"pid": "Jsoup", "bid": 56, "method_path": "./dataset/Jsoup/56/TokeniserState.java", "method": ["void read(Tokeniser t, CharacterReader r) {\n", "if (r.isEmpty()) {\n", "t.eofError(this);\n", "t.doctypePending.forceQuirks = true;\n", "t.emitDoctypePending();\n", "t.transition(Data);\n", "return;\n", "}\n", "if (r.matchesAny('\\t', '\\n', '\\r', '\\f', ' '))\n", "r.advance(); // ignore whitespace\n", "else if (r.matches('>')) {\n", "t.emitDoctypePending();\n", "t.advanceTransition(Data);\n", "} else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) {\n", "t.transition(AfterDoctypePublicKeyword);\n", "} else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) {\n", "t.transition(AfterDoctypeSystemKeyword);\n", "} else {\n", "t.error(this);\n", "t.doctypePending.forceQuirks = true;\n", "t.advanceTransition(BogusDoctype);\n", "}\n", "\n", "}\n"], "faulty_lines": [15, 17], "cluster": 8}, {"pid": "Jsoup", "bid": 56, "method_path": "./dataset/Jsoup/56/XmlTreeBuilder.java", "method": ["void insert(Token.Doctype d) {\n", "DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n", "insertNode(doctypeNode);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Jsoup", "bid": 57, "method_path": "./dataset/Jsoup/57/Attributes.java", "method": ["public void removeIgnoreCase(String key) {\n", "Validate.notEmpty(key);\n", "if (attributes == null)\n", "return;\n", "for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n", "String attrKey = it.next();\n", "if (attrKey.equalsIgnoreCase(key))\n", "attributes.remove(attrKey);\n", "}\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Jsoup", "bid": 58, "method_path": "./dataset/Jsoup/58/Jsoup.java", "method": ["public static boolean isValid(String bodyHtml, Whitelist whitelist) {\n", "return new Cleaner(whitelist).isValid(parseBodyFragment(bodyHtml, \"\"));\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Jsoup", "bid": 60, "method_path": "./dataset/Jsoup/60/QueryParser.java", "method": ["public static Evaluator parse(String query) {\n", "QueryParser p = new QueryParser(query);\n", "return p.parse();\n", "}\n"], "faulty_lines": [2, 4], "cluster": 0}, {"pid": "Jsoup", "bid": 61, "method_path": "./dataset/Jsoup/61/Element.java", "method": ["public boolean hasClass(String className) {\n", "final String classAttr = attributes.get(\"class\");\n", "final int len = classAttr.length();\n", "final int wantLen = className.length();\n", "\n", "if (len == 0 || len < wantLen) {\n", "return false;\n", "}\n", "\n", "// if both lengths are equal, only need compare the className with the attribute\n", "if (len == wantLen) {\n", "return className.equalsIgnoreCase(classAttr);\n", "}\n", "\n", "// otherwise, scan for whitespace and compare regions (with no string or arraylist allocations)\n", "boolean inClass = false;\n", "int start = 0;\n", "for (int i = 0; i < len; i++) {\n", "if (Character.isWhitespace(classAttr.charAt(i))) {\n", "if (inClass) {\n", "// white space ends a class name, compare it with the requested one, ignore case\n", "if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) {\n", "return true;\n", "}\n", "inClass = false;\n", "}\n", "} else {\n", "if (!inClass) {\n", "// we're in a class name : keep the start of the substring\n", "inClass = true;\n", "start = i;\n", "}\n", "}\n", "}\n", "\n", "// check the last entry\n", "if (inClass && len - start == wantLen) {\n", "return classAttr.regionMatches(true, start, className, 0, wantLen);\n", "}\n", "\n", "return false;\n", "}\n"], "faulty_lines": [2], "cluster": 1}, {"pid": "Jsoup", "bid": 62, "method_path": "./dataset/Jsoup/62/HtmlTreeBuilderState.java", "method": ["boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n", "String name = t.asEndTag().normalName();\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int pos = stack.size() -1; pos >= 0; pos--) {\n", "Element node = stack.get(pos);\n", "if (node.nodeName().equals(name)) {\n", "tb.generateImpliedEndTags(name);\n", "if (!name.equals(tb.currentElement().nodeName()))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "break;\n", "} else {\n", "if (tb.isSpecial(node)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "}\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [2], "cluster": 2}, {"pid": "Jsoup", "bid": 63, "method_path": "./dataset/Jsoup/63/Tokeniser.java", "method": ["void emit(Token token) {\n", "Validate.isFalse(isEmitPending, \"There is an unread token pending!\");\n", "\n", "emitPending = token;\n", "isEmitPending = true;\n", "\n", "if (token.type == Token.TokenType.StartTag) {\n", "Token.StartTag startTag = (Token.StartTag) token;\n", "lastStartTag = startTag.tagName;\n", "if (startTag.selfClosing)\n", "selfClosingFlagAcknowledged = false;\n", "} else if (token.type == Token.TokenType.EndTag) {\n", "Token.EndTag endTag = (Token.EndTag) token;\n", "if (endTag.attributes != null)\n", "error(\"Attributes incorrectly present on end tag\");\n", "}\n", "}\n"], "faulty_lines": [10, 11], "cluster": 2}, {"pid": "Jsoup", "bid": 64, "method_path": "./dataset/Jsoup/64/HtmlTreeBuilderState.java", "method": ["private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n", "tb.insert(startTag);\n", "tb.tokeniser.transition(TokeniserState.Rawtext);\n", "tb.markInsertionMode();\n", "tb.transition(Text);\n", "}\n"], "faulty_lines": [2, 6], "cluster": 0}, {"pid": "Jsoup", "bid": 65, "method_path": "./dataset/Jsoup/65/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case StartTag:\n", "Token.StartTag startTag = t.asStartTag();\n", "String name = startTag.normalName();\n", "if (name.equals(\"tr\")) {\n", "tb.clearStackToTableBodyContext();\n", "tb.insert(startTag);\n", "tb.transition(InRow);\n", "} else if (StringUtil.in(name, \"th\", \"td\")) {\n", "tb.error(this);\n", "tb.processStartTag(\"tr\");\n", "return tb.process(startTag);\n", "} else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) {\n", "return exitTableBody(t, tb);\n", "} else\n", "return anythingElse(t, tb);\n", "break;\n", "case EndTag:\n", "Token.EndTag endTag = t.asEndTag();\n", "name = endTag.normalName();\n", "if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n", "if (!tb.inTableScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.clearStackToTableBodyContext();\n", "tb.pop();\n", "tb.transition(InTable);\n", "}\n", "} else if (name.equals(\"table\")) {\n", "return exitTableBody(t, tb);\n", "} else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\", \"tr\")) {\n", "tb.error(this);\n", "return false;\n", "} else\n", "return anythingElse(t, tb);\n", "break;\n", "default:\n", "return anythingElse(t, tb);\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [6], "cluster": 6}, {"pid": "Jsoup", "bid": 65, "method_path": "./dataset/Jsoup/65/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "if (t.isStartTag()) {\n", "Token.StartTag startTag = t.asStartTag();\n", "String name = startTag.normalName();\n", "\n", "if (StringUtil.in(name, \"th\", \"td\")) {\n", "tb.clearStackToTableRowContext();\n", "tb.insert(startTag);\n", "tb.transition(InCell);\n", "tb.insertMarkerToFormattingElements();\n", "} else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n", "return handleMissingTr(t, tb);\n", "} else {\n", "return anythingElse(t, tb);\n", "}\n", "} else if (t.isEndTag()) {\n", "Token.EndTag endTag = t.asEndTag();\n", "String name = endTag.normalName();\n", "\n", "if (name.equals(\"tr\")) {\n", "if (!tb.inTableScope(name)) {\n", "tb.error(this); // frag\n", "return false;\n", "}\n", "tb.clearStackToTableRowContext();\n", "tb.pop(); // tr\n", "tb.transition(InTableBody);\n", "} else if (name.equals(\"table\")) {\n", "return handleMissingTr(t, tb);\n", "} else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n", "if (!tb.inTableScope(name)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "tb.processEndTag(\"tr\");\n", "return tb.process(t);\n", "} else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "return anythingElse(t, tb);\n", "}\n", "} else {\n", "return anythingElse(t, tb);\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [6], "cluster": 6}, {"pid": "Jsoup", "bid": 66, "method_path": "./dataset/Jsoup/66/Element.java", "method": ["protected List<Node> ensureChildNodes() {\n", "if (childNodes == EMPTY_NODES) {\n", "childNodes = new NodeList(4);\n", "}\n", "return childNodes;\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Jsoup", "bid": 67, "method_path": "./dataset/Jsoup/67/HtmlTreeBuilder.java", "method": ["private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n", "int depth = stack.size() -1;\n", "for (int pos = depth; pos >= 0; pos--) {\n", "Element el = stack.get(pos);\n", "String elName = el.nodeName();\n", "if (inSorted(elName, targetNames))\n", "return true;\n", "if (inSorted(elName, baseTypes))\n", "return false;\n", "if (extraTypes != null && inSorted(elName, extraTypes))\n", "return false;\n", "}\n", "Validate.fail(\"Should not be reachable\");\n", "return false;\n", "}\n"], "faulty_lines": [3], "cluster": 2}, {"pid": "Jsoup", "bid": 68, "method_path": "./dataset/Jsoup/68/HtmlTreeBuilder.java", "method": ["private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n", "// https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n", "int bottom = stack.size() -1;\n", "if (bottom > MaxScopeSearchDepth) {\n", "bottom = MaxScopeSearchDepth;\n", "}\n", "final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n", "// don't walk too far up the tree\n", "\n", "for (int pos = bottom; pos >= top; pos--) {\n", "final String elName = stack.get(pos).nodeName();\n", "if (inSorted(elName, targetNames))\n", "return true;\n", "if (inSorted(elName, baseTypes))\n", "return false;\n", "if (extraTypes != null && inSorted(elName, extraTypes))\n", "return false;\n", "}\n", "//Validate.fail(\"Should not be reachable\"); // would end up false because hitting 'html' at root (basetypes)\n", "return false;\n", "}\n"], "faulty_lines": [3, 4, 5, 6], "cluster": 8}, {"pid": "Jsoup", "bid": 72, "method_path": "./dataset/Jsoup/72/CharacterReader.java", "method": ["private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n", "// limit (no cache):\n", "if (count > maxStringCacheLen)\n", "return new String(charBuf, start, count);\n", "\n", "// calculate hash:\n", "int hash = 0;\n", "int offset = start;\n", "for (int i = 0; i < count; i++) {\n", "hash = 31 * hash + charBuf[offset++];\n", "}\n", "\n", "// get from cache\n", "final int index = hash & stringCache.length - 1;\n", "String cached = stringCache[index];\n", "\n", "if (cached == null) { // miss, add\n", "cached = new String(charBuf, start, count);\n", "stringCache[index] = cached;\n", "} else { // hashcode hit, check equality\n", "if (rangeEquals(charBuf, start, count, cached)) { // hit\n", "return cached;\n", "} else { // hashcode conflict\n", "cached = new String(charBuf, start, count);\n", "stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n", "}\n", "}\n", "return cached;\n", "}\n"], "faulty_lines": [5], "cluster": 8}, {"pid": "Jsoup", "bid": 73, "method_path": "./dataset/Jsoup/73/W3CDom.java", "method": ["public void tail(org.jsoup.nodes.Node source, int depth) {\n", "if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {\n", "dest = (Element) dest.getParentNode(); // undescend. cromulent.\n", "}\n", "}\n"], "faulty_lines": [5], "cluster": 4}, {"pid": "Jsoup", "bid": 73, "method_path": "./dataset/Jsoup/73/W3CDom.java", "method": ["private String updateNamespaces(org.jsoup.nodes.Element el) {\n", "// scan the element for namespace declarations\n", "// like: xmlns=\"blah\" or xmlns:prefix=\"blah\"\n", "Attributes attributes = el.attributes();\n", "for (Attribute attr : attributes) {\n", "String key = attr.getKey();\n", "String prefix;\n", "if (key.equals(xmlnsKey)) {\n", "prefix = \"\";\n", "} else if (key.startsWith(xmlnsPrefix)) {\n", "prefix = key.substring(xmlnsPrefix.length());\n", "} else {\n", "continue;\n", "}\n", "namespaces.put(prefix, attr.getValue());\n", "}\n", "\n", "// get the element prefix if any\n", "int pos = el.tagName().indexOf(\":\");\n", "return pos > 0 ? el.tagName().substring(0, pos) : \"\";\n", "}\n"], "faulty_lines": [15], "cluster": 2}, {"pid": "Jsoup", "bid": 76, "method_path": "./dataset/Jsoup/76/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case Character: {\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "// todo confirm that check\n", "tb.error(this);\n", "return false;\n", "} else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "tb.framesetOk(false);\n", "}\n", "break;\n", "}\n", "case Comment: {\n", "tb.insert(t.asComment());\n", "break;\n", "}\n", "case Doctype: {\n", "tb.error(this);\n", "return false;\n", "}\n", "case StartTag:\n", "Token.StartTag startTag = t.asStartTag();\n", "// todo - refactor to a switch statement\n", "String name = startTag.normalName();\n", "if (name.equals(\"a\")) {\n", "if (tb.getActiveFormattingElement(\"a\") != null) {\n", "tb.error(this);\n", "tb.processEndTag(\"a\");\n", "\n", "// still on stack?\n", "Element remainingA = tb.getFromStack(\"a\");\n", "if (remainingA != null) {\n", "tb.removeFromActiveFormattingElements(remainingA);\n", "tb.removeFromStack(remainingA);\n", "}\n", "}\n", "tb.reconstructFormattingElements();\n", "Element a = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(a);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n", "tb.reconstructFormattingElements();\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"span\")) {\n", "// same as final else, but short circuits lots of checks\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (name.equals(\"li\")) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (el.nodeName().equals(\"li\")) {\n", "tb.processEndTag(\"li\");\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"html\")) {\n", "tb.error(this);\n", "// merge attributes onto real html\n", "Element html = tb.getStack().get(0);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!html.hasAttr(attribute.getKey()))\n", "html.attributes().put(attribute);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n", "return tb.process(t, InHead);\n", "} else if (name.equals(\"body\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else {\n", "tb.framesetOk(false);\n", "Element body = stack.get(1);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!body.hasAttr(attribute.getKey()))\n", "body.attributes().put(attribute);\n", "}\n", "}\n", "} else if (name.equals(\"frameset\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else if (!tb.framesetOk()) {\n", "return false; // ignore frameset\n", "} else {\n", "Element second = stack.get(1);\n", "if (second.parent() != null)\n", "second.remove();\n", "// pop up to html element\n", "while (stack.size() > 1)\n", "stack.remove(stack.size()-1);\n", "tb.insert(startTag);\n", "tb.transition(InFrameset);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n", "tb.error(this);\n", "tb.pop();\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"form\")) {\n", "if (tb.getFormElement() != null) {\n", "tb.error(this);\n", "return false;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertForm(startTag, true);\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n", "tb.processEndTag(el.nodeName());\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"plaintext\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n", "} else if (name.equals(\"button\")) {\n", "if (tb.inButtonScope(\"button\")) {\n", "// close and reprocess\n", "tb.error(this);\n", "tb.processEndTag(\"button\");\n", "tb.process(startTag);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Formatters)) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (name.equals(\"nobr\")) {\n", "tb.reconstructFormattingElements();\n", "if (tb.inScope(\"nobr\")) {\n", "tb.error(this);\n", "tb.processEndTag(\"nobr\");\n", "tb.reconstructFormattingElements();\n", "}\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.insertMarkerToFormattingElements();\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"table\")) {\n", "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "tb.transition(InTable);\n", "} else if (name.equals(\"input\")) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insertEmpty(startTag);\n", "if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n", "tb.insertEmpty(startTag);\n", "} else if (name.equals(\"hr\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"image\")) {\n", "if (tb.getFromStack(\"svg\") == null)\n", "return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n", "else\n", "tb.insert(startTag);\n", "} else if (name.equals(\"isindex\")) {\n", "// how much do we care about the early 90s?\n", "tb.error(this);\n", "if (tb.getFormElement() != null)\n", "return false;\n", "\n", "tb.processStartTag(\"form\");\n", "if (startTag.attributes.hasKey(\"action\")) {\n", "Element form = tb.getFormElement();\n", "form.attr(\"action\", startTag.attributes.get(\"action\"));\n", "}\n", "tb.processStartTag(\"hr\");\n", "tb.processStartTag(\"label\");\n", "// hope you like english.\n", "String prompt = startTag.attributes.hasKey(\"prompt\") ?\n", "startTag.attributes.get(\"prompt\") :\n", "\"This is a searchable index. Enter search keywords: \";\n", "\n", "tb.process(new Token.Character().data(prompt));\n", "\n", "// input\n", "Attributes inputAttribs = new Attributes();\n", "for (Attribute attr : startTag.attributes) {\n", "if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n", "inputAttribs.put(attr);\n", "}\n", "inputAttribs.put(\"name\", \"isindex\");\n", "tb.processStartTag(\"input\", inputAttribs);\n", "tb.processEndTag(\"label\");\n", "tb.processStartTag(\"hr\");\n", "tb.processEndTag(\"form\");\n", "} else if (name.equals(\"textarea\")) {\n", "tb.insert(startTag);\n", "// todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n", "tb.tokeniser.transition(TokeniserState.Rcdata);\n", "tb.markInsertionMode();\n", "tb.framesetOk(false);\n", "tb.transition(Text);\n", "} else if (name.equals(\"xmp\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.reconstructFormattingElements();\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"iframe\")) {\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"noembed\")) {\n", "// also handle noscript if script enabled\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"select\")) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "\n", "HtmlTreeBuilderState state = tb.state();\n", "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n", "tb.transition(InSelectInTable);\n", "else\n", "tb.transition(InSelect);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n", "if (tb.inScope(\"ruby\")) {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n", "tb.error(this);\n", "tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n", "}\n", "tb.insert(startTag);\n", "}\n", "} else if (name.equals(\"math\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n", "tb.insert(startTag);\n", "} else if (name.equals(\"svg\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "}\n", "break;\n", "\n", "case EndTag:\n", "Token.EndTag endTag = t.asEndTag();\n", "name = endTag.normalName();\n", "if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n", "// Adoption Agency Algorithm.\n", "for (int i = 0; i < 8; i++) {\n", "Element formatEl = tb.getActiveFormattingElement(name);\n", "if (formatEl == null)\n", "return anyOtherEndTag(t, tb);\n", "else if (!tb.onStack(formatEl)) {\n", "tb.error(this);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "} else if (!tb.inScope(formatEl.nodeName())) {\n", "tb.error(this);\n", "return false;\n", "} else if (tb.currentElement() != formatEl)\n", "tb.error(this);\n", "\n", "Element furthestBlock = null;\n", "Element commonAncestor = null;\n", "boolean seenFormattingElement = false;\n", "ArrayList<Element> stack = tb.getStack();\n", "// the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n", "// run-aways\n", "final int stackSize = stack.size();\n", "for (int si = 0; si < stackSize && si < 64; si++) {\n", "Element el = stack.get(si);\n", "if (el == formatEl) {\n", "commonAncestor = stack.get(si - 1);\n", "seenFormattingElement = true;\n", "} else if (seenFormattingElement && tb.isSpecial(el)) {\n", "furthestBlock = el;\n", "break;\n", "}\n", "}\n", "if (furthestBlock == null) {\n", "tb.popStackToClose(formatEl.nodeName());\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "}\n", "\n", "// todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n", "// does that mean: int pos of format el in list?\n", "Element node = furthestBlock;\n", "Element lastNode = furthestBlock;\n", "for (int j = 0; j < 3; j++) {\n", "if (tb.onStack(node))\n", "node = tb.aboveOnStack(node);\n", "if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n", "tb.removeFromStack(node);\n", "continue;\n", "} else if (node == formatEl)\n", "break;\n", "\n", "Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n", "// case will follow the original node (so honours ParseSettings)\n", "tb.replaceActiveFormattingElement(node, replacement);\n", "tb.replaceOnStack(node, replacement);\n", "node = replacement;\n", "\n", "if (lastNode == furthestBlock) {\n", "// todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n", "// not getting how this bookmark both straddles the element above, but is inbetween here...\n", "}\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "node.appendChild(lastNode);\n", "\n", "lastNode = node;\n", "}\n", "\n", "if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "tb.insertInFosterParent(lastNode);\n", "} else {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "commonAncestor.appendChild(lastNode);\n", "}\n", "\n", "Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n", "adopter.attributes().addAll(formatEl.attributes());\n", "Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n", "for (Node childNode : childNodes) {\n", "adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n", "}\n", "furthestBlock.appendChild(adopter);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "// todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n", "tb.removeFromStack(formatEl);\n", "tb.insertOnStackAfter(furthestBlock, adopter);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n", "if (!tb.inScope(name)) {\n", "// nothing to close\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"span\")) {\n", "// same as final fall through, but saves short circuit\n", "return anyOtherEndTag(t, tb);\n", "} else if (name.equals(\"li\")) {\n", "if (!tb.inListItemScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"body\")) {\n", "if (!tb.inScope(\"body\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "// todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n", "tb.transition(AfterBody);\n", "}\n", "} else if (name.equals(\"html\")) {\n", "boolean notIgnored = tb.processEndTag(\"body\");\n", "if (notIgnored)\n", "return tb.process(endTag);\n", "} else if (name.equals(\"form\")) {\n", "Element currentForm = tb.getFormElement();\n", "tb.setFormElement(null);\n", "if (currentForm == null || !tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "// remove currentForm from stack. will shift anything under up.\n", "tb.removeFromStack(currentForm);\n", "}\n", "} else if (name.equals(\"p\")) {\n", "if (!tb.inButtonScope(name)) {\n", "tb.error(this);\n", "tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n", "return tb.process(endTag);\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (!tb.inScope(Constants.Headings)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(Constants.Headings);\n", "}\n", "} else if (name.equals(\"sarcasm\")) {\n", "// *sigh*\n", "return anyOtherEndTag(t, tb);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "if (!tb.inScope(\"name\")) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "tb.clearFormattingElementsToLastMarker();\n", "}\n", "} else if (name.equals(\"br\")) {\n", "tb.error(this);\n", "tb.processStartTag(\"br\");\n", "return false;\n", "} else {\n", "return anyOtherEndTag(t, tb);\n", "}\n", "\n", "break;\n", "case EOF:\n", "// todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n", "// stop parsing\n", "break;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [131], "cluster": 6}, {"pid": "Jsoup", "bid": 77, "method_path": "./dataset/Jsoup/77/XmlTreeBuilder.java", "method": ["private void popStackToClose(Token.EndTag endTag) {\n", "String elName = endTag.name();\n", "Element firstFound = null;\n", "\n", "for (int pos = stack.size() -1; pos >= 0; pos--) {\n", "Element next = stack.get(pos);\n", "if (next.nodeName().equals(elName)) {\n", "firstFound = next;\n", "break;\n", "}\n", "}\n", "if (firstFound == null)\n", "return; // not found, skip\n", "\n", "for (int pos = stack.size() -1; pos >= 0; pos--) {\n", "Element next = stack.get(pos);\n", "stack.remove(pos);\n", "if (next == firstFound)\n", "break;\n", "}\n", "}\n"], "faulty_lines": [2], "cluster": 2}, {"pid": "Jsoup", "bid": 79, "method_path": "./dataset/Jsoup/79/LeafNode.java", "method": ["protected List<Node> ensureChildNodes() {\n", "throw new UnsupportedOperationException(\"Leaf Nodes do not have child nodes.\");\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Jsoup", "bid": 80, "method_path": "./dataset/Jsoup/80/XmlTreeBuilder.java", "method": ["void insert(Token.Comment commentToken) {\n", "Comment comment = new Comment(commentToken.getData());\n", "Node insert = comment;\n", "if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n", "// so we do a bit of a hack and parse the data as an element to pull the attributes out\n", "String data = comment.getData();\n", "if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n", "Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n", "Element el = doc.child(0);\n", "insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n", "insert.attributes().addAll(el.attributes());\n", "}\n", "}\n", "insertNode(insert);\n", "}\n"], "faulty_lines": [9, 12], "cluster": 8}, {"pid": "Jsoup", "bid": 83, "method_path": "./dataset/Jsoup/83/TokeniserState.java", "method": ["void read(Tokeniser t, CharacterReader r) {\n", "// previous TagOpen state did NOT consume, will have a letter char in current\n", "//String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n", "String tagName = r.consumeTagName();\n", "t.tagPending.appendTagName(tagName);\n", "\n", "char c = r.consume();\n", "switch (c) {\n", "case '\\t':\n", "case '\\n':\n", "case '\\r':\n", "case '\\f':\n", "case ' ':\n", "t.transition(BeforeAttributeName);\n", "break;\n", "case '/':\n", "t.transition(SelfClosingStartTag);\n", "break;\n", "// intended fall through to next >\n", "case '>':\n", "t.emitTagPending();\n", "t.transition(Data);\n", "break;\n", "case nullChar: // replacement\n", "t.tagPending.appendTagName(replacementStr);\n", "break;\n", "case eof: // should emit pending tag?\n", "t.eofError(this);\n", "t.transition(Data);\n", "break;\n", "default: // buffer underrun\n", "t.tagPending.appendTagName(c);\n", "}\n", "}\n"], "faulty_lines": [19], "cluster": 8}, {"pid": "Jsoup", "bid": 83, "method_path": "./dataset/Jsoup/83/TokeniserState.java", "method": ["void read(Tokeniser t, CharacterReader r) {\n", "char c = r.consume();\n", "switch (c) {\n", "case '\\t':\n", "case '\\n':\n", "case '\\r':\n", "case '\\f':\n", "case ' ':\n", "break; // ignore whitespace\n", "case '/':\n", "t.transition(SelfClosingStartTag);\n", "break;\n", "// intended fall through as if >\n", "case '>':\n", "t.emitTagPending();\n", "t.transition(Data);\n", "break;\n", "case nullChar:\n", "t.error(this);\n", "t.tagPending.newAttribute();\n", "r.unconsume();\n", "t.transition(AttributeName);\n", "break;\n", "case eof:\n", "t.eofError(this);\n", "t.transition(Data);\n", "break;\n", "case '\"':\n", "case '\\'':\n", "case '<':\n", "case '=':\n", "t.error(this);\n", "t.tagPending.newAttribute();\n", "t.tagPending.appendAttributeName(c);\n", "t.transition(AttributeName);\n", "break;\n", "default: // A-Z, anything else\n", "t.tagPending.newAttribute();\n", "r.unconsume();\n", "t.transition(AttributeName);\n", "}\n", "}\n"], "faulty_lines": [13], "cluster": 8}, {"pid": "Jsoup", "bid": 83, "method_path": "./dataset/Jsoup/83/TokeniserState.java", "method": ["void read(Tokeniser t, CharacterReader r) {\n", "char c = r.consume();\n", "switch (c) {\n", "case '\\t':\n", "case '\\n':\n", "case '\\r':\n", "case '\\f':\n", "case ' ':\n", "break; // ignore whitespace\n", "case '/':\n", "t.transition(SelfClosingStartTag);\n", "break;\n", "// intended fall through as if >\n", "case '>':\n", "t.emitTagPending();\n", "t.transition(Data);\n", "break;\n", "case nullChar:\n", "t.error(this);\n", "t.tagPending.newAttribute();\n", "r.unconsume();\n", "t.transition(AttributeName);\n", "break;\n", "case eof:\n", "t.eofError(this);\n", "t.transition(Data);\n", "break;\n", "case '\"':\n", "case '\\'':\n", "case '<':\n", "case '=':\n", "t.error(this);\n", "t.tagPending.newAttribute();\n", "t.tagPending.appendAttributeName(c);\n", "t.transition(AttributeName);\n", "break;\n", "default: // A-Z, anything else\n", "t.tagPending.newAttribute();\n", "r.unconsume();\n", "t.transition(AttributeName);\n", "}\n", "}\n"], "faulty_lines": [30], "cluster": 8}, {"pid": "Jsoup", "bid": 84, "method_path": "./dataset/Jsoup/84/W3CDom.java", "method": ["public void head(org.jsoup.nodes.Node source, int depth) {\n", "namespacesStack.push(new HashMap<>(namespacesStack.peek())); // inherit from above on the stack\n", "if (source instanceof org.jsoup.nodes.Element) {\n", "org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n", "\n", "String prefix = updateNamespaces(sourceEl);\n", "String namespace = namespacesStack.peek().get(prefix);\n", "String tagName = sourceEl.tagName();\n", "\n", "Element el =\n", "doc.createElementNS(namespace, tagName);\n", "copyAttributes(sourceEl, el);\n", "if (dest == null) { // sets up the root\n", "doc.appendChild(el);\n", "} else {\n", "dest.appendChild(el);\n", "}\n", "dest = el; // descend\n", "} else if (source instanceof org.jsoup.nodes.TextNode) {\n", "org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;\n", "Text text = doc.createTextNode(sourceText.getWholeText());\n", "dest.appendChild(text);\n", "} else if (source instanceof org.jsoup.nodes.Comment) {\n", "org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;\n", "Comment comment = doc.createComment(sourceComment.getData());\n", "dest.appendChild(comment);\n", "} else if (source instanceof org.jsoup.nodes.DataNode) {\n", "org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n", "Text node = doc.createTextNode(sourceData.getWholeData());\n", "dest.appendChild(node);\n", "} else {\n", "// unhandled\n", "}\n", "}\n"], "faulty_lines": [10], "cluster": 5}, {"pid": "Jsoup", "bid": 85, "method_path": "./dataset/Jsoup/85/Attribute.java", "method": ["public Attribute(String key, String val, Attributes parent) {\n", "Validate.notNull(key);\n", "this.key = key.trim();\n", "Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n", "this.val = val;\n", "this.parent = parent;\n", "}\n"], "faulty_lines": [3, 5], "cluster": 4}, {"pid": "Jsoup", "bid": 86, "method_path": "./dataset/Jsoup/86/Comment.java", "method": ["public XmlDeclaration asXmlDeclaration() {\n", "String data = getData();\n", "Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n", "XmlDeclaration decl = null;\n", "if (doc.childNodeSize() > 0) {\n", "Element el = doc.child(0);\n", "decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n", "decl.attributes().addAll(el.attributes());\n", "}\n", "return decl;\n", "}\n"], "faulty_lines": [5], "cluster": 2}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilder.java", "method": ["void popStackToClose(String elName) {\n", "for (int pos = stack.size() -1; pos >= 0; pos--) {\n", "Element next = stack.get(pos);\n", "stack.remove(pos);\n", "if (next.nodeName().equals(elName))\n", "break;\n", "}\n", "}\n"], "faulty_lines": [5], "cluster": 4}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilder.java", "method": ["void popStackToClose(String... elNames) {\n", "for (int pos = stack.size() -1; pos >= 0; pos--) {\n", "Element next = stack.get(pos);\n", "stack.remove(pos);\n", "if (inSorted(next.nodeName(), elNames))\n", "break;\n", "}\n", "}\n"], "faulty_lines": [5], "cluster": 4}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilder.java", "method": ["void popStackToBefore(String elName) {\n", "for (int pos = stack.size() -1; pos >= 0; pos--) {\n", "Element next = stack.get(pos);\n", "if (next.nodeName().equals(elName)) {\n", "break;\n", "} else {\n", "stack.remove(pos);\n", "}\n", "}\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilder.java", "method": ["private void clearStackToContext(String... nodeNames) {\n", "for (int pos = stack.size() -1; pos >= 0; pos--) {\n", "Element next = stack.get(pos);\n", "if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n", "break;\n", "else\n", "stack.remove(pos);\n", "}\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilder.java", "method": ["boolean last = false;\n", "for (int pos = stack.size() -1; pos >= 0; pos--) {\n", "Element node = stack.get(pos);\n", "if (pos == 0) {\n", "last = true;\n", "node = contextElement;\n", "}\n", "String name = node.nodeName();\n", "if (\"select\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InSelect);\n", "break; // frag\n", "} else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n", "transition(HtmlTreeBuilderState.InCell);\n", "break;\n", "} else if (\"tr\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InRow);\n", "break;\n", "} else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InTableBody);\n", "break;\n", "} else if (\"caption\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InCaption);\n", "break;\n", "} else if (\"colgroup\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InColumnGroup);\n", "break; // frag\n", "} else if (\"table\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InTable);\n", "break;\n", "} else if (\"head\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InBody);\n", "break; // frag\n", "} else if (\"body\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InBody);\n", "break;\n", "} else if (\"frameset\".equals(name)) {\n", "transition(HtmlTreeBuilderState.InFrameset);\n", "break; // frag\n", "} else if (\"html\".equals(name)) {\n", "transition(HtmlTreeBuilderState.BeforeHead);\n", "break; // frag\n", "} else if (last) {\n", "transition(HtmlTreeBuilderState.InBody);\n", "break; // frag\n", "}\n", "}\n"], "faulty_lines": [8], "cluster": 6}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilder.java", "method": ["private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n", "// https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n", "final int bottom = stack.size() -1;\n", "final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n", "// don't walk too far up the tree\n", "\n", "for (int pos = bottom; pos >= top; pos--) {\n", "final String elName = stack.get(pos).nodeName();\n", "if (inSorted(elName, targetNames))\n", "return true;\n", "if (inSorted(elName, baseTypes))\n", "return false;\n", "if (extraTypes != null && inSorted(elName, extraTypes))\n", "return false;\n", "}\n", "//Validate.fail(\"Should not be reachable\"); // would end up false because hitting 'html' at root (basetypes)\n", "return false;\n", "}\n"], "faulty_lines": [8], "cluster": 8}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilder.java", "method": ["boolean inSelectScope(String targetName) {\n", "for (int pos = stack.size() -1; pos >= 0; pos--) {\n", "Element el = stack.get(pos);\n", "String elName = el.nodeName();\n", "if (elName.equals(targetName))\n", "return true;\n", "if (!inSorted(elName, TagSearchSelectScope)) // all elements except\n", "return false;\n", "}\n", "Validate.fail(\"Should not be reachable\");\n", "return false;\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilder.java", "method": ["void generateImpliedEndTags(String excludeTag) {\n", "while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n", "inSorted(currentElement().nodeName(), TagSearchEndTags))\n", "pop();\n", "}\n"], "faulty_lines": [2, 3], "cluster": 0}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilder.java", "method": ["boolean isSpecial(Element el) {\n", "// todo: mathml's mi, mo, mn\n", "// todo: svg's foreigObject, desc, title\n", "String name = el.nodeName();\n", "return inSorted(name, TagSearchSpecial);\n", "}\n"], "faulty_lines": [4], "cluster": 0}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilder.java", "method": ["private boolean isSameFormattingElement(Element a, Element b) {\n", "// same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n", "return a.nodeName().equals(b.nodeName()) &&\n", "// a.namespace().equals(b.namespace()) &&\n", "a.attributes().equals(b.attributes());\n", "// todo: namespaces\n", "}\n"], "faulty_lines": [3], "cluster": 4}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case Character: {\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "// todo confirm that check\n", "tb.error(this);\n", "return false;\n", "} else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "tb.framesetOk(false);\n", "}\n", "break;\n", "}\n", "case Comment: {\n", "tb.insert(t.asComment());\n", "break;\n", "}\n", "case Doctype: {\n", "tb.error(this);\n", "return false;\n", "}\n", "case StartTag:\n", "Token.StartTag startTag = t.asStartTag();\n", "// todo - refactor to a switch statement\n", "String name = startTag.normalName();\n", "if (name.equals(\"a\")) {\n", "if (tb.getActiveFormattingElement(\"a\") != null) {\n", "tb.error(this);\n", "tb.processEndTag(\"a\");\n", "\n", "// still on stack?\n", "Element remainingA = tb.getFromStack(\"a\");\n", "if (remainingA != null) {\n", "tb.removeFromActiveFormattingElements(remainingA);\n", "tb.removeFromStack(remainingA);\n", "}\n", "}\n", "tb.reconstructFormattingElements();\n", "Element a = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(a);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n", "tb.reconstructFormattingElements();\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"span\")) {\n", "// same as final else, but short circuits lots of checks\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (name.equals(\"li\")) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (el.nodeName().equals(\"li\")) {\n", "tb.processEndTag(\"li\");\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"html\")) {\n", "tb.error(this);\n", "// merge attributes onto real html\n", "Element html = tb.getStack().get(0);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!html.hasAttr(attribute.getKey()))\n", "html.attributes().put(attribute);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n", "return tb.process(t, InHead);\n", "} else if (name.equals(\"body\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else {\n", "tb.framesetOk(false);\n", "Element body = stack.get(1);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!body.hasAttr(attribute.getKey()))\n", "body.attributes().put(attribute);\n", "}\n", "}\n", "} else if (name.equals(\"frameset\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else if (!tb.framesetOk()) {\n", "return false; // ignore frameset\n", "} else {\n", "Element second = stack.get(1);\n", "if (second.parent() != null)\n", "second.remove();\n", "// pop up to html element\n", "while (stack.size() > 1)\n", "stack.remove(stack.size()-1);\n", "tb.insert(startTag);\n", "tb.transition(InFrameset);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n", "tb.error(this);\n", "tb.pop();\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.reader.matchConsume(\"\\n\"); // ignore LF if next token\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"form\")) {\n", "if (tb.getFormElement() != null) {\n", "tb.error(this);\n", "return false;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertForm(startTag, true);\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n", "tb.processEndTag(el.nodeName());\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"plaintext\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n", "} else if (name.equals(\"button\")) {\n", "if (tb.inButtonScope(\"button\")) {\n", "// close and reprocess\n", "tb.error(this);\n", "tb.processEndTag(\"button\");\n", "tb.process(startTag);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Formatters)) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (name.equals(\"nobr\")) {\n", "tb.reconstructFormattingElements();\n", "if (tb.inScope(\"nobr\")) {\n", "tb.error(this);\n", "tb.processEndTag(\"nobr\");\n", "tb.reconstructFormattingElements();\n", "}\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.insertMarkerToFormattingElements();\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"table\")) {\n", "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "tb.transition(InTable);\n", "} else if (name.equals(\"input\")) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insertEmpty(startTag);\n", "if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n", "tb.insertEmpty(startTag);\n", "} else if (name.equals(\"hr\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"image\")) {\n", "if (tb.getFromStack(\"svg\") == null)\n", "return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n", "else\n", "tb.insert(startTag);\n", "} else if (name.equals(\"isindex\")) {\n", "// how much do we care about the early 90s?\n", "tb.error(this);\n", "if (tb.getFormElement() != null)\n", "return false;\n", "\n", "tb.processStartTag(\"form\");\n", "if (startTag.attributes.hasKey(\"action\")) {\n", "Element form = tb.getFormElement();\n", "form.attr(\"action\", startTag.attributes.get(\"action\"));\n", "}\n", "tb.processStartTag(\"hr\");\n", "tb.processStartTag(\"label\");\n", "// hope you like english.\n", "String prompt = startTag.attributes.hasKey(\"prompt\") ?\n", "startTag.attributes.get(\"prompt\") :\n", "\"This is a searchable index. Enter search keywords: \";\n", "\n", "tb.process(new Token.Character().data(prompt));\n", "\n", "// input\n", "Attributes inputAttribs = new Attributes();\n", "for (Attribute attr : startTag.attributes) {\n", "if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n", "inputAttribs.put(attr);\n", "}\n", "inputAttribs.put(\"name\", \"isindex\");\n", "tb.processStartTag(\"input\", inputAttribs);\n", "tb.processEndTag(\"label\");\n", "tb.processStartTag(\"hr\");\n", "tb.processEndTag(\"form\");\n", "} else if (name.equals(\"textarea\")) {\n", "tb.insert(startTag);\n", "// todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n", "tb.tokeniser.transition(TokeniserState.Rcdata);\n", "tb.markInsertionMode();\n", "tb.framesetOk(false);\n", "tb.transition(Text);\n", "} else if (name.equals(\"xmp\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.reconstructFormattingElements();\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"iframe\")) {\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"noembed\")) {\n", "// also handle noscript if script enabled\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"select\")) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "\n", "HtmlTreeBuilderState state = tb.state();\n", "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n", "tb.transition(InSelectInTable);\n", "else\n", "tb.transition(InSelect);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n", "if (tb.inScope(\"ruby\")) {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n", "tb.error(this);\n", "tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n", "}\n", "tb.insert(startTag);\n", "}\n", "} else if (name.equals(\"math\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n", "tb.insert(startTag);\n", "} else if (name.equals(\"svg\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "}\n", "break;\n", "\n", "case EndTag:\n", "Token.EndTag endTag = t.asEndTag();\n", "name = endTag.normalName();\n", "if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n", "// Adoption Agency Algorithm.\n", "for (int i = 0; i < 8; i++) {\n", "Element formatEl = tb.getActiveFormattingElement(name);\n", "if (formatEl == null)\n", "return anyOtherEndTag(t, tb);\n", "else if (!tb.onStack(formatEl)) {\n", "tb.error(this);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "} else if (!tb.inScope(formatEl.nodeName())) {\n", "tb.error(this);\n", "return false;\n", "} else if (tb.currentElement() != formatEl)\n", "tb.error(this);\n", "\n", "Element furthestBlock = null;\n", "Element commonAncestor = null;\n", "boolean seenFormattingElement = false;\n", "ArrayList<Element> stack = tb.getStack();\n", "// the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n", "// run-aways\n", "final int stackSize = stack.size();\n", "for (int si = 0; si < stackSize && si < 64; si++) {\n", "Element el = stack.get(si);\n", "if (el == formatEl) {\n", "commonAncestor = stack.get(si - 1);\n", "seenFormattingElement = true;\n", "} else if (seenFormattingElement && tb.isSpecial(el)) {\n", "furthestBlock = el;\n", "break;\n", "}\n", "}\n", "if (furthestBlock == null) {\n", "tb.popStackToClose(formatEl.nodeName());\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "}\n", "\n", "// todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n", "// does that mean: int pos of format el in list?\n", "Element node = furthestBlock;\n", "Element lastNode = furthestBlock;\n", "for (int j = 0; j < 3; j++) {\n", "if (tb.onStack(node))\n", "node = tb.aboveOnStack(node);\n", "if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n", "tb.removeFromStack(node);\n", "continue;\n", "} else if (node == formatEl)\n", "break;\n", "\n", "Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n", "// case will follow the original node (so honours ParseSettings)\n", "tb.replaceActiveFormattingElement(node, replacement);\n", "tb.replaceOnStack(node, replacement);\n", "node = replacement;\n", "\n", "if (lastNode == furthestBlock) {\n", "// todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n", "// not getting how this bookmark both straddles the element above, but is inbetween here...\n", "}\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "node.appendChild(lastNode);\n", "\n", "lastNode = node;\n", "}\n", "\n", "if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "tb.insertInFosterParent(lastNode);\n", "} else {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "commonAncestor.appendChild(lastNode);\n", "}\n", "\n", "Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n", "adopter.attributes().addAll(formatEl.attributes());\n", "Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n", "for (Node childNode : childNodes) {\n", "adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n", "}\n", "furthestBlock.appendChild(adopter);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "// todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n", "tb.removeFromStack(formatEl);\n", "tb.insertOnStackAfter(furthestBlock, adopter);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n", "if (!tb.inScope(name)) {\n", "// nothing to close\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"span\")) {\n", "// same as final fall through, but saves short circuit\n", "return anyOtherEndTag(t, tb);\n", "} else if (name.equals(\"li\")) {\n", "if (!tb.inListItemScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"body\")) {\n", "if (!tb.inScope(\"body\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "// todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n", "tb.transition(AfterBody);\n", "}\n", "} else if (name.equals(\"html\")) {\n", "boolean notIgnored = tb.processEndTag(\"body\");\n", "if (notIgnored)\n", "return tb.process(endTag);\n", "} else if (name.equals(\"form\")) {\n", "Element currentForm = tb.getFormElement();\n", "tb.setFormElement(null);\n", "if (currentForm == null || !tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "// remove currentForm from stack. will shift anything under up.\n", "tb.removeFromStack(currentForm);\n", "}\n", "} else if (name.equals(\"p\")) {\n", "if (!tb.inButtonScope(name)) {\n", "tb.error(this);\n", "tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n", "return tb.process(endTag);\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (!tb.inScope(Constants.Headings)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(Constants.Headings);\n", "}\n", "} else if (name.equals(\"sarcasm\")) {\n", "// *sigh*\n", "return anyOtherEndTag(t, tb);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "if (!tb.inScope(\"name\")) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "tb.clearFormattingElementsToLastMarker();\n", "}\n", "} else if (name.equals(\"br\")) {\n", "tb.error(this);\n", "tb.processStartTag(\"br\");\n", "return false;\n", "} else {\n", "return anyOtherEndTag(t, tb);\n", "}\n", "\n", "break;\n", "case EOF:\n", "// todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n", "// stop parsing\n", "break;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [64, 68], "cluster": 6}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case Character: {\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "// todo confirm that check\n", "tb.error(this);\n", "return false;\n", "} else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "tb.framesetOk(false);\n", "}\n", "break;\n", "}\n", "case Comment: {\n", "tb.insert(t.asComment());\n", "break;\n", "}\n", "case Doctype: {\n", "tb.error(this);\n", "return false;\n", "}\n", "case StartTag:\n", "Token.StartTag startTag = t.asStartTag();\n", "// todo - refactor to a switch statement\n", "String name = startTag.normalName();\n", "if (name.equals(\"a\")) {\n", "if (tb.getActiveFormattingElement(\"a\") != null) {\n", "tb.error(this);\n", "tb.processEndTag(\"a\");\n", "\n", "// still on stack?\n", "Element remainingA = tb.getFromStack(\"a\");\n", "if (remainingA != null) {\n", "tb.removeFromActiveFormattingElements(remainingA);\n", "tb.removeFromStack(remainingA);\n", "}\n", "}\n", "tb.reconstructFormattingElements();\n", "Element a = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(a);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n", "tb.reconstructFormattingElements();\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"span\")) {\n", "// same as final else, but short circuits lots of checks\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (name.equals(\"li\")) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (el.nodeName().equals(\"li\")) {\n", "tb.processEndTag(\"li\");\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"html\")) {\n", "tb.error(this);\n", "// merge attributes onto real html\n", "Element html = tb.getStack().get(0);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!html.hasAttr(attribute.getKey()))\n", "html.attributes().put(attribute);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n", "return tb.process(t, InHead);\n", "} else if (name.equals(\"body\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else {\n", "tb.framesetOk(false);\n", "Element body = stack.get(1);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!body.hasAttr(attribute.getKey()))\n", "body.attributes().put(attribute);\n", "}\n", "}\n", "} else if (name.equals(\"frameset\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else if (!tb.framesetOk()) {\n", "return false; // ignore frameset\n", "} else {\n", "Element second = stack.get(1);\n", "if (second.parent() != null)\n", "second.remove();\n", "// pop up to html element\n", "while (stack.size() > 1)\n", "stack.remove(stack.size()-1);\n", "tb.insert(startTag);\n", "tb.transition(InFrameset);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n", "tb.error(this);\n", "tb.pop();\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.reader.matchConsume(\"\\n\"); // ignore LF if next token\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"form\")) {\n", "if (tb.getFormElement() != null) {\n", "tb.error(this);\n", "return false;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertForm(startTag, true);\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n", "tb.processEndTag(el.nodeName());\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"plaintext\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n", "} else if (name.equals(\"button\")) {\n", "if (tb.inButtonScope(\"button\")) {\n", "// close and reprocess\n", "tb.error(this);\n", "tb.processEndTag(\"button\");\n", "tb.process(startTag);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Formatters)) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (name.equals(\"nobr\")) {\n", "tb.reconstructFormattingElements();\n", "if (tb.inScope(\"nobr\")) {\n", "tb.error(this);\n", "tb.processEndTag(\"nobr\");\n", "tb.reconstructFormattingElements();\n", "}\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.insertMarkerToFormattingElements();\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"table\")) {\n", "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "tb.transition(InTable);\n", "} else if (name.equals(\"input\")) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insertEmpty(startTag);\n", "if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n", "tb.insertEmpty(startTag);\n", "} else if (name.equals(\"hr\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"image\")) {\n", "if (tb.getFromStack(\"svg\") == null)\n", "return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n", "else\n", "tb.insert(startTag);\n", "} else if (name.equals(\"isindex\")) {\n", "// how much do we care about the early 90s?\n", "tb.error(this);\n", "if (tb.getFormElement() != null)\n", "return false;\n", "\n", "tb.processStartTag(\"form\");\n", "if (startTag.attributes.hasKey(\"action\")) {\n", "Element form = tb.getFormElement();\n", "form.attr(\"action\", startTag.attributes.get(\"action\"));\n", "}\n", "tb.processStartTag(\"hr\");\n", "tb.processStartTag(\"label\");\n", "// hope you like english.\n", "String prompt = startTag.attributes.hasKey(\"prompt\") ?\n", "startTag.attributes.get(\"prompt\") :\n", "\"This is a searchable index. Enter search keywords: \";\n", "\n", "tb.process(new Token.Character().data(prompt));\n", "\n", "// input\n", "Attributes inputAttribs = new Attributes();\n", "for (Attribute attr : startTag.attributes) {\n", "if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n", "inputAttribs.put(attr);\n", "}\n", "inputAttribs.put(\"name\", \"isindex\");\n", "tb.processStartTag(\"input\", inputAttribs);\n", "tb.processEndTag(\"label\");\n", "tb.processStartTag(\"hr\");\n", "tb.processEndTag(\"form\");\n", "} else if (name.equals(\"textarea\")) {\n", "tb.insert(startTag);\n", "// todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n", "tb.tokeniser.transition(TokeniserState.Rcdata);\n", "tb.markInsertionMode();\n", "tb.framesetOk(false);\n", "tb.transition(Text);\n", "} else if (name.equals(\"xmp\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.reconstructFormattingElements();\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"iframe\")) {\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"noembed\")) {\n", "// also handle noscript if script enabled\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"select\")) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "\n", "HtmlTreeBuilderState state = tb.state();\n", "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n", "tb.transition(InSelectInTable);\n", "else\n", "tb.transition(InSelect);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n", "if (tb.inScope(\"ruby\")) {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n", "tb.error(this);\n", "tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n", "}\n", "tb.insert(startTag);\n", "}\n", "} else if (name.equals(\"math\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n", "tb.insert(startTag);\n", "} else if (name.equals(\"svg\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "}\n", "break;\n", "\n", "case EndTag:\n", "Token.EndTag endTag = t.asEndTag();\n", "name = endTag.normalName();\n", "if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n", "// Adoption Agency Algorithm.\n", "for (int i = 0; i < 8; i++) {\n", "Element formatEl = tb.getActiveFormattingElement(name);\n", "if (formatEl == null)\n", "return anyOtherEndTag(t, tb);\n", "else if (!tb.onStack(formatEl)) {\n", "tb.error(this);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "} else if (!tb.inScope(formatEl.nodeName())) {\n", "tb.error(this);\n", "return false;\n", "} else if (tb.currentElement() != formatEl)\n", "tb.error(this);\n", "\n", "Element furthestBlock = null;\n", "Element commonAncestor = null;\n", "boolean seenFormattingElement = false;\n", "ArrayList<Element> stack = tb.getStack();\n", "// the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n", "// run-aways\n", "final int stackSize = stack.size();\n", "for (int si = 0; si < stackSize && si < 64; si++) {\n", "Element el = stack.get(si);\n", "if (el == formatEl) {\n", "commonAncestor = stack.get(si - 1);\n", "seenFormattingElement = true;\n", "} else if (seenFormattingElement && tb.isSpecial(el)) {\n", "furthestBlock = el;\n", "break;\n", "}\n", "}\n", "if (furthestBlock == null) {\n", "tb.popStackToClose(formatEl.nodeName());\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "}\n", "\n", "// todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n", "// does that mean: int pos of format el in list?\n", "Element node = furthestBlock;\n", "Element lastNode = furthestBlock;\n", "for (int j = 0; j < 3; j++) {\n", "if (tb.onStack(node))\n", "node = tb.aboveOnStack(node);\n", "if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n", "tb.removeFromStack(node);\n", "continue;\n", "} else if (node == formatEl)\n", "break;\n", "\n", "Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n", "// case will follow the original node (so honours ParseSettings)\n", "tb.replaceActiveFormattingElement(node, replacement);\n", "tb.replaceOnStack(node, replacement);\n", "node = replacement;\n", "\n", "if (lastNode == furthestBlock) {\n", "// todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n", "// not getting how this bookmark both straddles the element above, but is inbetween here...\n", "}\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "node.appendChild(lastNode);\n", "\n", "lastNode = node;\n", "}\n", "\n", "if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "tb.insertInFosterParent(lastNode);\n", "} else {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "commonAncestor.appendChild(lastNode);\n", "}\n", "\n", "Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n", "adopter.attributes().addAll(formatEl.attributes());\n", "Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n", "for (Node childNode : childNodes) {\n", "adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n", "}\n", "furthestBlock.appendChild(adopter);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "// todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n", "tb.removeFromStack(formatEl);\n", "tb.insertOnStackAfter(furthestBlock, adopter);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n", "if (!tb.inScope(name)) {\n", "// nothing to close\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"span\")) {\n", "// same as final fall through, but saves short circuit\n", "return anyOtherEndTag(t, tb);\n", "} else if (name.equals(\"li\")) {\n", "if (!tb.inListItemScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"body\")) {\n", "if (!tb.inScope(\"body\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "// todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n", "tb.transition(AfterBody);\n", "}\n", "} else if (name.equals(\"html\")) {\n", "boolean notIgnored = tb.processEndTag(\"body\");\n", "if (notIgnored)\n", "return tb.process(endTag);\n", "} else if (name.equals(\"form\")) {\n", "Element currentForm = tb.getFormElement();\n", "tb.setFormElement(null);\n", "if (currentForm == null || !tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "// remove currentForm from stack. will shift anything under up.\n", "tb.removeFromStack(currentForm);\n", "}\n", "} else if (name.equals(\"p\")) {\n", "if (!tb.inButtonScope(name)) {\n", "tb.error(this);\n", "tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n", "return tb.process(endTag);\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (!tb.inScope(Constants.Headings)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(Constants.Headings);\n", "}\n", "} else if (name.equals(\"sarcasm\")) {\n", "// *sigh*\n", "return anyOtherEndTag(t, tb);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "if (!tb.inScope(\"name\")) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "tb.clearFormattingElementsToLastMarker();\n", "}\n", "} else if (name.equals(\"br\")) {\n", "tb.error(this);\n", "tb.processStartTag(\"br\");\n", "return false;\n", "} else {\n", "return anyOtherEndTag(t, tb);\n", "}\n", "\n", "break;\n", "case EOF:\n", "// todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n", "// stop parsing\n", "break;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [88], "cluster": 6}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case Character: {\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "// todo confirm that check\n", "tb.error(this);\n", "return false;\n", "} else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "tb.framesetOk(false);\n", "}\n", "break;\n", "}\n", "case Comment: {\n", "tb.insert(t.asComment());\n", "break;\n", "}\n", "case Doctype: {\n", "tb.error(this);\n", "return false;\n", "}\n", "case StartTag:\n", "Token.StartTag startTag = t.asStartTag();\n", "// todo - refactor to a switch statement\n", "String name = startTag.normalName();\n", "if (name.equals(\"a\")) {\n", "if (tb.getActiveFormattingElement(\"a\") != null) {\n", "tb.error(this);\n", "tb.processEndTag(\"a\");\n", "\n", "// still on stack?\n", "Element remainingA = tb.getFromStack(\"a\");\n", "if (remainingA != null) {\n", "tb.removeFromActiveFormattingElements(remainingA);\n", "tb.removeFromStack(remainingA);\n", "}\n", "}\n", "tb.reconstructFormattingElements();\n", "Element a = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(a);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n", "tb.reconstructFormattingElements();\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"span\")) {\n", "// same as final else, but short circuits lots of checks\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (name.equals(\"li\")) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (el.nodeName().equals(\"li\")) {\n", "tb.processEndTag(\"li\");\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"html\")) {\n", "tb.error(this);\n", "// merge attributes onto real html\n", "Element html = tb.getStack().get(0);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!html.hasAttr(attribute.getKey()))\n", "html.attributes().put(attribute);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n", "return tb.process(t, InHead);\n", "} else if (name.equals(\"body\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else {\n", "tb.framesetOk(false);\n", "Element body = stack.get(1);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!body.hasAttr(attribute.getKey()))\n", "body.attributes().put(attribute);\n", "}\n", "}\n", "} else if (name.equals(\"frameset\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else if (!tb.framesetOk()) {\n", "return false; // ignore frameset\n", "} else {\n", "Element second = stack.get(1);\n", "if (second.parent() != null)\n", "second.remove();\n", "// pop up to html element\n", "while (stack.size() > 1)\n", "stack.remove(stack.size()-1);\n", "tb.insert(startTag);\n", "tb.transition(InFrameset);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n", "tb.error(this);\n", "tb.pop();\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.reader.matchConsume(\"\\n\"); // ignore LF if next token\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"form\")) {\n", "if (tb.getFormElement() != null) {\n", "tb.error(this);\n", "return false;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertForm(startTag, true);\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n", "tb.processEndTag(el.nodeName());\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"plaintext\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n", "} else if (name.equals(\"button\")) {\n", "if (tb.inButtonScope(\"button\")) {\n", "// close and reprocess\n", "tb.error(this);\n", "tb.processEndTag(\"button\");\n", "tb.process(startTag);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Formatters)) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (name.equals(\"nobr\")) {\n", "tb.reconstructFormattingElements();\n", "if (tb.inScope(\"nobr\")) {\n", "tb.error(this);\n", "tb.processEndTag(\"nobr\");\n", "tb.reconstructFormattingElements();\n", "}\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.insertMarkerToFormattingElements();\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"table\")) {\n", "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "tb.transition(InTable);\n", "} else if (name.equals(\"input\")) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insertEmpty(startTag);\n", "if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n", "tb.insertEmpty(startTag);\n", "} else if (name.equals(\"hr\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"image\")) {\n", "if (tb.getFromStack(\"svg\") == null)\n", "return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n", "else\n", "tb.insert(startTag);\n", "} else if (name.equals(\"isindex\")) {\n", "// how much do we care about the early 90s?\n", "tb.error(this);\n", "if (tb.getFormElement() != null)\n", "return false;\n", "\n", "tb.processStartTag(\"form\");\n", "if (startTag.attributes.hasKey(\"action\")) {\n", "Element form = tb.getFormElement();\n", "form.attr(\"action\", startTag.attributes.get(\"action\"));\n", "}\n", "tb.processStartTag(\"hr\");\n", "tb.processStartTag(\"label\");\n", "// hope you like english.\n", "String prompt = startTag.attributes.hasKey(\"prompt\") ?\n", "startTag.attributes.get(\"prompt\") :\n", "\"This is a searchable index. Enter search keywords: \";\n", "\n", "tb.process(new Token.Character().data(prompt));\n", "\n", "// input\n", "Attributes inputAttribs = new Attributes();\n", "for (Attribute attr : startTag.attributes) {\n", "if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n", "inputAttribs.put(attr);\n", "}\n", "inputAttribs.put(\"name\", \"isindex\");\n", "tb.processStartTag(\"input\", inputAttribs);\n", "tb.processEndTag(\"label\");\n", "tb.processStartTag(\"hr\");\n", "tb.processEndTag(\"form\");\n", "} else if (name.equals(\"textarea\")) {\n", "tb.insert(startTag);\n", "// todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n", "tb.tokeniser.transition(TokeniserState.Rcdata);\n", "tb.markInsertionMode();\n", "tb.framesetOk(false);\n", "tb.transition(Text);\n", "} else if (name.equals(\"xmp\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.reconstructFormattingElements();\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"iframe\")) {\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"noembed\")) {\n", "// also handle noscript if script enabled\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"select\")) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "\n", "HtmlTreeBuilderState state = tb.state();\n", "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n", "tb.transition(InSelectInTable);\n", "else\n", "tb.transition(InSelect);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n", "if (tb.inScope(\"ruby\")) {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n", "tb.error(this);\n", "tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n", "}\n", "tb.insert(startTag);\n", "}\n", "} else if (name.equals(\"math\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n", "tb.insert(startTag);\n", "} else if (name.equals(\"svg\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "}\n", "break;\n", "\n", "case EndTag:\n", "Token.EndTag endTag = t.asEndTag();\n", "name = endTag.normalName();\n", "if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n", "// Adoption Agency Algorithm.\n", "for (int i = 0; i < 8; i++) {\n", "Element formatEl = tb.getActiveFormattingElement(name);\n", "if (formatEl == null)\n", "return anyOtherEndTag(t, tb);\n", "else if (!tb.onStack(formatEl)) {\n", "tb.error(this);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "} else if (!tb.inScope(formatEl.nodeName())) {\n", "tb.error(this);\n", "return false;\n", "} else if (tb.currentElement() != formatEl)\n", "tb.error(this);\n", "\n", "Element furthestBlock = null;\n", "Element commonAncestor = null;\n", "boolean seenFormattingElement = false;\n", "ArrayList<Element> stack = tb.getStack();\n", "// the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n", "// run-aways\n", "final int stackSize = stack.size();\n", "for (int si = 0; si < stackSize && si < 64; si++) {\n", "Element el = stack.get(si);\n", "if (el == formatEl) {\n", "commonAncestor = stack.get(si - 1);\n", "seenFormattingElement = true;\n", "} else if (seenFormattingElement && tb.isSpecial(el)) {\n", "furthestBlock = el;\n", "break;\n", "}\n", "}\n", "if (furthestBlock == null) {\n", "tb.popStackToClose(formatEl.nodeName());\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "}\n", "\n", "// todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n", "// does that mean: int pos of format el in list?\n", "Element node = furthestBlock;\n", "Element lastNode = furthestBlock;\n", "for (int j = 0; j < 3; j++) {\n", "if (tb.onStack(node))\n", "node = tb.aboveOnStack(node);\n", "if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n", "tb.removeFromStack(node);\n", "continue;\n", "} else if (node == formatEl)\n", "break;\n", "\n", "Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n", "// case will follow the original node (so honours ParseSettings)\n", "tb.replaceActiveFormattingElement(node, replacement);\n", "tb.replaceOnStack(node, replacement);\n", "node = replacement;\n", "\n", "if (lastNode == furthestBlock) {\n", "// todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n", "// not getting how this bookmark both straddles the element above, but is inbetween here...\n", "}\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "node.appendChild(lastNode);\n", "\n", "lastNode = node;\n", "}\n", "\n", "if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "tb.insertInFosterParent(lastNode);\n", "} else {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "commonAncestor.appendChild(lastNode);\n", "}\n", "\n", "Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n", "adopter.attributes().addAll(formatEl.attributes());\n", "Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n", "for (Node childNode : childNodes) {\n", "adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n", "}\n", "furthestBlock.appendChild(adopter);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "// todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n", "tb.removeFromStack(formatEl);\n", "tb.insertOnStackAfter(furthestBlock, adopter);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n", "if (!tb.inScope(name)) {\n", "// nothing to close\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"span\")) {\n", "// same as final fall through, but saves short circuit\n", "return anyOtherEndTag(t, tb);\n", "} else if (name.equals(\"li\")) {\n", "if (!tb.inListItemScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"body\")) {\n", "if (!tb.inScope(\"body\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "// todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n", "tb.transition(AfterBody);\n", "}\n", "} else if (name.equals(\"html\")) {\n", "boolean notIgnored = tb.processEndTag(\"body\");\n", "if (notIgnored)\n", "return tb.process(endTag);\n", "} else if (name.equals(\"form\")) {\n", "Element currentForm = tb.getFormElement();\n", "tb.setFormElement(null);\n", "if (currentForm == null || !tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "// remove currentForm from stack. will shift anything under up.\n", "tb.removeFromStack(currentForm);\n", "}\n", "} else if (name.equals(\"p\")) {\n", "if (!tb.inButtonScope(name)) {\n", "tb.error(this);\n", "tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n", "return tb.process(endTag);\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (!tb.inScope(Constants.Headings)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(Constants.Headings);\n", "}\n", "} else if (name.equals(\"sarcasm\")) {\n", "// *sigh*\n", "return anyOtherEndTag(t, tb);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "if (!tb.inScope(\"name\")) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "tb.clearFormattingElementsToLastMarker();\n", "}\n", "} else if (name.equals(\"br\")) {\n", "tb.error(this);\n", "tb.processStartTag(\"br\");\n", "return false;\n", "} else {\n", "return anyOtherEndTag(t, tb);\n", "}\n", "\n", "break;\n", "case EOF:\n", "// todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n", "// stop parsing\n", "break;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [102], "cluster": 6}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case Character: {\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "// todo confirm that check\n", "tb.error(this);\n", "return false;\n", "} else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "tb.framesetOk(false);\n", "}\n", "break;\n", "}\n", "case Comment: {\n", "tb.insert(t.asComment());\n", "break;\n", "}\n", "case Doctype: {\n", "tb.error(this);\n", "return false;\n", "}\n", "case StartTag:\n", "Token.StartTag startTag = t.asStartTag();\n", "// todo - refactor to a switch statement\n", "String name = startTag.normalName();\n", "if (name.equals(\"a\")) {\n", "if (tb.getActiveFormattingElement(\"a\") != null) {\n", "tb.error(this);\n", "tb.processEndTag(\"a\");\n", "\n", "// still on stack?\n", "Element remainingA = tb.getFromStack(\"a\");\n", "if (remainingA != null) {\n", "tb.removeFromActiveFormattingElements(remainingA);\n", "tb.removeFromStack(remainingA);\n", "}\n", "}\n", "tb.reconstructFormattingElements();\n", "Element a = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(a);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n", "tb.reconstructFormattingElements();\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"span\")) {\n", "// same as final else, but short circuits lots of checks\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (name.equals(\"li\")) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (el.nodeName().equals(\"li\")) {\n", "tb.processEndTag(\"li\");\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"html\")) {\n", "tb.error(this);\n", "// merge attributes onto real html\n", "Element html = tb.getStack().get(0);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!html.hasAttr(attribute.getKey()))\n", "html.attributes().put(attribute);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n", "return tb.process(t, InHead);\n", "} else if (name.equals(\"body\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else {\n", "tb.framesetOk(false);\n", "Element body = stack.get(1);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!body.hasAttr(attribute.getKey()))\n", "body.attributes().put(attribute);\n", "}\n", "}\n", "} else if (name.equals(\"frameset\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else if (!tb.framesetOk()) {\n", "return false; // ignore frameset\n", "} else {\n", "Element second = stack.get(1);\n", "if (second.parent() != null)\n", "second.remove();\n", "// pop up to html element\n", "while (stack.size() > 1)\n", "stack.remove(stack.size()-1);\n", "tb.insert(startTag);\n", "tb.transition(InFrameset);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n", "tb.error(this);\n", "tb.pop();\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.reader.matchConsume(\"\\n\"); // ignore LF if next token\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"form\")) {\n", "if (tb.getFormElement() != null) {\n", "tb.error(this);\n", "return false;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertForm(startTag, true);\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n", "tb.processEndTag(el.nodeName());\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"plaintext\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n", "} else if (name.equals(\"button\")) {\n", "if (tb.inButtonScope(\"button\")) {\n", "// close and reprocess\n", "tb.error(this);\n", "tb.processEndTag(\"button\");\n", "tb.process(startTag);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Formatters)) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (name.equals(\"nobr\")) {\n", "tb.reconstructFormattingElements();\n", "if (tb.inScope(\"nobr\")) {\n", "tb.error(this);\n", "tb.processEndTag(\"nobr\");\n", "tb.reconstructFormattingElements();\n", "}\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.insertMarkerToFormattingElements();\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"table\")) {\n", "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "tb.transition(InTable);\n", "} else if (name.equals(\"input\")) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insertEmpty(startTag);\n", "if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n", "tb.insertEmpty(startTag);\n", "} else if (name.equals(\"hr\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"image\")) {\n", "if (tb.getFromStack(\"svg\") == null)\n", "return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n", "else\n", "tb.insert(startTag);\n", "} else if (name.equals(\"isindex\")) {\n", "// how much do we care about the early 90s?\n", "tb.error(this);\n", "if (tb.getFormElement() != null)\n", "return false;\n", "\n", "tb.processStartTag(\"form\");\n", "if (startTag.attributes.hasKey(\"action\")) {\n", "Element form = tb.getFormElement();\n", "form.attr(\"action\", startTag.attributes.get(\"action\"));\n", "}\n", "tb.processStartTag(\"hr\");\n", "tb.processStartTag(\"label\");\n", "// hope you like english.\n", "String prompt = startTag.attributes.hasKey(\"prompt\") ?\n", "startTag.attributes.get(\"prompt\") :\n", "\"This is a searchable index. Enter search keywords: \";\n", "\n", "tb.process(new Token.Character().data(prompt));\n", "\n", "// input\n", "Attributes inputAttribs = new Attributes();\n", "for (Attribute attr : startTag.attributes) {\n", "if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n", "inputAttribs.put(attr);\n", "}\n", "inputAttribs.put(\"name\", \"isindex\");\n", "tb.processStartTag(\"input\", inputAttribs);\n", "tb.processEndTag(\"label\");\n", "tb.processStartTag(\"hr\");\n", "tb.processEndTag(\"form\");\n", "} else if (name.equals(\"textarea\")) {\n", "tb.insert(startTag);\n", "// todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n", "tb.tokeniser.transition(TokeniserState.Rcdata);\n", "tb.markInsertionMode();\n", "tb.framesetOk(false);\n", "tb.transition(Text);\n", "} else if (name.equals(\"xmp\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.reconstructFormattingElements();\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"iframe\")) {\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"noembed\")) {\n", "// also handle noscript if script enabled\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"select\")) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "\n", "HtmlTreeBuilderState state = tb.state();\n", "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n", "tb.transition(InSelectInTable);\n", "else\n", "tb.transition(InSelect);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n", "if (tb.inScope(\"ruby\")) {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n", "tb.error(this);\n", "tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n", "}\n", "tb.insert(startTag);\n", "}\n", "} else if (name.equals(\"math\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n", "tb.insert(startTag);\n", "} else if (name.equals(\"svg\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "}\n", "break;\n", "\n", "case EndTag:\n", "Token.EndTag endTag = t.asEndTag();\n", "name = endTag.normalName();\n", "if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n", "// Adoption Agency Algorithm.\n", "for (int i = 0; i < 8; i++) {\n", "Element formatEl = tb.getActiveFormattingElement(name);\n", "if (formatEl == null)\n", "return anyOtherEndTag(t, tb);\n", "else if (!tb.onStack(formatEl)) {\n", "tb.error(this);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "} else if (!tb.inScope(formatEl.nodeName())) {\n", "tb.error(this);\n", "return false;\n", "} else if (tb.currentElement() != formatEl)\n", "tb.error(this);\n", "\n", "Element furthestBlock = null;\n", "Element commonAncestor = null;\n", "boolean seenFormattingElement = false;\n", "ArrayList<Element> stack = tb.getStack();\n", "// the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n", "// run-aways\n", "final int stackSize = stack.size();\n", "for (int si = 0; si < stackSize && si < 64; si++) {\n", "Element el = stack.get(si);\n", "if (el == formatEl) {\n", "commonAncestor = stack.get(si - 1);\n", "seenFormattingElement = true;\n", "} else if (seenFormattingElement && tb.isSpecial(el)) {\n", "furthestBlock = el;\n", "break;\n", "}\n", "}\n", "if (furthestBlock == null) {\n", "tb.popStackToClose(formatEl.nodeName());\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "}\n", "\n", "// todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n", "// does that mean: int pos of format el in list?\n", "Element node = furthestBlock;\n", "Element lastNode = furthestBlock;\n", "for (int j = 0; j < 3; j++) {\n", "if (tb.onStack(node))\n", "node = tb.aboveOnStack(node);\n", "if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n", "tb.removeFromStack(node);\n", "continue;\n", "} else if (node == formatEl)\n", "break;\n", "\n", "Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n", "// case will follow the original node (so honours ParseSettings)\n", "tb.replaceActiveFormattingElement(node, replacement);\n", "tb.replaceOnStack(node, replacement);\n", "node = replacement;\n", "\n", "if (lastNode == furthestBlock) {\n", "// todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n", "// not getting how this bookmark both straddles the element above, but is inbetween here...\n", "}\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "node.appendChild(lastNode);\n", "\n", "lastNode = node;\n", "}\n", "\n", "if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "tb.insertInFosterParent(lastNode);\n", "} else {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "commonAncestor.appendChild(lastNode);\n", "}\n", "\n", "Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n", "adopter.attributes().addAll(formatEl.attributes());\n", "Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n", "for (Node childNode : childNodes) {\n", "adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n", "}\n", "furthestBlock.appendChild(adopter);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "// todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n", "tb.removeFromStack(formatEl);\n", "tb.insertOnStackAfter(furthestBlock, adopter);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n", "if (!tb.inScope(name)) {\n", "// nothing to close\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"span\")) {\n", "// same as final fall through, but saves short circuit\n", "return anyOtherEndTag(t, tb);\n", "} else if (name.equals(\"li\")) {\n", "if (!tb.inListItemScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"body\")) {\n", "if (!tb.inScope(\"body\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "// todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n", "tb.transition(AfterBody);\n", "}\n", "} else if (name.equals(\"html\")) {\n", "boolean notIgnored = tb.processEndTag(\"body\");\n", "if (notIgnored)\n", "return tb.process(endTag);\n", "} else if (name.equals(\"form\")) {\n", "Element currentForm = tb.getFormElement();\n", "tb.setFormElement(null);\n", "if (currentForm == null || !tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "// remove currentForm from stack. will shift anything under up.\n", "tb.removeFromStack(currentForm);\n", "}\n", "} else if (name.equals(\"p\")) {\n", "if (!tb.inButtonScope(name)) {\n", "tb.error(this);\n", "tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n", "return tb.process(endTag);\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (!tb.inScope(Constants.Headings)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(Constants.Headings);\n", "}\n", "} else if (name.equals(\"sarcasm\")) {\n", "// *sigh*\n", "return anyOtherEndTag(t, tb);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "if (!tb.inScope(\"name\")) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "tb.clearFormattingElementsToLastMarker();\n", "}\n", "} else if (name.equals(\"br\")) {\n", "tb.error(this);\n", "tb.processStartTag(\"br\");\n", "return false;\n", "} else {\n", "return anyOtherEndTag(t, tb);\n", "}\n", "\n", "break;\n", "case EOF:\n", "// todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n", "// stop parsing\n", "break;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [121], "cluster": 6}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case Character: {\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "// todo confirm that check\n", "tb.error(this);\n", "return false;\n", "} else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "tb.framesetOk(false);\n", "}\n", "break;\n", "}\n", "case Comment: {\n", "tb.insert(t.asComment());\n", "break;\n", "}\n", "case Doctype: {\n", "tb.error(this);\n", "return false;\n", "}\n", "case StartTag:\n", "Token.StartTag startTag = t.asStartTag();\n", "// todo - refactor to a switch statement\n", "String name = startTag.normalName();\n", "if (name.equals(\"a\")) {\n", "if (tb.getActiveFormattingElement(\"a\") != null) {\n", "tb.error(this);\n", "tb.processEndTag(\"a\");\n", "\n", "// still on stack?\n", "Element remainingA = tb.getFromStack(\"a\");\n", "if (remainingA != null) {\n", "tb.removeFromActiveFormattingElements(remainingA);\n", "tb.removeFromStack(remainingA);\n", "}\n", "}\n", "tb.reconstructFormattingElements();\n", "Element a = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(a);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n", "tb.reconstructFormattingElements();\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"span\")) {\n", "// same as final else, but short circuits lots of checks\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (name.equals(\"li\")) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (el.nodeName().equals(\"li\")) {\n", "tb.processEndTag(\"li\");\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"html\")) {\n", "tb.error(this);\n", "// merge attributes onto real html\n", "Element html = tb.getStack().get(0);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!html.hasAttr(attribute.getKey()))\n", "html.attributes().put(attribute);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n", "return tb.process(t, InHead);\n", "} else if (name.equals(\"body\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else {\n", "tb.framesetOk(false);\n", "Element body = stack.get(1);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!body.hasAttr(attribute.getKey()))\n", "body.attributes().put(attribute);\n", "}\n", "}\n", "} else if (name.equals(\"frameset\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else if (!tb.framesetOk()) {\n", "return false; // ignore frameset\n", "} else {\n", "Element second = stack.get(1);\n", "if (second.parent() != null)\n", "second.remove();\n", "// pop up to html element\n", "while (stack.size() > 1)\n", "stack.remove(stack.size()-1);\n", "tb.insert(startTag);\n", "tb.transition(InFrameset);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n", "tb.error(this);\n", "tb.pop();\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.reader.matchConsume(\"\\n\"); // ignore LF if next token\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"form\")) {\n", "if (tb.getFormElement() != null) {\n", "tb.error(this);\n", "return false;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertForm(startTag, true);\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n", "tb.processEndTag(el.nodeName());\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"plaintext\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n", "} else if (name.equals(\"button\")) {\n", "if (tb.inButtonScope(\"button\")) {\n", "// close and reprocess\n", "tb.error(this);\n", "tb.processEndTag(\"button\");\n", "tb.process(startTag);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Formatters)) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (name.equals(\"nobr\")) {\n", "tb.reconstructFormattingElements();\n", "if (tb.inScope(\"nobr\")) {\n", "tb.error(this);\n", "tb.processEndTag(\"nobr\");\n", "tb.reconstructFormattingElements();\n", "}\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.insertMarkerToFormattingElements();\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"table\")) {\n", "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "tb.transition(InTable);\n", "} else if (name.equals(\"input\")) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insertEmpty(startTag);\n", "if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n", "tb.insertEmpty(startTag);\n", "} else if (name.equals(\"hr\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"image\")) {\n", "if (tb.getFromStack(\"svg\") == null)\n", "return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n", "else\n", "tb.insert(startTag);\n", "} else if (name.equals(\"isindex\")) {\n", "// how much do we care about the early 90s?\n", "tb.error(this);\n", "if (tb.getFormElement() != null)\n", "return false;\n", "\n", "tb.processStartTag(\"form\");\n", "if (startTag.attributes.hasKey(\"action\")) {\n", "Element form = tb.getFormElement();\n", "form.attr(\"action\", startTag.attributes.get(\"action\"));\n", "}\n", "tb.processStartTag(\"hr\");\n", "tb.processStartTag(\"label\");\n", "// hope you like english.\n", "String prompt = startTag.attributes.hasKey(\"prompt\") ?\n", "startTag.attributes.get(\"prompt\") :\n", "\"This is a searchable index. Enter search keywords: \";\n", "\n", "tb.process(new Token.Character().data(prompt));\n", "\n", "// input\n", "Attributes inputAttribs = new Attributes();\n", "for (Attribute attr : startTag.attributes) {\n", "if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n", "inputAttribs.put(attr);\n", "}\n", "inputAttribs.put(\"name\", \"isindex\");\n", "tb.processStartTag(\"input\", inputAttribs);\n", "tb.processEndTag(\"label\");\n", "tb.processStartTag(\"hr\");\n", "tb.processEndTag(\"form\");\n", "} else if (name.equals(\"textarea\")) {\n", "tb.insert(startTag);\n", "// todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n", "tb.tokeniser.transition(TokeniserState.Rcdata);\n", "tb.markInsertionMode();\n", "tb.framesetOk(false);\n", "tb.transition(Text);\n", "} else if (name.equals(\"xmp\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.reconstructFormattingElements();\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"iframe\")) {\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"noembed\")) {\n", "// also handle noscript if script enabled\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"select\")) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "\n", "HtmlTreeBuilderState state = tb.state();\n", "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n", "tb.transition(InSelectInTable);\n", "else\n", "tb.transition(InSelect);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n", "if (tb.inScope(\"ruby\")) {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n", "tb.error(this);\n", "tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n", "}\n", "tb.insert(startTag);\n", "}\n", "} else if (name.equals(\"math\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n", "tb.insert(startTag);\n", "} else if (name.equals(\"svg\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "}\n", "break;\n", "\n", "case EndTag:\n", "Token.EndTag endTag = t.asEndTag();\n", "name = endTag.normalName();\n", "if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n", "// Adoption Agency Algorithm.\n", "for (int i = 0; i < 8; i++) {\n", "Element formatEl = tb.getActiveFormattingElement(name);\n", "if (formatEl == null)\n", "return anyOtherEndTag(t, tb);\n", "else if (!tb.onStack(formatEl)) {\n", "tb.error(this);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "} else if (!tb.inScope(formatEl.nodeName())) {\n", "tb.error(this);\n", "return false;\n", "} else if (tb.currentElement() != formatEl)\n", "tb.error(this);\n", "\n", "Element furthestBlock = null;\n", "Element commonAncestor = null;\n", "boolean seenFormattingElement = false;\n", "ArrayList<Element> stack = tb.getStack();\n", "// the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n", "// run-aways\n", "final int stackSize = stack.size();\n", "for (int si = 0; si < stackSize && si < 64; si++) {\n", "Element el = stack.get(si);\n", "if (el == formatEl) {\n", "commonAncestor = stack.get(si - 1);\n", "seenFormattingElement = true;\n", "} else if (seenFormattingElement && tb.isSpecial(el)) {\n", "furthestBlock = el;\n", "break;\n", "}\n", "}\n", "if (furthestBlock == null) {\n", "tb.popStackToClose(formatEl.nodeName());\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "}\n", "\n", "// todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n", "// does that mean: int pos of format el in list?\n", "Element node = furthestBlock;\n", "Element lastNode = furthestBlock;\n", "for (int j = 0; j < 3; j++) {\n", "if (tb.onStack(node))\n", "node = tb.aboveOnStack(node);\n", "if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n", "tb.removeFromStack(node);\n", "continue;\n", "} else if (node == formatEl)\n", "break;\n", "\n", "Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n", "// case will follow the original node (so honours ParseSettings)\n", "tb.replaceActiveFormattingElement(node, replacement);\n", "tb.replaceOnStack(node, replacement);\n", "node = replacement;\n", "\n", "if (lastNode == furthestBlock) {\n", "// todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n", "// not getting how this bookmark both straddles the element above, but is inbetween here...\n", "}\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "node.appendChild(lastNode);\n", "\n", "lastNode = node;\n", "}\n", "\n", "if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "tb.insertInFosterParent(lastNode);\n", "} else {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "commonAncestor.appendChild(lastNode);\n", "}\n", "\n", "Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n", "adopter.attributes().addAll(formatEl.attributes());\n", "Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n", "for (Node childNode : childNodes) {\n", "adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n", "}\n", "furthestBlock.appendChild(adopter);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "// todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n", "tb.removeFromStack(formatEl);\n", "tb.insertOnStackAfter(furthestBlock, adopter);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n", "if (!tb.inScope(name)) {\n", "// nothing to close\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"span\")) {\n", "// same as final fall through, but saves short circuit\n", "return anyOtherEndTag(t, tb);\n", "} else if (name.equals(\"li\")) {\n", "if (!tb.inListItemScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"body\")) {\n", "if (!tb.inScope(\"body\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "// todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n", "tb.transition(AfterBody);\n", "}\n", "} else if (name.equals(\"html\")) {\n", "boolean notIgnored = tb.processEndTag(\"body\");\n", "if (notIgnored)\n", "return tb.process(endTag);\n", "} else if (name.equals(\"form\")) {\n", "Element currentForm = tb.getFormElement();\n", "tb.setFormElement(null);\n", "if (currentForm == null || !tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "// remove currentForm from stack. will shift anything under up.\n", "tb.removeFromStack(currentForm);\n", "}\n", "} else if (name.equals(\"p\")) {\n", "if (!tb.inButtonScope(name)) {\n", "tb.error(this);\n", "tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n", "return tb.process(endTag);\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (!tb.inScope(Constants.Headings)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(Constants.Headings);\n", "}\n", "} else if (name.equals(\"sarcasm\")) {\n", "// *sigh*\n", "return anyOtherEndTag(t, tb);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "if (!tb.inScope(\"name\")) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "tb.clearFormattingElementsToLastMarker();\n", "}\n", "} else if (name.equals(\"br\")) {\n", "tb.error(this);\n", "tb.processStartTag(\"br\");\n", "return false;\n", "} else {\n", "return anyOtherEndTag(t, tb);\n", "}\n", "\n", "break;\n", "case EOF:\n", "// todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n", "// stop parsing\n", "break;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [147, 148, 151], "cluster": 6}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case Character: {\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "// todo confirm that check\n", "tb.error(this);\n", "return false;\n", "} else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "tb.framesetOk(false);\n", "}\n", "break;\n", "}\n", "case Comment: {\n", "tb.insert(t.asComment());\n", "break;\n", "}\n", "case Doctype: {\n", "tb.error(this);\n", "return false;\n", "}\n", "case StartTag:\n", "Token.StartTag startTag = t.asStartTag();\n", "// todo - refactor to a switch statement\n", "String name = startTag.normalName();\n", "if (name.equals(\"a\")) {\n", "if (tb.getActiveFormattingElement(\"a\") != null) {\n", "tb.error(this);\n", "tb.processEndTag(\"a\");\n", "\n", "// still on stack?\n", "Element remainingA = tb.getFromStack(\"a\");\n", "if (remainingA != null) {\n", "tb.removeFromActiveFormattingElements(remainingA);\n", "tb.removeFromStack(remainingA);\n", "}\n", "}\n", "tb.reconstructFormattingElements();\n", "Element a = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(a);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n", "tb.reconstructFormattingElements();\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"span\")) {\n", "// same as final else, but short circuits lots of checks\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (name.equals(\"li\")) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (el.nodeName().equals(\"li\")) {\n", "tb.processEndTag(\"li\");\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"html\")) {\n", "tb.error(this);\n", "// merge attributes onto real html\n", "Element html = tb.getStack().get(0);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!html.hasAttr(attribute.getKey()))\n", "html.attributes().put(attribute);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n", "return tb.process(t, InHead);\n", "} else if (name.equals(\"body\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else {\n", "tb.framesetOk(false);\n", "Element body = stack.get(1);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!body.hasAttr(attribute.getKey()))\n", "body.attributes().put(attribute);\n", "}\n", "}\n", "} else if (name.equals(\"frameset\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else if (!tb.framesetOk()) {\n", "return false; // ignore frameset\n", "} else {\n", "Element second = stack.get(1);\n", "if (second.parent() != null)\n", "second.remove();\n", "// pop up to html element\n", "while (stack.size() > 1)\n", "stack.remove(stack.size()-1);\n", "tb.insert(startTag);\n", "tb.transition(InFrameset);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n", "tb.error(this);\n", "tb.pop();\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.reader.matchConsume(\"\\n\"); // ignore LF if next token\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"form\")) {\n", "if (tb.getFormElement() != null) {\n", "tb.error(this);\n", "return false;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertForm(startTag, true);\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n", "tb.processEndTag(el.nodeName());\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"plaintext\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n", "} else if (name.equals(\"button\")) {\n", "if (tb.inButtonScope(\"button\")) {\n", "// close and reprocess\n", "tb.error(this);\n", "tb.processEndTag(\"button\");\n", "tb.process(startTag);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Formatters)) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (name.equals(\"nobr\")) {\n", "tb.reconstructFormattingElements();\n", "if (tb.inScope(\"nobr\")) {\n", "tb.error(this);\n", "tb.processEndTag(\"nobr\");\n", "tb.reconstructFormattingElements();\n", "}\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.insertMarkerToFormattingElements();\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"table\")) {\n", "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "tb.transition(InTable);\n", "} else if (name.equals(\"input\")) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insertEmpty(startTag);\n", "if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n", "tb.insertEmpty(startTag);\n", "} else if (name.equals(\"hr\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"image\")) {\n", "if (tb.getFromStack(\"svg\") == null)\n", "return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n", "else\n", "tb.insert(startTag);\n", "} else if (name.equals(\"isindex\")) {\n", "// how much do we care about the early 90s?\n", "tb.error(this);\n", "if (tb.getFormElement() != null)\n", "return false;\n", "\n", "tb.processStartTag(\"form\");\n", "if (startTag.attributes.hasKey(\"action\")) {\n", "Element form = tb.getFormElement();\n", "form.attr(\"action\", startTag.attributes.get(\"action\"));\n", "}\n", "tb.processStartTag(\"hr\");\n", "tb.processStartTag(\"label\");\n", "// hope you like english.\n", "String prompt = startTag.attributes.hasKey(\"prompt\") ?\n", "startTag.attributes.get(\"prompt\") :\n", "\"This is a searchable index. Enter search keywords: \";\n", "\n", "tb.process(new Token.Character().data(prompt));\n", "\n", "// input\n", "Attributes inputAttribs = new Attributes();\n", "for (Attribute attr : startTag.attributes) {\n", "if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n", "inputAttribs.put(attr);\n", "}\n", "inputAttribs.put(\"name\", \"isindex\");\n", "tb.processStartTag(\"input\", inputAttribs);\n", "tb.processEndTag(\"label\");\n", "tb.processStartTag(\"hr\");\n", "tb.processEndTag(\"form\");\n", "} else if (name.equals(\"textarea\")) {\n", "tb.insert(startTag);\n", "// todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n", "tb.tokeniser.transition(TokeniserState.Rcdata);\n", "tb.markInsertionMode();\n", "tb.framesetOk(false);\n", "tb.transition(Text);\n", "} else if (name.equals(\"xmp\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.reconstructFormattingElements();\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"iframe\")) {\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"noembed\")) {\n", "// also handle noscript if script enabled\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"select\")) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "\n", "HtmlTreeBuilderState state = tb.state();\n", "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n", "tb.transition(InSelectInTable);\n", "else\n", "tb.transition(InSelect);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n", "if (tb.inScope(\"ruby\")) {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n", "tb.error(this);\n", "tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n", "}\n", "tb.insert(startTag);\n", "}\n", "} else if (name.equals(\"math\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n", "tb.insert(startTag);\n", "} else if (name.equals(\"svg\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "}\n", "break;\n", "\n", "case EndTag:\n", "Token.EndTag endTag = t.asEndTag();\n", "name = endTag.normalName();\n", "if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n", "// Adoption Agency Algorithm.\n", "for (int i = 0; i < 8; i++) {\n", "Element formatEl = tb.getActiveFormattingElement(name);\n", "if (formatEl == null)\n", "return anyOtherEndTag(t, tb);\n", "else if (!tb.onStack(formatEl)) {\n", "tb.error(this);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "} else if (!tb.inScope(formatEl.nodeName())) {\n", "tb.error(this);\n", "return false;\n", "} else if (tb.currentElement() != formatEl)\n", "tb.error(this);\n", "\n", "Element furthestBlock = null;\n", "Element commonAncestor = null;\n", "boolean seenFormattingElement = false;\n", "ArrayList<Element> stack = tb.getStack();\n", "// the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n", "// run-aways\n", "final int stackSize = stack.size();\n", "for (int si = 0; si < stackSize && si < 64; si++) {\n", "Element el = stack.get(si);\n", "if (el == formatEl) {\n", "commonAncestor = stack.get(si - 1);\n", "seenFormattingElement = true;\n", "} else if (seenFormattingElement && tb.isSpecial(el)) {\n", "furthestBlock = el;\n", "break;\n", "}\n", "}\n", "if (furthestBlock == null) {\n", "tb.popStackToClose(formatEl.nodeName());\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "}\n", "\n", "// todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n", "// does that mean: int pos of format el in list?\n", "Element node = furthestBlock;\n", "Element lastNode = furthestBlock;\n", "for (int j = 0; j < 3; j++) {\n", "if (tb.onStack(node))\n", "node = tb.aboveOnStack(node);\n", "if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n", "tb.removeFromStack(node);\n", "continue;\n", "} else if (node == formatEl)\n", "break;\n", "\n", "Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n", "// case will follow the original node (so honours ParseSettings)\n", "tb.replaceActiveFormattingElement(node, replacement);\n", "tb.replaceOnStack(node, replacement);\n", "node = replacement;\n", "\n", "if (lastNode == furthestBlock) {\n", "// todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n", "// not getting how this bookmark both straddles the element above, but is inbetween here...\n", "}\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "node.appendChild(lastNode);\n", "\n", "lastNode = node;\n", "}\n", "\n", "if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "tb.insertInFosterParent(lastNode);\n", "} else {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "commonAncestor.appendChild(lastNode);\n", "}\n", "\n", "Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n", "adopter.attributes().addAll(formatEl.attributes());\n", "Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n", "for (Node childNode : childNodes) {\n", "adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n", "}\n", "furthestBlock.appendChild(adopter);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "// todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n", "tb.removeFromStack(formatEl);\n", "tb.insertOnStackAfter(furthestBlock, adopter);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n", "if (!tb.inScope(name)) {\n", "// nothing to close\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"span\")) {\n", "// same as final fall through, but saves short circuit\n", "return anyOtherEndTag(t, tb);\n", "} else if (name.equals(\"li\")) {\n", "if (!tb.inListItemScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"body\")) {\n", "if (!tb.inScope(\"body\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "// todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n", "tb.transition(AfterBody);\n", "}\n", "} else if (name.equals(\"html\")) {\n", "boolean notIgnored = tb.processEndTag(\"body\");\n", "if (notIgnored)\n", "return tb.process(endTag);\n", "} else if (name.equals(\"form\")) {\n", "Element currentForm = tb.getFormElement();\n", "tb.setFormElement(null);\n", "if (currentForm == null || !tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "// remove currentForm from stack. will shift anything under up.\n", "tb.removeFromStack(currentForm);\n", "}\n", "} else if (name.equals(\"p\")) {\n", "if (!tb.inButtonScope(name)) {\n", "tb.error(this);\n", "tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n", "return tb.process(endTag);\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (!tb.inScope(Constants.Headings)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(Constants.Headings);\n", "}\n", "} else if (name.equals(\"sarcasm\")) {\n", "// *sigh*\n", "return anyOtherEndTag(t, tb);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "if (!tb.inScope(\"name\")) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "tb.clearFormattingElementsToLastMarker();\n", "}\n", "} else if (name.equals(\"br\")) {\n", "tb.error(this);\n", "tb.processStartTag(\"br\");\n", "return false;\n", "} else {\n", "return anyOtherEndTag(t, tb);\n", "}\n", "\n", "break;\n", "case EOF:\n", "// todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n", "// stop parsing\n", "break;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [280, 287], "cluster": 6}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case Character: {\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "// todo confirm that check\n", "tb.error(this);\n", "return false;\n", "} else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(c);\n", "tb.framesetOk(false);\n", "}\n", "break;\n", "}\n", "case Comment: {\n", "tb.insert(t.asComment());\n", "break;\n", "}\n", "case Doctype: {\n", "tb.error(this);\n", "return false;\n", "}\n", "case StartTag:\n", "Token.StartTag startTag = t.asStartTag();\n", "// todo - refactor to a switch statement\n", "String name = startTag.normalName();\n", "if (name.equals(\"a\")) {\n", "if (tb.getActiveFormattingElement(\"a\") != null) {\n", "tb.error(this);\n", "tb.processEndTag(\"a\");\n", "\n", "// still on stack?\n", "Element remainingA = tb.getFromStack(\"a\");\n", "if (remainingA != null) {\n", "tb.removeFromActiveFormattingElements(remainingA);\n", "tb.removeFromStack(remainingA);\n", "}\n", "}\n", "tb.reconstructFormattingElements();\n", "Element a = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(a);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\n", "tb.reconstructFormattingElements();\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"span\")) {\n", "// same as final else, but short circuits lots of checks\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (name.equals(\"li\")) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (el.nodeName().equals(\"li\")) {\n", "tb.processEndTag(\"li\");\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"html\")) {\n", "tb.error(this);\n", "// merge attributes onto real html\n", "Element html = tb.getStack().get(0);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!html.hasAttr(attribute.getKey()))\n", "html.attributes().put(attribute);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\n", "return tb.process(t, InHead);\n", "} else if (name.equals(\"body\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else {\n", "tb.framesetOk(false);\n", "Element body = stack.get(1);\n", "for (Attribute attribute : startTag.getAttributes()) {\n", "if (!body.hasAttr(attribute.getKey()))\n", "body.attributes().put(attribute);\n", "}\n", "}\n", "} else if (name.equals(\"frameset\")) {\n", "tb.error(this);\n", "ArrayList<Element> stack = tb.getStack();\n", "if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n", "// only in fragment case\n", "return false; // ignore\n", "} else if (!tb.framesetOk()) {\n", "return false; // ignore frameset\n", "} else {\n", "Element second = stack.get(1);\n", "if (second.parent() != null)\n", "second.remove();\n", "// pop up to html element\n", "while (stack.size() > 1)\n", "stack.remove(stack.size()-1);\n", "tb.insert(startTag);\n", "tb.transition(InFrameset);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "if (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\n", "tb.error(this);\n", "tb.pop();\n", "}\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.reader.matchConsume(\"\\n\"); // ignore LF if next token\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"form\")) {\n", "if (tb.getFormElement() != null) {\n", "tb.error(this);\n", "return false;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertForm(startTag, true);\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "tb.framesetOk(false);\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int i = stack.size() - 1; i > 0; i--) {\n", "Element el = stack.get(i);\n", "if (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\n", "tb.processEndTag(el.nodeName());\n", "break;\n", "}\n", "if (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\n", "break;\n", "}\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "} else if (name.equals(\"plaintext\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n", "} else if (name.equals(\"button\")) {\n", "if (tb.inButtonScope(\"button\")) {\n", "// close and reprocess\n", "tb.error(this);\n", "tb.processEndTag(\"button\");\n", "tb.process(startTag);\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Formatters)) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (name.equals(\"nobr\")) {\n", "tb.reconstructFormattingElements();\n", "if (tb.inScope(\"nobr\")) {\n", "tb.error(this);\n", "tb.processEndTag(\"nobr\");\n", "tb.reconstructFormattingElements();\n", "}\n", "Element el = tb.insert(startTag);\n", "tb.pushActiveFormattingElements(el);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.insertMarkerToFormattingElements();\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"table\")) {\n", "if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "tb.transition(InTable);\n", "} else if (name.equals(\"input\")) {\n", "tb.reconstructFormattingElements();\n", "Element el = tb.insertEmpty(startTag);\n", "if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n", "tb.framesetOk(false);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\n", "tb.insertEmpty(startTag);\n", "} else if (name.equals(\"hr\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.insertEmpty(startTag);\n", "tb.framesetOk(false);\n", "} else if (name.equals(\"image\")) {\n", "if (tb.getFromStack(\"svg\") == null)\n", "return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\n", "else\n", "tb.insert(startTag);\n", "} else if (name.equals(\"isindex\")) {\n", "// how much do we care about the early 90s?\n", "tb.error(this);\n", "if (tb.getFormElement() != null)\n", "return false;\n", "\n", "tb.processStartTag(\"form\");\n", "if (startTag.attributes.hasKey(\"action\")) {\n", "Element form = tb.getFormElement();\n", "form.attr(\"action\", startTag.attributes.get(\"action\"));\n", "}\n", "tb.processStartTag(\"hr\");\n", "tb.processStartTag(\"label\");\n", "// hope you like english.\n", "String prompt = startTag.attributes.hasKey(\"prompt\") ?\n", "startTag.attributes.get(\"prompt\") :\n", "\"This is a searchable index. Enter search keywords: \";\n", "\n", "tb.process(new Token.Character().data(prompt));\n", "\n", "// input\n", "Attributes inputAttribs = new Attributes();\n", "for (Attribute attr : startTag.attributes) {\n", "if (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\n", "inputAttribs.put(attr);\n", "}\n", "inputAttribs.put(\"name\", \"isindex\");\n", "tb.processStartTag(\"input\", inputAttribs);\n", "tb.processEndTag(\"label\");\n", "tb.processStartTag(\"hr\");\n", "tb.processEndTag(\"form\");\n", "} else if (name.equals(\"textarea\")) {\n", "tb.insert(startTag);\n", "// todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n", "tb.tokeniser.transition(TokeniserState.Rcdata);\n", "tb.markInsertionMode();\n", "tb.framesetOk(false);\n", "tb.transition(Text);\n", "} else if (name.equals(\"xmp\")) {\n", "if (tb.inButtonScope(\"p\")) {\n", "tb.processEndTag(\"p\");\n", "}\n", "tb.reconstructFormattingElements();\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"iframe\")) {\n", "tb.framesetOk(false);\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"noembed\")) {\n", "// also handle noscript if script enabled\n", "handleRawtext(startTag, tb);\n", "} else if (name.equals(\"select\")) {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "tb.framesetOk(false);\n", "\n", "HtmlTreeBuilderState state = tb.state();\n", "if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n", "tb.transition(InSelectInTable);\n", "else\n", "tb.transition(InSelect);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\n", "if (tb.inScope(\"ruby\")) {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n", "tb.error(this);\n", "tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n", "}\n", "tb.insert(startTag);\n", "}\n", "} else if (name.equals(\"math\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n", "tb.insert(startTag);\n", "} else if (name.equals(\"svg\")) {\n", "tb.reconstructFormattingElements();\n", "// todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n", "tb.insert(startTag);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.reconstructFormattingElements();\n", "tb.insert(startTag);\n", "}\n", "break;\n", "\n", "case EndTag:\n", "Token.EndTag endTag = t.asEndTag();\n", "name = endTag.normalName();\n", "if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n", "// Adoption Agency Algorithm.\n", "for (int i = 0; i < 8; i++) {\n", "Element formatEl = tb.getActiveFormattingElement(name);\n", "if (formatEl == null)\n", "return anyOtherEndTag(t, tb);\n", "else if (!tb.onStack(formatEl)) {\n", "tb.error(this);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "} else if (!tb.inScope(formatEl.nodeName())) {\n", "tb.error(this);\n", "return false;\n", "} else if (tb.currentElement() != formatEl)\n", "tb.error(this);\n", "\n", "Element furthestBlock = null;\n", "Element commonAncestor = null;\n", "boolean seenFormattingElement = false;\n", "ArrayList<Element> stack = tb.getStack();\n", "// the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n", "// run-aways\n", "final int stackSize = stack.size();\n", "for (int si = 0; si < stackSize && si < 64; si++) {\n", "Element el = stack.get(si);\n", "if (el == formatEl) {\n", "commonAncestor = stack.get(si - 1);\n", "seenFormattingElement = true;\n", "} else if (seenFormattingElement && tb.isSpecial(el)) {\n", "furthestBlock = el;\n", "break;\n", "}\n", "}\n", "if (furthestBlock == null) {\n", "tb.popStackToClose(formatEl.nodeName());\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "return true;\n", "}\n", "\n", "// todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n", "// does that mean: int pos of format el in list?\n", "Element node = furthestBlock;\n", "Element lastNode = furthestBlock;\n", "for (int j = 0; j < 3; j++) {\n", "if (tb.onStack(node))\n", "node = tb.aboveOnStack(node);\n", "if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n", "tb.removeFromStack(node);\n", "continue;\n", "} else if (node == formatEl)\n", "break;\n", "\n", "Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n", "// case will follow the original node (so honours ParseSettings)\n", "tb.replaceActiveFormattingElement(node, replacement);\n", "tb.replaceOnStack(node, replacement);\n", "node = replacement;\n", "\n", "if (lastNode == furthestBlock) {\n", "// todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n", "// not getting how this bookmark both straddles the element above, but is inbetween here...\n", "}\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "node.appendChild(lastNode);\n", "\n", "lastNode = node;\n", "}\n", "\n", "if (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "tb.insertInFosterParent(lastNode);\n", "} else {\n", "if (lastNode.parent() != null)\n", "lastNode.remove();\n", "commonAncestor.appendChild(lastNode);\n", "}\n", "\n", "Element adopter = new Element(formatEl.tag(), tb.getBaseUri());\n", "adopter.attributes().addAll(formatEl.attributes());\n", "Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n", "for (Node childNode : childNodes) {\n", "adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n", "}\n", "furthestBlock.appendChild(adopter);\n", "tb.removeFromActiveFormattingElements(formatEl);\n", "// todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n", "tb.removeFromStack(formatEl);\n", "tb.insertOnStackAfter(furthestBlock, adopter);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\n", "if (!tb.inScope(name)) {\n", "// nothing to close\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"span\")) {\n", "// same as final fall through, but saves short circuit\n", "return anyOtherEndTag(t, tb);\n", "} else if (name.equals(\"li\")) {\n", "if (!tb.inListItemScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (name.equals(\"body\")) {\n", "if (!tb.inScope(\"body\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "// todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n", "tb.transition(AfterBody);\n", "}\n", "} else if (name.equals(\"html\")) {\n", "boolean notIgnored = tb.processEndTag(\"body\");\n", "if (notIgnored)\n", "return tb.process(endTag);\n", "} else if (name.equals(\"form\")) {\n", "Element currentForm = tb.getFormElement();\n", "tb.setFormElement(null);\n", "if (currentForm == null || !tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "// remove currentForm from stack. will shift anything under up.\n", "tb.removeFromStack(currentForm);\n", "}\n", "} else if (name.equals(\"p\")) {\n", "if (!tb.inButtonScope(name)) {\n", "tb.error(this);\n", "tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n", "return tb.process(endTag);\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.DdDt)) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "}\n", "} else if (StringUtil.inSorted(name, Constants.Headings)) {\n", "if (!tb.inScope(Constants.Headings)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags(name);\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(Constants.Headings);\n", "}\n", "} else if (name.equals(\"sarcasm\")) {\n", "// *sigh*\n", "return anyOtherEndTag(t, tb);\n", "} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\n", "if (!tb.inScope(\"name\")) {\n", "if (!tb.inScope(name)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "tb.clearFormattingElementsToLastMarker();\n", "}\n", "} else if (name.equals(\"br\")) {\n", "tb.error(this);\n", "tb.processStartTag(\"br\");\n", "return false;\n", "} else {\n", "return anyOtherEndTag(t, tb);\n", "}\n", "\n", "break;\n", "case EOF:\n", "// todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n", "// stop parsing\n", "break;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [323], "cluster": 6}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n", "String name = tb.settings.normalizeTag(t.asEndTag().name());\n", "ArrayList<Element> stack = tb.getStack();\n", "for (int pos = stack.size() -1; pos >= 0; pos--) {\n", "Element node = stack.get(pos);\n", "if (node.nodeName().equals(name)) {\n", "tb.generateImpliedEndTags(name);\n", "if (!name.equals(tb.currentElement().nodeName()))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "break;\n", "} else {\n", "if (tb.isSpecial(node)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "}\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [2, 6, 8], "cluster": 2}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n", "tb.error(this);\n", "boolean processed;\n", "if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n", "tb.setFosterInserts(true);\n", "processed = tb.process(t, InBody);\n", "tb.setFosterInserts(false);\n", "} else {\n", "processed = tb.process(t, InBody);\n", "}\n", "return processed;\n", "}\n"], "faulty_lines": [4], "cluster": 4}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case Character:\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.getPendingTableCharacters().add(c.getData());\n", "}\n", "break;\n", "default:\n", "// todo - don't really like the way these table character data lists are built\n", "if (tb.getPendingTableCharacters().size() > 0) {\n", "for (String character : tb.getPendingTableCharacters()) {\n", "if (!isWhitespace(character)) {\n", "// InTable anything else section:\n", "tb.error(this);\n", "if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n", "tb.setFosterInserts(true);\n", "tb.process(new Token.Character().data(character), InBody);\n", "tb.setFosterInserts(false);\n", "} else {\n", "tb.process(new Token.Character().data(character), InBody);\n", "}\n", "} else\n", "tb.insert(new Token.Character().data(character));\n", "}\n", "tb.newPendingTableCharacters();\n", "}\n", "tb.transition(tb.originalState());\n", "return tb.process(t);\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [19], "cluster": 1}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "if (t.isEndTag() && t.asEndTag().normalName().equals(\"caption\")) {\n", "Token.EndTag endTag = t.asEndTag();\n", "String name = endTag.normalName();\n", "if (!tb.inTableScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(\"caption\"))\n", "tb.error(this);\n", "tb.popStackToClose(\"caption\");\n", "tb.clearFormattingElementsToLastMarker();\n", "tb.transition(InTable);\n", "}\n", "} else if ((\n", "t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n", "\"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\") ||\n", "t.isEndTag() && t.asEndTag().normalName().equals(\"table\"))\n", ") {\n", "tb.error(this);\n", "boolean processed = tb.processEndTag(\"caption\");\n", "if (processed)\n", "return tb.process(t);\n", "} else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(),\n", "\"body\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "return tb.process(t, InBody);\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [10], "cluster": 5}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "if (isWhitespace(t)) {\n", "tb.insert(t.asCharacter());\n", "return true;\n", "}\n", "switch (t.type) {\n", "case Comment:\n", "tb.insert(t.asComment());\n", "break;\n", "case Doctype:\n", "tb.error(this);\n", "break;\n", "case StartTag:\n", "Token.StartTag startTag = t.asStartTag();\n", "switch (startTag.normalName()) {\n", "case \"html\":\n", "return tb.process(t, InBody);\n", "case \"col\":\n", "tb.insertEmpty(startTag);\n", "break;\n", "default:\n", "return anythingElse(t, tb);\n", "}\n", "break;\n", "case EndTag:\n", "Token.EndTag endTag = t.asEndTag();\n", "if (endTag.normalName.equals(\"colgroup\")) {\n", "if (tb.currentElement().nodeName().equals(\"html\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.pop();\n", "tb.transition(InTable);\n", "}\n", "} else\n", "return anythingElse(t, tb);\n", "break;\n", "case EOF:\n", "if (tb.currentElement().nodeName().equals(\"html\"))\n", "return true; // stop parsing; frag case\n", "else\n", "return anythingElse(t, tb);\n", "default:\n", "return anythingElse(t, tb);\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [28], "cluster": 1}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "if (isWhitespace(t)) {\n", "tb.insert(t.asCharacter());\n", "return true;\n", "}\n", "switch (t.type) {\n", "case Comment:\n", "tb.insert(t.asComment());\n", "break;\n", "case Doctype:\n", "tb.error(this);\n", "break;\n", "case StartTag:\n", "Token.StartTag startTag = t.asStartTag();\n", "switch (startTag.normalName()) {\n", "case \"html\":\n", "return tb.process(t, InBody);\n", "case \"col\":\n", "tb.insertEmpty(startTag);\n", "break;\n", "default:\n", "return anythingElse(t, tb);\n", "}\n", "break;\n", "case EndTag:\n", "Token.EndTag endTag = t.asEndTag();\n", "if (endTag.normalName.equals(\"colgroup\")) {\n", "if (tb.currentElement().nodeName().equals(\"html\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.pop();\n", "tb.transition(InTable);\n", "}\n", "} else\n", "return anythingElse(t, tb);\n", "break;\n", "case EOF:\n", "if (tb.currentElement().nodeName().equals(\"html\"))\n", "return true; // stop parsing; frag case\n", "else\n", "return anythingElse(t, tb);\n", "default:\n", "return anythingElse(t, tb);\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [39], "cluster": 1}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["private boolean exitTableBody(Token t, HtmlTreeBuilder tb) {\n", "if (!(tb.inTableScope(\"tbody\") || tb.inTableScope(\"thead\") || tb.inScope(\"tfoot\"))) {\n", "// frag case\n", "tb.error(this);\n", "return false;\n", "}\n", "tb.clearStackToTableBodyContext();\n", "tb.processEndTag(tb.currentElement().nodeName());\n", "return tb.process(t);\n", "}\n"], "faulty_lines": [8], "cluster": 4}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "if (t.isEndTag()) {\n", "Token.EndTag endTag = t.asEndTag();\n", "String name = endTag.normalName();\n", "\n", "if (StringUtil.inSorted(name, Constants.InCellNames)) {\n", "if (!tb.inTableScope(name)) {\n", "tb.error(this);\n", "tb.transition(InRow); // might not be in scope if empty: <td /> and processing fake end tag\n", "return false;\n", "}\n", "tb.generateImpliedEndTags();\n", "if (!tb.currentElement().nodeName().equals(name))\n", "tb.error(this);\n", "tb.popStackToClose(name);\n", "tb.clearFormattingElementsToLastMarker();\n", "tb.transition(InRow);\n", "} else if (StringUtil.inSorted(name, Constants.InCellBody)) {\n", "tb.error(this);\n", "return false;\n", "} else if (StringUtil.inSorted(name, Constants.InCellTable)) {\n", "if (!tb.inTableScope(name)) {\n", "tb.error(this);\n", "return false;\n", "}\n", "closeCell(tb);\n", "return tb.process(t);\n", "} else {\n", "return anythingElse(t, tb);\n", "}\n", "} else if (t.isStartTag() &&\n", "StringUtil.inSorted(t.asStartTag().normalName(), Constants.InCellCol)) {\n", "if (!(tb.inTableScope(\"td\") || tb.inTableScope(\"th\"))) {\n", "tb.error(this);\n", "return false;\n", "}\n", "closeCell(tb);\n", "return tb.process(t);\n", "} else {\n", "return anythingElse(t, tb);\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [13], "cluster": 6}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case Character:\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.insert(c);\n", "}\n", "break;\n", "case Comment:\n", "tb.insert(t.asComment());\n", "break;\n", "case Doctype:\n", "tb.error(this);\n", "return false;\n", "case StartTag:\n", "Token.StartTag start = t.asStartTag();\n", "String name = start.normalName();\n", "if (name.equals(\"html\"))\n", "return tb.process(start, InBody);\n", "else if (name.equals(\"option\")) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "tb.insert(start);\n", "} else if (name.equals(\"optgroup\")) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "else if (tb.currentElement().nodeName().equals(\"optgroup\"))\n", "tb.processEndTag(\"optgroup\");\n", "tb.insert(start);\n", "} else if (name.equals(\"select\")) {\n", "tb.error(this);\n", "return tb.processEndTag(\"select\");\n", "} else if (StringUtil.in(name, \"input\", \"keygen\", \"textarea\")) {\n", "tb.error(this);\n", "if (!tb.inSelectScope(\"select\"))\n", "return false; // frag\n", "tb.processEndTag(\"select\");\n", "return tb.process(start);\n", "} else if (name.equals(\"script\")) {\n", "return tb.process(t, InHead);\n", "} else {\n", "return anythingElse(t, tb);\n", "}\n", "break;\n", "case EndTag:\n", "Token.EndTag end = t.asEndTag();\n", "name = end.normalName();\n", "switch (name) {\n", "case \"optgroup\":\n", "if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n", "tb.processEndTag(\"option\");\n", "if (tb.currentElement().nodeName().equals(\"optgroup\"))\n", "tb.pop();\n", "else\n", "tb.error(this);\n", "break;\n", "case \"option\":\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.pop();\n", "else\n", "tb.error(this);\n", "break;\n", "case \"select\":\n", "if (!tb.inSelectScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.popStackToClose(name);\n", "tb.resetInsertionMode();\n", "}\n", "break;\n", "default:\n", "return anythingElse(t, tb);\n", "}\n", "break;\n", "case EOF:\n", "if (!tb.currentElement().nodeName().equals(\"html\"))\n", "tb.error(this);\n", "break;\n", "default:\n", "return anythingElse(t, tb);\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [24, 28, 30], "cluster": 6}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case Character:\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.insert(c);\n", "}\n", "break;\n", "case Comment:\n", "tb.insert(t.asComment());\n", "break;\n", "case Doctype:\n", "tb.error(this);\n", "return false;\n", "case StartTag:\n", "Token.StartTag start = t.asStartTag();\n", "String name = start.normalName();\n", "if (name.equals(\"html\"))\n", "return tb.process(start, InBody);\n", "else if (name.equals(\"option\")) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "tb.insert(start);\n", "} else if (name.equals(\"optgroup\")) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "else if (tb.currentElement().nodeName().equals(\"optgroup\"))\n", "tb.processEndTag(\"optgroup\");\n", "tb.insert(start);\n", "} else if (name.equals(\"select\")) {\n", "tb.error(this);\n", "return tb.processEndTag(\"select\");\n", "} else if (StringUtil.in(name, \"input\", \"keygen\", \"textarea\")) {\n", "tb.error(this);\n", "if (!tb.inSelectScope(\"select\"))\n", "return false; // frag\n", "tb.processEndTag(\"select\");\n", "return tb.process(start);\n", "} else if (name.equals(\"script\")) {\n", "return tb.process(t, InHead);\n", "} else {\n", "return anythingElse(t, tb);\n", "}\n", "break;\n", "case EndTag:\n", "Token.EndTag end = t.asEndTag();\n", "name = end.normalName();\n", "switch (name) {\n", "case \"optgroup\":\n", "if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n", "tb.processEndTag(\"option\");\n", "if (tb.currentElement().nodeName().equals(\"optgroup\"))\n", "tb.pop();\n", "else\n", "tb.error(this);\n", "break;\n", "case \"option\":\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.pop();\n", "else\n", "tb.error(this);\n", "break;\n", "case \"select\":\n", "if (!tb.inSelectScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.popStackToClose(name);\n", "tb.resetInsertionMode();\n", "}\n", "break;\n", "default:\n", "return anythingElse(t, tb);\n", "}\n", "break;\n", "case EOF:\n", "if (!tb.currentElement().nodeName().equals(\"html\"))\n", "tb.error(this);\n", "break;\n", "default:\n", "return anythingElse(t, tb);\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [53, 55, 61], "cluster": 6}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "switch (t.type) {\n", "case Character:\n", "Token.Character c = t.asCharacter();\n", "if (c.getData().equals(nullString)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.insert(c);\n", "}\n", "break;\n", "case Comment:\n", "tb.insert(t.asComment());\n", "break;\n", "case Doctype:\n", "tb.error(this);\n", "return false;\n", "case StartTag:\n", "Token.StartTag start = t.asStartTag();\n", "String name = start.normalName();\n", "if (name.equals(\"html\"))\n", "return tb.process(start, InBody);\n", "else if (name.equals(\"option\")) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "tb.insert(start);\n", "} else if (name.equals(\"optgroup\")) {\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.processEndTag(\"option\");\n", "else if (tb.currentElement().nodeName().equals(\"optgroup\"))\n", "tb.processEndTag(\"optgroup\");\n", "tb.insert(start);\n", "} else if (name.equals(\"select\")) {\n", "tb.error(this);\n", "return tb.processEndTag(\"select\");\n", "} else if (StringUtil.in(name, \"input\", \"keygen\", \"textarea\")) {\n", "tb.error(this);\n", "if (!tb.inSelectScope(\"select\"))\n", "return false; // frag\n", "tb.processEndTag(\"select\");\n", "return tb.process(start);\n", "} else if (name.equals(\"script\")) {\n", "return tb.process(t, InHead);\n", "} else {\n", "return anythingElse(t, tb);\n", "}\n", "break;\n", "case EndTag:\n", "Token.EndTag end = t.asEndTag();\n", "name = end.normalName();\n", "switch (name) {\n", "case \"optgroup\":\n", "if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n", "tb.processEndTag(\"option\");\n", "if (tb.currentElement().nodeName().equals(\"optgroup\"))\n", "tb.pop();\n", "else\n", "tb.error(this);\n", "break;\n", "case \"option\":\n", "if (tb.currentElement().nodeName().equals(\"option\"))\n", "tb.pop();\n", "else\n", "tb.error(this);\n", "break;\n", "case \"select\":\n", "if (!tb.inSelectScope(name)) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.popStackToClose(name);\n", "tb.resetInsertionMode();\n", "}\n", "break;\n", "default:\n", "return anythingElse(t, tb);\n", "}\n", "break;\n", "case EOF:\n", "if (!tb.currentElement().nodeName().equals(\"html\"))\n", "tb.error(this);\n", "break;\n", "default:\n", "return anythingElse(t, tb);\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [80], "cluster": 6}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/HtmlTreeBuilderState.java", "method": ["boolean process(Token t, HtmlTreeBuilder tb) {\n", "if (isWhitespace(t)) {\n", "tb.insert(t.asCharacter());\n", "} else if (t.isComment()) {\n", "tb.insert(t.asComment());\n", "} else if (t.isDoctype()) {\n", "tb.error(this);\n", "return false;\n", "} else if (t.isStartTag()) {\n", "Token.StartTag start = t.asStartTag();\n", "switch (start.normalName()) {\n", "case \"html\":\n", "return tb.process(start, InBody);\n", "case \"frameset\":\n", "tb.insert(start);\n", "break;\n", "case \"frame\":\n", "tb.insertEmpty(start);\n", "break;\n", "case \"noframes\":\n", "return tb.process(start, InHead);\n", "default:\n", "tb.error(this);\n", "return false;\n", "}\n", "} else if (t.isEndTag() && t.asEndTag().normalName().equals(\"frameset\")) {\n", "if (tb.currentElement().nodeName().equals(\"html\")) {\n", "tb.error(this);\n", "return false;\n", "} else {\n", "tb.pop();\n", "if (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals(\"frameset\")) {\n", "tb.transition(AfterFrameset);\n", "}\n", "}\n", "} else if (t.isEOF()) {\n", "if (!tb.currentElement().nodeName().equals(\"html\")) {\n", "tb.error(this);\n", "return true;\n", "}\n", "} else {\n", "tb.error(this);\n", "return false;\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [27, 32, 37], "cluster": 5}, {"pid": "Jsoup", "bid": 87, "method_path": "./dataset/Jsoup/87/Tag.java", "method": ["private Tag(String tagName) {\n", "this.tagName = tagName;\n", "}\n"], "faulty_lines": [3], "cluster": 0}, {"pid": "Jsoup", "bid": 88, "method_path": "./dataset/Jsoup/88/Attribute.java", "method": ["public String getValue() {\n", "return val;\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Jsoup", "bid": 89, "method_path": "./dataset/Jsoup/89/Attribute.java", "method": ["public String setValue(String val) {\n", "String oldVal = parent.get(this.key);\n", "if (parent != null) {\n", "int i = parent.indexOfKey(this.key);\n", "if (i != Attributes.NotFound)\n", "parent.vals[i] = val;\n", "}\n", "this.val = val;\n", "return Attributes.checkNotNull(oldVal);\n", "}\n"], "faulty_lines": [2, 4], "cluster": 4}, {"pid": "Jsoup", "bid": 90, "method_path": "./dataset/Jsoup/90/HttpConnection.java", "method": ["private static boolean looksLikeUtf8(byte[] input) {\n", "int i = 0;\n", "// BOM:\n", "if (input.length >= 3 && (input[0] & 0xFF) == 0xEF\n", "&& (input[1] & 0xFF) == 0xBB & (input[2] & 0xFF) == 0xBF) {\n", "i = 3;\n", "}\n", "\n", "int end;\n", "for (int j = input.length; i < j; ++i) {\n", "int o = input[i];\n", "if ((o & 0x80) == 0) {\n", "continue; // ASCII\n", "}\n", "\n", "// UTF-8 leading:\n", "if ((o & 0xE0) == 0xC0) {\n", "end = i + 1;\n", "} else if ((o & 0xF0) == 0xE0) {\n", "end = i + 2;\n", "} else if ((o & 0xF8) == 0xF0) {\n", "end = i + 3;\n", "} else {\n", "return false;\n", "}\n", "\n", "\n", "while (i < end) {\n", "i++;\n", "o = input[i];\n", "if ((o & 0xC0) != 0x80) {\n", "return false;\n", "}\n", "}\n", "}\n", "return true;\n", "}\n"], "faulty_lines": [27], "cluster": 8}, {"pid": "Jsoup", "bid": 91, "method_path": "./dataset/Jsoup/91/CharacterReader.java", "method": ["public CharacterReader(Reader input, int sz) {\n", "Validate.notNull(input);\n", "Validate.isTrue(input.markSupported());\n", "reader = input;\n", "charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n", "bufferUp();\n", "\n", "}\n"], "faulty_lines": [8], "cluster": 0}, {"pid": "Jsoup", "bid": 92, "method_path": "./dataset/Jsoup/92/Attributes.java", "method": ["private void add(String key, String value) {\n", "checkCapacity(size + 1);\n", "keys[size] = key;\n", "vals[size] = value;\n", "size++;\n", "}\n"], "faulty_lines": [1, 6], "cluster": 0}, {"pid": "Jsoup", "bid": 93, "method_path": "./dataset/Jsoup/93/FormElement.java", "method": ["public List<Connection.KeyVal> formData() {\n", "ArrayList<Connection.KeyVal> data = new ArrayList<>();\n", "\n", "// iterate the form control elements and accumulate their values\n", "for (Element el: elements) {\n", "if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n", "if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n", "String name = el.attr(\"name\");\n", "if (name.length() == 0) continue;\n", "String type = el.attr(\"type\");\n", "\n", "\n", "if (\"select\".equals(el.normalName())) {\n", "Elements options = el.select(\"option[selected]\");\n", "boolean set = false;\n", "for (Element option: options) {\n", "data.add(HttpConnection.KeyVal.create(name, option.val()));\n", "set = true;\n", "}\n", "if (!set) {\n", "Element option = el.select(\"option\").first();\n", "if (option != null)\n", "data.add(HttpConnection.KeyVal.create(name, option.val()));\n", "}\n", "} else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n", "// only add checkbox or radio if they have the checked attribute\n", "if (el.hasAttr(\"checked\")) {\n", "final String val = el.val().length() >  0 ? el.val() : \"on\";\n", "data.add(HttpConnection.KeyVal.create(name, val));\n", "}\n", "} else {\n", "data.add(HttpConnection.KeyVal.create(name, el.val()));\n", "}\n", "}\n", "return data;\n", "}\n"], "faulty_lines": [12], "cluster": 5}, {"pid": "Codec", "bid": 1, "method_path": "./dataset/Codec/1/Caverphone.java", "method": ["public String caverphone(String txt) {\n", "// NOTE: Version 1.0 of Caverphone is easily derivable from this code\n", "// by commenting out the 2.0 lines and adding in the 1.0 lines\n", "\n", "if( txt == null || txt.length() == 0 ) {\n", "return \"1111111111\";\n", "}\n", "\n", "// 1. Convert to lowercase\n", "txt = txt.toLowerCase();\n", "\n", "// 2. Remove anything not A-Z\n", "txt = txt.replaceAll(\"[^a-z]\", \"\");\n", "\n", "// 2.5. Remove final e\n", "txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n", "\n", "// 3. Handle various start options\n", "txt = txt.replaceAll(\"^cough\", \"cou2f\");\n", "txt = txt.replaceAll(\"^rough\", \"rou2f\");\n", "txt = txt.replaceAll(\"^tough\", \"tou2f\");\n", "txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n", "txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n", "txt = txt.replaceAll(\"^gn\", \"2n\");\n", "txt = txt.replaceAll(\"^mb\", \"m2\");\n", "\n", "// 4. Handle replacements\n", "txt = txt.replaceAll(\"cq\", \"2q\");\n", "txt = txt.replaceAll(\"ci\", \"si\");\n", "txt = txt.replaceAll(\"ce\", \"se\");\n", "txt = txt.replaceAll(\"cy\", \"sy\");\n", "txt = txt.replaceAll(\"tch\", \"2ch\");\n", "txt = txt.replaceAll(\"c\", \"k\");\n", "txt = txt.replaceAll(\"q\", \"k\");\n", "txt = txt.replaceAll(\"x\", \"k\");\n", "txt = txt.replaceAll(\"v\", \"f\");\n", "txt = txt.replaceAll(\"dg\", \"2g\");\n", "txt = txt.replaceAll(\"tio\", \"sio\");\n", "txt = txt.replaceAll(\"tia\", \"sia\");\n", "txt = txt.replaceAll(\"d\", \"t\");\n", "txt = txt.replaceAll(\"ph\", \"fh\");\n", "txt = txt.replaceAll(\"b\", \"p\");\n", "txt = txt.replaceAll(\"sh\", \"s2\");\n", "txt = txt.replaceAll(\"z\", \"s\");\n", "txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n", "txt = txt.replaceAll(\"[aeiou]\", \"3\");\n", "txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n", "txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n", "txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n", "txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n", "txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n", "txt = txt.replaceAll(\"gh\", \"22\");\n", "txt = txt.replaceAll(\"g\", \"k\");\n", "txt = txt.replaceAll(\"s+\", \"S\");\n", "txt = txt.replaceAll(\"t+\", \"T\");\n", "txt = txt.replaceAll(\"p+\", \"P\");\n", "txt = txt.replaceAll(\"k+\", \"K\");\n", "txt = txt.replaceAll(\"f+\", \"F\");\n", "txt = txt.replaceAll(\"m+\", \"M\");\n", "txt = txt.replaceAll(\"n+\", \"N\");\n", "txt = txt.replaceAll(\"w3\", \"W3\");\n", "//txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n", "txt = txt.replaceAll(\"wh3\", \"Wh3\");\n", "txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n", "//txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n", "txt = txt.replaceAll(\"w\", \"2\");\n", "txt = txt.replaceAll(\"^h\", \"A\");\n", "txt = txt.replaceAll(\"h\", \"2\");\n", "txt = txt.replaceAll(\"r3\", \"R3\");\n", "txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n", "//txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n", "txt = txt.replaceAll(\"r\", \"2\");\n", "txt = txt.replaceAll(\"l3\", \"L3\");\n", "txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n", "//txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n", "txt = txt.replaceAll(\"l\", \"2\");\n", "//txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n", "//txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n", "//txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n", "\n", "// 5. Handle removals\n", "txt = txt.replaceAll(\"2\", \"\");\n", "txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n", "txt = txt.replaceAll(\"3\", \"\");\n", "\n", "// 6. put ten 1s on the end\n", "txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n", "\n", "// 7. take the first six characters as the code\n", "return txt.substring(0, 10);          // 1.0 truncates to 6\n", "}\n"], "faulty_lines": [10], "cluster": 6}, {"pid": "Codec", "bid": 2, "method_path": "./dataset/Codec/2/Base64.java", "method": ["void encode(byte[] in, int inPos, int inAvail) {\n", "if (eof) {\n", "return;\n", "}\n", "// inAvail < 0 is how we're informed of EOF in the underlying data we're\n", "// encoding.\n", "if (inAvail < 0) {\n", "eof = true;\n", "if (buf == null || buf.length - pos < encodeSize) {\n", "resizeBuf();\n", "}\n", "switch (modulus) {\n", "case 1:\n", "buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n", "buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n", "// URL-SAFE skips the padding to further reduce size.\n", "if (encodeTable == STANDARD_ENCODE_TABLE) {\n", "buf[pos++] = PAD;\n", "buf[pos++] = PAD;\n", "}\n", "break;\n", "\n", "case 2:\n", "buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n", "buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n", "buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n", "// URL-SAFE skips the padding to further reduce size.\n", "if (encodeTable == STANDARD_ENCODE_TABLE) {\n", "buf[pos++] = PAD;\n", "}\n", "break;\n", "}\n", "if (lineLength > 0) {\n", "System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n", "pos += lineSeparator.length;\n", "}\n", "} else {\n", "for (int i = 0; i < inAvail; i++) {\n", "if (buf == null || buf.length - pos < encodeSize) {\n", "resizeBuf();\n", "}\n", "modulus = (++modulus) % 3;\n", "int b = in[inPos++];\n", "if (b < 0) { b += 256; }\n", "x = (x << 8) + b;\n", "if (0 == modulus) {\n", "buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n", "buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\n", "buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\n", "buf[pos++] = encodeTable[x & MASK_6BITS];\n", "currentLinePos += 4;\n", "if (lineLength > 0 && lineLength <= currentLinePos) {\n", "System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n", "pos += lineSeparator.length;\n", "currentLinePos = 0;\n", "}\n", "}\n", "}\n", "}\n", "}\n"], "faulty_lines": [33], "cluster": 3}, {"pid": "Codec", "bid": 3, "method_path": "./dataset/Codec/3/DoubleMetaphone.java", "method": ["boolean slavoGermanic) {\n", "if (charAt(value, index + 1) == 'H') {\n", "index = handleGH(value, result, index);\n", "} else if (charAt(value, index + 1) == 'N') {\n", "if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {\n", "result.append(\"KN\", \"N\");\n", "} else if (!contains(value, index + 2, 2, \"EY\") &&\n", "charAt(value, index + 1) != 'Y' && !slavoGermanic) {\n", "result.append(\"N\", \"KN\");\n", "} else {\n", "result.append(\"KN\");\n", "}\n", "index = index + 2;\n", "} else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) {\n", "result.append(\"KL\", \"L\");\n", "index += 2;\n", "} else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {\n", "//-- -ges-, -gep-, -gel-, -gie- at beginning --//\n", "result.append('K', 'J');\n", "index += 2;\n", "} else if ((contains(value, index + 1, 2, \"ER\") ||\n", "charAt(value, index + 1) == 'Y') &&\n", "!contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") &&\n", "!contains(value, index - 1, 1, \"E\", \"I\") &&\n", "!contains(value, index - 1, 3, \"RGY\", \"OGY\")) {\n", "//-- -ger-, -gy- --//\n", "result.append('K', 'J');\n", "index += 2;\n", "} else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") ||\n", "contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n", "//-- Italian \"biaggi\" --//\n", "if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n", "//-- obvious germanic --//\n", "result.append('K');\n", "} else if (contains(value, index + 1, 4, \"IER\")) {\n", "result.append('J');\n", "} else {\n", "result.append('J', 'K');\n", "}\n", "index += 2;\n", "} else if (charAt(value, index + 1) == 'G') {\n", "index += 2;\n", "result.append('K');\n", "} else {\n", "index++;\n", "result.append('K');\n", "}\n", "return index;\n", "}\n"], "faulty_lines": [35], "cluster": 3}, {"pid": "Codec", "bid": 4, "method_path": "./dataset/Codec/4/Base64.java", "method": ["public Base64() {\n", "this(false);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Codec", "bid": 5, "method_path": "./dataset/Codec/5/Base64.java", "method": ["void decode(byte[] in, int inPos, int inAvail) {\n", "if (eof) {\n", "return;\n", "}\n", "if (inAvail < 0) {\n", "eof = true;\n", "}\n", "for (int i = 0; i < inAvail; i++) {\n", "if (buffer == null || buffer.length - pos < decodeSize) {\n", "resizeBuffer();\n", "}\n", "byte b = in[inPos++];\n", "if (b == PAD) {\n", "// We're done.\n", "eof = true;\n", "break;\n", "} else {\n", "if (b >= 0 && b < DECODE_TABLE.length) {\n", "int result = DECODE_TABLE[b];\n", "if (result >= 0) {\n", "modulus = (++modulus) % 4;\n", "x = (x << 6) + result;\n", "if (modulus == 0) {\n", "buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n", "buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n", "buffer[pos++] = (byte) (x & MASK_8BITS);\n", "}\n", "}\n", "}\n", "}\n", "}\n", "\n", "// Two forms of EOF as far as base64 decoder is concerned: actual\n", "// EOF (-1) and first time '=' character is encountered in stream.\n", "// This approach makes the '=' padding characters completely optional.\n", "if (eof && modulus != 0) {\n", "\n", "x = x << 6;\n", "switch (modulus) {\n", "case 2 :\n", "x = x << 6;\n", "buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n", "break;\n", "case 3 :\n", "buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);\n", "buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);\n", "break;\n", "}\n", "}\n", "}\n"], "faulty_lines": [37], "cluster": 5}, {"pid": "Codec", "bid": 6, "method_path": "./dataset/Codec/6/Base64InputStream.java", "method": ["public int read(byte b[], int offset, int len) throws IOException {\n", "if (b == null) {\n", "throw new NullPointerException();\n", "} else if (offset < 0 || len < 0) {\n", "throw new IndexOutOfBoundsException();\n", "} else if (offset > b.length || offset + len > b.length) {\n", "throw new IndexOutOfBoundsException();\n", "} else if (len == 0) {\n", "return 0;\n", "} else {\n", "/*\n", "Rationale for while-loop on (readLen == 0):\n", "-----\n", "Base64.readResults() usually returns > 0 or EOF (-1).  In the\n", "rare case where it returns 0, we just keep trying.\n", "\n", "This is essentially an undocumented contract for InputStream\n", "implementors that want their code to work properly with\n", "java.io.InputStreamReader, since the latter hates it when\n", "InputStream.read(byte[]) returns a zero.  Unfortunately our\n", "readResults() call must return 0 if a large amount of the data\n", "being decoded was non-base64, so this while-loop enables proper\n", "interop with InputStreamReader for that scenario.\n", "-----\n", "This is a fix for CODEC-101\n", "*/\n", "if (!base64.hasData()) {\n", "byte[] buf = new byte[doEncode ? 4096 : 8192];\n", "int c = in.read(buf);\n", "// A little optimization to avoid System.arraycopy()\n", "// when possible.\n", "if (c > 0 && b.length == len) {\n", "base64.setInitialBuffer(b, offset, len);\n", "}\n", "if (doEncode) {\n", "base64.encode(buf, 0, c);\n", "} else {\n", "base64.decode(buf, 0, c);\n", "}\n", "}\n", "return base64.readResults(b, offset, len);\n", "}\n", "}\n"], "faulty_lines": [11], "cluster": 5}, {"pid": "Codec", "bid": 6, "method_path": "./dataset/Codec/6/Base64InputStream.java", "method": ["public int read(byte b[], int offset, int len) throws IOException {\n", "if (b == null) {\n", "throw new NullPointerException();\n", "} else if (offset < 0 || len < 0) {\n", "throw new IndexOutOfBoundsException();\n", "} else if (offset > b.length || offset + len > b.length) {\n", "throw new IndexOutOfBoundsException();\n", "} else if (len == 0) {\n", "return 0;\n", "} else {\n", "/*\n", "Rationale for while-loop on (readLen == 0):\n", "-----\n", "Base64.readResults() usually returns > 0 or EOF (-1).  In the\n", "rare case where it returns 0, we just keep trying.\n", "\n", "This is essentially an undocumented contract for InputStream\n", "implementors that want their code to work properly with\n", "java.io.InputStreamReader, since the latter hates it when\n", "InputStream.read(byte[]) returns a zero.  Unfortunately our\n", "readResults() call must return 0 if a large amount of the data\n", "being decoded was non-base64, so this while-loop enables proper\n", "interop with InputStreamReader for that scenario.\n", "-----\n", "This is a fix for CODEC-101\n", "*/\n", "if (!base64.hasData()) {\n", "byte[] buf = new byte[doEncode ? 4096 : 8192];\n", "int c = in.read(buf);\n", "// A little optimization to avoid System.arraycopy()\n", "// when possible.\n", "if (c > 0 && b.length == len) {\n", "base64.setInitialBuffer(b, offset, len);\n", "}\n", "if (doEncode) {\n", "base64.encode(buf, 0, c);\n", "} else {\n", "base64.decode(buf, 0, c);\n", "}\n", "}\n", "return base64.readResults(b, offset, len);\n", "}\n", "}\n"], "faulty_lines": [27], "cluster": 5}, {"pid": "Codec", "bid": 6, "method_path": "./dataset/Codec/6/Base64InputStream.java", "method": ["public int read(byte b[], int offset, int len) throws IOException {\n", "if (b == null) {\n", "throw new NullPointerException();\n", "} else if (offset < 0 || len < 0) {\n", "throw new IndexOutOfBoundsException();\n", "} else if (offset > b.length || offset + len > b.length) {\n", "throw new IndexOutOfBoundsException();\n", "} else if (len == 0) {\n", "return 0;\n", "} else {\n", "/*\n", "Rationale for while-loop on (readLen == 0):\n", "-----\n", "Base64.readResults() usually returns > 0 or EOF (-1).  In the\n", "rare case where it returns 0, we just keep trying.\n", "\n", "This is essentially an undocumented contract for InputStream\n", "implementors that want their code to work properly with\n", "java.io.InputStreamReader, since the latter hates it when\n", "InputStream.read(byte[]) returns a zero.  Unfortunately our\n", "readResults() call must return 0 if a large amount of the data\n", "being decoded was non-base64, so this while-loop enables proper\n", "interop with InputStreamReader for that scenario.\n", "-----\n", "This is a fix for CODEC-101\n", "*/\n", "if (!base64.hasData()) {\n", "byte[] buf = new byte[doEncode ? 4096 : 8192];\n", "int c = in.read(buf);\n", "// A little optimization to avoid System.arraycopy()\n", "// when possible.\n", "if (c > 0 && b.length == len) {\n", "base64.setInitialBuffer(b, offset, len);\n", "}\n", "if (doEncode) {\n", "base64.encode(buf, 0, c);\n", "} else {\n", "base64.decode(buf, 0, c);\n", "}\n", "}\n", "return base64.readResults(b, offset, len);\n", "}\n", "}\n"], "faulty_lines": [41], "cluster": 5}, {"pid": "Codec", "bid": 7, "method_path": "./dataset/Codec/7/Base64.java", "method": ["public static String encodeBase64String(byte[] binaryData) {\n", "return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Codec", "bid": 8, "method_path": "./dataset/Codec/8/Base64InputStream.java", "method": ["public int read(byte b[], int offset, int len) throws IOException {\n", "if (b == null) {\n", "throw new NullPointerException();\n", "} else if (offset < 0 || len < 0) {\n", "throw new IndexOutOfBoundsException();\n", "} else if (offset > b.length || offset + len > b.length) {\n", "throw new IndexOutOfBoundsException();\n", "} else if (len == 0) {\n", "return 0;\n", "} else {\n", "int readLen = 0;\n", "/*\n", "Rationale for while-loop on (readLen == 0):\n", "-----\n", "Base64.readResults() usually returns > 0 or EOF (-1).  In the\n", "rare case where it returns 0, we just keep trying.\n", "\n", "This is essentially an undocumented contract for InputStream\n", "implementors that want their code to work properly with\n", "java.io.InputStreamReader, since the latter hates it when\n", "InputStream.read(byte[]) returns a zero.  Unfortunately our\n", "readResults() call must return 0 if a large amount of the data\n", "being decoded was non-base64, so this while-loop enables proper\n", "interop with InputStreamReader for that scenario.\n", "-----\n", "This is a fix for CODEC-101\n", "*/\n", "while (readLen == 0) {\n", "if (!base64.hasData()) {\n", "byte[] buf = new byte[doEncode ? 4096 : 8192];\n", "int c = in.read(buf);\n", "if (c > 0 && b.length == len) {\n", "base64.setInitialBuffer(b, offset, len);\n", "}\n", "if (doEncode) {\n", "base64.encode(buf, 0, c);\n", "} else {\n", "base64.decode(buf, 0, c);\n", "}\n", "}\n", "readLen = base64.readResults(b, offset, len);\n", "}\n", "return readLen;\n", "}\n", "}\n"], "faulty_lines": [32, 33, 34], "cluster": 5}, {"pid": "Codec", "bid": 9, "method_path": "./dataset/Codec/9/Base64.java", "method": ["public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n", "if (binaryData == null || binaryData.length == 0) {\n", "return binaryData;\n", "}\n", "\n", "long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n", "if (len > maxResultSize) {\n", "throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n", "len +\n", "\") than the specified maxium size of \" +\n", "maxResultSize);\n", "}\n", "\n", "Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n", "return b64.encode(binaryData);\n", "}\n"], "faulty_lines": [6], "cluster": 2}, {"pid": "Codec", "bid": 10, "method_path": "./dataset/Codec/10/Caverphone.java", "method": ["public String caverphone(String txt) {\n", "// NOTE: Version 1.0 of Caverphone is easily derivable from this code\n", "// by commenting out the 2.0 lines and adding in the 1.0 lines\n", "\n", "if( txt == null || txt.length() == 0 ) {\n", "return \"1111111111\";\n", "}\n", "\n", "// 1. Convert to lowercase\n", "txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n", "\n", "// 2. Remove anything not A-Z\n", "txt = txt.replaceAll(\"[^a-z]\", \"\");\n", "\n", "// 2.5. Remove final e\n", "txt = txt.replaceAll(\"e$\", \"\");             // 2.0 only\n", "\n", "// 3. Handle various start options\n", "txt = txt.replaceAll(\"^cough\", \"cou2f\");\n", "txt = txt.replaceAll(\"^rough\", \"rou2f\");\n", "txt = txt.replaceAll(\"^tough\", \"tou2f\");\n", "txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n", "txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n", "txt = txt.replaceAll(\"^gn\", \"2n\");\n", "\n", "// End\n", "txt = txt.replaceAll(\"^mb\", \"m2\");\n", "\n", "// 4. Handle replacements\n", "txt = txt.replaceAll(\"cq\", \"2q\");\n", "txt = txt.replaceAll(\"ci\", \"si\");\n", "txt = txt.replaceAll(\"ce\", \"se\");\n", "txt = txt.replaceAll(\"cy\", \"sy\");\n", "txt = txt.replaceAll(\"tch\", \"2ch\");\n", "txt = txt.replaceAll(\"c\", \"k\");\n", "txt = txt.replaceAll(\"q\", \"k\");\n", "txt = txt.replaceAll(\"x\", \"k\");\n", "txt = txt.replaceAll(\"v\", \"f\");\n", "txt = txt.replaceAll(\"dg\", \"2g\");\n", "txt = txt.replaceAll(\"tio\", \"sio\");\n", "txt = txt.replaceAll(\"tia\", \"sia\");\n", "txt = txt.replaceAll(\"d\", \"t\");\n", "txt = txt.replaceAll(\"ph\", \"fh\");\n", "txt = txt.replaceAll(\"b\", \"p\");\n", "txt = txt.replaceAll(\"sh\", \"s2\");\n", "txt = txt.replaceAll(\"z\", \"s\");\n", "txt = txt.replaceAll(\"^[aeiou]\", \"A\");\n", "txt = txt.replaceAll(\"[aeiou]\", \"3\");\n", "txt = txt.replaceAll(\"j\", \"y\");        // 2.0 only\n", "txt = txt.replaceAll(\"^y3\", \"Y3\");     // 2.0 only\n", "txt = txt.replaceAll(\"^y\", \"A\");       // 2.0 only\n", "txt = txt.replaceAll(\"y\", \"3\");        // 2.0 only\n", "txt = txt.replaceAll(\"3gh3\", \"3kh3\");\n", "txt = txt.replaceAll(\"gh\", \"22\");\n", "txt = txt.replaceAll(\"g\", \"k\");\n", "txt = txt.replaceAll(\"s+\", \"S\");\n", "txt = txt.replaceAll(\"t+\", \"T\");\n", "txt = txt.replaceAll(\"p+\", \"P\");\n", "txt = txt.replaceAll(\"k+\", \"K\");\n", "txt = txt.replaceAll(\"f+\", \"F\");\n", "txt = txt.replaceAll(\"m+\", \"M\");\n", "txt = txt.replaceAll(\"n+\", \"N\");\n", "txt = txt.replaceAll(\"w3\", \"W3\");\n", "//txt = txt.replaceAll(\"wy\", \"Wy\");    // 1.0 only\n", "txt = txt.replaceAll(\"wh3\", \"Wh3\");\n", "txt = txt.replaceAll(\"w$\", \"3\");       // 2.0 only\n", "//txt = txt.replaceAll(\"why\", \"Why\");  // 1.0 only\n", "txt = txt.replaceAll(\"w\", \"2\");\n", "txt = txt.replaceAll(\"^h\", \"A\");\n", "txt = txt.replaceAll(\"h\", \"2\");\n", "txt = txt.replaceAll(\"r3\", \"R3\");\n", "txt = txt.replaceAll(\"r$\", \"3\");       // 2.0 only\n", "//txt = txt.replaceAll(\"ry\", \"Ry\");    // 1.0 only\n", "txt = txt.replaceAll(\"r\", \"2\");\n", "txt = txt.replaceAll(\"l3\", \"L3\");\n", "txt = txt.replaceAll(\"l$\", \"3\");       // 2.0 only\n", "//txt = txt.replaceAll(\"ly\", \"Ly\");    // 1.0 only\n", "txt = txt.replaceAll(\"l\", \"2\");\n", "//txt = txt.replaceAll(\"j\", \"y\");      // 1.0 only\n", "//txt = txt.replaceAll(\"y3\", \"Y3\");    // 1.0 only\n", "//txt = txt.replaceAll(\"y\", \"2\");      // 1.0 only\n", "\n", "// 5. Handle removals\n", "txt = txt.replaceAll(\"2\", \"\");\n", "txt = txt.replaceAll(\"3$\", \"A\");       // 2.0 only\n", "txt = txt.replaceAll(\"3\", \"\");\n", "\n", "// 6. put ten 1s on the end\n", "txt = txt + \"111111\" + \"1111\";        // 1.0 only has 6 1s\n", "\n", "// 7. take the first six characters as the code\n", "return txt.substring(0, 10);          // 1.0 truncates to 6\n", "}\n"], "faulty_lines": [27], "cluster": 6}, {"pid": "Codec", "bid": 11, "method_path": "./dataset/Codec/11/QuotedPrintableCodec.java", "method": ["private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {\n", "buffer.write(ESCAPE_CHAR);\n", "char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));\n", "char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));\n", "buffer.write(hex1);\n", "buffer.write(hex2);\n", "}\n"], "faulty_lines": [1, 7], "cluster": 4}, {"pid": "Codec", "bid": 11, "method_path": "./dataset/Codec/11/QuotedPrintableCodec.java", "method": ["public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {\n", "if (bytes == null) {\n", "return null;\n", "}\n", "if (printable == null) {\n", "printable = PRINTABLE_CHARS;\n", "}\n", "ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n", "// encode up to buffer.length - 3, the last three octets will be treated\n", "// separately for simplification of note #3\n", "// up to this length it is safe to add any byte, encoded or not\n", "for (byte c : bytes) {\n", "int b = c;\n", "if (b < 0) {\n", "b = 256 + b;\n", "}\n", "if (printable.get(b)) {\n", "buffer.write(b);\n", "} else {\n", "// rule #3: whitespace at the end of a line *must* be encoded\n", "\n", "// rule #5: soft line break\n", "encodeQuotedPrintable(b, buffer);\n", "}\n", "}\n", "\n", "// rule #3: whitespace at the end of a line *must* be encoded\n", "// if we would do a soft break line after this octet, encode whitespace\n", "\n", "// note #3: '=' *must not* be the ultimate or penultimate character\n", "// simplification: if < 6 bytes left, do a soft line break as we may need\n", "//                 exactly 6 bytes space for the last 2 bytes\n", "// rule #3: trailing whitespace shall be encoded\n", "\n", "return buffer.toByteArray();\n", "}\n"], "faulty_lines": [9, 11, 12, 13, 14, 15, 16, 17, 18, 21, 23, 29, 33, 34], "cluster": 1}, {"pid": "Codec", "bid": 11, "method_path": "./dataset/Codec/11/QuotedPrintableCodec.java", "method": ["public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {\n", "if (bytes == null) {\n", "return null;\n", "}\n", "ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n", "for (int i = 0; i < bytes.length; i++) {\n", "final int b = bytes[i];\n", "if (b == ESCAPE_CHAR) {\n", "try {\n", "// if the next octet is a CR we have found a soft line break\n", "int u = Utils.digit16(bytes[++i]);\n", "int l = Utils.digit16(bytes[++i]);\n", "buffer.write((char) ((u << 4) + l));\n", "} catch (ArrayIndexOutOfBoundsException e) {\n", "throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n", "}\n", "} else {\n", "// every other octet is appended except for CR & LF\n", "buffer.write(b);\n", "}\n", "}\n", "return buffer.toByteArray();\n", "}\n"], "faulty_lines": [11, 17], "cluster": 2}, {"pid": "Codec", "bid": 15, "method_path": "./dataset/Codec/15/Soundex.java", "method": ["private char getMappingCode(final String str, final int index) {\n", "// map() throws IllegalArgumentException\n", "final char mappedChar = this.map(str.charAt(index));\n", "// HW rule check\n", "if (index > 1 && mappedChar != '0') {\n", "final char hwChar = str.charAt(index - 1);\n", "if ('H' == hwChar || 'W' == hwChar) {\n", "final char preHWChar = str.charAt(index - 2);\n", "final char firstCode = this.map(preHWChar);\n", "if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n", "return 0;\n", "}\n", "}\n", "}\n", "return mappedChar;\n", "}\n"], "faulty_lines": [6, 7, 8, 9, 10, 13], "cluster": 2}, {"pid": "Codec", "bid": 16, "method_path": "./dataset/Codec/16/Base32.java", "method": ["private static final byte[] HEX_DECODE_TABLE = {\n", "//  0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F\n", "-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n", "-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n", "-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n", "0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n", "-1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n", "25, 26, 27, 28, 29, 30, 31, 32,\n", "};\n"], "faulty_lines": [8], "cluster": 8}, {"pid": "Codec", "bid": 17, "method_path": "./dataset/Codec/17/StringUtils.java", "method": ["public static String newStringIso8859_1(final byte[] bytes) {\n", "return new String(bytes, Charsets.ISO_8859_1);\n", "}\n"], "faulty_lines": [2], "cluster": 0}, {"pid": "Codec", "bid": 18, "method_path": "./dataset/Codec/18/StringUtils.java", "method": ["public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n", "if (cs1 == cs2) {\n", "return true;\n", "}\n", "if (cs1 == null || cs2 == null) {\n", "return false;\n", "}\n", "if (cs1 instanceof String && cs2 instanceof String) {\n", "return cs1.equals(cs2);\n", "}\n", "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n", "}\n"], "faulty_lines": [11], "cluster": 4}]