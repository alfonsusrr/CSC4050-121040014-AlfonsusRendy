{"dataset": [{"lang": "java", "bug_type": "operation error", "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++){\n            char c = stones.charAt(i);\n            if(jewels.contains(String.valueOf(c))){\n                count--;\n            }\n        }\n        return count;\n    }\n}\n", "reasoning": "\nThe bug is that count decreases when a jewel is found, instead of increasing.\n"}, {"lang": "java", "bug_type": "operation error", "buggy_code": "\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        ArrayList<Integer>atr=new ArrayList<>();\n        for(int a:nums){\n            atr.add(a);\n        }\n        atr.add(target);\n        Collections.sort(atr);\n        atr.remove(target);\n        int k=atr.indexOf(target);\n        return k;\n        \n    }\n}\n", "reasoning": "\nThe bug is in atr.remove(target), it removes the target before getting its index.\n"}, {"lang": "java", "bug_type": "operation error", "buggy_code": "\nclass Solution {\n    public int numberOfWeakCharacters(int[][] properties) {\n        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (b[0]-a[0]));\n        int count = 0, max = 0;\n        for(int[] arr: properties){\n            if(arr[1] < max)    count++;\n            max = Math.max(max, arr[1]);\n        }\n        return count;\n    }\n}\n", "reasoning": "\nThe bug is in the sorting comparator causing the sorting order to be incorrect.\n"}, {"lang": "python3", "bug_type": "operation error", "buggy_code": "\nclass Solution:\n    def firstPalindrome(self, words: List[str]) -> str:\n        for i in words:\n            if i==i.sort():\n                return i\n        return \"\"\n", "reasoning": "\nThe bug is in the palindrome check, it sorts string instead of reversing.\n"}, {"lang": "java", "bug_type": "operation error", "buggy_code": "\nclass Solution {\n    public String sortString(String s) {\n        int[] arr = new int[27];\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\n        for(int i=0;i<s.length();i++){\n            int num = str.indexOf((s.charAt(i)));\n            arr[num]=arr[num]+1; \n            ++num; \n        }\n\n        int len = s.length();\n        int count=0;\n        StringBuilder ans = new StringBuilder();\n\n        while(count<len){\n            for(int i=1;i<27;i++){\n                if(arr[i]>0){\n                    ans.append(str.charAt(i - 1));\n                    arr[i]=arr[i]-1;\n                    count++;\n                }\n            }\n            for(int j=26;j>=1;j--){\n                if(arr[j]>0){\n                    ans.append(str.charAt(j - 1));\n                    arr[j]=arr[j]-1;\n                    count++;\n                }\n            }\n        }\n        return new String(ans);\n    }\n}\n", "reasoning": "\nThe num variable is incremented after being used to index the arr array, leading to incorrect count of characters.\n"}, {"lang": "cpp", "bug_type": "operation error", "buggy_code": "\nclass Solution {\npublic:\n    vector<int> getStrongest(vector<int>& arr, int k) {\n        vector<pair<int,int>>v;\n        int sum=0,n=arr.size();\n        sort(arr.begin(),arr.end());\n        int median=arr[(n-2)/2]; \n        for(int i=0;i<arr.size();i++)\n        {\n            v.push_back({abs(arr[i]-median),arr[i]});\n        }\n        sort(v.begin(),v.end());\n        reverse(v.begin(),v.end());\n        vector<int>ans;\n        for(int i=0;i<k;i++)\n        {\n            ans.push_back(v[i].second);\n        }\n        return ans;\n    }\n};\n", "reasoning": "\nThe median of array is fetched incorrectly leading to wrong calculations and unexpected results.\n"}, {"lang": "java", "bug_type": "operation error", "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for(String x : words) {\n            StringBuilder SB = new StringBuilder(x);\n            x = SB.reverse().toString();\n            if(x.equals(SB.toString())) {\n                return x;\n            }\n        }\n        return \"\";\n    }\n}\n", "reasoning": "\nThe variable 'x' is changed before comparison, which constantly makes the condition true.\n"}, {"lang": "java", "bug_type": "operation error", "buggy_code": "\nclass Solution {\n    public boolean doesValidArrayExist(int[] de) {\n        int ans=0;\n        for(int a:de){\n            if(a==1)\n                ans++;\n        }\n        return (ans%3==0);\n    }\n}\n", "reasoning": "\nThe logic error is in the return line. It is checking for divisibility by 3 instead of 2.\n"}, {"lang": "python3", "bug_type": "operation error", "buggy_code": "\nimport math\nfrom typing import List\nimport bisect\n\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        def buildSparseTable(arr, n):\n            k = int(math.log2(n))\n            st = [[None for j in range(n)] for i in range(k + 1)]\n            for i in range(k + 1):\n                for j in range(n - (1 << i) + 1):\n                    if i == 0:\n                        st[i][j] = arr[j]\n                    else:\n                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])\n            return st\n\n        def getMax(st, l, r):\n            i = int(math.log2(r - l + 1))\n            return max(st[i][l], st[i][r - (1 << i) + 1])\n\n        n = len(nums1)\n        a = sorted([[nums1[i], nums2[i]] for i in range(n)])\n        max_y = [v[1] for v in a]\n        for i in range(n - 2, -1, -1):\n            max_y[i] = max(max_y[i], max_y[1 + 1])   \n        _sum = [v[0] + v[1] for v in a]\n        st_max_sum = buildSparseTable(_sum, n)\n        res = []\n        for x, y in queries:\n            i = bisect.bisect_left(a, [x, y])\n            if i == n or max_y[i] < y:\n                res.append(-1)\n                continue\n            left, right = i, n - 1\n            while left < right:\n                m = (left + right + 1) // 2\n                if max_y[m] >= y:\n                    left = m\n                else:\n                    right = m - 1\n            j = right\n            res.append(getMax(st_max_sum, i, j))\n        return res\n", "reasoning": "\nIn the loop over max_y, I changed \"max_y[i+1]\" to \"max_y[1 + 1],\" causing incorrect indexing.\n"}, {"lang": "cpp", "bug_type": "operation error", "buggy_code": "\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n=digits.size();\n        digits[n]++;\n        for(int i=n-1;i>=1;i--)\n        {\n            if(digits[i]>9)\n            {\n                digits[i]%=10;\n                digits[i-1]++;\n            }\n        }\n        if(digits[0]>9)\n        {\n            digits.insert(digits.begin(),1);\n            digits[1]%=10;\n        }\n        return digits;\n    }\n};\n", "reasoning": "\nTrying to increment index n of vector 'digits', which is out of bound. \n"}, {"lang": "python3", "bug_type": "operation error", "buggy_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"b\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])\n", "reasoning": "\nThe code incorrectly subtracts 1 from index 'ord(char) - ord(\"b\")' instead of 'ord(char) - ord(\"a\")'.\n"}, {"lang": "java", "bug_type": "operation error", "buggy_code": "\nclass Solution {\n    public int tupleSameProduct(int[] nums) {\n        int m = nums.length;\n        int factor = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for(int i = 0; i < m - 1; i ++) {\n            for(int j = i + 1; j < m; j ++) {\n                int curNumber = nums[i] * nums[j];\n                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;\n                hm.put(curNumber, curNumberCount);\n            }\n        }\n        \n        \n\t\t\n        for(Integer key: hm.keySet()) {\n            int count = hm.get(key);\n            if(count == 1) continue;\n            factor += (count - 1) / 2; \n        }\n        return factor * 8;\n    }\n}\n", "reasoning": "\nThe factor calculation logic is wrong. It should be \"count * (count - 1) / 2\", not \"(count - 1) / 2\".\n"}, {"lang": "cpp", "bug_type": "operation error", "buggy_code": "\nclass Solution {\npublic:\n    int sumOfMultiples(int n,int count=0) {\n\n       for (int i=1;i<=n;i++)\n       {\n         if (i%3==0 || i%5==0 ||i%7==0)\n           count+=i;\n       }\n    return count-1;\n\n    }\n};\n", "reasoning": "\nThe function is subtracting 1 from the total sum unexpectedly, resulting in incorrect results.\n"}, {"lang": "java", "bug_type": "operation error", "buggy_code": "\nclass Solution {\n    public int passThePillow(int n, int time) {\n        int num=(time/(n-1));\n        if(n>time){\n            return time;\n        }\n        if(num%2==1){\n            return n-((time%(n-1)));\n        }\n            \n        return (time%(n-1))+1;\n    }\n}\n", "reasoning": "\nChanged return time+1 to return time, mistakenly not increasing count by 1 in base case.\n"}, {"lang": "cpp", "bug_type": "operation error", "buggy_code": "\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        vector<int> ans={-1,-1};\n        ListNode* prev=head;\n        if(!prev) return ans;\n        ListNode* curr=prev->next;\n        if(!curr) return ans;\n        ListNode* next=curr->next;\n        if(!next) return ans;\n\n        int first=-1;\n        int last=-1;\n        int mind=INT_MAX;\n        int i=1;\n        while(next){\n            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;\n            if(iscp&&first==-1){\n                first=i;\n                last=i;\n            }\n            else if(iscp){\n                mind=min(mind,i-last);\n                last=i;\n            }\n            i++;\n            prev=curr;\n            curr=next;\n            next=next->next;\n        }\n        if(first==last)\n         return ans;\n         else\n         {\n             ans[0]=mind;\n             ans[1]=last+first;\n         }\n         return ans;\n    }\n};\n", "reasoning": "\nInstead of subtracting 'first' from 'last', 'first' is being added to 'last'.\n"}, {"lang": "java", "bug_type": "operation error", "buggy_code": "\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\n        arr[0] = celsius + 237.15;\n        return arr;\n    }\n}\n", "reasoning": "\nThe conversion from Celsius to Kelvin is incorrect, it should be 273.15, not 237.15.\n"}, {"lang": "python3", "bug_type": "operation error", "buggy_code": "\nclass Solution:\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\n        return max(max(left, default=0), n - max(right, default=n))\n", "reasoning": "\nChanged min to max for right array, resulting in wrong calculation for 'n - right' distance.\n"}, {"lang": "python3", "bug_type": "operation error", "buggy_code": "\nclass Solution:\n    def distributeCandies(self, candyType: List[int]) -> int:\n        return max(len(candyType)//2, len(set(candyType)))\n", "reasoning": "\nThe 'max' function should be 'min' so it distributes correctly between twin sisters.\n"}, {"lang": "python3", "bug_type": "operation error", "buggy_code": "\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            while s[i]!=s[j] and j>0:\n                j=lps[j]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]\n", "reasoning": "\nIn while loop, program refers to incorrect array index on j=lps[j]. It should be j=lps[j-1].\n"}, {"lang": "cpp", "bug_type": "operation error", "buggy_code": "\nclass Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[s[i]-'z']++; \n        }\n        \n\t\t// similar strings\n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};\n", "reasoning": "\nThe ASCII subtraction is incorrect, should be 'a' not 'z', leading to incorrect counting.\n"}], "heuristic": "<heuristic>\n\nGiven the commonality in the bugs across various code snippets, one can design an automated fault localization heuristic specifically targeting incorrect mathematical operations, incorrect array indexing, wrong conditional logic, and misused string operations. This heuristic comprises several steps to pinpoint defective lines efficiently:\n\n1. **Incorrect Mathematical Operations Detection**:\n    - Parse the code to extract all arithmetic operations and their contexts.\n    - For each operation, evaluate the operands based on their types (e.g., integer, float) and the operation itself.\n    - Compare the result against known correct operations within similar contexts (using a database of common programming patterns and errors).\n    - If an operation yields a result outside the expected range or type, flag it as potentially defective.\n\n2. **Incorrect Array Indexing**:\n    - Identify all instances of array access.\n    - For each instance, compare the index against the array's declared size or length property.\n    - If the index is statically determined to be out of bounds (negative or greater than or equal to the array's length), flag the line as having a defect.\n    - For dynamically calculated indices, check for common off-by-one errors or incorrect variables being used as indices.\n\n3. **Wrong Conditional Logic**:\n    - Extract all conditional statements from the code.\n    - Analyze the logical expressions for common pitfalls (e.g., using `=` instead of `==`, off-by-one errors).\n    - Utilize symbolic execution to traverse different paths and check if some conditions lead to logically impossible or inconsistent states.\n    - Flag conditions that consistently result in incorrect path selection.\n\n4. **Misused String Operations**:\n    - Identify all string manipulation functions (e.g., `substring`, `indexOf`, `sort`, `reverse`).\n    - Check for common errors such as using a sort when a reverse is needed, incorrect parameters leading to out-of-bound errors, or using comparisons meant for characters on strings.\n    - Use pattern recognition to flag lines where the operation being performed does not match typical use cases for the given context.\n\nMathematically, this heuristic can be formulated as follows: Let \\(C\\) be the set of code lines, \\(A\\) be the set of arithmetic operations, \\(I\\) be the set of array index usages, \\(L\\) be the set of logical conditions, and \\(S\\) be the set of string operations within a program. For each element \\(c \\in C\\), if \\(c \\in A\\) and the operation deviates from expected results, \\(c\\) is flagged. Similarly, if \\(c \\in I\\) and indices are out of bounds, \\(c\\) is flagged; if \\(c \\in L\\) and leads to incorrect branches, \\(c\\) is flagged; if \\(c \\in S\\) and the operation is misused, \\(c\\) is flagged. This approach systematically identifies and locates different categories of common coding defects.\n\n</heuristic>"}